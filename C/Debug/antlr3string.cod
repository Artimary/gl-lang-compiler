; Listing generated by Microsoft (R) Optimizing Compiler Version 19.42.34436.0 

	TITLE	C:\SPO_labs\C\Debug\antlr3string.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	___local_stdio_printf_options
PUBLIC	__vsnprintf_l
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	_antlr3StringFactoryNew
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd@				; `string'
EXTRN	__imp__isdigit:PROC
EXTRN	__imp__isprint:PROC
EXTRN	_memmove:PROC
EXTRN	_strcmp:PROC
EXTRN	_strlen:PROC
EXTRN	__imp__calloc:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp__realloc:PROC
EXTRN	__imp__atoi:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	_ConvertUTF16toUTF8:PROC
EXTRN	_antlr3VectorNew:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___security_cookie:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd@ DB '%d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	01eH
	DB	069H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	01eH
	DB	069H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	01eH
	DB	065H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	01eH
	DB	065H
voltbl	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3string.c
;	COMDAT _stringFree
_TEXT	SEGMENT
_string$ = 8						; size = 4
_stringFree PROC					; COMDAT

; 240  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 241  :     /* First free the string itself if there was anything in it
; 242  :      */
; 243  :     if	(string->chars)

  00004	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  00007	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000b	74 1a		 je	 SHORT $LN2@stringFree

; 244  :     {
; 245  : 	ANTLR3_FREE(string->chars);

  0000d	8b f4		 mov	 esi, esp
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  00012	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00015	52		 push	 edx
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0001c	83 c4 04	 add	 esp, 4
  0001f	3b f4		 cmp	 esi, esp
  00021	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00026	90		 npad	 1
$LN2@stringFree:

; 246  :     }
; 247  : 
; 248  :     /* Now free the space for this string
; 249  :      */
; 250  :     ANTLR3_FREE(string);

  00027	8b f4		 mov	 esi, esp
  00029	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  0002c	50		 push	 eax
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00033	83 c4 04	 add	 esp, 4
  00036	3b f4		 cmp	 esi, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	90		 npad	 1

; 251  : 
; 252  :     return;
; 253  : }

  0003e	5e		 pop	 esi
  0003f	3b ec		 cmp	 ebp, esp
  00041	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
_stringFree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3string.c
;	COMDAT _stringInitUTF16
_TEXT	SEGMENT
_string$ = 8						; size = 4
_stringInitUTF16 PROC					; COMDAT

; 298  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 299  :     string->len		= 0;

  00003	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  00006	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 300  :     string->size	= 0;

  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  00010	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 301  :     string->chars	= NULL;

  00017	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  0001a	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 302  :     string->encoding	= ANTLR3_ENC_8BIT;

  00021	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  00024	c6 40 14 04	 mov	 BYTE PTR [eax+20], 4

; 303  : 
; 304  :     /* API for UTF16 strings */
; 305  : 
; 306  :     string->set		= setUTF16_UTF16;

  00028	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  0002b	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET _setUTF16_UTF16

; 307  :     string->set8	= setUTF16_8;

  00032	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  00035	c7 42 1c 00 00
	00 00		 mov	 DWORD PTR [edx+28], OFFSET _setUTF16_8

; 308  :     string->append	= appendUTF16_UTF16;

  0003c	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  0003f	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], OFFSET _appendUTF16_UTF16

; 309  :     string->append8	= appendUTF16_8;

  00046	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  00049	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], OFFSET _appendUTF16_8

; 310  :     string->insert	= insertUTF16_UTF16;

  00050	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  00053	c7 42 28 00 00
	00 00		 mov	 DWORD PTR [edx+40], OFFSET _insertUTF16_UTF16

; 311  :     string->insert8	= insertUTF16_8;

  0005a	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  0005d	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], OFFSET _insertUTF16_8

; 312  :     string->addi	= addiUTF16;

  00064	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  00067	c7 41 44 00 00
	00 00		 mov	 DWORD PTR [ecx+68], OFFSET _addiUTF16

; 313  :     string->inserti	= insertiUTF16;

  0006e	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  00071	c7 42 3c 00 00
	00 00		 mov	 DWORD PTR [edx+60], OFFSET _insertiUTF16

; 314  :     string->addc	= addcUTF16;

  00078	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  0007b	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [eax+64], OFFSET _addcUTF16

; 315  :     string->charAt	= charAtUTF16;

  00082	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  00085	c7 41 54 00 00
	00 00		 mov	 DWORD PTR [ecx+84], OFFSET _charAtUTF16

; 316  :     string->compare	= compareUTF16_UTF16;

  0008c	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  0008f	c7 42 4c 00 00
	00 00		 mov	 DWORD PTR [edx+76], OFFSET _compareUTF16_UTF16

; 317  :     string->compare8	= compareUTF16_8;

  00096	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  00099	c7 40 48 00 00
	00 00		 mov	 DWORD PTR [eax+72], OFFSET _compareUTF16_8

; 318  :     string->subString	= subStringUTF16;

  000a0	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  000a3	c7 41 58 00 00
	00 00		 mov	 DWORD PTR [ecx+88], OFFSET _subStringUTF16

; 319  :     string->toInt32	= toInt32_UTF16;

  000aa	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  000ad	c7 42 5c 00 00
	00 00		 mov	 DWORD PTR [edx+92], OFFSET _toInt32_UTF16

; 320  :     string->to8		= to8_UTF16;

  000b4	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  000b7	c7 40 60 00 00
	00 00		 mov	 DWORD PTR [eax+96], OFFSET _to8_UTF16

; 321  :     string->toUTF8	= toUTF8_UTF16;

  000be	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  000c1	c7 41 64 00 00
	00 00		 mov	 DWORD PTR [ecx+100], OFFSET _toUTF8_UTF16

; 322  : 
; 323  :     string->compareS	= compareS;

  000c8	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  000cb	c7 42 50 00 00
	00 00		 mov	 DWORD PTR [edx+80], OFFSET _compareS

; 324  :     string->setS	= setS;

  000d2	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  000d5	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], OFFSET _setS

; 325  :     string->appendS	= appendS;

  000dc	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  000df	c7 41 34 00 00
	00 00		 mov	 DWORD PTR [ecx+52], OFFSET _appendS

; 326  :     string->insertS	= insertS;

  000e6	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  000e9	c7 42 38 00 00
	00 00		 mov	 DWORD PTR [edx+56], OFFSET _insertS

; 327  : }

  000f0	5d		 pop	 ebp
  000f1	c3		 ret	 0
_stringInitUTF16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3string.c
;	COMDAT _stringInit8
_TEXT	SEGMENT
_string$ = 8						; size = 4
_stringInit8 PROC					; COMDAT

; 261  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 262  :     string->len			= 0;

  00003	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  00006	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 263  :     string->size		= 0;

  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  00010	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 264  :     string->chars		= NULL;

  00017	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  0001a	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 265  :     string->encoding	= ANTLR3_ENC_8BIT ;

  00021	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  00024	c6 40 14 04	 mov	 BYTE PTR [eax+20], 4

; 266  : 
; 267  :     /* API for 8 bit strings*/
; 268  : 
; 269  :     string->set		= set8;

  00028	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  0002b	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET _set8

; 270  :     string->set8	= set8;

  00032	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  00035	c7 42 1c 00 00
	00 00		 mov	 DWORD PTR [edx+28], OFFSET _set8

; 271  :     string->append	= append8;

  0003c	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  0003f	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], OFFSET _append8

; 272  :     string->append8	= append8;

  00046	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  00049	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], OFFSET _append8

; 273  :     string->insert	= insert8;

  00050	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  00053	c7 42 28 00 00
	00 00		 mov	 DWORD PTR [edx+40], OFFSET _insert8

; 274  :     string->insert8	= insert8;

  0005a	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  0005d	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], OFFSET _insert8

; 275  :     string->addi	= addi8;

  00064	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  00067	c7 41 44 00 00
	00 00		 mov	 DWORD PTR [ecx+68], OFFSET _addi8

; 276  :     string->inserti	= inserti8;

  0006e	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  00071	c7 42 3c 00 00
	00 00		 mov	 DWORD PTR [edx+60], OFFSET _inserti8

; 277  :     string->addc	= addc8;

  00078	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  0007b	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [eax+64], OFFSET _addc8

; 278  :     string->charAt	= charAt8;

  00082	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  00085	c7 41 54 00 00
	00 00		 mov	 DWORD PTR [ecx+84], OFFSET _charAt8

; 279  :     string->compare	= compare8;

  0008c	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  0008f	c7 42 4c 00 00
	00 00		 mov	 DWORD PTR [edx+76], OFFSET _compare8

; 280  :     string->compare8	= compare8;

  00096	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  00099	c7 40 48 00 00
	00 00		 mov	 DWORD PTR [eax+72], OFFSET _compare8

; 281  :     string->subString	= subString8;

  000a0	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  000a3	c7 41 58 00 00
	00 00		 mov	 DWORD PTR [ecx+88], OFFSET _subString8

; 282  :     string->toInt32	= toInt32_8;

  000aa	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  000ad	c7 42 5c 00 00
	00 00		 mov	 DWORD PTR [edx+92], OFFSET _toInt32_8

; 283  :     string->to8		= to8_8;

  000b4	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  000b7	c7 40 60 00 00
	00 00		 mov	 DWORD PTR [eax+96], OFFSET _to8_8

; 284  :     string->toUTF8	= toUTF8_8;

  000be	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  000c1	c7 41 64 00 00
	00 00		 mov	 DWORD PTR [ecx+100], OFFSET _toUTF8_8

; 285  :     string->compareS	= compareS;

  000c8	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  000cb	c7 42 50 00 00
	00 00		 mov	 DWORD PTR [edx+80], OFFSET _compareS

; 286  :     string->setS	= setS;

  000d2	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  000d5	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], OFFSET _setS

; 287  :     string->appendS	= appendS;

  000dc	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  000df	c7 41 34 00 00
	00 00		 mov	 DWORD PTR [ecx+52], OFFSET _appendS

; 288  :     string->insertS	= insertS;

  000e6	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  000e9	c7 42 38 00 00
	00 00		 mov	 DWORD PTR [edx+56], OFFSET _insertS

; 289  : 
; 290  : }

  000f0	5d		 pop	 ebp
  000f1	c3		 ret	 0
_stringInit8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3string.c
;	COMDAT _toUTF8_UTF16
_TEXT	SEGMENT
_cResult$ = -32						; size = 4
_utf8String$ = -28					; size = 4
_inputEnd$ = -20					; size = 4
_outputEnd$ = -8					; size = 4
_string$ = 8						; size = 4
_toUTF8_UTF16 PROC					; COMDAT

; 361  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  0000f	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00012	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00015	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00018	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0001b	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  0001e	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00021	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 362  : 
; 363  :     UTF8	      * outputEnd;	
; 364  :     UTF16	      * inputEnd;
; 365  :     pANTLR3_STRING	utf8String;
; 366  : 
; 367  :     ConversionResult	cResult;
; 368  : 
; 369  :     // Allocate the output buffer, which needs to accommodate potentially
; 370  :     // 3X (in bytes) the input size (in chars).
; 371  :     //
; 372  :     utf8String	= string->factory->newStr8(string->factory, (pANTLR3_UINT8)"");

  00024	8b f4		 mov	 esi, esp
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
  0002b	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  0002e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00030	51		 push	 ecx
  00031	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  00034	8b 02		 mov	 eax, DWORD PTR [edx]
  00036	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00039	ff d1		 call	 ecx
  0003b	83 c4 08	 add	 esp, 8
  0003e	3b f4		 cmp	 esi, esp
  00040	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00045	89 45 e4	 mov	 DWORD PTR _utf8String$[ebp], eax

; 373  : 
; 374  :     if	(utf8String != NULL)

  00048	83 7d e4 00	 cmp	 DWORD PTR _utf8String$[ebp], 0
  0004c	0f 84 ac 00 00
	00		 je	 $LN3@toUTF8_UTF

; 375  :     {
; 376  :         // Free existing allocation
; 377  :         //
; 378  :         ANTLR3_FREE(utf8String->chars);

  00052	8b f4		 mov	 esi, esp
  00054	8b 55 e4	 mov	 edx, DWORD PTR _utf8String$[ebp]
  00057	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0005a	50		 push	 eax
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00061	83 c4 04	 add	 esp, 4
  00064	3b f4		 cmp	 esi, esp
  00066	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 379  : 
; 380  :         // Reallocate according to maximum expected size
; 381  :         //
; 382  :         utf8String->size	= string->len *3;

  0006b	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  0006e	6b 51 08 03	 imul	 edx, DWORD PTR [ecx+8], 3
  00072	8b 45 e4	 mov	 eax, DWORD PTR _utf8String$[ebp]
  00075	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 383  :         utf8String->chars	= (pANTLR3_UINT8)ANTLR3_MALLOC(utf8String->size +1);

  00078	8b 4d e4	 mov	 ecx, DWORD PTR _utf8String$[ebp]
  0007b	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0007e	83 c2 01	 add	 edx, 1
  00081	8b f4		 mov	 esi, esp
  00083	52		 push	 edx
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0008a	83 c4 04	 add	 esp, 4
  0008d	3b f4		 cmp	 esi, esp
  0008f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00094	8b 4d e4	 mov	 ecx, DWORD PTR _utf8String$[ebp]
  00097	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 384  : 
; 385  :         if	(utf8String->chars != NULL)

  0009a	8b 55 e4	 mov	 edx, DWORD PTR _utf8String$[ebp]
  0009d	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  000a1	74 5b		 je	 SHORT $LN3@toUTF8_UTF

; 386  :         {
; 387  :             inputEnd  = (UTF16 *)	(string->chars);

  000a3	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  000a6	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000a9	89 4d ec	 mov	 DWORD PTR _inputEnd$[ebp], ecx

; 388  :             outputEnd = (UTF8 *)	(utf8String->chars);

  000ac	8b 55 e4	 mov	 edx, DWORD PTR _utf8String$[ebp]
  000af	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000b2	89 45 f8	 mov	 DWORD PTR _outputEnd$[ebp], eax

; 389  : 
; 390  :             // Call the Unicode converter
; 391  :             //
; 392  :             cResult =  ConvertUTF16toUTF8

  000b5	6a 01		 push	 1
  000b7	8b 4d e4	 mov	 ecx, DWORD PTR _utf8String$[ebp]
  000ba	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  000bd	8b 45 f8	 mov	 eax, DWORD PTR _outputEnd$[ebp]
  000c0	8d 4c 10 ff	 lea	 ecx, DWORD PTR [eax+edx-1]
  000c4	51		 push	 ecx
  000c5	8d 55 f8	 lea	 edx, DWORD PTR _outputEnd$[ebp]
  000c8	52		 push	 edx
  000c9	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  000cc	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000cf	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  000d2	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000d5	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  000d8	51		 push	 ecx
  000d9	8d 55 ec	 lea	 edx, DWORD PTR _inputEnd$[ebp]
  000dc	52		 push	 edx
  000dd	e8 00 00 00 00	 call	 _ConvertUTF16toUTF8
  000e2	83 c4 14	 add	 esp, 20			; 00000014H
  000e5	89 45 e0	 mov	 DWORD PTR _cResult$[ebp], eax

; 393  :                 (
; 394  :                 (const UTF16**)&inputEnd, 
; 395  :                 ((const UTF16 *)(string->chars)) + string->len, 
; 396  :                 &outputEnd, 
; 397  :                 outputEnd + utf8String->size - 1,
; 398  :                 lenientConversion
; 399  :                 );
; 400  : 
; 401  :             // We don't really care if things failed or not here, we just converted
; 402  :             // everything that was vaguely possible and stopped when it wasn't. It is
; 403  :             // up to the grammar programmer to verify that the input is sensible.
; 404  :             //
; 405  :             utf8String->len = ANTLR3_UINT32_CAST(((pANTLR3_UINT8)outputEnd) - utf8String->chars);

  000e8	8b 45 e4	 mov	 eax, DWORD PTR _utf8String$[ebp]
  000eb	8b 4d f8	 mov	 ecx, DWORD PTR _outputEnd$[ebp]
  000ee	2b 48 04	 sub	 ecx, DWORD PTR [eax+4]
  000f1	8b 55 e4	 mov	 edx, DWORD PTR _utf8String$[ebp]
  000f4	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 406  : 
; 407  :             *(outputEnd+1) = '\0';		// Always null terminate

  000f7	8b 45 f8	 mov	 eax, DWORD PTR _outputEnd$[ebp]
  000fa	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0
$LN3@toUTF8_UTF:

; 408  :         }
; 409  :     }
; 410  :     return utf8String;

  000fe	8b 45 e4	 mov	 eax, DWORD PTR _utf8String$[ebp]

; 411  : }

  00101	52		 push	 edx
  00102	8b cd		 mov	 ecx, ebp
  00104	50		 push	 eax
  00105	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN8@toUTF8_UTF
  0010b	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00110	58		 pop	 eax
  00111	5a		 pop	 edx
  00112	5e		 pop	 esi
  00113	83 c4 20	 add	 esp, 32			; 00000020H
  00116	3b ec		 cmp	 ebp, esp
  00118	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0011d	8b e5		 mov	 esp, ebp
  0011f	5d		 pop	 ebp
  00120	c3		 ret	 0
  00121	0f 1f 00	 npad	 3
$LN8@toUTF8_UTF:
  00124	02 00 00 00	 DD	 2
  00128	00 00 00 00	 DD	 $LN7@toUTF8_UTF
$LN7@toUTF8_UTF:
  0012c	f8 ff ff ff	 DD	 -8			; fffffff8H
  00130	04 00 00 00	 DD	 4
  00134	00 00 00 00	 DD	 $LN5@toUTF8_UTF
  00138	ec ff ff ff	 DD	 -20			; ffffffecH
  0013c	04 00 00 00	 DD	 4
  00140	00 00 00 00	 DD	 $LN6@toUTF8_UTF
$LN6@toUTF8_UTF:
  00144	69		 DB	 105			; 00000069H
  00145	6e		 DB	 110			; 0000006eH
  00146	70		 DB	 112			; 00000070H
  00147	75		 DB	 117			; 00000075H
  00148	74		 DB	 116			; 00000074H
  00149	45		 DB	 69			; 00000045H
  0014a	6e		 DB	 110			; 0000006eH
  0014b	64		 DB	 100			; 00000064H
  0014c	00		 DB	 0
$LN5@toUTF8_UTF:
  0014d	6f		 DB	 111			; 0000006fH
  0014e	75		 DB	 117			; 00000075H
  0014f	74		 DB	 116			; 00000074H
  00150	70		 DB	 112			; 00000070H
  00151	75		 DB	 117			; 00000075H
  00152	74		 DB	 116			; 00000074H
  00153	45		 DB	 69			; 00000045H
  00154	6e		 DB	 110			; 0000006eH
  00155	64		 DB	 100			; 00000064H
  00156	00		 DB	 0
_toUTF8_UTF16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3string.c
;	COMDAT _toUTF8_8
_TEXT	SEGMENT
_string$ = 8						; size = 4
_toUTF8_8 PROC						; COMDAT

; 350  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 351  : 	return string->factory->newPtr(string->factory, (pANTLR3_UINT8)(string->chars), string->len);

  00004	8b f4		 mov	 esi, esp
  00006	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  00009	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000c	51		 push	 ecx
  0000d	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  00010	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00013	50		 push	 eax
  00014	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  00017	8b 11		 mov	 edx, DWORD PTR [ecx]
  00019	52		 push	 edx
  0001a	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  0001d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001f	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00022	ff d2		 call	 edx
  00024	83 c4 0c	 add	 esp, 12			; 0000000cH
  00027	3b f4		 cmp	 esi, esp
  00029	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 352  : }

  0002e	5e		 pop	 esi
  0002f	3b ec		 cmp	 ebp, esp
  00031	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
_toUTF8_8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3string.c
;	COMDAT _to8_UTF16
_TEXT	SEGMENT
tv93 = -16						; size = 4
_c$1 = -12						; size = 4
_i$ = -8						; size = 4
_newStr$ = -4						; size = 4
_string$ = 8						; size = 4
_to8_UTF16 PROC						; COMDAT

; 1426 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000f	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00012	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00015	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 1427 : 	pANTLR3_STRING  newStr;
; 1428 : 	ANTLR3_UINT32   i;
; 1429 : 
; 1430 : 	/* Create a new 8 bit string
; 1431 : 	*/
; 1432 : 	newStr  = newRaw8(string->factory);

  00018	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  0001b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001d	51		 push	 ecx
  0001e	e8 00 00 00 00	 call	 _newRaw8
  00023	83 c4 04	 add	 esp, 4
  00026	89 45 fc	 mov	 DWORD PTR _newStr$[ebp], eax

; 1433 : 
; 1434 : 	if	(newStr == NULL)

  00029	83 7d fc 00	 cmp	 DWORD PTR _newStr$[ebp], 0
  0002d	75 07		 jne	 SHORT $LN5@to8_UTF16

; 1435 : 	{
; 1436 : 		return	NULL;

  0002f	33 c0		 xor	 eax, eax
  00031	e9 b3 00 00 00	 jmp	 $LN1@to8_UTF16
$LN5@to8_UTF16:

; 1437 : 	}
; 1438 : 
; 1439 : 	/* Always add one more byte for a terminator
; 1440 : 	*/
; 1441 : 	newStr->chars   = (pANTLR3_UINT8) ANTLR3_MALLOC((size_t)(string->len + 1));

  00036	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  00039	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0003c	83 c0 01	 add	 eax, 1
  0003f	8b f4		 mov	 esi, esp
  00041	50		 push	 eax
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00048	83 c4 04	 add	 esp, 4
  0004b	3b f4		 cmp	 esi, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	8b 4d fc	 mov	 ecx, DWORD PTR _newStr$[ebp]
  00055	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1442 : 	if (newStr->chars != NULL)

  00058	8b 55 fc	 mov	 edx, DWORD PTR _newStr$[ebp]
  0005b	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  0005f	0f 84 81 00 00
	00		 je	 $LN6@to8_UTF16

; 1443 : 	{
; 1444 : 		newStr->size    = string->len + 1;

  00065	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  00068	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0006b	83 c1 01	 add	 ecx, 1
  0006e	8b 55 fc	 mov	 edx, DWORD PTR _newStr$[ebp]
  00071	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 1445 : 		newStr->len	    = string->len;

  00074	8b 45 fc	 mov	 eax, DWORD PTR _newStr$[ebp]
  00077	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  0007a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0007d	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1446 : 
; 1447 : 		/* Now copy each UTF16 charActer , making it an 8 bit character of 
; 1448 : 		* some sort.
; 1449 : 		*/
; 1450 : 		for	(i=0; i<string->len; i++)

  00080	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00087	eb 09		 jmp	 SHORT $LN4@to8_UTF16
$LN2@to8_UTF16:
  00089	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0008c	83 c0 01	 add	 eax, 1
  0008f	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@to8_UTF16:
  00092	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  00095	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00098	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0009b	73 39		 jae	 SHORT $LN3@to8_UTF16

; 1451 : 		{
; 1452 : 			ANTLR3_UCHAR	c;
; 1453 : 
; 1454 : 			c = *(((pANTLR3_UINT16)(string->chars)) + i);

  0009d	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  000a0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000a3	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  000a6	0f b7 04 51	 movzx	 eax, WORD PTR [ecx+edx*2]
  000aa	89 45 f4	 mov	 DWORD PTR _c$1[ebp], eax

; 1455 : 
; 1456 : 			*(newStr->chars + i) = (ANTLR3_UINT8)(c > 255 ? '_' : c);

  000ad	81 7d f4 ff 00
	00 00		 cmp	 DWORD PTR _c$1[ebp], 255 ; 000000ffH
  000b4	76 09		 jbe	 SHORT $LN8@to8_UTF16
  000b6	c7 45 f0 5f 00
	00 00		 mov	 DWORD PTR tv93[ebp], 95	; 0000005fH
  000bd	eb 06		 jmp	 SHORT $LN9@to8_UTF16
$LN8@to8_UTF16:
  000bf	8b 4d f4	 mov	 ecx, DWORD PTR _c$1[ebp]
  000c2	89 4d f0	 mov	 DWORD PTR tv93[ebp], ecx
$LN9@to8_UTF16:
  000c5	8b 55 fc	 mov	 edx, DWORD PTR _newStr$[ebp]
  000c8	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000cb	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  000ce	8a 55 f0	 mov	 dl, BYTE PTR tv93[ebp]
  000d1	88 14 08	 mov	 BYTE PTR [eax+ecx], dl

; 1457 : 		}

  000d4	eb b3		 jmp	 SHORT $LN2@to8_UTF16
$LN3@to8_UTF16:

; 1458 : 
; 1459 : 		/* Terminate
; 1460 : 		*/
; 1461 : 		*(newStr->chars + newStr->len) = '\0';

  000d6	8b 45 fc	 mov	 eax, DWORD PTR _newStr$[ebp]
  000d9	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000dc	8b 55 fc	 mov	 edx, DWORD PTR _newStr$[ebp]
  000df	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000e2	c6 04 01 00	 mov	 BYTE PTR [ecx+eax], 0
$LN6@to8_UTF16:

; 1462 : 	}
; 1463 : 
; 1464 : 	return newStr;

  000e6	8b 45 fc	 mov	 eax, DWORD PTR _newStr$[ebp]
$LN1@to8_UTF16:

; 1465 : }

  000e9	5e		 pop	 esi
  000ea	83 c4 10	 add	 esp, 16			; 00000010H
  000ed	3b ec		 cmp	 ebp, esp
  000ef	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f4	8b e5		 mov	 esp, ebp
  000f6	5d		 pop	 ebp
  000f7	c3		 ret	 0
_to8_UTF16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3string.c
;	COMDAT _to8_8
_TEXT	SEGMENT
_string$ = 8						; size = 4
_to8_8	PROC						; COMDAT

; 1416 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1417 :     return  string;

  00003	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]

; 1418 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
_to8_8	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3string.c
;	COMDAT _toInt32_UTF16
_TEXT	SEGMENT
tv85 = -16						; size = 4
_negate$ = -9						; size = 1
_value$ = -8						; size = 4
_input$ = -4						; size = 4
_string$ = 8						; size = 4
_toInt32_UTF16 PROC					; COMDAT

; 1382 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000f	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00012	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00015	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 1383 :     pANTLR3_UINT16  input;
; 1384 :     ANTLR3_INT32   value;
; 1385 :     ANTLR3_BOOLEAN  negate;
; 1386 : 
; 1387 :     value   = 0;

  00018	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _value$[ebp], 0

; 1388 :     input   = (pANTLR3_UINT16)(string->chars);

  0001f	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  00022	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00025	89 4d fc	 mov	 DWORD PTR _input$[ebp], ecx

; 1389 :     negate  = ANTLR3_FALSE;

  00028	c6 45 f7 00	 mov	 BYTE PTR _negate$[ebp], 0

; 1390 : 
; 1391 :     if	(*input == (ANTLR3_UCHAR)'-')

  0002c	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  0002f	0f b7 02	 movzx	 eax, WORD PTR [edx]
  00032	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  00035	75 0f		 jne	 SHORT $LN4@toInt32_UT

; 1392 :     {
; 1393 : 		negate = ANTLR3_TRUE;

  00037	c6 45 f7 01	 mov	 BYTE PTR _negate$[ebp], 1

; 1394 : 		input++;

  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  0003e	83 c1 02	 add	 ecx, 2
  00041	89 4d fc	 mov	 DWORD PTR _input$[ebp], ecx

; 1395 :     }

  00044	eb 14		 jmp	 SHORT $LN6@toInt32_UT
$LN4@toInt32_UT:

; 1396 :     else if (*input == (ANTLR3_UCHAR)'+')

  00046	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  00049	0f b7 02	 movzx	 eax, WORD PTR [edx]
  0004c	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  0004f	75 09		 jne	 SHORT $LN6@toInt32_UT

; 1397 :     {
; 1398 : 		input++;

  00051	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  00054	83 c1 02	 add	 ecx, 2
  00057	89 4d fc	 mov	 DWORD PTR _input$[ebp], ecx
$LN6@toInt32_UT:

; 1399 :     }
; 1400 : 
; 1401 :     while   (*input != '\0' && isdigit(*input))

  0005a	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  0005d	0f b7 02	 movzx	 eax, WORD PTR [edx]
  00060	85 c0		 test	 eax, eax
  00062	74 3f		 je	 SHORT $LN3@toInt32_UT
  00064	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  00067	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  0006a	8b f4		 mov	 esi, esp
  0006c	52		 push	 edx
  0006d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__isdigit
  00073	83 c4 04	 add	 esp, 4
  00076	3b f4		 cmp	 esi, esp
  00078	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007d	85 c0		 test	 eax, eax
  0007f	74 22		 je	 SHORT $LN3@toInt32_UT

; 1402 :     {
; 1403 : 		value	 = value * 10;

  00081	6b 45 f8 0a	 imul	 eax, DWORD PTR _value$[ebp], 10
  00085	89 45 f8	 mov	 DWORD PTR _value$[ebp], eax

; 1404 : 		value	+= ((ANTLR3_UINT32)(*input) - (ANTLR3_UINT32)'0');

  00088	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  0008b	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  0008e	8b 45 f8	 mov	 eax, DWORD PTR _value$[ebp]
  00091	8d 4c 10 d0	 lea	 ecx, DWORD PTR [eax+edx-48]
  00095	89 4d f8	 mov	 DWORD PTR _value$[ebp], ecx

; 1405 : 		input++;

  00098	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  0009b	83 c2 02	 add	 edx, 2
  0009e	89 55 fc	 mov	 DWORD PTR _input$[ebp], edx

; 1406 :     }

  000a1	eb b7		 jmp	 SHORT $LN6@toInt32_UT
$LN3@toInt32_UT:

; 1407 : 
; 1408 :     return negate ? -value : value;

  000a3	0f b6 45 f7	 movzx	 eax, BYTE PTR _negate$[ebp]
  000a7	85 c0		 test	 eax, eax
  000a9	74 0a		 je	 SHORT $LN8@toInt32_UT
  000ab	8b 4d f8	 mov	 ecx, DWORD PTR _value$[ebp]
  000ae	f7 d9		 neg	 ecx
  000b0	89 4d f0	 mov	 DWORD PTR tv85[ebp], ecx
  000b3	eb 06		 jmp	 SHORT $LN9@toInt32_UT
$LN8@toInt32_UT:
  000b5	8b 55 f8	 mov	 edx, DWORD PTR _value$[ebp]
  000b8	89 55 f0	 mov	 DWORD PTR tv85[ebp], edx
$LN9@toInt32_UT:
  000bb	8b 45 f0	 mov	 eax, DWORD PTR tv85[ebp]

; 1409 : }

  000be	5e		 pop	 esi
  000bf	83 c4 10	 add	 esp, 16			; 00000010H
  000c2	3b ec		 cmp	 ebp, esp
  000c4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c9	8b e5		 mov	 esp, ebp
  000cb	5d		 pop	 ebp
  000cc	c3		 ret	 0
_toInt32_UTF16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3string.c
;	COMDAT _toInt32_8
_TEXT	SEGMENT
_string$ = 8						; size = 4
_toInt32_8 PROC						; COMDAT

; 1374 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1375 :     return  atoi((const char *)(string->chars));

  00004	8b f4		 mov	 esi, esp
  00006	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  00009	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000c	51		 push	 ecx
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  00013	83 c4 04	 add	 esp, 4
  00016	3b f4		 cmp	 esi, esp
  00018	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1376 : }

  0001d	5e		 pop	 esi
  0001e	3b ec		 cmp	 ebp, esp
  00020	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
_toInt32_8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3string.c
;	COMDAT _subStringUTF16
_TEXT	SEGMENT
_newStr$ = -4						; size = 4
_string$ = 8						; size = 4
_startIndex$ = 12					; size = 4
_endIndex$ = 16						; size = 4
_subStringUTF16 PROC					; COMDAT

; 1358 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 1359 :     pANTLR3_STRING newStr;
; 1360 : 
; 1361 :     if	(endIndex > string->len)

  0000c	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  0000f	8b 4d 10	 mov	 ecx, DWORD PTR _endIndex$[ebp]
  00012	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00015	76 0c		 jbe	 SHORT $LN2@subStringU

; 1362 :     {
; 1363 : 		endIndex = string->len + 1;

  00017	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  0001a	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0001d	83 c0 01	 add	 eax, 1
  00020	89 45 10	 mov	 DWORD PTR _endIndex$[ebp], eax
$LN2@subStringU:

; 1364 :     }
; 1365 :     newStr  = string->factory->newPtr(string->factory, (pANTLR3_UINT8)((pANTLR3_UINT16)(string->chars) + startIndex), endIndex - startIndex);

  00023	8b 4d 10	 mov	 ecx, DWORD PTR _endIndex$[ebp]
  00026	2b 4d 0c	 sub	 ecx, DWORD PTR _startIndex$[ebp]
  00029	8b f4		 mov	 esi, esp
  0002b	51		 push	 ecx
  0002c	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  0002f	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00032	8b 4d 0c	 mov	 ecx, DWORD PTR _startIndex$[ebp]
  00035	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  00038	52		 push	 edx
  00039	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  0003c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003e	51		 push	 ecx
  0003f	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  00042	8b 02		 mov	 eax, DWORD PTR [edx]
  00044	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00047	ff d1		 call	 ecx
  00049	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004c	3b f4		 cmp	 esi, esp
  0004e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00053	89 45 fc	 mov	 DWORD PTR _newStr$[ebp], eax

; 1366 : 
; 1367 :     return newStr;

  00056	8b 45 fc	 mov	 eax, DWORD PTR _newStr$[ebp]

; 1368 : }

  00059	5e		 pop	 esi
  0005a	83 c4 04	 add	 esp, 4
  0005d	3b ec		 cmp	 ebp, esp
  0005f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
_subStringUTF16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3string.c
;	COMDAT _subString8
_TEXT	SEGMENT
_newStr$ = -4						; size = 4
_string$ = 8						; size = 4
_startIndex$ = 12					; size = 4
_endIndex$ = 16						; size = 4
_subString8 PROC					; COMDAT

; 1341 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 1342 :     pANTLR3_STRING newStr;
; 1343 : 
; 1344 :     if	(endIndex > string->len)

  0000c	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  0000f	8b 4d 10	 mov	 ecx, DWORD PTR _endIndex$[ebp]
  00012	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00015	76 0c		 jbe	 SHORT $LN2@subString8

; 1345 :     {
; 1346 : 		endIndex = string->len + 1;

  00017	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  0001a	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0001d	83 c0 01	 add	 eax, 1
  00020	89 45 10	 mov	 DWORD PTR _endIndex$[ebp], eax
$LN2@subString8:

; 1347 :     }
; 1348 :     newStr  = string->factory->newPtr(string->factory, string->chars + startIndex, endIndex - startIndex);

  00023	8b 4d 10	 mov	 ecx, DWORD PTR _endIndex$[ebp]
  00026	2b 4d 0c	 sub	 ecx, DWORD PTR _startIndex$[ebp]
  00029	8b f4		 mov	 esi, esp
  0002b	51		 push	 ecx
  0002c	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  0002f	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00032	03 45 0c	 add	 eax, DWORD PTR _startIndex$[ebp]
  00035	50		 push	 eax
  00036	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  00039	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003b	52		 push	 edx
  0003c	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  0003f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00041	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00044	ff d2		 call	 edx
  00046	83 c4 0c	 add	 esp, 12			; 0000000cH
  00049	3b f4		 cmp	 esi, esp
  0004b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00050	89 45 fc	 mov	 DWORD PTR _newStr$[ebp], eax

; 1349 : 
; 1350 :     return newStr;

  00053	8b 45 fc	 mov	 eax, DWORD PTR _newStr$[ebp]

; 1351 : }

  00056	5e		 pop	 esi
  00057	83 c4 04	 add	 esp, 4
  0005a	3b ec		 cmp	 ebp, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
_subString8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3string.c
;	COMDAT _charAtUTF16
_TEXT	SEGMENT
_string$ = 8						; size = 4
_offset$ = 12						; size = 4
_charAtUTF16 PROC					; COMDAT

; 1325 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1326 :     if	(offset > string->len)

  00003	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _offset$[ebp]
  00009	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  0000c	76 06		 jbe	 SHORT $LN2@charAtUTF1

; 1327 :     {
; 1328 : 		return (ANTLR3_UCHAR)'\0';

  0000e	33 c0		 xor	 eax, eax
  00010	eb 0f		 jmp	 SHORT $LN3@charAtUTF1

; 1329 :     }

  00012	eb 0d		 jmp	 SHORT $LN3@charAtUTF1
$LN2@charAtUTF1:

; 1330 :     else
; 1331 :     {
; 1332 : 		return  (ANTLR3_UCHAR)(*((pANTLR3_UINT16)(string->chars) + offset));

  00014	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  00017	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0001a	8b 4d 0c	 mov	 ecx, DWORD PTR _offset$[ebp]
  0001d	0f b7 04 48	 movzx	 eax, WORD PTR [eax+ecx*2]
$LN3@charAtUTF1:

; 1333 :     }
; 1334 : }

  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
_charAtUTF16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3string.c
;	COMDAT _charAt8
_TEXT	SEGMENT
_string$ = 8						; size = 4
_offset$ = 12						; size = 4
_charAt8 PROC						; COMDAT

; 1309 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1310 :     if	(offset > string->len)

  00003	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _offset$[ebp]
  00009	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  0000c	76 06		 jbe	 SHORT $LN2@charAt8

; 1311 :     {
; 1312 : 		return (ANTLR3_UCHAR)'\0';

  0000e	33 c0		 xor	 eax, eax
  00010	eb 0f		 jmp	 SHORT $LN3@charAt8

; 1313 :     }

  00012	eb 0d		 jmp	 SHORT $LN3@charAt8
$LN2@charAt8:

; 1314 :     else
; 1315 :     {
; 1316 : 		return  (ANTLR3_UCHAR)(*(string->chars + offset));

  00014	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  00017	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0001a	8b 4d 0c	 mov	 ecx, DWORD PTR _offset$[ebp]
  0001d	0f b6 04 08	 movzx	 eax, BYTE PTR [eax+ecx]
$LN3@charAt8:

; 1317 :     }
; 1318 : }

  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
_charAt8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3string.c
;	COMDAT _compareS
_TEXT	SEGMENT
_string$ = 8						; size = 4
_compStr$ = 12						; size = 4
_compareS PROC						; COMDAT

; 1299 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1300 :     return  string->compare(string, (const char *)compStr->chars);

  00004	8b f4		 mov	 esi, esp
  00006	8b 45 0c	 mov	 eax, DWORD PTR _compStr$[ebp]
  00009	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000c	51		 push	 ecx
  0000d	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  00010	52		 push	 edx
  00011	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  00014	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  00017	ff d1		 call	 ecx
  00019	83 c4 08	 add	 esp, 8
  0001c	3b f4		 cmp	 esi, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1301 : }

  00023	5e		 pop	 esi
  00024	3b ec		 cmp	 ebp, esp
  00026	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
_compareS ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3string.c
;	COMDAT _compareUTF16_UTF16
_TEXT	SEGMENT
_charDiff$ = -12					; size = 4
_compStr$ = -8						; size = 4
_ourString$ = -4					; size = 4
_string$ = 8						; size = 4
_compStr8$ = 12						; size = 4
_compareUTF16_UTF16 PROC				; COMDAT

; 1269 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1270 :     pANTLR3_UINT16  ourString;
; 1271 :     pANTLR3_UINT16  compStr;
; 1272 :     ANTLR3_UINT32   charDiff;
; 1273 : 
; 1274 :     ourString	= (pANTLR3_UINT16)(string->chars);

  00006	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  00009	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000c	89 4d fc	 mov	 DWORD PTR _ourString$[ebp], ecx

; 1275 :     compStr	= (pANTLR3_UINT16)(compStr8);

  0000f	8b 55 0c	 mov	 edx, DWORD PTR _compStr8$[ebp]
  00012	89 55 f8	 mov	 DWORD PTR _compStr$[ebp], edx
$LN2@compareUTF:

; 1276 : 
; 1277 :     while   (((ANTLR3_UCHAR)(*ourString) != '\0') && ((ANTLR3_UCHAR)(*((pANTLR3_UINT16)compStr)) != '\0'))

  00015	8b 45 fc	 mov	 eax, DWORD PTR _ourString$[ebp]
  00018	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  0001b	85 c9		 test	 ecx, ecx
  0001d	74 36		 je	 SHORT $LN3@compareUTF
  0001f	8b 55 f8	 mov	 edx, DWORD PTR _compStr$[ebp]
  00022	0f b7 02	 movzx	 eax, WORD PTR [edx]
  00025	85 c0		 test	 eax, eax
  00027	74 2c		 je	 SHORT $LN3@compareUTF

; 1278 :     {
; 1279 : 		charDiff = *ourString - *compStr;

  00029	8b 4d fc	 mov	 ecx, DWORD PTR _ourString$[ebp]
  0002c	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  0002f	8b 45 f8	 mov	 eax, DWORD PTR _compStr$[ebp]
  00032	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00035	2b d1		 sub	 edx, ecx
  00037	89 55 f4	 mov	 DWORD PTR _charDiff$[ebp], edx

; 1280 : 		if  (charDiff != 0)

  0003a	74 05		 je	 SHORT $LN4@compareUTF

; 1281 : 		{
; 1282 : 			return charDiff;

  0003c	8b 45 f4	 mov	 eax, DWORD PTR _charDiff$[ebp]
  0003f	eb 22		 jmp	 SHORT $LN1@compareUTF
$LN4@compareUTF:

; 1283 : 		}
; 1284 : 		ourString++;

  00041	8b 55 fc	 mov	 edx, DWORD PTR _ourString$[ebp]
  00044	83 c2 02	 add	 edx, 2
  00047	89 55 fc	 mov	 DWORD PTR _ourString$[ebp], edx

; 1285 : 		compStr++;

  0004a	8b 45 f8	 mov	 eax, DWORD PTR _compStr$[ebp]
  0004d	83 c0 02	 add	 eax, 2
  00050	89 45 f8	 mov	 DWORD PTR _compStr$[ebp], eax

; 1286 :     }

  00053	eb c0		 jmp	 SHORT $LN2@compareUTF
$LN3@compareUTF:

; 1287 : 
; 1288 :     /* At this point, one of the strings was terminated
; 1289 :      */
; 1290 :     return (ANTLR3_UINT32)((ANTLR3_UCHAR)(*ourString) - (ANTLR3_UCHAR)(*compStr));

  00055	8b 4d fc	 mov	 ecx, DWORD PTR _ourString$[ebp]
  00058	0f b7 01	 movzx	 eax, WORD PTR [ecx]
  0005b	8b 55 f8	 mov	 edx, DWORD PTR _compStr$[ebp]
  0005e	0f b7 0a	 movzx	 ecx, WORD PTR [edx]
  00061	2b c1		 sub	 eax, ecx
$LN1@compareUTF:

; 1291 : }

  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
_compareUTF16_UTF16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3string.c
;	COMDAT _compareUTF16_8
_TEXT	SEGMENT
_charDiff$ = -8						; size = 4
_ourString$ = -4					; size = 4
_string$ = 8						; size = 4
_compStr$ = 12						; size = 4
_compareUTF16_8 PROC					; COMDAT

; 1240 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1241 :     pANTLR3_UINT16  ourString;
; 1242 :     ANTLR3_UINT32   charDiff;
; 1243 : 
; 1244 :     ourString	= (pANTLR3_UINT16)(string->chars);

  00006	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  00009	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000c	89 4d fc	 mov	 DWORD PTR _ourString$[ebp], ecx
$LN2@compareUTF:

; 1245 : 
; 1246 :     while   (((ANTLR3_UCHAR)(*ourString) != '\0') && ((ANTLR3_UCHAR)(*compStr) != '\0'))

  0000f	8b 55 fc	 mov	 edx, DWORD PTR _ourString$[ebp]
  00012	0f b7 02	 movzx	 eax, WORD PTR [edx]
  00015	85 c0		 test	 eax, eax
  00017	74 36		 je	 SHORT $LN3@compareUTF
  00019	8b 4d 0c	 mov	 ecx, DWORD PTR _compStr$[ebp]
  0001c	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  0001f	85 d2		 test	 edx, edx
  00021	74 2c		 je	 SHORT $LN3@compareUTF

; 1247 :     {
; 1248 : 		charDiff = *ourString - *compStr;

  00023	8b 45 fc	 mov	 eax, DWORD PTR _ourString$[ebp]
  00026	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00029	8b 55 0c	 mov	 edx, DWORD PTR _compStr$[ebp]
  0002c	0f be 02	 movsx	 eax, BYTE PTR [edx]
  0002f	2b c8		 sub	 ecx, eax
  00031	89 4d f8	 mov	 DWORD PTR _charDiff$[ebp], ecx

; 1249 : 		if  (charDiff != 0)

  00034	74 05		 je	 SHORT $LN4@compareUTF

; 1250 : 		{
; 1251 : 			return charDiff;

  00036	8b 45 f8	 mov	 eax, DWORD PTR _charDiff$[ebp]
  00039	eb 22		 jmp	 SHORT $LN1@compareUTF
$LN4@compareUTF:

; 1252 : 		}
; 1253 : 		ourString++;

  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _ourString$[ebp]
  0003e	83 c1 02	 add	 ecx, 2
  00041	89 4d fc	 mov	 DWORD PTR _ourString$[ebp], ecx

; 1254 : 		compStr++;

  00044	8b 55 0c	 mov	 edx, DWORD PTR _compStr$[ebp]
  00047	83 c2 01	 add	 edx, 1
  0004a	89 55 0c	 mov	 DWORD PTR _compStr$[ebp], edx

; 1255 :     }

  0004d	eb c0		 jmp	 SHORT $LN2@compareUTF
$LN3@compareUTF:

; 1256 : 
; 1257 :     /* At this point, one of the strings was terminated
; 1258 :      */
; 1259 :     return (ANTLR3_UINT32)((ANTLR3_UCHAR)(*ourString) - (ANTLR3_UCHAR)(*compStr));

  0004f	8b 45 fc	 mov	 eax, DWORD PTR _ourString$[ebp]
  00052	0f b7 00	 movzx	 eax, WORD PTR [eax]
  00055	8b 4d 0c	 mov	 ecx, DWORD PTR _compStr$[ebp]
  00058	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  0005b	2b c2		 sub	 eax, edx
$LN1@compareUTF:

; 1260 : 
; 1261 : }

  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
_compareUTF16_8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3string.c
;	COMDAT _compare8
_TEXT	SEGMENT
_string$ = 8						; size = 4
_compStr$ = 12						; size = 4
_compare8 PROC						; COMDAT

; 1230 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1231 :     return  strcmp((const char *)(string->chars), compStr);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _compStr$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  0000a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0000d	52		 push	 edx
  0000e	e8 00 00 00 00	 call	 _strcmp
  00013	83 c4 08	 add	 esp, 8

; 1232 : }

  00016	3b ec		 cmp	 ebp, esp
  00018	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
_compare8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3string.c
;	COMDAT _insertiUTF16
_TEXT	SEGMENT
_newbit$ = -40						; size = 32
__$ArrayPad$ = -4					; size = 4
_string$ = 8						; size = 4
_point$ = 12						; size = 4
_i$ = 16						; size = 4
_insertiUTF16 PROC					; COMDAT

; 1057 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8d 7d d4	 lea	 edi, DWORD PTR [ebp-44]
  0000b	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1058 :     ANTLR3_UINT8	    newbit[32];
; 1059 : 
; 1060 :     sprintf((char *)newbit, "%d", i);

  00021	8b 45 10	 mov	 eax, DWORD PTR _i$[ebp]
  00024	50		 push	 eax
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  0002a	8d 4d d8	 lea	 ecx, DWORD PTR _newbit$[ebp]
  0002d	51		 push	 ecx
  0002e	e8 00 00 00 00	 call	 _sprintf
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1061 :     return  string->insert8(string, point, (const char *)newbit);

  00036	8b f4		 mov	 esi, esp
  00038	8d 55 d8	 lea	 edx, DWORD PTR _newbit$[ebp]
  0003b	52		 push	 edx
  0003c	8b 45 0c	 mov	 eax, DWORD PTR _point$[ebp]
  0003f	50		 push	 eax
  00040	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  00043	51		 push	 ecx
  00044	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  00047	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  0004a	ff d0		 call	 eax
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004f	3b f4		 cmp	 esi, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1062 : }

  00056	52		 push	 edx
  00057	8b cd		 mov	 ecx, ebp
  00059	50		 push	 eax
  0005a	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@insertiUTF
  00060	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00065	58		 pop	 eax
  00066	5a		 pop	 edx
  00067	5f		 pop	 edi
  00068	5e		 pop	 esi
  00069	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006c	33 cd		 xor	 ecx, ebp
  0006e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00073	83 c4 2c	 add	 esp, 44			; 0000002cH
  00076	3b ec		 cmp	 ebp, esp
  00078	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007d	8b e5		 mov	 esp, ebp
  0007f	5d		 pop	 ebp
  00080	c3		 ret	 0
  00081	0f 1f 00	 npad	 3
$LN5@insertiUTF:
  00084	01 00 00 00	 DD	 1
  00088	00 00 00 00	 DD	 $LN4@insertiUTF
$LN4@insertiUTF:
  0008c	d8 ff ff ff	 DD	 -40			; ffffffd8H
  00090	20 00 00 00	 DD	 32			; 00000020H
  00094	00 00 00 00	 DD	 $LN3@insertiUTF
$LN3@insertiUTF:
  00098	6e		 DB	 110			; 0000006eH
  00099	65		 DB	 101			; 00000065H
  0009a	77		 DB	 119			; 00000077H
  0009b	62		 DB	 98			; 00000062H
  0009c	69		 DB	 105			; 00000069H
  0009d	74		 DB	 116			; 00000074H
  0009e	00		 DB	 0
_insertiUTF16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3string.c
;	COMDAT _inserti8
_TEXT	SEGMENT
_newbit$ = -40						; size = 32
__$ArrayPad$ = -4					; size = 4
_string$ = 8						; size = 4
_point$ = 12						; size = 4
_i$ = 16						; size = 4
_inserti8 PROC						; COMDAT

; 1049 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8d 7d d4	 lea	 edi, DWORD PTR [ebp-44]
  0000b	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1050 :     ANTLR3_UINT8	    newbit[32];
; 1051 : 
; 1052 :     sprintf((char *)newbit, "%d", i);

  00021	8b 45 10	 mov	 eax, DWORD PTR _i$[ebp]
  00024	50		 push	 eax
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  0002a	8d 4d d8	 lea	 ecx, DWORD PTR _newbit$[ebp]
  0002d	51		 push	 ecx
  0002e	e8 00 00 00 00	 call	 _sprintf
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1053 :     return  string->insert8(string, point, (const char *)newbit);

  00036	8b f4		 mov	 esi, esp
  00038	8d 55 d8	 lea	 edx, DWORD PTR _newbit$[ebp]
  0003b	52		 push	 edx
  0003c	8b 45 0c	 mov	 eax, DWORD PTR _point$[ebp]
  0003f	50		 push	 eax
  00040	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  00043	51		 push	 ecx
  00044	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  00047	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  0004a	ff d0		 call	 eax
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004f	3b f4		 cmp	 esi, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1054 : }

  00056	52		 push	 edx
  00057	8b cd		 mov	 ecx, ebp
  00059	50		 push	 eax
  0005a	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@inserti8
  00060	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00065	58		 pop	 eax
  00066	5a		 pop	 edx
  00067	5f		 pop	 edi
  00068	5e		 pop	 esi
  00069	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006c	33 cd		 xor	 ecx, ebp
  0006e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00073	83 c4 2c	 add	 esp, 44			; 0000002cH
  00076	3b ec		 cmp	 ebp, esp
  00078	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007d	8b e5		 mov	 esp, ebp
  0007f	5d		 pop	 ebp
  00080	c3		 ret	 0
  00081	0f 1f 00	 npad	 3
$LN5@inserti8:
  00084	01 00 00 00	 DD	 1
  00088	00 00 00 00	 DD	 $LN4@inserti8
$LN4@inserti8:
  0008c	d8 ff ff ff	 DD	 -40			; ffffffd8H
  00090	20 00 00 00	 DD	 32			; 00000020H
  00094	00 00 00 00	 DD	 $LN3@inserti8
$LN3@inserti8:
  00098	6e		 DB	 110			; 0000006eH
  00099	65		 DB	 101			; 00000065H
  0009a	77		 DB	 119			; 00000077H
  0009b	62		 DB	 98			; 00000062H
  0009c	69		 DB	 105			; 00000069H
  0009d	74		 DB	 116			; 00000074H
  0009e	00		 DB	 0
_inserti8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3string.c
;	COMDAT _addiUTF16
_TEXT	SEGMENT
_newbit$ = -40						; size = 32
__$ArrayPad$ = -4					; size = 4
_string$ = 8						; size = 4
_i$ = 12						; size = 4
_addiUTF16 PROC						; COMDAT

; 1039 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8d 7d d4	 lea	 edi, DWORD PTR [ebp-44]
  0000b	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1040 :     ANTLR3_UINT8	    newbit[32];
; 1041 : 
; 1042 :     sprintf((char *)newbit, "%d", i);

  00021	8b 45 0c	 mov	 eax, DWORD PTR _i$[ebp]
  00024	50		 push	 eax
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  0002a	8d 4d d8	 lea	 ecx, DWORD PTR _newbit$[ebp]
  0002d	51		 push	 ecx
  0002e	e8 00 00 00 00	 call	 _sprintf
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1043 : 
; 1044 :     return  string->append8(string, (const char *)newbit);

  00036	8b f4		 mov	 esi, esp
  00038	8d 55 d8	 lea	 edx, DWORD PTR _newbit$[ebp]
  0003b	52		 push	 edx
  0003c	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  0003f	50		 push	 eax
  00040	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  00043	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00046	ff d2		 call	 edx
  00048	83 c4 08	 add	 esp, 8
  0004b	3b f4		 cmp	 esi, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1045 : }

  00052	52		 push	 edx
  00053	8b cd		 mov	 ecx, ebp
  00055	50		 push	 eax
  00056	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@addiUTF16
  0005c	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00061	58		 pop	 eax
  00062	5a		 pop	 edx
  00063	5f		 pop	 edi
  00064	5e		 pop	 esi
  00065	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00068	33 cd		 xor	 ecx, ebp
  0006a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006f	83 c4 2c	 add	 esp, 44			; 0000002cH
  00072	3b ec		 cmp	 ebp, esp
  00074	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
  0007d	0f 1f 00	 npad	 3
$LN5@addiUTF16:
  00080	01 00 00 00	 DD	 1
  00084	00 00 00 00	 DD	 $LN4@addiUTF16
$LN4@addiUTF16:
  00088	d8 ff ff ff	 DD	 -40			; ffffffd8H
  0008c	20 00 00 00	 DD	 32			; 00000020H
  00090	00 00 00 00	 DD	 $LN3@addiUTF16
$LN3@addiUTF16:
  00094	6e		 DB	 110			; 0000006eH
  00095	65		 DB	 101			; 00000065H
  00096	77		 DB	 119			; 00000077H
  00097	62		 DB	 98			; 00000062H
  00098	69		 DB	 105			; 00000069H
  00099	74		 DB	 116			; 00000074H
  0009a	00		 DB	 0
_addiUTF16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3string.c
;	COMDAT _addi8
_TEXT	SEGMENT
_newbit$ = -40						; size = 32
__$ArrayPad$ = -4					; size = 4
_string$ = 8						; size = 4
_i$ = 12						; size = 4
_addi8	PROC						; COMDAT

; 1030 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8d 7d d4	 lea	 edi, DWORD PTR [ebp-44]
  0000b	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1031 :     ANTLR3_UINT8	    newbit[32];
; 1032 : 
; 1033 :     sprintf((char *)newbit, "%d", i);

  00021	8b 45 0c	 mov	 eax, DWORD PTR _i$[ebp]
  00024	50		 push	 eax
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  0002a	8d 4d d8	 lea	 ecx, DWORD PTR _newbit$[ebp]
  0002d	51		 push	 ecx
  0002e	e8 00 00 00 00	 call	 _sprintf
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1034 : 
; 1035 :     return  string->append8(string, (const char *)newbit);

  00036	8b f4		 mov	 esi, esp
  00038	8d 55 d8	 lea	 edx, DWORD PTR _newbit$[ebp]
  0003b	52		 push	 edx
  0003c	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  0003f	50		 push	 eax
  00040	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  00043	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00046	ff d2		 call	 edx
  00048	83 c4 08	 add	 esp, 8
  0004b	3b f4		 cmp	 esi, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1036 : }

  00052	52		 push	 edx
  00053	8b cd		 mov	 ecx, ebp
  00055	50		 push	 eax
  00056	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@addi8
  0005c	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00061	58		 pop	 eax
  00062	5a		 pop	 edx
  00063	5f		 pop	 edi
  00064	5e		 pop	 esi
  00065	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00068	33 cd		 xor	 ecx, ebp
  0006a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006f	83 c4 2c	 add	 esp, 44			; 0000002cH
  00072	3b ec		 cmp	 ebp, esp
  00074	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
  0007d	0f 1f 00	 npad	 3
$LN5@addi8:
  00080	01 00 00 00	 DD	 1
  00084	00 00 00 00	 DD	 $LN4@addi8
$LN4@addi8:
  00088	d8 ff ff ff	 DD	 -40			; ffffffd8H
  0008c	20 00 00 00	 DD	 32			; 00000020H
  00090	00 00 00 00	 DD	 $LN3@addi8
$LN3@addi8:
  00094	6e		 DB	 110			; 0000006eH
  00095	65		 DB	 101			; 00000065H
  00096	77		 DB	 119			; 00000077H
  00097	62		 DB	 98			; 00000062H
  00098	69		 DB	 105			; 00000069H
  00099	74		 DB	 116			; 00000074H
  0009a	00		 DB	 0
_addi8	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3string.c
;	COMDAT _addcUTF16
_TEXT	SEGMENT
_newAlloc$1 = -8					; size = 4
_ptr$ = -4						; size = 4
_string$ = 8						; size = 4
_c$ = 12						; size = 4
_addcUTF16 PROC						; COMDAT

; 1006 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 1007 :     pANTLR3_UINT16  ptr;
; 1008 : 
; 1009 :     if	(string->size < string->len + 2)

  00015	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  00018	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0001b	83 c1 02	 add	 ecx, 2
  0001e	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  00021	39 4a 0c	 cmp	 DWORD PTR [edx+12], ecx
  00024	73 49		 jae	 SHORT $LN2@addcUTF16

; 1010 :     {
; 1011 : 		pANTLR3_UINT8 newAlloc = (pANTLR3_UINT8) ANTLR3_REALLOC((void *)string->chars, (ANTLR3_UINT32)(sizeof(ANTLR3_UINT16) * (string->len + 2)));

  00026	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  00029	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0002c	8d 54 09 04	 lea	 edx, DWORD PTR [ecx+ecx+4]
  00030	8b f4		 mov	 esi, esp
  00032	52		 push	 edx
  00033	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  00036	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00039	51		 push	 ecx
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__realloc
  00040	83 c4 08	 add	 esp, 8
  00043	3b f4		 cmp	 esi, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	89 45 f8	 mov	 DWORD PTR _newAlloc$1[ebp], eax

; 1012 : 		if (newAlloc == NULL)

  0004d	83 7d f8 00	 cmp	 DWORD PTR _newAlloc$1[ebp], 0
  00051	75 04		 jne	 SHORT $LN3@addcUTF16

; 1013 : 		{
; 1014 : 			return NULL;

  00053	33 c0		 xor	 eax, eax
  00055	eb 57		 jmp	 SHORT $LN1@addcUTF16
$LN3@addcUTF16:

; 1015 : 		}
; 1016 : 		string->chars	= newAlloc;

  00057	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  0005a	8b 45 f8	 mov	 eax, DWORD PTR _newAlloc$1[ebp]
  0005d	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1017 : 		string->size	= string->len + 2;

  00060	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  00063	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00066	83 c2 02	 add	 edx, 2
  00069	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  0006c	89 50 0c	 mov	 DWORD PTR [eax+12], edx
$LN2@addcUTF16:

; 1018 :     }
; 1019 :     ptr	= (pANTLR3_UINT16)(string->chars);

  0006f	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  00072	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00075	89 55 fc	 mov	 DWORD PTR _ptr$[ebp], edx

; 1020 : 
; 1021 :     *(ptr + string->len)	= (ANTLR3_UINT16)c;

  00078	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  0007b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0007e	8b 55 fc	 mov	 edx, DWORD PTR _ptr$[ebp]
  00081	66 8b 45 0c	 mov	 ax, WORD PTR _c$[ebp]
  00085	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax

; 1022 :     *(ptr + string->len + 1)	= '\0';

  00089	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  0008c	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0008f	33 c0		 xor	 eax, eax
  00091	8b 4d fc	 mov	 ecx, DWORD PTR _ptr$[ebp]
  00094	66 89 44 51 02	 mov	 WORD PTR [ecx+edx*2+2], ax

; 1023 :     string->len++;

  00099	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  0009c	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0009f	83 c0 01	 add	 eax, 1
  000a2	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  000a5	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1024 : 
; 1025 :     return  string->chars;

  000a8	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  000ab	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
$LN1@addcUTF16:

; 1026 : }

  000ae	5e		 pop	 esi
  000af	83 c4 08	 add	 esp, 8
  000b2	3b ec		 cmp	 ebp, esp
  000b4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b9	8b e5		 mov	 esp, ebp
  000bb	5d		 pop	 ebp
  000bc	c3		 ret	 0
_addcUTF16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3string.c
;	COMDAT _addc8
_TEXT	SEGMENT
_newAlloc$1 = -4					; size = 4
_string$ = 8						; size = 4
_c$ = 12						; size = 4
_addc8	PROC						; COMDAT

; 986  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 987  :     if	(string->size < string->len + 2)

  0000c	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  0000f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00012	83 c1 02	 add	 ecx, 2
  00015	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  00018	39 4a 0c	 cmp	 DWORD PTR [edx+12], ecx
  0001b	73 48		 jae	 SHORT $LN2@addc8

; 988  :     {
; 989  : 		pANTLR3_UINT8 newAlloc = (pANTLR3_UINT8) ANTLR3_REALLOC((void *)string->chars, (ANTLR3_UINT32)(string->len + 2));

  0001d	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  00020	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00023	83 c1 02	 add	 ecx, 2
  00026	8b f4		 mov	 esi, esp
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  0002c	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0002f	50		 push	 eax
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__realloc
  00036	83 c4 08	 add	 esp, 8
  00039	3b f4		 cmp	 esi, esp
  0003b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00040	89 45 fc	 mov	 DWORD PTR _newAlloc$1[ebp], eax

; 990  : 		if (newAlloc == NULL)

  00043	83 7d fc 00	 cmp	 DWORD PTR _newAlloc$1[ebp], 0
  00047	75 04		 jne	 SHORT $LN3@addc8

; 991  : 		{
; 992  : 			return NULL;

  00049	33 c0		 xor	 eax, eax
  0004b	eb 50		 jmp	 SHORT $LN1@addc8
$LN3@addc8:

; 993  : 		}
; 994  : 		string->chars	= newAlloc;

  0004d	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  00050	8b 55 fc	 mov	 edx, DWORD PTR _newAlloc$1[ebp]
  00053	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 995  : 		string->size	= string->len + 2;

  00056	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  00059	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0005c	83 c1 02	 add	 ecx, 2
  0005f	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  00062	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
$LN2@addc8:

; 996  :     }
; 997  :     *(string->chars + string->len)	= (ANTLR3_UINT8)c;

  00065	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  00068	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0006b	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  0006e	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00071	8a 55 0c	 mov	 dl, BYTE PTR _c$[ebp]
  00074	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 998  :     *(string->chars + string->len + 1)	= '\0';

  00077	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  0007a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0007d	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  00080	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00083	c6 44 01 01 00	 mov	 BYTE PTR [ecx+eax+1], 0

; 999  :     string->len++;

  00088	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  0008b	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0008e	83 c2 01	 add	 edx, 1
  00091	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  00094	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1000 : 
; 1001 :     return  string->chars;

  00097	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  0009a	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
$LN1@addc8:

; 1002 : }

  0009d	5e		 pop	 esi
  0009e	83 c4 04	 add	 esp, 4
  000a1	3b ec		 cmp	 ebp, esp
  000a3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a8	8b e5		 mov	 esp, ebp
  000aa	5d		 pop	 ebp
  000ab	c3		 ret	 0
_addc8	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3string.c
;	COMDAT _insertS
_TEXT	SEGMENT
_string$ = 8						; size = 4
_point$ = 12						; size = 4
_newbit$ = 16						; size = 4
_insertS PROC						; COMDAT

; 1221 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1222 :     return  string->insert(string, point, (const char *)(newbit->chars));

  00004	8b f4		 mov	 esi, esp
  00006	8b 45 10	 mov	 eax, DWORD PTR _newbit$[ebp]
  00009	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000c	51		 push	 ecx
  0000d	8b 55 0c	 mov	 edx, DWORD PTR _point$[ebp]
  00010	52		 push	 edx
  00011	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  00014	50		 push	 eax
  00015	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  00018	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  0001b	ff d2		 call	 edx
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00020	3b f4		 cmp	 esi, esp
  00022	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1223 : }

  00027	5e		 pop	 esi
  00028	3b ec		 cmp	 ebp, esp
  0002a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
_insertS ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3string.c
;	COMDAT _appendS
_TEXT	SEGMENT
_string$ = 8						; size = 4
_newbit$ = 12						; size = 4
_appendS PROC						; COMDAT

; 1207 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1208 :     /* We may be passed an empty string, in which case we just return the current pointer
; 1209 :      */
; 1210 :     if	(newbit == NULL || newbit->len == 0 || newbit->size == 0 || newbit->chars == NULL)

  00004	83 7d 0c 00	 cmp	 DWORD PTR _newbit$[ebp], 0
  00008	74 1b		 je	 SHORT $LN4@appendS
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _newbit$[ebp]
  0000d	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00011	74 12		 je	 SHORT $LN4@appendS
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR _newbit$[ebp]
  00016	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  0001a	74 09		 je	 SHORT $LN4@appendS
  0001c	8b 55 0c	 mov	 edx, DWORD PTR _newbit$[ebp]
  0001f	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  00023	75 0a		 jne	 SHORT $LN2@appendS
$LN4@appendS:

; 1211 :     {
; 1212 : 		return	string->chars;

  00025	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  00028	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002b	eb 21		 jmp	 SHORT $LN3@appendS

; 1213 :     }

  0002d	eb 1f		 jmp	 SHORT $LN3@appendS
$LN2@appendS:

; 1214 :     else
; 1215 :     {
; 1216 : 		return  string->append(string, (const char *)(newbit->chars));

  0002f	8b f4		 mov	 esi, esp
  00031	8b 4d 0c	 mov	 ecx, DWORD PTR _newbit$[ebp]
  00034	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00037	52		 push	 edx
  00038	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  0003b	50		 push	 eax
  0003c	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  0003f	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00042	ff d2		 call	 edx
  00044	83 c4 08	 add	 esp, 8
  00047	3b f4		 cmp	 esi, esp
  00049	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@appendS:

; 1217 :     }
; 1218 : }

  0004e	5e		 pop	 esi
  0004f	3b ec		 cmp	 ebp, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
_appendS ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3string.c
;	COMDAT _setS
_TEXT	SEGMENT
_string$ = 8						; size = 4
_chars$ = 12						; size = 4
_setS	PROC						; COMDAT

; 1202 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1203 :     return  string->set(string, (const char *)(chars->chars));

  00004	8b f4		 mov	 esi, esp
  00006	8b 45 0c	 mov	 eax, DWORD PTR _chars$[ebp]
  00009	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000c	51		 push	 ecx
  0000d	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  00010	52		 push	 edx
  00011	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  00014	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00017	ff d1		 call	 ecx
  00019	83 c4 08	 add	 esp, 8
  0001c	3b f4		 cmp	 esi, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1204 : }

  00023	5e		 pop	 esi
  00024	3b ec		 cmp	 ebp, esp
  00026	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
_setS	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3string.c
;	COMDAT _insertUTF16_UTF16
_TEXT	SEGMENT
tv74 = -20						; size = 4
tv73 = -16						; size = 4
_newAlloc$1 = -12					; size = 4
_in$ = -8						; size = 4
_len$ = -4						; size = 4
_string$ = 8						; size = 4
_point$ = 12						; size = 4
_newbit$ = 16						; size = 4
_insertUTF16_UTF16 PROC					; COMDAT

; 1152 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0000f	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00012	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00015	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00018	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 1153 :     ANTLR3_UINT32	len;
; 1154 :     pANTLR3_UINT16	in;
; 1155 : 
; 1156 :     if	(point >= string->len)

  0001b	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  0001e	8b 4d 0c	 mov	 ecx, DWORD PTR _point$[ebp]
  00021	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00024	72 21		 jb	 SHORT $LN4@insertUTF1

; 1157 :     {
; 1158 : 		return	string->append(string, newbit);

  00026	8b f4		 mov	 esi, esp
  00028	8b 55 10	 mov	 edx, DWORD PTR _newbit$[ebp]
  0002b	52		 push	 edx
  0002c	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  0002f	50		 push	 eax
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  00033	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00036	ff d2		 call	 edx
  00038	83 c4 08	 add	 esp, 8
  0003b	3b f4		 cmp	 esi, esp
  0003d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00042	e9 29 01 00 00	 jmp	 $LN1@insertUTF1
$LN4@insertUTF1:

; 1159 :     }
; 1160 :  
; 1161 :     /** First, determine the length of the input string
; 1162 :      */
; 1163 :     in	    = (pANTLR3_UINT16)newbit;

  00047	8b 45 10	 mov	 eax, DWORD PTR _newbit$[ebp]
  0004a	89 45 f8	 mov	 DWORD PTR _in$[ebp], eax

; 1164 :     len	    = 0;

  0004d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _len$[ebp], 0
$LN2@insertUTF1:

; 1165 : 
; 1166 :     while   (*in++ != '\0')

  00054	8b 4d f8	 mov	 ecx, DWORD PTR _in$[ebp]
  00057	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  0005a	89 55 f0	 mov	 DWORD PTR tv73[ebp], edx
  0005d	8b 45 f8	 mov	 eax, DWORD PTR _in$[ebp]
  00060	83 c0 02	 add	 eax, 2
  00063	89 45 f8	 mov	 DWORD PTR _in$[ebp], eax
  00066	83 7d f0 00	 cmp	 DWORD PTR tv73[ebp], 0
  0006a	74 09		 je	 SHORT $LN9@insertUTF1
  0006c	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv74[ebp], 1
  00073	eb 07		 jmp	 SHORT $LN10@insertUTF1
$LN9@insertUTF1:
  00075	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN10@insertUTF1:
  0007c	83 7d ec 00	 cmp	 DWORD PTR tv74[ebp], 0
  00080	74 0b		 je	 SHORT $LN3@insertUTF1

; 1167 :     {
; 1168 : 		len++;

  00082	8b 4d fc	 mov	 ecx, DWORD PTR _len$[ebp]
  00085	83 c1 01	 add	 ecx, 1
  00088	89 4d fc	 mov	 DWORD PTR _len$[ebp], ecx

; 1169 :     }

  0008b	eb c7		 jmp	 SHORT $LN2@insertUTF1
$LN3@insertUTF1:

; 1170 : 
; 1171 :     if	(len == 0)

  0008d	83 7d fc 00	 cmp	 DWORD PTR _len$[ebp], 0
  00091	75 0b		 jne	 SHORT $LN5@insertUTF1

; 1172 :     {
; 1173 : 		return	string->chars;

  00093	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  00096	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00099	e9 d2 00 00 00	 jmp	 $LN1@insertUTF1
$LN5@insertUTF1:

; 1174 :     }
; 1175 : 
; 1176 :     if	(string->size < (string->len + len + 1))

  0009e	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  000a1	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000a4	8b 55 fc	 mov	 edx, DWORD PTR _len$[ebp]
  000a7	8d 44 11 01	 lea	 eax, DWORD PTR [ecx+edx+1]
  000ab	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  000ae	39 41 0c	 cmp	 DWORD PTR [ecx+12], eax
  000b1	73 53		 jae	 SHORT $LN6@insertUTF1

; 1177 :     {
; 1178 : 		pANTLR3_UINT8 newAlloc = (pANTLR3_UINT8) ANTLR3_REALLOC((void *)string->chars, (ANTLR3_UINT32)(sizeof(ANTLR3_UINT16)*(string->len + len + 1)));

  000b3	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  000b6	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000b9	03 45 fc	 add	 eax, DWORD PTR _len$[ebp]
  000bc	8d 4c 00 02	 lea	 ecx, DWORD PTR [eax+eax+2]
  000c0	8b f4		 mov	 esi, esp
  000c2	51		 push	 ecx
  000c3	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  000c6	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000c9	50		 push	 eax
  000ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__realloc
  000d0	83 c4 08	 add	 esp, 8
  000d3	3b f4		 cmp	 esi, esp
  000d5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000da	89 45 f4	 mov	 DWORD PTR _newAlloc$1[ebp], eax

; 1179 : 		if (newAlloc == NULL)

  000dd	83 7d f4 00	 cmp	 DWORD PTR _newAlloc$1[ebp], 0
  000e1	75 07		 jne	 SHORT $LN7@insertUTF1

; 1180 : 		{
; 1181 : 			return NULL;

  000e3	33 c0		 xor	 eax, eax
  000e5	e9 86 00 00 00	 jmp	 $LN1@insertUTF1
$LN7@insertUTF1:

; 1182 : 		}
; 1183 : 		string->chars	= newAlloc;

  000ea	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  000ed	8b 55 f4	 mov	 edx, DWORD PTR _newAlloc$1[ebp]
  000f0	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 1184 : 		string->size	= string->len + len + 1;

  000f3	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  000f6	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000f9	8b 55 fc	 mov	 edx, DWORD PTR _len$[ebp]
  000fc	8d 44 11 01	 lea	 eax, DWORD PTR [ecx+edx+1]
  00100	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  00103	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
$LN6@insertUTF1:

; 1185 :     }
; 1186 : 
; 1187 :     /* Move the characters we are inserting before, including the delimiter
; 1188 :      */
; 1189 :     ANTLR3_MEMMOVE((void *)(((pANTLR3_UINT16)string->chars) + point + len), (void *)(((pANTLR3_UINT16)string->chars) + point), (ANTLR3_UINT32)(sizeof(ANTLR3_UINT16)*(string->len - point + 1)));

  00106	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  00109	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0010c	2b 45 0c	 sub	 eax, DWORD PTR _point$[ebp]
  0010f	8d 4c 00 02	 lea	 ecx, DWORD PTR [eax+eax+2]
  00113	51		 push	 ecx
  00114	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  00117	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0011a	8b 4d 0c	 mov	 ecx, DWORD PTR _point$[ebp]
  0011d	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  00120	52		 push	 edx
  00121	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  00124	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00127	8b 55 0c	 mov	 edx, DWORD PTR _point$[ebp]
  0012a	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  0012d	8b 4d fc	 mov	 ecx, DWORD PTR _len$[ebp]
  00130	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  00133	52		 push	 edx
  00134	e8 00 00 00 00	 call	 _memmove
  00139	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1190 : 
; 1191 : 
; 1192 :     /* Note we copy the exact number of characters
; 1193 :      */
; 1194 :     ANTLR3_MEMMOVE((void *)(((pANTLR3_UINT16)string->chars) + point), newbit, (ANTLR3_UINT32)(sizeof(ANTLR3_UINT16)*(len)));

  0013c	8b 45 fc	 mov	 eax, DWORD PTR _len$[ebp]
  0013f	d1 e0		 shl	 eax, 1
  00141	50		 push	 eax
  00142	8b 4d 10	 mov	 ecx, DWORD PTR _newbit$[ebp]
  00145	51		 push	 ecx
  00146	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  00149	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0014c	8b 4d 0c	 mov	 ecx, DWORD PTR _point$[ebp]
  0014f	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  00152	52		 push	 edx
  00153	e8 00 00 00 00	 call	 _memmove
  00158	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1195 :     
; 1196 :     string->len += len;

  0015b	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  0015e	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00161	03 4d fc	 add	 ecx, DWORD PTR _len$[ebp]
  00164	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  00167	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 1197 : 
; 1198 :     return  string->chars;

  0016a	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  0016d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
$LN1@insertUTF1:

; 1199 : }

  00170	5e		 pop	 esi
  00171	83 c4 14	 add	 esp, 20			; 00000014H
  00174	3b ec		 cmp	 ebp, esp
  00176	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0017b	8b e5		 mov	 esp, ebp
  0017d	5d		 pop	 ebp
  0017e	c3		 ret	 0
_insertUTF16_UTF16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3string.c
;	COMDAT _insertUTF16_8
_TEXT	SEGMENT
_newAlloc$1 = -16					; size = 4
_inPoint$ = -12						; size = 4
_count$ = -8						; size = 4
_len$ = -4						; size = 4
_string$ = 8						; size = 4
_point$ = 12						; size = 4
_newbit$ = 16						; size = 4
_insertUTF16_8 PROC					; COMDAT

; 1107 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000f	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00012	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00015	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 1108 :     ANTLR3_UINT32	len;
; 1109 :     ANTLR3_UINT32	count;
; 1110 :     pANTLR3_UINT16	inPoint;
; 1111 : 
; 1112 :     if	(point >= string->len)

  00018	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  0001b	8b 4d 0c	 mov	 ecx, DWORD PTR _point$[ebp]
  0001e	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00021	72 21		 jb	 SHORT $LN5@insertUTF1

; 1113 :     {
; 1114 : 		return	string->append8(string, newbit);

  00023	8b f4		 mov	 esi, esp
  00025	8b 55 10	 mov	 edx, DWORD PTR _newbit$[ebp]
  00028	52		 push	 edx
  00029	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  0002c	50		 push	 eax
  0002d	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  00030	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00033	ff d2		 call	 edx
  00035	83 c4 08	 add	 esp, 8
  00038	3b f4		 cmp	 esi, esp
  0003a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003f	e9 12 01 00 00	 jmp	 $LN1@insertUTF1
$LN5@insertUTF1:

; 1115 :     }
; 1116 :  
; 1117 :     len	= (ANTLR3_UINT32)strlen(newbit);

  00044	8b 45 10	 mov	 eax, DWORD PTR _newbit$[ebp]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 _strlen
  0004d	83 c4 04	 add	 esp, 4
  00050	89 45 fc	 mov	 DWORD PTR _len$[ebp], eax

; 1118 : 
; 1119 :     if	(len == 0)

  00053	83 7d fc 00	 cmp	 DWORD PTR _len$[ebp], 0
  00057	75 0b		 jne	 SHORT $LN6@insertUTF1

; 1120 :     {
; 1121 : 		return	string->chars;

  00059	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  0005c	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0005f	e9 f2 00 00 00	 jmp	 $LN1@insertUTF1
$LN6@insertUTF1:

; 1122 :     }
; 1123 : 
; 1124 :     if	(string->size < (string->len + len + 1))

  00064	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  00067	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0006a	8b 4d fc	 mov	 ecx, DWORD PTR _len$[ebp]
  0006d	8d 54 08 01	 lea	 edx, DWORD PTR [eax+ecx+1]
  00071	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  00074	39 50 0c	 cmp	 DWORD PTR [eax+12], edx
  00077	73 53		 jae	 SHORT $LN7@insertUTF1

; 1125 :     {
; 1126 : 		pANTLR3_UINT8 newAlloc = (pANTLR3_UINT8) ANTLR3_REALLOC((void *)string->chars, (ANTLR3_UINT32)(sizeof(ANTLR3_UINT16)*(string->len + len + 1)));

  00079	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  0007c	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0007f	03 55 fc	 add	 edx, DWORD PTR _len$[ebp]
  00082	8d 44 12 02	 lea	 eax, DWORD PTR [edx+edx+2]
  00086	8b f4		 mov	 esi, esp
  00088	50		 push	 eax
  00089	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  0008c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0008f	52		 push	 edx
  00090	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__realloc
  00096	83 c4 08	 add	 esp, 8
  00099	3b f4		 cmp	 esi, esp
  0009b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a0	89 45 f0	 mov	 DWORD PTR _newAlloc$1[ebp], eax

; 1127 : 		if (newAlloc == NULL)

  000a3	83 7d f0 00	 cmp	 DWORD PTR _newAlloc$1[ebp], 0
  000a7	75 07		 jne	 SHORT $LN8@insertUTF1

; 1128 : 		{
; 1129 : 			return NULL;

  000a9	33 c0		 xor	 eax, eax
  000ab	e9 a6 00 00 00	 jmp	 $LN1@insertUTF1
$LN8@insertUTF1:

; 1130 : 		}
; 1131 : 		string->chars	= newAlloc;

  000b0	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  000b3	8b 4d f0	 mov	 ecx, DWORD PTR _newAlloc$1[ebp]
  000b6	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1132 : 		string->size	= string->len + len + 1;

  000b9	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  000bc	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000bf	8b 4d fc	 mov	 ecx, DWORD PTR _len$[ebp]
  000c2	8d 54 08 01	 lea	 edx, DWORD PTR [eax+ecx+1]
  000c6	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  000c9	89 50 0c	 mov	 DWORD PTR [eax+12], edx
$LN7@insertUTF1:

; 1133 :     }
; 1134 : 
; 1135 :     /* Move the characters we are inserting before, including the delimiter
; 1136 :      */
; 1137 :     ANTLR3_MEMMOVE((void *)(((pANTLR3_UINT16)string->chars) + point + len), (void *)(((pANTLR3_UINT16)string->chars) + point), (ANTLR3_UINT32)(sizeof(ANTLR3_UINT16)*(string->len - point + 1)));

  000cc	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  000cf	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000d2	2b 55 0c	 sub	 edx, DWORD PTR _point$[ebp]
  000d5	8d 44 12 02	 lea	 eax, DWORD PTR [edx+edx+2]
  000d9	50		 push	 eax
  000da	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  000dd	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000e0	8b 45 0c	 mov	 eax, DWORD PTR _point$[ebp]
  000e3	8d 0c 42	 lea	 ecx, DWORD PTR [edx+eax*2]
  000e6	51		 push	 ecx
  000e7	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  000ea	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000ed	8b 4d 0c	 mov	 ecx, DWORD PTR _point$[ebp]
  000f0	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  000f3	8b 45 fc	 mov	 eax, DWORD PTR _len$[ebp]
  000f6	8d 0c 42	 lea	 ecx, DWORD PTR [edx+eax*2]
  000f9	51		 push	 ecx
  000fa	e8 00 00 00 00	 call	 _memmove
  000ff	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1138 : 
; 1139 :     string->len += len;

  00102	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  00105	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00108	03 45 fc	 add	 eax, DWORD PTR _len$[ebp]
  0010b	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  0010e	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1140 :     
; 1141 :     inPoint = ((pANTLR3_UINT16)(string->chars))+point;

  00111	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  00114	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00117	8b 4d 0c	 mov	 ecx, DWORD PTR _point$[ebp]
  0011a	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  0011d	89 55 f4	 mov	 DWORD PTR _inPoint$[ebp], edx

; 1142 :     for	(count = 0; count<len; count++)

  00120	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  00127	eb 09		 jmp	 SHORT $LN4@insertUTF1
$LN2@insertUTF1:
  00129	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  0012c	83 c0 01	 add	 eax, 1
  0012f	89 45 f8	 mov	 DWORD PTR _count$[ebp], eax
$LN4@insertUTF1:
  00132	8b 4d f8	 mov	 ecx, DWORD PTR _count$[ebp]
  00135	3b 4d fc	 cmp	 ecx, DWORD PTR _len$[ebp]
  00138	73 16		 jae	 SHORT $LN3@insertUTF1

; 1143 :     {
; 1144 : 		*(inPoint + count) = (ANTLR3_UINT16)(*(newbit+count));

  0013a	8b 55 10	 mov	 edx, DWORD PTR _newbit$[ebp]
  0013d	03 55 f8	 add	 edx, DWORD PTR _count$[ebp]
  00140	66 0f be 02	 movsx	 ax, BYTE PTR [edx]
  00144	8b 4d f8	 mov	 ecx, DWORD PTR _count$[ebp]
  00147	8b 55 f4	 mov	 edx, DWORD PTR _inPoint$[ebp]
  0014a	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax

; 1145 :     }

  0014e	eb d9		 jmp	 SHORT $LN2@insertUTF1
$LN3@insertUTF1:

; 1146 : 
; 1147 :     return  string->chars;

  00150	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  00153	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
$LN1@insertUTF1:

; 1148 : }

  00156	5e		 pop	 esi
  00157	83 c4 10	 add	 esp, 16			; 00000010H
  0015a	3b ec		 cmp	 ebp, esp
  0015c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00161	8b e5		 mov	 esp, ebp
  00163	5d		 pop	 ebp
  00164	c3		 ret	 0
_insertUTF16_8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3string.c
;	COMDAT _insert8
_TEXT	SEGMENT
_newAlloc$1 = -8					; size = 4
_len$ = -4						; size = 4
_string$ = 8						; size = 4
_point$ = 12						; size = 4
_newbit$ = 16						; size = 4
_insert8 PROC						; COMDAT

; 1066 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 1067 :     ANTLR3_UINT32	len;
; 1068 : 
; 1069 :     if	(point >= string->len)

  00015	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  00018	8b 4d 0c	 mov	 ecx, DWORD PTR _point$[ebp]
  0001b	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  0001e	72 21		 jb	 SHORT $LN2@insert8

; 1070 :     {
; 1071 : 		return	string->append(string, newbit);

  00020	8b f4		 mov	 esi, esp
  00022	8b 55 10	 mov	 edx, DWORD PTR _newbit$[ebp]
  00025	52		 push	 edx
  00026	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  00029	50		 push	 eax
  0002a	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  0002d	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00030	ff d2		 call	 edx
  00032	83 c4 08	 add	 esp, 8
  00035	3b f4		 cmp	 esi, esp
  00037	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003c	e9 e0 00 00 00	 jmp	 $LN1@insert8
$LN2@insert8:

; 1072 :     }
; 1073 :  
; 1074 :     len	= (ANTLR3_UINT32)strlen(newbit);

  00041	8b 45 10	 mov	 eax, DWORD PTR _newbit$[ebp]
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 _strlen
  0004a	83 c4 04	 add	 esp, 4
  0004d	89 45 fc	 mov	 DWORD PTR _len$[ebp], eax

; 1075 : 
; 1076 :     if	(len == 0)

  00050	83 7d fc 00	 cmp	 DWORD PTR _len$[ebp], 0
  00054	75 0b		 jne	 SHORT $LN3@insert8

; 1077 :     {
; 1078 : 		return	string->chars;

  00056	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  00059	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0005c	e9 c0 00 00 00	 jmp	 $LN1@insert8
$LN3@insert8:

; 1079 :     }
; 1080 : 
; 1081 :     if	(string->size < (string->len + len + 1))

  00061	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  00064	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00067	8b 4d fc	 mov	 ecx, DWORD PTR _len$[ebp]
  0006a	8d 54 08 01	 lea	 edx, DWORD PTR [eax+ecx+1]
  0006e	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  00071	39 50 0c	 cmp	 DWORD PTR [eax+12], edx
  00074	73 50		 jae	 SHORT $LN4@insert8

; 1082 :     {
; 1083 : 		pANTLR3_UINT8 newAlloc = (pANTLR3_UINT8) ANTLR3_REALLOC((void *)string->chars, (ANTLR3_UINT32)(string->len + len + 1));

  00076	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  00079	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0007c	8b 45 fc	 mov	 eax, DWORD PTR _len$[ebp]
  0007f	8d 4c 02 01	 lea	 ecx, DWORD PTR [edx+eax+1]
  00083	8b f4		 mov	 esi, esp
  00085	51		 push	 ecx
  00086	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  00089	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0008c	50		 push	 eax
  0008d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__realloc
  00093	83 c4 08	 add	 esp, 8
  00096	3b f4		 cmp	 esi, esp
  00098	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009d	89 45 f8	 mov	 DWORD PTR _newAlloc$1[ebp], eax

; 1084 : 		if (newAlloc == NULL)

  000a0	83 7d f8 00	 cmp	 DWORD PTR _newAlloc$1[ebp], 0
  000a4	75 04		 jne	 SHORT $LN5@insert8

; 1085 : 		{
; 1086 : 			return NULL;

  000a6	33 c0		 xor	 eax, eax
  000a8	eb 77		 jmp	 SHORT $LN1@insert8
$LN5@insert8:

; 1087 : 		}
; 1088 : 		string->chars	= newAlloc;

  000aa	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  000ad	8b 55 f8	 mov	 edx, DWORD PTR _newAlloc$1[ebp]
  000b0	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 1089 : 		string->size	= string->len + len + 1;

  000b3	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  000b6	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000b9	8b 55 fc	 mov	 edx, DWORD PTR _len$[ebp]
  000bc	8d 44 11 01	 lea	 eax, DWORD PTR [ecx+edx+1]
  000c0	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  000c3	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
$LN4@insert8:

; 1090 :     }
; 1091 : 
; 1092 :     /* Move the characters we are inserting before, including the delimiter
; 1093 :      */
; 1094 :     ANTLR3_MEMMOVE((void *)(string->chars + point + len), (void *)(string->chars + point), (ANTLR3_UINT32)(string->len - point + 1));

  000c6	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  000c9	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000cc	2b 45 0c	 sub	 eax, DWORD PTR _point$[ebp]
  000cf	83 c0 01	 add	 eax, 1
  000d2	50		 push	 eax
  000d3	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  000d6	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000d9	03 55 0c	 add	 edx, DWORD PTR _point$[ebp]
  000dc	52		 push	 edx
  000dd	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  000e0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000e3	03 4d 0c	 add	 ecx, DWORD PTR _point$[ebp]
  000e6	03 4d fc	 add	 ecx, DWORD PTR _len$[ebp]
  000e9	51		 push	 ecx
  000ea	e8 00 00 00 00	 call	 _memmove
  000ef	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1095 : 
; 1096 :     /* Note we copy the exact number of bytes
; 1097 :      */
; 1098 :     ANTLR3_MEMMOVE((void *)(string->chars + point), newbit, (ANTLR3_UINT32)(len));

  000f2	8b 55 fc	 mov	 edx, DWORD PTR _len$[ebp]
  000f5	52		 push	 edx
  000f6	8b 45 10	 mov	 eax, DWORD PTR _newbit$[ebp]
  000f9	50		 push	 eax
  000fa	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  000fd	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00100	03 55 0c	 add	 edx, DWORD PTR _point$[ebp]
  00103	52		 push	 edx
  00104	e8 00 00 00 00	 call	 _memmove
  00109	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1099 :     
; 1100 :     string->len += len;

  0010c	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  0010f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00112	03 4d fc	 add	 ecx, DWORD PTR _len$[ebp]
  00115	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  00118	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 1101 : 
; 1102 :     return  string->chars;

  0011b	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  0011e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
$LN1@insert8:

; 1103 : }

  00121	5e		 pop	 esi
  00122	83 c4 08	 add	 esp, 8
  00125	3b ec		 cmp	 ebp, esp
  00127	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0012c	8b e5		 mov	 esp, ebp
  0012e	5d		 pop	 ebp
  0012f	c3		 ret	 0
_insert8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3string.c
;	COMDAT _appendUTF16_UTF16
_TEXT	SEGMENT
tv68 = -20						; size = 4
tv67 = -16						; size = 4
_newAlloc$1 = -12					; size = 4
_in$ = -8						; size = 4
_len$ = -4						; size = 4
_string$ = 8						; size = 4
_newbit$ = 12						; size = 4
_appendUTF16_UTF16 PROC					; COMDAT

; 859  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0000f	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00012	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00015	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00018	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 860  :     ANTLR3_UINT32 len;
; 861  :     pANTLR3_UINT16  in;
; 862  : 
; 863  :     /** First, determine the length of the input string
; 864  :      */
; 865  :     in	    = (pANTLR3_UINT16)newbit;

  0001b	8b 45 0c	 mov	 eax, DWORD PTR _newbit$[ebp]
  0001e	89 45 f8	 mov	 DWORD PTR _in$[ebp], eax

; 866  :     len   = 0;

  00021	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _len$[ebp], 0
$LN2@appendUTF1:

; 867  : 
; 868  :     while   (*in++ != '\0')

  00028	8b 4d f8	 mov	 ecx, DWORD PTR _in$[ebp]
  0002b	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  0002e	89 55 f0	 mov	 DWORD PTR tv67[ebp], edx
  00031	8b 45 f8	 mov	 eax, DWORD PTR _in$[ebp]
  00034	83 c0 02	 add	 eax, 2
  00037	89 45 f8	 mov	 DWORD PTR _in$[ebp], eax
  0003a	83 7d f0 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003e	74 09		 je	 SHORT $LN7@appendUTF1
  00040	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
  00047	eb 07		 jmp	 SHORT $LN8@appendUTF1
$LN7@appendUTF1:
  00049	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
$LN8@appendUTF1:
  00050	83 7d ec 00	 cmp	 DWORD PTR tv68[ebp], 0
  00054	74 0b		 je	 SHORT $LN3@appendUTF1

; 869  :     {
; 870  : 		len++;

  00056	8b 4d fc	 mov	 ecx, DWORD PTR _len$[ebp]
  00059	83 c1 01	 add	 ecx, 1
  0005c	89 4d fc	 mov	 DWORD PTR _len$[ebp], ecx

; 871  :     }

  0005f	eb c7		 jmp	 SHORT $LN2@appendUTF1
$LN3@appendUTF1:

; 872  : 
; 873  :     if	(string->size < (string->len + len + 1))

  00061	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  00064	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00067	8b 4d fc	 mov	 ecx, DWORD PTR _len$[ebp]
  0006a	8d 54 08 01	 lea	 edx, DWORD PTR [eax+ecx+1]
  0006e	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  00071	39 50 0c	 cmp	 DWORD PTR [eax+12], edx
  00074	73 50		 jae	 SHORT $LN4@appendUTF1

; 874  :     {
; 875  : 		pANTLR3_UINT8 newAlloc = (pANTLR3_UINT8) ANTLR3_REALLOC((void *)string->chars, (ANTLR3_UINT32)( sizeof(ANTLR3_UINT16) *(string->len + len + 1) ));

  00076	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  00079	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0007c	03 55 fc	 add	 edx, DWORD PTR _len$[ebp]
  0007f	8d 44 12 02	 lea	 eax, DWORD PTR [edx+edx+2]
  00083	8b f4		 mov	 esi, esp
  00085	50		 push	 eax
  00086	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  00089	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0008c	52		 push	 edx
  0008d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__realloc
  00093	83 c4 08	 add	 esp, 8
  00096	3b f4		 cmp	 esi, esp
  00098	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009d	89 45 f4	 mov	 DWORD PTR _newAlloc$1[ebp], eax

; 876  : 		if (newAlloc == NULL)

  000a0	83 7d f4 00	 cmp	 DWORD PTR _newAlloc$1[ebp], 0
  000a4	75 04		 jne	 SHORT $LN5@appendUTF1

; 877  : 		{
; 878  : 			return NULL;

  000a6	33 c0		 xor	 eax, eax
  000a8	eb 55		 jmp	 SHORT $LN1@appendUTF1
$LN5@appendUTF1:

; 879  : 		}
; 880  : 		string->chars	= newAlloc;

  000aa	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  000ad	8b 4d f4	 mov	 ecx, DWORD PTR _newAlloc$1[ebp]
  000b0	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 881  : 		string->size	= string->len + len + 1;

  000b3	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  000b6	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000b9	8b 4d fc	 mov	 ecx, DWORD PTR _len$[ebp]
  000bc	8d 54 08 01	 lea	 edx, DWORD PTR [eax+ecx+1]
  000c0	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  000c3	89 50 0c	 mov	 DWORD PTR [eax+12], edx
$LN4@appendUTF1:

; 882  :     }
; 883  : 
; 884  :     /* Note we copy one more byte than the strlen in order to get the trailing delimiter
; 885  :      */
; 886  :     ANTLR3_MEMMOVE((void *)(((pANTLR3_UINT16)string->chars) + string->len), newbit, (ANTLR3_UINT32)(sizeof(ANTLR3_UINT16)*(len+1)));

  000c6	8b 4d fc	 mov	 ecx, DWORD PTR _len$[ebp]
  000c9	8d 54 09 02	 lea	 edx, DWORD PTR [ecx+ecx+2]
  000cd	52		 push	 edx
  000ce	8b 45 0c	 mov	 eax, DWORD PTR _newbit$[ebp]
  000d1	50		 push	 eax
  000d2	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  000d5	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000d8	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  000db	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000de	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  000e1	52		 push	 edx
  000e2	e8 00 00 00 00	 call	 _memmove
  000e7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 887  :     string->len	+= len;

  000ea	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  000ed	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000f0	03 4d fc	 add	 ecx, DWORD PTR _len$[ebp]
  000f3	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  000f6	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 888  : 
; 889  :     return string->chars;

  000f9	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  000fc	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
$LN1@appendUTF1:

; 890  : }

  000ff	5e		 pop	 esi
  00100	83 c4 14	 add	 esp, 20			; 00000014H
  00103	3b ec		 cmp	 ebp, esp
  00105	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0010a	8b e5		 mov	 esp, ebp
  0010c	5d		 pop	 ebp
  0010d	c3		 ret	 0
_appendUTF16_UTF16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3string.c
;	COMDAT _appendUTF16_8
_TEXT	SEGMENT
_newAlloc$1 = -16					; size = 4
_count$ = -12						; size = 4
_apPoint$ = -8						; size = 4
_len$ = -4						; size = 4
_string$ = 8						; size = 4
_newbit$ = 12						; size = 4
_appendUTF16_8 PROC					; COMDAT

; 827  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000f	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00012	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00015	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 828  :     ANTLR3_UINT32   len;
; 829  :     pANTLR3_UINT16  apPoint;
; 830  :     ANTLR3_UINT32   count;
; 831  : 
; 832  :     len	= (ANTLR3_UINT32)strlen(newbit);

  00018	8b 45 0c	 mov	 eax, DWORD PTR _newbit$[ebp]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _strlen
  00021	83 c4 04	 add	 esp, 4
  00024	89 45 fc	 mov	 DWORD PTR _len$[ebp], eax

; 833  : 
; 834  :     if	(string->size < (string->len + len + 1))

  00027	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  0002a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0002d	8b 45 fc	 mov	 eax, DWORD PTR _len$[ebp]
  00030	8d 4c 02 01	 lea	 ecx, DWORD PTR [edx+eax+1]
  00034	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  00037	39 4a 0c	 cmp	 DWORD PTR [edx+12], ecx
  0003a	73 53		 jae	 SHORT $LN5@appendUTF1

; 835  :     {
; 836  : 		pANTLR3_UINT8 newAlloc = (pANTLR3_UINT8) ANTLR3_REALLOC((void *)string->chars, (ANTLR3_UINT32)((sizeof(ANTLR3_UINT16)*(string->len + len + 1))));

  0003c	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  0003f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00042	03 4d fc	 add	 ecx, DWORD PTR _len$[ebp]
  00045	8d 54 09 02	 lea	 edx, DWORD PTR [ecx+ecx+2]
  00049	8b f4		 mov	 esi, esp
  0004b	52		 push	 edx
  0004c	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  0004f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00052	51		 push	 ecx
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__realloc
  00059	83 c4 08	 add	 esp, 8
  0005c	3b f4		 cmp	 esi, esp
  0005e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00063	89 45 f0	 mov	 DWORD PTR _newAlloc$1[ebp], eax

; 837  : 		if (newAlloc == NULL)

  00066	83 7d f0 00	 cmp	 DWORD PTR _newAlloc$1[ebp], 0
  0006a	75 07		 jne	 SHORT $LN6@appendUTF1

; 838  : 		{
; 839  : 			return NULL;

  0006c	33 c0		 xor	 eax, eax
  0006e	e9 80 00 00 00	 jmp	 $LN1@appendUTF1
$LN6@appendUTF1:

; 840  : 		}
; 841  : 		string->chars	= newAlloc;

  00073	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  00076	8b 45 f0	 mov	 eax, DWORD PTR _newAlloc$1[ebp]
  00079	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 842  : 		string->size	= string->len + len + 1;

  0007c	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  0007f	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00082	8b 45 fc	 mov	 eax, DWORD PTR _len$[ebp]
  00085	8d 4c 02 01	 lea	 ecx, DWORD PTR [edx+eax+1]
  00089	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  0008c	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
$LN5@appendUTF1:

; 843  :     }
; 844  : 
; 845  :     apPoint = ((pANTLR3_UINT16)string->chars) + string->len;

  0008f	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  00092	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00095	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  00098	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0009b	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  0009e	89 4d f8	 mov	 DWORD PTR _apPoint$[ebp], ecx

; 846  :     string->len	+= len;

  000a1	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  000a4	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000a7	03 45 fc	 add	 eax, DWORD PTR _len$[ebp]
  000aa	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  000ad	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 847  : 
; 848  :     for	(count = 0; count < len; count++)

  000b0	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  000b7	eb 09		 jmp	 SHORT $LN4@appendUTF1
$LN2@appendUTF1:
  000b9	8b 55 f4	 mov	 edx, DWORD PTR _count$[ebp]
  000bc	83 c2 01	 add	 edx, 1
  000bf	89 55 f4	 mov	 DWORD PTR _count$[ebp], edx
$LN4@appendUTF1:
  000c2	8b 45 f4	 mov	 eax, DWORD PTR _count$[ebp]
  000c5	3b 45 fc	 cmp	 eax, DWORD PTR _len$[ebp]
  000c8	73 1b		 jae	 SHORT $LN3@appendUTF1

; 849  :     {
; 850  : 		*apPoint++   = *(newbit + count);

  000ca	8b 4d 0c	 mov	 ecx, DWORD PTR _newbit$[ebp]
  000cd	03 4d f4	 add	 ecx, DWORD PTR _count$[ebp]
  000d0	66 0f be 11	 movsx	 dx, BYTE PTR [ecx]
  000d4	8b 45 f8	 mov	 eax, DWORD PTR _apPoint$[ebp]
  000d7	66 89 10	 mov	 WORD PTR [eax], dx
  000da	8b 4d f8	 mov	 ecx, DWORD PTR _apPoint$[ebp]
  000dd	83 c1 02	 add	 ecx, 2
  000e0	89 4d f8	 mov	 DWORD PTR _apPoint$[ebp], ecx

; 851  :     }

  000e3	eb d4		 jmp	 SHORT $LN2@appendUTF1
$LN3@appendUTF1:

; 852  :     *apPoint = '\0';

  000e5	33 d2		 xor	 edx, edx
  000e7	8b 45 f8	 mov	 eax, DWORD PTR _apPoint$[ebp]
  000ea	66 89 10	 mov	 WORD PTR [eax], dx

; 853  : 
; 854  :     return string->chars;

  000ed	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  000f0	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
$LN1@appendUTF1:

; 855  : }

  000f3	5e		 pop	 esi
  000f4	83 c4 10	 add	 esp, 16			; 00000010H
  000f7	3b ec		 cmp	 ebp, esp
  000f9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000fe	8b e5		 mov	 esp, ebp
  00100	5d		 pop	 ebp
  00101	c3		 ret	 0
_appendUTF16_8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3string.c
;	COMDAT _append8
_TEXT	SEGMENT
_newAlloc$1 = -8					; size = 4
_len$ = -4						; size = 4
_string$ = 8						; size = 4
_newbit$ = 12						; size = 4
_append8 PROC						; COMDAT

; 801  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 802  :     ANTLR3_UINT32 len;
; 803  : 
; 804  :     len	= (ANTLR3_UINT32)strlen(newbit);

  00015	8b 45 0c	 mov	 eax, DWORD PTR _newbit$[ebp]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 _strlen
  0001e	83 c4 04	 add	 esp, 4
  00021	89 45 fc	 mov	 DWORD PTR _len$[ebp], eax

; 805  : 
; 806  :     if	(string->size < (string->len + len + 1))

  00024	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  00027	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _len$[ebp]
  0002d	8d 4c 02 01	 lea	 ecx, DWORD PTR [edx+eax+1]
  00031	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  00034	39 4a 0c	 cmp	 DWORD PTR [edx+12], ecx
  00037	73 50		 jae	 SHORT $LN2@append8

; 807  :     {
; 808  : 		pANTLR3_UINT8 newAlloc = (pANTLR3_UINT8) ANTLR3_REALLOC((void *)string->chars, (ANTLR3_UINT32)(string->len + len + 1));

  00039	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  0003c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0003f	8b 55 fc	 mov	 edx, DWORD PTR _len$[ebp]
  00042	8d 44 11 01	 lea	 eax, DWORD PTR [ecx+edx+1]
  00046	8b f4		 mov	 esi, esp
  00048	50		 push	 eax
  00049	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  0004c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0004f	52		 push	 edx
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__realloc
  00056	83 c4 08	 add	 esp, 8
  00059	3b f4		 cmp	 esi, esp
  0005b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00060	89 45 f8	 mov	 DWORD PTR _newAlloc$1[ebp], eax

; 809  : 		if (newAlloc == NULL)

  00063	83 7d f8 00	 cmp	 DWORD PTR _newAlloc$1[ebp], 0
  00067	75 04		 jne	 SHORT $LN3@append8

; 810  : 		{
; 811  : 			return NULL;

  00069	33 c0		 xor	 eax, eax
  0006b	eb 51		 jmp	 SHORT $LN1@append8
$LN3@append8:

; 812  : 		}
; 813  : 		string->chars	= newAlloc;

  0006d	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  00070	8b 4d f8	 mov	 ecx, DWORD PTR _newAlloc$1[ebp]
  00073	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 814  : 		string->size	= string->len + len + 1;

  00076	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  00079	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0007c	8b 4d fc	 mov	 ecx, DWORD PTR _len$[ebp]
  0007f	8d 54 08 01	 lea	 edx, DWORD PTR [eax+ecx+1]
  00083	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  00086	89 50 0c	 mov	 DWORD PTR [eax+12], edx
$LN2@append8:

; 815  :     }
; 816  : 
; 817  :     /* Note we copy one more byte than the strlen in order to get the trailing
; 818  :      */
; 819  :     ANTLR3_MEMMOVE((void *)(string->chars + string->len), newbit, (ANTLR3_UINT32)(len+1));

  00089	8b 4d fc	 mov	 ecx, DWORD PTR _len$[ebp]
  0008c	83 c1 01	 add	 ecx, 1
  0008f	51		 push	 ecx
  00090	8b 55 0c	 mov	 edx, DWORD PTR _newbit$[ebp]
  00093	52		 push	 edx
  00094	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  00097	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0009a	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  0009d	03 4a 08	 add	 ecx, DWORD PTR [edx+8]
  000a0	51		 push	 ecx
  000a1	e8 00 00 00 00	 call	 _memmove
  000a6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 820  :     string->len	+= len;

  000a9	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  000ac	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000af	03 4d fc	 add	 ecx, DWORD PTR _len$[ebp]
  000b2	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  000b5	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 821  : 
; 822  :     return string->chars;

  000b8	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  000bb	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
$LN1@append8:

; 823  : }

  000be	5e		 pop	 esi
  000bf	83 c4 08	 add	 esp, 8
  000c2	3b ec		 cmp	 ebp, esp
  000c4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c9	8b e5		 mov	 esp, ebp
  000cb	5d		 pop	 ebp
  000cc	c3		 ret	 0
_append8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3string.c
;	COMDAT _setUTF16_UTF16
_TEXT	SEGMENT
tv68 = -20						; size = 4
tv67 = -16						; size = 4
_newAlloc$1 = -12					; size = 4
_in$ = -8						; size = 4
_len$ = -4						; size = 4
_string$ = 8						; size = 4
_chars$ = 12						; size = 4
_setUTF16_UTF16 PROC					; COMDAT

; 950  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0000f	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00012	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00015	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00018	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 951  :     ANTLR3_UINT32   len;
; 952  :     pANTLR3_UINT16  in;
; 953  : 
; 954  :     /** First, determine the length of the input string
; 955  :      */
; 956  :     in	    = (pANTLR3_UINT16)chars;

  0001b	8b 45 0c	 mov	 eax, DWORD PTR _chars$[ebp]
  0001e	89 45 f8	 mov	 DWORD PTR _in$[ebp], eax

; 957  :     len   = 0;

  00021	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _len$[ebp], 0
$LN2@setUTF16_U:

; 958  : 
; 959  :     while   (*in++ != '\0')

  00028	8b 4d f8	 mov	 ecx, DWORD PTR _in$[ebp]
  0002b	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  0002e	89 55 f0	 mov	 DWORD PTR tv67[ebp], edx
  00031	8b 45 f8	 mov	 eax, DWORD PTR _in$[ebp]
  00034	83 c0 02	 add	 eax, 2
  00037	89 45 f8	 mov	 DWORD PTR _in$[ebp], eax
  0003a	83 7d f0 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003e	74 09		 je	 SHORT $LN7@setUTF16_U
  00040	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
  00047	eb 07		 jmp	 SHORT $LN8@setUTF16_U
$LN7@setUTF16_U:
  00049	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
$LN8@setUTF16_U:
  00050	83 7d ec 00	 cmp	 DWORD PTR tv68[ebp], 0
  00054	74 0b		 je	 SHORT $LN3@setUTF16_U

; 960  :     {
; 961  : 		len++;

  00056	8b 4d fc	 mov	 ecx, DWORD PTR _len$[ebp]
  00059	83 c1 01	 add	 ecx, 1
  0005c	89 4d fc	 mov	 DWORD PTR _len$[ebp], ecx

; 962  :     }

  0005f	eb c7		 jmp	 SHORT $LN2@setUTF16_U
$LN3@setUTF16_U:

; 963  : 
; 964  :     if	(string->size < len + 1)

  00061	8b 55 fc	 mov	 edx, DWORD PTR _len$[ebp]
  00064	83 c2 01	 add	 edx, 1
  00067	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  0006a	39 50 0c	 cmp	 DWORD PTR [eax+12], edx
  0006d	73 43		 jae	 SHORT $LN4@setUTF16_U

; 965  :     {
; 966  : 		pANTLR3_UINT8 newAlloc = (pANTLR3_UINT8) ANTLR3_REALLOC((void *)string->chars, (ANTLR3_UINT32)(sizeof(ANTLR3_UINT16)*(len + 1)));

  0006f	8b 4d fc	 mov	 ecx, DWORD PTR _len$[ebp]
  00072	8d 54 09 02	 lea	 edx, DWORD PTR [ecx+ecx+2]
  00076	8b f4		 mov	 esi, esp
  00078	52		 push	 edx
  00079	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  0007c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0007f	51		 push	 ecx
  00080	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__realloc
  00086	83 c4 08	 add	 esp, 8
  00089	3b f4		 cmp	 esi, esp
  0008b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00090	89 45 f4	 mov	 DWORD PTR _newAlloc$1[ebp], eax

; 967  : 		if (newAlloc == NULL)

  00093	83 7d f4 00	 cmp	 DWORD PTR _newAlloc$1[ebp], 0
  00097	75 04		 jne	 SHORT $LN5@setUTF16_U

; 968  : 		{
; 969  : 			return NULL;

  00099	33 c0		 xor	 eax, eax
  0009b	eb 3f		 jmp	 SHORT $LN1@setUTF16_U
$LN5@setUTF16_U:

; 970  : 		}
; 971  : 		string->chars	= newAlloc;

  0009d	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  000a0	8b 45 f4	 mov	 eax, DWORD PTR _newAlloc$1[ebp]
  000a3	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 972  : 		string->size	= len + 1;

  000a6	8b 4d fc	 mov	 ecx, DWORD PTR _len$[ebp]
  000a9	83 c1 01	 add	 ecx, 1
  000ac	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  000af	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
$LN4@setUTF16_U:

; 973  :     }
; 974  : 
; 975  :     /* Note we copy one more byte than the strlen in order to get the trailing '\0'
; 976  :      */
; 977  :     ANTLR3_MEMMOVE((void *)(string->chars), chars, (ANTLR3_UINT32)((len+1) * sizeof(ANTLR3_UINT16)));

  000b2	8b 45 fc	 mov	 eax, DWORD PTR _len$[ebp]
  000b5	8d 4c 00 02	 lea	 ecx, DWORD PTR [eax+eax+2]
  000b9	51		 push	 ecx
  000ba	8b 55 0c	 mov	 edx, DWORD PTR _chars$[ebp]
  000bd	52		 push	 edx
  000be	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  000c1	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000c4	51		 push	 ecx
  000c5	e8 00 00 00 00	 call	 _memmove
  000ca	83 c4 0c	 add	 esp, 12			; 0000000cH

; 978  :     string->len	    = len;

  000cd	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  000d0	8b 45 fc	 mov	 eax, DWORD PTR _len$[ebp]
  000d3	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 979  : 
; 980  :     return  string->chars;

  000d6	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  000d9	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
$LN1@setUTF16_U:

; 981  : 
; 982  : }

  000dc	5e		 pop	 esi
  000dd	83 c4 14	 add	 esp, 20			; 00000014H
  000e0	3b ec		 cmp	 ebp, esp
  000e2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e7	8b e5		 mov	 esp, ebp
  000e9	5d		 pop	 ebp
  000ea	c3		 ret	 0
_setUTF16_UTF16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3string.c
;	COMDAT _setUTF16_8
_TEXT	SEGMENT
_newAlloc$1 = -16					; size = 4
_apPoint$ = -12						; size = 4
_count$ = -8						; size = 4
_len$ = -4						; size = 4
_string$ = 8						; size = 4
_chars$ = 12						; size = 4
_setUTF16_8 PROC					; COMDAT

; 920  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000f	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00012	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00015	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 921  :     ANTLR3_UINT32	len;
; 922  :     ANTLR3_UINT32	count;
; 923  :     pANTLR3_UINT16	apPoint;
; 924  : 
; 925  :     len = (ANTLR3_UINT32)strlen(chars);

  00018	8b 45 0c	 mov	 eax, DWORD PTR _chars$[ebp]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _strlen
  00021	83 c4 04	 add	 esp, 4
  00024	89 45 fc	 mov	 DWORD PTR _len$[ebp], eax

; 926  :     if	(string->size < len + 1)

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _len$[ebp]
  0002a	83 c1 01	 add	 ecx, 1
  0002d	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  00030	39 4a 0c	 cmp	 DWORD PTR [edx+12], ecx
  00033	73 43		 jae	 SHORT $LN5@setUTF16_8

; 927  : 	{
; 928  : 		pANTLR3_UINT8 newAlloc = (pANTLR3_UINT8) ANTLR3_REALLOC((void *)string->chars, (ANTLR3_UINT32)(sizeof(ANTLR3_UINT16)*(len + 1)));

  00035	8b 45 fc	 mov	 eax, DWORD PTR _len$[ebp]
  00038	8d 4c 00 02	 lea	 ecx, DWORD PTR [eax+eax+2]
  0003c	8b f4		 mov	 esi, esp
  0003e	51		 push	 ecx
  0003f	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  00042	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00045	50		 push	 eax
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__realloc
  0004c	83 c4 08	 add	 esp, 8
  0004f	3b f4		 cmp	 esi, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00056	89 45 f0	 mov	 DWORD PTR _newAlloc$1[ebp], eax

; 929  : 		if (newAlloc == NULL)

  00059	83 7d f0 00	 cmp	 DWORD PTR _newAlloc$1[ebp], 0
  0005d	75 04		 jne	 SHORT $LN6@setUTF16_8

; 930  : 		{
; 931  : 			return NULL;

  0005f	33 c0		 xor	 eax, eax
  00061	eb 6d		 jmp	 SHORT $LN1@setUTF16_8
$LN6@setUTF16_8:

; 932  : 		}
; 933  : 		string->chars	= newAlloc;

  00063	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  00066	8b 55 f0	 mov	 edx, DWORD PTR _newAlloc$1[ebp]
  00069	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 934  : 		string->size	= len + 1;

  0006c	8b 45 fc	 mov	 eax, DWORD PTR _len$[ebp]
  0006f	83 c0 01	 add	 eax, 1
  00072	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  00075	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
$LN5@setUTF16_8:

; 935  :     }
; 936  :     apPoint = ((pANTLR3_UINT16)string->chars);

  00078	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  0007b	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0007e	89 45 f4	 mov	 DWORD PTR _apPoint$[ebp], eax

; 937  :     string->len	= len;

  00081	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  00084	8b 55 fc	 mov	 edx, DWORD PTR _len$[ebp]
  00087	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 938  : 
; 939  :     for	(count = 0; count < string->len; count++)

  0008a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  00091	eb 09		 jmp	 SHORT $LN4@setUTF16_8
$LN2@setUTF16_8:
  00093	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  00096	83 c0 01	 add	 eax, 1
  00099	89 45 f8	 mov	 DWORD PTR _count$[ebp], eax
$LN4@setUTF16_8:
  0009c	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  0009f	8b 55 f8	 mov	 edx, DWORD PTR _count$[ebp]
  000a2	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  000a5	73 1b		 jae	 SHORT $LN3@setUTF16_8

; 940  :     {
; 941  : 		*apPoint++   = *(chars + count);

  000a7	8b 45 0c	 mov	 eax, DWORD PTR _chars$[ebp]
  000aa	03 45 f8	 add	 eax, DWORD PTR _count$[ebp]
  000ad	66 0f be 08	 movsx	 cx, BYTE PTR [eax]
  000b1	8b 55 f4	 mov	 edx, DWORD PTR _apPoint$[ebp]
  000b4	66 89 0a	 mov	 WORD PTR [edx], cx
  000b7	8b 45 f4	 mov	 eax, DWORD PTR _apPoint$[ebp]
  000ba	83 c0 02	 add	 eax, 2
  000bd	89 45 f4	 mov	 DWORD PTR _apPoint$[ebp], eax

; 942  :     }

  000c0	eb d1		 jmp	 SHORT $LN2@setUTF16_8
$LN3@setUTF16_8:

; 943  :     *apPoint = '\0';

  000c2	33 c9		 xor	 ecx, ecx
  000c4	8b 55 f4	 mov	 edx, DWORD PTR _apPoint$[ebp]
  000c7	66 89 0a	 mov	 WORD PTR [edx], cx

; 944  : 
; 945  :     return  string->chars;

  000ca	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  000cd	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
$LN1@setUTF16_8:

; 946  : }

  000d0	5e		 pop	 esi
  000d1	83 c4 10	 add	 esp, 16			; 00000010H
  000d4	3b ec		 cmp	 ebp, esp
  000d6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000db	8b e5		 mov	 esp, ebp
  000dd	5d		 pop	 ebp
  000de	c3		 ret	 0
_setUTF16_8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3string.c
;	COMDAT _set8
_TEXT	SEGMENT
_newAlloc$1 = -8					; size = 4
_len$ = -4						; size = 4
_string$ = 8						; size = 4
_chars$ = 12						; size = 4
_set8	PROC						; COMDAT

; 894  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 895  :     ANTLR3_UINT32	len;
; 896  : 
; 897  :     len = (ANTLR3_UINT32)strlen(chars);

  00015	8b 45 0c	 mov	 eax, DWORD PTR _chars$[ebp]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 _strlen
  0001e	83 c4 04	 add	 esp, 4
  00021	89 45 fc	 mov	 DWORD PTR _len$[ebp], eax

; 898  :     if	(string->size < len + 1)

  00024	8b 4d fc	 mov	 ecx, DWORD PTR _len$[ebp]
  00027	83 c1 01	 add	 ecx, 1
  0002a	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  0002d	39 4a 0c	 cmp	 DWORD PTR [edx+12], ecx
  00030	73 42		 jae	 SHORT $LN2@set8

; 899  :     {
; 900  : 		pANTLR3_UINT8 newAlloc = (pANTLR3_UINT8) ANTLR3_REALLOC((void *)string->chars, (ANTLR3_UINT32)(len + 1));

  00032	8b 45 fc	 mov	 eax, DWORD PTR _len$[ebp]
  00035	83 c0 01	 add	 eax, 1
  00038	8b f4		 mov	 esi, esp
  0003a	50		 push	 eax
  0003b	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  0003e	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00041	52		 push	 edx
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__realloc
  00048	83 c4 08	 add	 esp, 8
  0004b	3b f4		 cmp	 esi, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	89 45 f8	 mov	 DWORD PTR _newAlloc$1[ebp], eax

; 901  : 		if (newAlloc == NULL)

  00055	83 7d f8 00	 cmp	 DWORD PTR _newAlloc$1[ebp], 0
  00059	75 04		 jne	 SHORT $LN3@set8

; 902  : 		{
; 903  : 			return NULL;

  0005b	33 c0		 xor	 eax, eax
  0005d	eb 3e		 jmp	 SHORT $LN1@set8
$LN3@set8:

; 904  : 		}
; 905  : 		string->chars	= newAlloc;

  0005f	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  00062	8b 4d f8	 mov	 ecx, DWORD PTR _newAlloc$1[ebp]
  00065	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 906  : 		string->size	= len + 1;

  00068	8b 55 fc	 mov	 edx, DWORD PTR _len$[ebp]
  0006b	83 c2 01	 add	 edx, 1
  0006e	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  00071	89 50 0c	 mov	 DWORD PTR [eax+12], edx
$LN2@set8:

; 907  :     }
; 908  : 
; 909  :     /* Note we copy one more byte than the strlen in order to get the trailing '\0'
; 910  :      */
; 911  :     ANTLR3_MEMMOVE((void *)(string->chars), chars, (ANTLR3_UINT32)(len+1));

  00074	8b 4d fc	 mov	 ecx, DWORD PTR _len$[ebp]
  00077	83 c1 01	 add	 ecx, 1
  0007a	51		 push	 ecx
  0007b	8b 55 0c	 mov	 edx, DWORD PTR _chars$[ebp]
  0007e	52		 push	 edx
  0007f	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  00082	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00085	51		 push	 ecx
  00086	e8 00 00 00 00	 call	 _memmove
  0008b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 912  :     string->len	    = len;

  0008e	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  00091	8b 45 fc	 mov	 eax, DWORD PTR _len$[ebp]
  00094	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 913  : 
; 914  :     return  string->chars;

  00097	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  0009a	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
$LN1@set8:

; 915  : 
; 916  : }

  0009d	5e		 pop	 esi
  0009e	83 c4 08	 add	 esp, 8
  000a1	3b ec		 cmp	 ebp, esp
  000a3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a8	8b e5		 mov	 esp, ebp
  000aa	5d		 pop	 ebp
  000ab	c3		 ret	 0
_set8	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3string.c
;	COMDAT _closeFactory
_TEXT	SEGMENT
_factory$ = 8						; size = 4
_closeFactory PROC					; COMDAT

; 788  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 789  :     /* Delete the vector we were tracking the strings with, this will
; 790  :      * causes all the allocated strings to be deallocated too
; 791  :      */
; 792  :     factory->strings->free(factory->strings);

  00004	8b f4		 mov	 esi, esp
  00006	8b 45 08	 mov	 eax, DWORD PTR _factory$[ebp]
  00009	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000b	51		 push	 ecx
  0000c	8b 55 08	 mov	 edx, DWORD PTR _factory$[ebp]
  0000f	8b 02		 mov	 eax, DWORD PTR [edx]
  00011	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  00017	ff d1		 call	 ecx
  00019	83 c4 04	 add	 esp, 4
  0001c	3b f4		 cmp	 esi, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 793  : 
; 794  :     /* Delete the space for the factory itself
; 795  :      */
; 796  :     ANTLR3_FREE((void *)factory);

  00023	8b f4		 mov	 esi, esp
  00025	8b 55 08	 mov	 edx, DWORD PTR _factory$[ebp]
  00028	52		 push	 edx
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0002f	83 c4 04	 add	 esp, 4
  00032	3b f4		 cmp	 esi, esp
  00034	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00039	90		 npad	 1

; 797  : }

  0003a	5e		 pop	 esi
  0003b	3b ec		 cmp	 ebp, esp
  0003d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
_closeFactory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3string.c
;	COMDAT _printableUTF16
_TEXT	SEGMENT
_outLen$ = -20						; size = 4
_i$ = -16						; size = 4
_inText$ = -12						; size = 4
_scannedText$ = -8					; size = 4
_string$ = -4						; size = 4
_factory$ = 8						; size = 4
_instr$ = 12						; size = 4
_printableUTF16 PROC					; COMDAT

; 730  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0000f	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00012	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00015	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00018	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 731  :     pANTLR3_STRING  string;
; 732  :     
; 733  :     /* We don't need to be too efficient here, this is mostly for error messages and so on.
; 734  :      */
; 735  :     pANTLR3_UINT16  scannedText;
; 736  :     pANTLR3_UINT16  inText;
; 737  :     ANTLR3_UINT32   i;
; 738  :     ANTLR3_UINT32   outLen;
; 739  : 
; 740  :     /* Assume we need as much as twice as much space to parse out the control characters
; 741  :      */
; 742  :     string  = factory->newSize(factory, instr->len *2 + 1);

  0001b	8b 45 0c	 mov	 eax, DWORD PTR _instr$[ebp]
  0001e	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00021	8d 54 09 01	 lea	 edx, DWORD PTR [ecx+ecx+1]
  00025	8b f4		 mov	 esi, esp
  00027	52		 push	 edx
  00028	8b 45 08	 mov	 eax, DWORD PTR _factory$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _factory$[ebp]
  0002f	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00032	ff d2		 call	 edx
  00034	83 c4 08	 add	 esp, 8
  00037	3b f4		 cmp	 esi, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	89 45 fc	 mov	 DWORD PTR _string$[ebp], eax

; 743  : 
; 744  :     /* Scan through and replace unprintable (in terms of this routine)
; 745  :      * characters
; 746  :      */
; 747  :     scannedText = (pANTLR3_UINT16)(string->chars);

  00041	8b 45 fc	 mov	 eax, DWORD PTR _string$[ebp]
  00044	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00047	89 4d f8	 mov	 DWORD PTR _scannedText$[ebp], ecx

; 748  :     inText	= (pANTLR3_UINT16)(instr->chars);

  0004a	8b 55 0c	 mov	 edx, DWORD PTR _instr$[ebp]
  0004d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00050	89 45 f4	 mov	 DWORD PTR _inText$[ebp], eax

; 749  :     outLen	= 0;

  00053	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _outLen$[ebp], 0

; 750  : 
; 751  :     for	(i = 0; i < instr->len; i++)

  0005a	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00061	eb 09		 jmp	 SHORT $LN4@printableU
$LN2@printableU:
  00063	8b 4d f0	 mov	 ecx, DWORD PTR _i$[ebp]
  00066	83 c1 01	 add	 ecx, 1
  00069	89 4d f0	 mov	 DWORD PTR _i$[ebp], ecx
$LN4@printableU:
  0006c	8b 55 0c	 mov	 edx, DWORD PTR _instr$[ebp]
  0006f	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  00072	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  00075	0f 83 ee 00 00
	00		 jae	 $LN3@printableU

; 752  :     {
; 753  : 		if (*(inText + i) == '\n')

  0007b	8b 4d f0	 mov	 ecx, DWORD PTR _i$[ebp]
  0007e	8b 55 f4	 mov	 edx, DWORD PTR _inText$[ebp]
  00081	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00085	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00088	75 36		 jne	 SHORT $LN5@printableU

; 754  : 		{
; 755  : 			*scannedText++   = '\\';

  0008a	b9 5c 00 00 00	 mov	 ecx, 92			; 0000005cH
  0008f	8b 55 f8	 mov	 edx, DWORD PTR _scannedText$[ebp]
  00092	66 89 0a	 mov	 WORD PTR [edx], cx
  00095	8b 45 f8	 mov	 eax, DWORD PTR _scannedText$[ebp]
  00098	83 c0 02	 add	 eax, 2
  0009b	89 45 f8	 mov	 DWORD PTR _scannedText$[ebp], eax

; 756  : 			*scannedText++   = 'n';

  0009e	b9 6e 00 00 00	 mov	 ecx, 110		; 0000006eH
  000a3	8b 55 f8	 mov	 edx, DWORD PTR _scannedText$[ebp]
  000a6	66 89 0a	 mov	 WORD PTR [edx], cx
  000a9	8b 45 f8	 mov	 eax, DWORD PTR _scannedText$[ebp]
  000ac	83 c0 02	 add	 eax, 2
  000af	89 45 f8	 mov	 DWORD PTR _scannedText$[ebp], eax

; 757  : 			outLen	    += 2;

  000b2	8b 4d ec	 mov	 ecx, DWORD PTR _outLen$[ebp]
  000b5	83 c1 02	 add	 ecx, 2
  000b8	89 4d ec	 mov	 DWORD PTR _outLen$[ebp], ecx

; 758  : 		}

  000bb	e9 a4 00 00 00	 jmp	 $LN10@printableU
$LN5@printableU:

; 759  : 		else if (*(inText + i) == '\r')

  000c0	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  000c3	8b 45 f4	 mov	 eax, DWORD PTR _inText$[ebp]
  000c6	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  000ca	83 f9 0d	 cmp	 ecx, 13			; 0000000dH
  000cd	75 33		 jne	 SHORT $LN7@printableU

; 760  : 		{
; 761  : 			*scannedText++   = '\\';

  000cf	ba 5c 00 00 00	 mov	 edx, 92			; 0000005cH
  000d4	8b 45 f8	 mov	 eax, DWORD PTR _scannedText$[ebp]
  000d7	66 89 10	 mov	 WORD PTR [eax], dx
  000da	8b 4d f8	 mov	 ecx, DWORD PTR _scannedText$[ebp]
  000dd	83 c1 02	 add	 ecx, 2
  000e0	89 4d f8	 mov	 DWORD PTR _scannedText$[ebp], ecx

; 762  : 			*scannedText++   = 'r';

  000e3	ba 72 00 00 00	 mov	 edx, 114		; 00000072H
  000e8	8b 45 f8	 mov	 eax, DWORD PTR _scannedText$[ebp]
  000eb	66 89 10	 mov	 WORD PTR [eax], dx
  000ee	8b 4d f8	 mov	 ecx, DWORD PTR _scannedText$[ebp]
  000f1	83 c1 02	 add	 ecx, 2
  000f4	89 4d f8	 mov	 DWORD PTR _scannedText$[ebp], ecx

; 763  : 			outLen	    += 2;

  000f7	8b 55 ec	 mov	 edx, DWORD PTR _outLen$[ebp]
  000fa	83 c2 02	 add	 edx, 2
  000fd	89 55 ec	 mov	 DWORD PTR _outLen$[ebp], edx

; 764  : 		}

  00100	eb 62		 jmp	 SHORT $LN10@printableU
$LN7@printableU:

; 765  : 		else if	(!isprint(*(inText +i)))

  00102	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  00105	8b 4d f4	 mov	 ecx, DWORD PTR _inText$[ebp]
  00108	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  0010c	8b f4		 mov	 esi, esp
  0010e	52		 push	 edx
  0010f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__isprint
  00115	83 c4 04	 add	 esp, 4
  00118	3b f4		 cmp	 esi, esp
  0011a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0011f	85 c0		 test	 eax, eax
  00121	75 1f		 jne	 SHORT $LN9@printableU

; 766  : 		{
; 767  : 			*scannedText++ = '?';

  00123	b8 3f 00 00 00	 mov	 eax, 63			; 0000003fH
  00128	8b 4d f8	 mov	 ecx, DWORD PTR _scannedText$[ebp]
  0012b	66 89 01	 mov	 WORD PTR [ecx], ax
  0012e	8b 55 f8	 mov	 edx, DWORD PTR _scannedText$[ebp]
  00131	83 c2 02	 add	 edx, 2
  00134	89 55 f8	 mov	 DWORD PTR _scannedText$[ebp], edx

; 768  : 			outLen++;

  00137	8b 45 ec	 mov	 eax, DWORD PTR _outLen$[ebp]
  0013a	83 c0 01	 add	 eax, 1
  0013d	89 45 ec	 mov	 DWORD PTR _outLen$[ebp], eax

; 769  : 		}

  00140	eb 22		 jmp	 SHORT $LN10@printableU
$LN9@printableU:

; 770  : 		else
; 771  : 		{
; 772  : 			*scannedText++ = *(inText + i);

  00142	8b 4d f8	 mov	 ecx, DWORD PTR _scannedText$[ebp]
  00145	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  00148	8b 45 f4	 mov	 eax, DWORD PTR _inText$[ebp]
  0014b	66 8b 14 50	 mov	 dx, WORD PTR [eax+edx*2]
  0014f	66 89 11	 mov	 WORD PTR [ecx], dx
  00152	8b 45 f8	 mov	 eax, DWORD PTR _scannedText$[ebp]
  00155	83 c0 02	 add	 eax, 2
  00158	89 45 f8	 mov	 DWORD PTR _scannedText$[ebp], eax

; 773  : 			outLen++;

  0015b	8b 4d ec	 mov	 ecx, DWORD PTR _outLen$[ebp]
  0015e	83 c1 01	 add	 ecx, 1
  00161	89 4d ec	 mov	 DWORD PTR _outLen$[ebp], ecx
$LN10@printableU:

; 774  : 		}
; 775  :     }

  00164	e9 fa fe ff ff	 jmp	 $LN2@printableU
$LN3@printableU:

; 776  :     *scannedText  = '\0';

  00169	33 d2		 xor	 edx, edx
  0016b	8b 45 f8	 mov	 eax, DWORD PTR _scannedText$[ebp]
  0016e	66 89 10	 mov	 WORD PTR [eax], dx

; 777  : 
; 778  :     string->len	= outLen;

  00171	8b 4d fc	 mov	 ecx, DWORD PTR _string$[ebp]
  00174	8b 55 ec	 mov	 edx, DWORD PTR _outLen$[ebp]
  00177	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 779  :     
; 780  :     return  string;

  0017a	8b 45 fc	 mov	 eax, DWORD PTR _string$[ebp]

; 781  : }

  0017d	5e		 pop	 esi
  0017e	83 c4 14	 add	 esp, 20			; 00000014H
  00181	3b ec		 cmp	 ebp, esp
  00183	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00188	8b e5		 mov	 esp, ebp
  0018a	5d		 pop	 ebp
  0018b	c3		 ret	 0
_printableUTF16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3string.c
;	COMDAT _printable8
_TEXT	SEGMENT
_i$ = -12						; size = 4
_scannedText$ = -8					; size = 4
_string$ = -4						; size = 4
_factory$ = 8						; size = 4
_instr$ = 12						; size = 4
_printable8 PROC					; COMDAT

; 683  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000e	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00015	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 684  :     pANTLR3_STRING  string;
; 685  :     
; 686  :     /* We don't need to be too efficient here, this is mostly for error messages and so on.
; 687  :      */
; 688  :     pANTLR3_UINT8   scannedText;
; 689  :     ANTLR3_UINT32   i;
; 690  : 
; 691  :     /* Assume we need as much as twice as much space to parse out the control characters
; 692  :      */
; 693  :     string  = factory->newSize(factory, instr->len *2 + 1);

  0001c	8b 45 0c	 mov	 eax, DWORD PTR _instr$[ebp]
  0001f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00022	8d 54 09 01	 lea	 edx, DWORD PTR [ecx+ecx+1]
  00026	8b f4		 mov	 esi, esp
  00028	52		 push	 edx
  00029	8b 45 08	 mov	 eax, DWORD PTR _factory$[ebp]
  0002c	50		 push	 eax
  0002d	8b 4d 08	 mov	 ecx, DWORD PTR _factory$[ebp]
  00030	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00033	ff d2		 call	 edx
  00035	83 c4 08	 add	 esp, 8
  00038	3b f4		 cmp	 esi, esp
  0003a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003f	89 45 fc	 mov	 DWORD PTR _string$[ebp], eax

; 694  : 
; 695  :     /* Scan through and replace unprintable (in terms of this routine)
; 696  :      * characters
; 697  :      */
; 698  :     scannedText = string->chars;

  00042	8b 45 fc	 mov	 eax, DWORD PTR _string$[ebp]
  00045	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00048	89 4d f8	 mov	 DWORD PTR _scannedText$[ebp], ecx

; 699  : 
; 700  :     for	(i = 0; i < instr->len; i++)

  0004b	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00052	eb 09		 jmp	 SHORT $LN4@printable8
$LN2@printable8:
  00054	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  00057	83 c2 01	 add	 edx, 1
  0005a	89 55 f4	 mov	 DWORD PTR _i$[ebp], edx
$LN4@printable8:
  0005d	8b 45 0c	 mov	 eax, DWORD PTR _instr$[ebp]
  00060	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  00063	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00066	0f 83 bb 00 00
	00		 jae	 $LN3@printable8

; 701  :     {
; 702  : 		if (*(instr->chars + i) == '\n')

  0006c	8b 55 0c	 mov	 edx, DWORD PTR _instr$[ebp]
  0006f	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00072	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  00075	0f b6 14 08	 movzx	 edx, BYTE PTR [eax+ecx]
  00079	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  0007c	75 23		 jne	 SHORT $LN5@printable8

; 703  : 		{
; 704  : 			*scannedText++ = '\\';

  0007e	8b 45 f8	 mov	 eax, DWORD PTR _scannedText$[ebp]
  00081	c6 00 5c	 mov	 BYTE PTR [eax], 92	; 0000005cH
  00084	8b 4d f8	 mov	 ecx, DWORD PTR _scannedText$[ebp]
  00087	83 c1 01	 add	 ecx, 1
  0008a	89 4d f8	 mov	 DWORD PTR _scannedText$[ebp], ecx

; 705  : 			*scannedText++ = 'n';

  0008d	8b 55 f8	 mov	 edx, DWORD PTR _scannedText$[ebp]
  00090	c6 02 6e	 mov	 BYTE PTR [edx], 110	; 0000006eH
  00093	8b 45 f8	 mov	 eax, DWORD PTR _scannedText$[ebp]
  00096	83 c0 01	 add	 eax, 1
  00099	89 45 f8	 mov	 DWORD PTR _scannedText$[ebp], eax

; 706  : 		}

  0009c	e9 81 00 00 00	 jmp	 $LN10@printable8
$LN5@printable8:

; 707  : 		else if (*(instr->chars + i) == '\r')

  000a1	8b 4d 0c	 mov	 ecx, DWORD PTR _instr$[ebp]
  000a4	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000a7	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  000aa	0f b6 0c 02	 movzx	 ecx, BYTE PTR [edx+eax]
  000ae	83 f9 0d	 cmp	 ecx, 13			; 0000000dH
  000b1	75 20		 jne	 SHORT $LN7@printable8

; 708  : 		{
; 709  : 			*scannedText++ = '\\';

  000b3	8b 55 f8	 mov	 edx, DWORD PTR _scannedText$[ebp]
  000b6	c6 02 5c	 mov	 BYTE PTR [edx], 92	; 0000005cH
  000b9	8b 45 f8	 mov	 eax, DWORD PTR _scannedText$[ebp]
  000bc	83 c0 01	 add	 eax, 1
  000bf	89 45 f8	 mov	 DWORD PTR _scannedText$[ebp], eax

; 710  : 			*scannedText++ = 'r';

  000c2	8b 4d f8	 mov	 ecx, DWORD PTR _scannedText$[ebp]
  000c5	c6 01 72	 mov	 BYTE PTR [ecx], 114	; 00000072H
  000c8	8b 55 f8	 mov	 edx, DWORD PTR _scannedText$[ebp]
  000cb	83 c2 01	 add	 edx, 1
  000ce	89 55 f8	 mov	 DWORD PTR _scannedText$[ebp], edx

; 711  : 		}

  000d1	eb 4f		 jmp	 SHORT $LN10@printable8
$LN7@printable8:

; 712  : 		else if	(!isprint(*(instr->chars +i)))

  000d3	8b 45 0c	 mov	 eax, DWORD PTR _instr$[ebp]
  000d6	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000d9	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  000dc	0f b6 04 11	 movzx	 eax, BYTE PTR [ecx+edx]
  000e0	8b f4		 mov	 esi, esp
  000e2	50		 push	 eax
  000e3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__isprint
  000e9	83 c4 04	 add	 esp, 4
  000ec	3b f4		 cmp	 esi, esp
  000ee	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f3	85 c0		 test	 eax, eax
  000f5	75 11		 jne	 SHORT $LN9@printable8

; 713  : 		{
; 714  : 			*scannedText++ = '?';

  000f7	8b 4d f8	 mov	 ecx, DWORD PTR _scannedText$[ebp]
  000fa	c6 01 3f	 mov	 BYTE PTR [ecx], 63	; 0000003fH
  000fd	8b 55 f8	 mov	 edx, DWORD PTR _scannedText$[ebp]
  00100	83 c2 01	 add	 edx, 1
  00103	89 55 f8	 mov	 DWORD PTR _scannedText$[ebp], edx

; 715  : 		}

  00106	eb 1a		 jmp	 SHORT $LN10@printable8
$LN9@printable8:

; 716  : 		else
; 717  : 		{
; 718  : 			*scannedText++ = *(instr->chars + i);

  00108	8b 45 0c	 mov	 eax, DWORD PTR _instr$[ebp]
  0010b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0010e	8b 55 f8	 mov	 edx, DWORD PTR _scannedText$[ebp]
  00111	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00114	8a 0c 01	 mov	 cl, BYTE PTR [ecx+eax]
  00117	88 0a		 mov	 BYTE PTR [edx], cl
  00119	8b 55 f8	 mov	 edx, DWORD PTR _scannedText$[ebp]
  0011c	83 c2 01	 add	 edx, 1
  0011f	89 55 f8	 mov	 DWORD PTR _scannedText$[ebp], edx
$LN10@printable8:

; 719  : 		}
; 720  :     }

  00122	e9 2d ff ff ff	 jmp	 $LN2@printable8
$LN3@printable8:

; 721  :     *scannedText  = '\0';

  00127	8b 45 f8	 mov	 eax, DWORD PTR _scannedText$[ebp]
  0012a	c6 00 00	 mov	 BYTE PTR [eax], 0

; 722  : 
; 723  :     string->len	= (ANTLR3_UINT32)(scannedText - string->chars);

  0012d	8b 4d fc	 mov	 ecx, DWORD PTR _string$[ebp]
  00130	8b 55 f8	 mov	 edx, DWORD PTR _scannedText$[ebp]
  00133	2b 51 04	 sub	 edx, DWORD PTR [ecx+4]
  00136	8b 45 fc	 mov	 eax, DWORD PTR _string$[ebp]
  00139	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 724  :     
; 725  :     return  string;

  0013c	8b 45 fc	 mov	 eax, DWORD PTR _string$[ebp]

; 726  : }

  0013f	5e		 pop	 esi
  00140	83 c4 0c	 add	 esp, 12			; 0000000cH
  00143	3b ec		 cmp	 ebp, esp
  00145	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0014a	8b e5		 mov	 esp, ebp
  0014c	5d		 pop	 ebp
  0014d	c3		 ret	 0
_printable8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3string.c
;	COMDAT _destroy
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_strIndex$ = -4						; size = 4
_factory$ = 8						; size = 4
_string$ = 12						; size = 4
_destroy PROC						; COMDAT

; 638  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 639  :     // Record which string we are deleting
; 640  :     //
; 641  :     ANTLR3_UINT32 strIndex = string->index;

  00015	8b 45 0c	 mov	 eax, DWORD PTR _string$[ebp]
  00018	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0001b	89 4d fc	 mov	 DWORD PTR _strIndex$[ebp], ecx

; 642  :     
; 643  :     // Ensure that the string was not factory made, or we would try
; 644  :     // to delete memory that wasn't allocated outside the factory
; 645  :     // block.
; 646  :     // Remove the specific indexed string from the vector
; 647  :     //
; 648  :     factory->strings->del(factory->strings, strIndex);

  0001e	8b f4		 mov	 esi, esp
  00020	8b 55 fc	 mov	 edx, DWORD PTR _strIndex$[ebp]
  00023	52		 push	 edx
  00024	8b 45 08	 mov	 eax, DWORD PTR _factory$[ebp]
  00027	8b 08		 mov	 ecx, DWORD PTR [eax]
  00029	51		 push	 ecx
  0002a	8b 55 08	 mov	 edx, DWORD PTR _factory$[ebp]
  0002d	8b 02		 mov	 eax, DWORD PTR [edx]
  0002f	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [eax+148]
  00035	ff d1		 call	 ecx
  00037	83 c4 08	 add	 esp, 8
  0003a	3b f4		 cmp	 esi, esp
  0003c	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 649  : 
; 650  :     // One less string in the vector, so decrement the factory index
; 651  :     // so that the next string allocated is indexed correctly with
; 652  :     // respect to the vector.
; 653  :     //
; 654  :     factory->index--;

  00041	8b 55 08	 mov	 edx, DWORD PTR _factory$[ebp]
  00044	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00047	83 e8 01	 sub	 eax, 1
  0004a	8b 4d 08	 mov	 ecx, DWORD PTR _factory$[ebp]
  0004d	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 655  : 
; 656  :     // Now we have to reindex the strings in the vector that followed
; 657  :     // the one we just deleted. We only do this if the one we just deleted
; 658  :     // was not the last one.
; 659  :     //
; 660  :     if  (strIndex< factory->index)

  00050	8b 55 08	 mov	 edx, DWORD PTR _factory$[ebp]
  00053	8b 45 fc	 mov	 eax, DWORD PTR _strIndex$[ebp]
  00056	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  00059	73 31		 jae	 SHORT $LN3@destroy

; 661  :     {
; 662  :         // We must reindex the strings after the one we just deleted.
; 663  :         // The one that follows the one we just deleted is also out
; 664  :         // of whack, so we start there.
; 665  :         //
; 666  :         ANTLR3_UINT32 i;
; 667  : 
; 668  :         for (i = strIndex; i < factory->index; i++)

  0005b	8b 4d fc	 mov	 ecx, DWORD PTR _strIndex$[ebp]
  0005e	89 4d f8	 mov	 DWORD PTR _i$1[ebp], ecx
  00061	eb 09		 jmp	 SHORT $LN4@destroy
$LN2@destroy:
  00063	8b 55 f8	 mov	 edx, DWORD PTR _i$1[ebp]
  00066	83 c2 01	 add	 edx, 1
  00069	89 55 f8	 mov	 DWORD PTR _i$1[ebp], edx
$LN4@destroy:
  0006c	8b 45 08	 mov	 eax, DWORD PTR _factory$[ebp]
  0006f	8b 4d f8	 mov	 ecx, DWORD PTR _i$1[ebp]
  00072	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00075	73 15		 jae	 SHORT $LN3@destroy

; 669  :         {
; 670  :             // Renumber the entry
; 671  :             //
; 672  :             ((pANTLR3_STRING)(factory->strings->elements[i].element))->index = i;

  00077	8b 55 08	 mov	 edx, DWORD PTR _factory$[ebp]
  0007a	8b 02		 mov	 eax, DWORD PTR [edx]
  0007c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007e	8b 55 f8	 mov	 edx, DWORD PTR _i$1[ebp]
  00081	8b 04 d1	 mov	 eax, DWORD PTR [ecx+edx*8]
  00084	8b 4d f8	 mov	 ecx, DWORD PTR _i$1[ebp]
  00087	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 673  :         }

  0008a	eb d7		 jmp	 SHORT $LN2@destroy
$LN3@destroy:

; 674  :     }
; 675  : 
; 676  :     // The string has been destroyed and the elements of the factory are reindexed.
; 677  :     //
; 678  : 
; 679  : }

  0008c	5e		 pop	 esi
  0008d	83 c4 08	 add	 esp, 8
  00090	3b ec		 cmp	 ebp, esp
  00092	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00097	8b e5		 mov	 esp, ebp
  00099	5d		 pop	 ebp
  0009a	c3		 ret	 0
_destroy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3string.c
;	COMDAT _newStrUTF16_UTF16
_TEXT	SEGMENT
tv68 = -16						; size = 4
tv67 = -12						; size = 4
_count$ = -8						; size = 4
_in$ = -4						; size = 4
_factory$ = 8						; size = 4
_ptr$ = 12						; size = 4
_newStrUTF16_UTF16 PROC					; COMDAT

; 620  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000f	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00012	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00015	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 621  :     pANTLR3_UINT16  in;
; 622  :     ANTLR3_UINT32   count;
; 623  : 
; 624  :     /** First, determine the length of the input string
; 625  :      */
; 626  :     in	    = (pANTLR3_UINT16)ptr;

  00018	8b 45 0c	 mov	 eax, DWORD PTR _ptr$[ebp]
  0001b	89 45 fc	 mov	 DWORD PTR _in$[ebp], eax

; 627  :     count   = 0;

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
$LN2@newStrUTF1:

; 628  : 
; 629  :     while   (*in++ != '\0')

  00025	8b 4d fc	 mov	 ecx, DWORD PTR _in$[ebp]
  00028	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  0002b	89 55 f4	 mov	 DWORD PTR tv67[ebp], edx
  0002e	8b 45 fc	 mov	 eax, DWORD PTR _in$[ebp]
  00031	83 c0 02	 add	 eax, 2
  00034	89 45 fc	 mov	 DWORD PTR _in$[ebp], eax
  00037	83 7d f4 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	74 09		 je	 SHORT $LN5@newStrUTF1
  0003d	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
  00044	eb 07		 jmp	 SHORT $LN6@newStrUTF1
$LN5@newStrUTF1:
  00046	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
$LN6@newStrUTF1:
  0004d	83 7d f0 00	 cmp	 DWORD PTR tv68[ebp], 0
  00051	74 0b		 je	 SHORT $LN3@newStrUTF1

; 630  :     {
; 631  : 		count++;

  00053	8b 4d f8	 mov	 ecx, DWORD PTR _count$[ebp]
  00056	83 c1 01	 add	 ecx, 1
  00059	89 4d f8	 mov	 DWORD PTR _count$[ebp], ecx

; 632  :     }

  0005c	eb c7		 jmp	 SHORT $LN2@newStrUTF1
$LN3@newStrUTF1:

; 633  :     return factory->newPtr(factory, ptr, count);

  0005e	8b f4		 mov	 esi, esp
  00060	8b 55 f8	 mov	 edx, DWORD PTR _count$[ebp]
  00063	52		 push	 edx
  00064	8b 45 0c	 mov	 eax, DWORD PTR _ptr$[ebp]
  00067	50		 push	 eax
  00068	8b 4d 08	 mov	 ecx, DWORD PTR _factory$[ebp]
  0006b	51		 push	 ecx
  0006c	8b 55 08	 mov	 edx, DWORD PTR _factory$[ebp]
  0006f	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00072	ff d0		 call	 eax
  00074	83 c4 0c	 add	 esp, 12			; 0000000cH
  00077	3b f4		 cmp	 esi, esp
  00079	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 634  : }

  0007e	5e		 pop	 esi
  0007f	83 c4 10	 add	 esp, 16			; 00000010H
  00082	3b ec		 cmp	 ebp, esp
  00084	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c3		 ret	 0
_newStrUTF16_UTF16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3string.c
;	COMDAT _newStrUTF16_8
_TEXT	SEGMENT
_factory$ = 8						; size = 4
_ptr$ = 12						; size = 4
_newStrUTF16_8 PROC					; COMDAT

; 609  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 610  :     return factory->newPtr8(factory, ptr, (ANTLR3_UINT32)strlen((const char *)ptr));

  00004	8b 45 0c	 mov	 eax, DWORD PTR _ptr$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 _strlen
  0000d	83 c4 04	 add	 esp, 4
  00010	8b f4		 mov	 esi, esp
  00012	50		 push	 eax
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR _ptr$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 08	 mov	 edx, DWORD PTR _factory$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 08	 mov	 eax, DWORD PTR _factory$[ebp]
  0001e	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00021	ff d1		 call	 ecx
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH
  00026	3b f4		 cmp	 esi, esp
  00028	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 611  : }

  0002d	5e		 pop	 esi
  0002e	3b ec		 cmp	 ebp, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
_newStrUTF16_8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3string.c
;	COMDAT _newStr8
_TEXT	SEGMENT
_factory$ = 8						; size = 4
_ptr$ = 12						; size = 4
_newStr8 PROC						; COMDAT

; 598  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 599  :     return factory->newPtr8(factory, ptr, (ANTLR3_UINT32)strlen((const char *)ptr));

  00004	8b 45 0c	 mov	 eax, DWORD PTR _ptr$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 _strlen
  0000d	83 c4 04	 add	 esp, 4
  00010	8b f4		 mov	 esi, esp
  00012	50		 push	 eax
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR _ptr$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 08	 mov	 edx, DWORD PTR _factory$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 08	 mov	 eax, DWORD PTR _factory$[ebp]
  0001e	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00021	ff d1		 call	 ecx
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH
  00026	3b f4		 cmp	 esi, esp
  00028	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 600  : }

  0002d	5e		 pop	 esi
  0002e	3b ec		 cmp	 ebp, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
_newStr8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3string.c
;	COMDAT _newPtrUTF16_UTF16
_TEXT	SEGMENT
_string$ = -4						; size = 4
_factory$ = 8						; size = 4
_ptr$ = 12						; size = 4
_size$ = 16						; size = 4
_newPtrUTF16_UTF16 PROC					; COMDAT

; 563  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 564  : 	pANTLR3_STRING  string;
; 565  : 
; 566  : 	string  = factory->newSize(factory, size);

  0000c	8b f4		 mov	 esi, esp
  0000e	8b 45 10	 mov	 eax, DWORD PTR _size$[ebp]
  00011	50		 push	 eax
  00012	8b 4d 08	 mov	 ecx, DWORD PTR _factory$[ebp]
  00015	51		 push	 ecx
  00016	8b 55 08	 mov	 edx, DWORD PTR _factory$[ebp]
  00019	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0001c	ff d0		 call	 eax
  0001e	83 c4 08	 add	 esp, 8
  00021	3b f4		 cmp	 esi, esp
  00023	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00028	89 45 fc	 mov	 DWORD PTR _string$[ebp], eax

; 567  : 
; 568  : 	if	(string == NULL)

  0002b	83 7d fc 00	 cmp	 DWORD PTR _string$[ebp], 0
  0002f	75 04		 jne	 SHORT $LN2@newPtrUTF1

; 569  : 	{
; 570  : 		return	NULL;

  00031	33 c0		 xor	 eax, eax
  00033	eb 45		 jmp	 SHORT $LN1@newPtrUTF1
$LN2@newPtrUTF1:

; 571  : 	}
; 572  : 
; 573  : 	if	(size <= 0)

  00035	83 7d 10 00	 cmp	 DWORD PTR _size$[ebp], 0
  00039	77 05		 ja	 SHORT $LN3@newPtrUTF1

; 574  : 	{
; 575  : 		return	string;

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _string$[ebp]
  0003e	eb 3a		 jmp	 SHORT $LN1@newPtrUTF1
$LN3@newPtrUTF1:

; 576  : 	}
; 577  : 
; 578  : 	if	(ptr != NULL)

  00040	83 7d 0c 00	 cmp	 DWORD PTR _ptr$[ebp], 0
  00044	74 31		 je	 SHORT $LN4@newPtrUTF1

; 579  : 	{
; 580  : 		ANTLR3_MEMMOVE(string->chars, (const void *)ptr, (size * sizeof(ANTLR3_UINT16)));

  00046	8b 4d 10	 mov	 ecx, DWORD PTR _size$[ebp]
  00049	d1 e1		 shl	 ecx, 1
  0004b	51		 push	 ecx
  0004c	8b 55 0c	 mov	 edx, DWORD PTR _ptr$[ebp]
  0004f	52		 push	 edx
  00050	8b 45 fc	 mov	 eax, DWORD PTR _string$[ebp]
  00053	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00056	51		 push	 ecx
  00057	e8 00 00 00 00	 call	 _memmove
  0005c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 581  : 
; 582  : 		/* Terminate, these strings are usually used for Token streams and printing etc.	
; 583  : 		*/
; 584  : 		*(((pANTLR3_UINT16)(string->chars)) + size) = '\0';	    

  0005f	8b 55 fc	 mov	 edx, DWORD PTR _string$[ebp]
  00062	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00065	33 c9		 xor	 ecx, ecx
  00067	8b 55 10	 mov	 edx, DWORD PTR _size$[ebp]
  0006a	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx

; 585  : 		string->len = size;

  0006e	8b 45 fc	 mov	 eax, DWORD PTR _string$[ebp]
  00071	8b 4d 10	 mov	 ecx, DWORD PTR _size$[ebp]
  00074	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN4@newPtrUTF1:

; 586  : 	}
; 587  : 
; 588  : 	return  string;

  00077	8b 45 fc	 mov	 eax, DWORD PTR _string$[ebp]
$LN1@newPtrUTF1:

; 589  : }

  0007a	5e		 pop	 esi
  0007b	83 c4 04	 add	 esp, 4
  0007e	3b ec		 cmp	 ebp, esp
  00080	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
_newPtrUTF16_UTF16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3string.c
;	COMDAT _newPtrUTF16_8
_TEXT	SEGMENT
tv75 = -20						; size = 4
tv74 = -16						; size = 4
_inSize$1 = -12						; size = 4
_out$2 = -8						; size = 4
_string$ = -4						; size = 4
_factory$ = 8						; size = 4
_ptr$ = 12						; size = 4
_size$ = 16						; size = 4
_newPtrUTF16_8 PROC					; COMDAT

; 515  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0000f	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00012	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00015	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00018	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 516  : 	pANTLR3_STRING  string;
; 517  : 
; 518  : 	/* newSize accepts size in characters, not bytes
; 519  : 	*/
; 520  : 	string  = factory->newSize(factory, size);

  0001b	8b f4		 mov	 esi, esp
  0001d	8b 45 10	 mov	 eax, DWORD PTR _size$[ebp]
  00020	50		 push	 eax
  00021	8b 4d 08	 mov	 ecx, DWORD PTR _factory$[ebp]
  00024	51		 push	 ecx
  00025	8b 55 08	 mov	 edx, DWORD PTR _factory$[ebp]
  00028	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0002b	ff d0		 call	 eax
  0002d	83 c4 08	 add	 esp, 8
  00030	3b f4		 cmp	 esi, esp
  00032	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00037	89 45 fc	 mov	 DWORD PTR _string$[ebp], eax

; 521  : 
; 522  : 	if	(string == NULL)

  0003a	83 7d fc 00	 cmp	 DWORD PTR _string$[ebp], 0
  0003e	75 07		 jne	 SHORT $LN4@newPtrUTF1

; 523  : 	{
; 524  : 		return	NULL;

  00040	33 c0		 xor	 eax, eax
  00042	e9 87 00 00 00	 jmp	 $LN1@newPtrUTF1
$LN4@newPtrUTF1:

; 525  : 	}
; 526  : 
; 527  : 	if	(size <= 0)

  00047	83 7d 10 00	 cmp	 DWORD PTR _size$[ebp], 0
  0004b	77 05		 ja	 SHORT $LN5@newPtrUTF1

; 528  : 	{
; 529  : 		return	string;

  0004d	8b 45 fc	 mov	 eax, DWORD PTR _string$[ebp]
  00050	eb 7c		 jmp	 SHORT $LN1@newPtrUTF1
$LN5@newPtrUTF1:

; 530  : 	}
; 531  : 
; 532  : 	if	(ptr != NULL)

  00052	83 7d 0c 00	 cmp	 DWORD PTR _ptr$[ebp], 0
  00056	74 73		 je	 SHORT $LN6@newPtrUTF1

; 533  : 	{
; 534  : 		pANTLR3_UINT16	out;
; 535  : 		ANTLR3_INT32    inSize;
; 536  : 
; 537  : 		out = (pANTLR3_UINT16)(string->chars);

  00058	8b 4d fc	 mov	 ecx, DWORD PTR _string$[ebp]
  0005b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0005e	89 55 f8	 mov	 DWORD PTR _out$2[ebp], edx

; 538  : 		inSize	= size;

  00061	8b 45 10	 mov	 eax, DWORD PTR _size$[ebp]
  00064	89 45 f4	 mov	 DWORD PTR _inSize$1[ebp], eax
$LN2@newPtrUTF1:

; 539  : 
; 540  : 		while	(inSize-- > 0)

  00067	8b 4d f4	 mov	 ecx, DWORD PTR _inSize$1[ebp]
  0006a	89 4d f0	 mov	 DWORD PTR tv74[ebp], ecx
  0006d	8b 55 f4	 mov	 edx, DWORD PTR _inSize$1[ebp]
  00070	83 ea 01	 sub	 edx, 1
  00073	89 55 f4	 mov	 DWORD PTR _inSize$1[ebp], edx
  00076	83 7d f0 00	 cmp	 DWORD PTR tv74[ebp], 0
  0007a	7e 09		 jle	 SHORT $LN8@newPtrUTF1
  0007c	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv75[ebp], 1
  00083	eb 07		 jmp	 SHORT $LN9@newPtrUTF1
$LN8@newPtrUTF1:
  00085	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv75[ebp], 0
$LN9@newPtrUTF1:
  0008c	83 7d ec 00	 cmp	 DWORD PTR tv75[ebp], 0
  00090	74 21		 je	 SHORT $LN3@newPtrUTF1

; 541  : 		{
; 542  : 			*out++ = (ANTLR3_UINT16)(*ptr++);

  00092	8b 45 0c	 mov	 eax, DWORD PTR _ptr$[ebp]
  00095	66 0f b6 08	 movzx	 cx, BYTE PTR [eax]
  00099	8b 55 f8	 mov	 edx, DWORD PTR _out$2[ebp]
  0009c	66 89 0a	 mov	 WORD PTR [edx], cx
  0009f	8b 45 f8	 mov	 eax, DWORD PTR _out$2[ebp]
  000a2	83 c0 02	 add	 eax, 2
  000a5	89 45 f8	 mov	 DWORD PTR _out$2[ebp], eax
  000a8	8b 4d 0c	 mov	 ecx, DWORD PTR _ptr$[ebp]
  000ab	83 c1 01	 add	 ecx, 1
  000ae	89 4d 0c	 mov	 DWORD PTR _ptr$[ebp], ecx

; 543  : 		}

  000b1	eb b4		 jmp	 SHORT $LN2@newPtrUTF1
$LN3@newPtrUTF1:

; 544  : 
; 545  : 		/* Terminate, these strings are usually used for Token streams and printing etc.	
; 546  : 		*/
; 547  : 		*(((pANTLR3_UINT16)(string->chars)) + size) = '\0';

  000b3	8b 55 fc	 mov	 edx, DWORD PTR _string$[ebp]
  000b6	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000b9	33 c9		 xor	 ecx, ecx
  000bb	8b 55 10	 mov	 edx, DWORD PTR _size$[ebp]
  000be	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx

; 548  : 
; 549  : 		string->len = size;

  000c2	8b 45 fc	 mov	 eax, DWORD PTR _string$[ebp]
  000c5	8b 4d 10	 mov	 ecx, DWORD PTR _size$[ebp]
  000c8	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN6@newPtrUTF1:

; 550  : 	}
; 551  : 
; 552  : 	return  string;

  000cb	8b 45 fc	 mov	 eax, DWORD PTR _string$[ebp]
$LN1@newPtrUTF1:

; 553  : }

  000ce	5e		 pop	 esi
  000cf	83 c4 14	 add	 esp, 20			; 00000014H
  000d2	3b ec		 cmp	 ebp, esp
  000d4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d9	8b e5		 mov	 esp, ebp
  000db	5d		 pop	 ebp
  000dc	c3		 ret	 0
_newPtrUTF16_8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3string.c
;	COMDAT _newPtr8
_TEXT	SEGMENT
_string$ = -4						; size = 4
_factory$ = 8						; size = 4
_ptr$ = 12						; size = 4
_size$ = 16						; size = 4
_newPtr8 PROC						; COMDAT

; 482  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 483  : 	pANTLR3_STRING  string;
; 484  : 
; 485  : 	string  = factory->newSize(factory, size);

  0000c	8b f4		 mov	 esi, esp
  0000e	8b 45 10	 mov	 eax, DWORD PTR _size$[ebp]
  00011	50		 push	 eax
  00012	8b 4d 08	 mov	 ecx, DWORD PTR _factory$[ebp]
  00015	51		 push	 ecx
  00016	8b 55 08	 mov	 edx, DWORD PTR _factory$[ebp]
  00019	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0001c	ff d0		 call	 eax
  0001e	83 c4 08	 add	 esp, 8
  00021	3b f4		 cmp	 esi, esp
  00023	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00028	89 45 fc	 mov	 DWORD PTR _string$[ebp], eax

; 486  : 
; 487  : 	if	(string == NULL)

  0002b	83 7d fc 00	 cmp	 DWORD PTR _string$[ebp], 0
  0002f	75 04		 jne	 SHORT $LN2@newPtr8

; 488  : 	{
; 489  : 		return	NULL;

  00031	33 c0		 xor	 eax, eax
  00033	eb 41		 jmp	 SHORT $LN1@newPtr8
$LN2@newPtr8:

; 490  : 	}
; 491  : 
; 492  : 	if	(size <= 0)

  00035	83 7d 10 00	 cmp	 DWORD PTR _size$[ebp], 0
  00039	77 05		 ja	 SHORT $LN3@newPtr8

; 493  : 	{
; 494  : 		return	string;

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _string$[ebp]
  0003e	eb 36		 jmp	 SHORT $LN1@newPtr8
$LN3@newPtr8:

; 495  : 	}
; 496  : 
; 497  : 	if	(ptr != NULL)

  00040	83 7d 0c 00	 cmp	 DWORD PTR _ptr$[ebp], 0
  00044	74 2d		 je	 SHORT $LN4@newPtr8

; 498  : 	{
; 499  : 		ANTLR3_MEMMOVE(string->chars, (const void *)ptr, size);

  00046	8b 4d 10	 mov	 ecx, DWORD PTR _size$[ebp]
  00049	51		 push	 ecx
  0004a	8b 55 0c	 mov	 edx, DWORD PTR _ptr$[ebp]
  0004d	52		 push	 edx
  0004e	8b 45 fc	 mov	 eax, DWORD PTR _string$[ebp]
  00051	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00054	51		 push	 ecx
  00055	e8 00 00 00 00	 call	 _memmove
  0005a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 500  : 		*(string->chars + size) = '\0';	    /* Terminate, these strings are usually used for Token streams and printing etc.	*/

  0005d	8b 55 fc	 mov	 edx, DWORD PTR _string$[ebp]
  00060	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00063	8b 4d 10	 mov	 ecx, DWORD PTR _size$[ebp]
  00066	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0

; 501  : 		string->len = size;

  0006a	8b 55 fc	 mov	 edx, DWORD PTR _string$[ebp]
  0006d	8b 45 10	 mov	 eax, DWORD PTR _size$[ebp]
  00070	89 42 08	 mov	 DWORD PTR [edx+8], eax
$LN4@newPtr8:

; 502  : 	}
; 503  : 
; 504  : 	return  string;

  00073	8b 45 fc	 mov	 eax, DWORD PTR _string$[ebp]
$LN1@newPtr8:

; 505  : }

  00076	5e		 pop	 esi
  00077	83 c4 04	 add	 esp, 4
  0007a	3b ec		 cmp	 ebp, esp
  0007c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c3		 ret	 0
_newPtr8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3string.c
;	COMDAT _newSizeUTF16
_TEXT	SEGMENT
_string$ = -4						; size = 4
_factory$ = 8						; size = 4
_size$ = 12						; size = 4
_newSizeUTF16 PROC					; COMDAT

; 452  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 453  :     pANTLR3_STRING  string;
; 454  : 
; 455  :     string  = factory->newRaw(factory);

  0000c	8b f4		 mov	 esi, esp
  0000e	8b 45 08	 mov	 eax, DWORD PTR _factory$[ebp]
  00011	50		 push	 eax
  00012	8b 4d 08	 mov	 ecx, DWORD PTR _factory$[ebp]
  00015	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00018	ff d2		 call	 edx
  0001a	83 c4 04	 add	 esp, 4
  0001d	3b f4		 cmp	 esi, esp
  0001f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00024	89 45 fc	 mov	 DWORD PTR _string$[ebp], eax

; 456  : 
; 457  :     if	(string == NULL)

  00027	83 7d fc 00	 cmp	 DWORD PTR _string$[ebp], 0
  0002b	75 05		 jne	 SHORT $LN2@newSizeUTF

; 458  :     {
; 459  :         return	string;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _string$[ebp]
  00030	eb 41		 jmp	 SHORT $LN1@newSizeUTF
$LN2@newSizeUTF:

; 460  :     }
; 461  : 
; 462  :     /* Always add one more byte for a terminator ;-)
; 463  :     */	
; 464  :     string->chars	= (pANTLR3_UINT8) ANTLR3_MALLOC((size_t)(sizeof(ANTLR3_UINT16) * (size+1)));

  00032	8b 45 0c	 mov	 eax, DWORD PTR _size$[ebp]
  00035	8d 4c 00 02	 lea	 ecx, DWORD PTR [eax+eax+2]
  00039	8b f4		 mov	 esi, esp
  0003b	51		 push	 ecx
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00042	83 c4 04	 add	 esp, 4
  00045	3b f4		 cmp	 esi, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	8b 55 fc	 mov	 edx, DWORD PTR _string$[ebp]
  0004f	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 465  :     if (string->chars != NULL)

  00052	8b 45 fc	 mov	 eax, DWORD PTR _string$[ebp]
  00055	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00059	74 15		 je	 SHORT $LN3@newSizeUTF

; 466  : 	{
; 467  : 		*(string->chars)	= '\0';

  0005b	8b 4d fc	 mov	 ecx, DWORD PTR _string$[ebp]
  0005e	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00061	c6 02 00	 mov	 BYTE PTR [edx], 0

; 468  : 		string->size	= size+1;	/* Size is always in characters, as is len */

  00064	8b 45 0c	 mov	 eax, DWORD PTR _size$[ebp]
  00067	83 c0 01	 add	 eax, 1
  0006a	8b 4d fc	 mov	 ecx, DWORD PTR _string$[ebp]
  0006d	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
$LN3@newSizeUTF:

; 469  : 	}
; 470  : 
; 471  :     return string;

  00070	8b 45 fc	 mov	 eax, DWORD PTR _string$[ebp]
$LN1@newSizeUTF:

; 472  : }

  00073	5e		 pop	 esi
  00074	83 c4 04	 add	 esp, 4
  00077	3b ec		 cmp	 ebp, esp
  00079	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c3		 ret	 0
_newSizeUTF16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3string.c
;	COMDAT _newSize8
_TEXT	SEGMENT
_string$ = -4						; size = 4
_factory$ = 8						; size = 4
_size$ = 12						; size = 4
_newSize8 PROC						; COMDAT

; 422  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 423  :     pANTLR3_STRING  string;
; 424  : 
; 425  :     string  = factory->newRaw(factory);

  0000c	8b f4		 mov	 esi, esp
  0000e	8b 45 08	 mov	 eax, DWORD PTR _factory$[ebp]
  00011	50		 push	 eax
  00012	8b 4d 08	 mov	 ecx, DWORD PTR _factory$[ebp]
  00015	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00018	ff d2		 call	 edx
  0001a	83 c4 04	 add	 esp, 4
  0001d	3b f4		 cmp	 esi, esp
  0001f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00024	89 45 fc	 mov	 DWORD PTR _string$[ebp], eax

; 426  : 
; 427  :     if	(string == NULL)

  00027	83 7d fc 00	 cmp	 DWORD PTR _string$[ebp], 0
  0002b	75 05		 jne	 SHORT $LN2@newSize8

; 428  :     {
; 429  :         return	string;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _string$[ebp]
  00030	eb 40		 jmp	 SHORT $LN1@newSize8
$LN2@newSize8:

; 430  :     }
; 431  : 
; 432  :     /* Always add one more byte for a terminator ;-)
; 433  :     */
; 434  :     string->chars	= (pANTLR3_UINT8) ANTLR3_MALLOC((size_t)(sizeof(ANTLR3_UINT8) * (size+1)));

  00032	8b 45 0c	 mov	 eax, DWORD PTR _size$[ebp]
  00035	83 c0 01	 add	 eax, 1
  00038	8b f4		 mov	 esi, esp
  0003a	50		 push	 eax
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00041	83 c4 04	 add	 esp, 4
  00044	3b f4		 cmp	 esi, esp
  00046	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004b	8b 4d fc	 mov	 ecx, DWORD PTR _string$[ebp]
  0004e	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 435  : 	if (string->chars != NULL)

  00051	8b 55 fc	 mov	 edx, DWORD PTR _string$[ebp]
  00054	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  00058	74 15		 je	 SHORT $LN3@newSize8

; 436  :     {
; 437  : 		*(string->chars)	= '\0';

  0005a	8b 45 fc	 mov	 eax, DWORD PTR _string$[ebp]
  0005d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00060	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 438  : 		string->size	= size + 1;

  00063	8b 55 0c	 mov	 edx, DWORD PTR _size$[ebp]
  00066	83 c2 01	 add	 edx, 1
  00069	8b 45 fc	 mov	 eax, DWORD PTR _string$[ebp]
  0006c	89 50 0c	 mov	 DWORD PTR [eax+12], edx
$LN3@newSize8:

; 439  : 	}
; 440  : 
; 441  :     return string;

  0006f	8b 45 fc	 mov	 eax, DWORD PTR _string$[ebp]
$LN1@newSize8:

; 442  : }

  00072	5e		 pop	 esi
  00073	83 c4 04	 add	 esp, 4
  00076	3b ec		 cmp	 ebp, esp
  00078	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007d	8b e5		 mov	 esp, ebp
  0007f	5d		 pop	 ebp
  00080	c3		 ret	 0
_newSize8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3string.c
;	COMDAT _newRawUTF16
_TEXT	SEGMENT
_string$ = -4						; size = 4
_factory$ = 8						; size = 4
_newRawUTF16 PROC					; COMDAT

; 216  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 217  :     pANTLR3_STRING  string;
; 218  : 
; 219  :     string  = (pANTLR3_STRING) ANTLR3_MALLOC(sizeof(ANTLR3_STRING));

  0000c	8b f4		 mov	 esi, esp
  0000e	6a 68		 push	 104			; 00000068H
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00016	83 c4 04	 add	 esp, 4
  00019	3b f4		 cmp	 esi, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	89 45 fc	 mov	 DWORD PTR _string$[ebp], eax

; 220  : 
; 221  :     if	(string == NULL)

  00023	83 7d fc 00	 cmp	 DWORD PTR _string$[ebp], 0
  00027	75 04		 jne	 SHORT $LN2@newRawUTF1

; 222  :     {
; 223  : 		return	NULL;

  00029	33 c0		 xor	 eax, eax
  0002b	eb 63		 jmp	 SHORT $LN1@newRawUTF1
$LN2@newRawUTF1:

; 224  :     }
; 225  : 
; 226  :     /* Structure is allocated, now fill in the API etc.
; 227  :      */
; 228  :     stringInitUTF16(string);

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _string$[ebp]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 _stringInitUTF16
  00036	83 c4 04	 add	 esp, 4

; 229  :     string->factory = factory;

  00039	8b 4d fc	 mov	 ecx, DWORD PTR _string$[ebp]
  0003c	8b 55 08	 mov	 edx, DWORD PTR _factory$[ebp]
  0003f	89 11		 mov	 DWORD PTR [ecx], edx

; 230  : 
; 231  :     /* Add the string into the allocated list
; 232  :      */
; 233  :     factory->strings->set(factory->strings, factory->index, (void *) string, (void (ANTLR3_CDECL *)(void *))(stringFree), ANTLR3_TRUE);

  00041	8b f4		 mov	 esi, esp
  00043	6a 01		 push	 1
  00045	68 00 00 00 00	 push	 OFFSET _stringFree
  0004a	8b 45 fc	 mov	 eax, DWORD PTR _string$[ebp]
  0004d	50		 push	 eax
  0004e	8b 4d 08	 mov	 ecx, DWORD PTR _factory$[ebp]
  00051	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00054	52		 push	 edx
  00055	8b 45 08	 mov	 eax, DWORD PTR _factory$[ebp]
  00058	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005a	51		 push	 ecx
  0005b	8b 55 08	 mov	 edx, DWORD PTR _factory$[ebp]
  0005e	8b 02		 mov	 eax, DWORD PTR [edx]
  00060	8b 88 ac 00 00
	00		 mov	 ecx, DWORD PTR [eax+172]
  00066	ff d1		 call	 ecx
  00068	83 c4 14	 add	 esp, 20			; 00000014H
  0006b	3b f4		 cmp	 esi, esp
  0006d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 234  :     string->index   = factory->index++;

  00072	8b 55 fc	 mov	 edx, DWORD PTR _string$[ebp]
  00075	8b 45 08	 mov	 eax, DWORD PTR _factory$[ebp]
  00078	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0007b	89 4a 10	 mov	 DWORD PTR [edx+16], ecx
  0007e	8b 55 08	 mov	 edx, DWORD PTR _factory$[ebp]
  00081	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00084	83 c0 01	 add	 eax, 1
  00087	8b 4d 08	 mov	 ecx, DWORD PTR _factory$[ebp]
  0008a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 235  : 
; 236  :     return string;

  0008d	8b 45 fc	 mov	 eax, DWORD PTR _string$[ebp]
$LN1@newRawUTF1:

; 237  : }

  00090	5e		 pop	 esi
  00091	83 c4 04	 add	 esp, 4
  00094	3b ec		 cmp	 ebp, esp
  00096	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c3		 ret	 0
_newRawUTF16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3string.c
;	COMDAT _newRaw8
_TEXT	SEGMENT
_string$ = -4						; size = 4
_factory$ = 8						; size = 4
_newRaw8 PROC						; COMDAT

; 187  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 188  :     pANTLR3_STRING  string;
; 189  : 
; 190  :     string  = (pANTLR3_STRING) ANTLR3_MALLOC(sizeof(ANTLR3_STRING));

  0000c	8b f4		 mov	 esi, esp
  0000e	6a 68		 push	 104			; 00000068H
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00016	83 c4 04	 add	 esp, 4
  00019	3b f4		 cmp	 esi, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	89 45 fc	 mov	 DWORD PTR _string$[ebp], eax

; 191  : 
; 192  :     if	(string == NULL)

  00023	83 7d fc 00	 cmp	 DWORD PTR _string$[ebp], 0
  00027	75 04		 jne	 SHORT $LN2@newRaw8

; 193  :     {
; 194  : 		return	NULL;

  00029	33 c0		 xor	 eax, eax
  0002b	eb 63		 jmp	 SHORT $LN1@newRaw8
$LN2@newRaw8:

; 195  :     }
; 196  : 
; 197  :     /* Structure is allocated, now fill in the API etc.
; 198  :      */
; 199  :     stringInit8(string);

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _string$[ebp]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 _stringInit8
  00036	83 c4 04	 add	 esp, 4

; 200  :     string->factory = factory;

  00039	8b 4d fc	 mov	 ecx, DWORD PTR _string$[ebp]
  0003c	8b 55 08	 mov	 edx, DWORD PTR _factory$[ebp]
  0003f	89 11		 mov	 DWORD PTR [ecx], edx

; 201  : 
; 202  :     /* Add the string into the allocated list
; 203  :      */
; 204  :     factory->strings->set(factory->strings, factory->index, (void *) string, (void (ANTLR3_CDECL *)(void *))(stringFree), ANTLR3_TRUE);

  00041	8b f4		 mov	 esi, esp
  00043	6a 01		 push	 1
  00045	68 00 00 00 00	 push	 OFFSET _stringFree
  0004a	8b 45 fc	 mov	 eax, DWORD PTR _string$[ebp]
  0004d	50		 push	 eax
  0004e	8b 4d 08	 mov	 ecx, DWORD PTR _factory$[ebp]
  00051	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00054	52		 push	 edx
  00055	8b 45 08	 mov	 eax, DWORD PTR _factory$[ebp]
  00058	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005a	51		 push	 ecx
  0005b	8b 55 08	 mov	 edx, DWORD PTR _factory$[ebp]
  0005e	8b 02		 mov	 eax, DWORD PTR [edx]
  00060	8b 88 ac 00 00
	00		 mov	 ecx, DWORD PTR [eax+172]
  00066	ff d1		 call	 ecx
  00068	83 c4 14	 add	 esp, 20			; 00000014H
  0006b	3b f4		 cmp	 esi, esp
  0006d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 205  :     string->index   = factory->index++;

  00072	8b 55 fc	 mov	 edx, DWORD PTR _string$[ebp]
  00075	8b 45 08	 mov	 eax, DWORD PTR _factory$[ebp]
  00078	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0007b	89 4a 10	 mov	 DWORD PTR [edx+16], ecx
  0007e	8b 55 08	 mov	 edx, DWORD PTR _factory$[ebp]
  00081	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00084	83 c0 01	 add	 eax, 1
  00087	8b 4d 08	 mov	 ecx, DWORD PTR _factory$[ebp]
  0008a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 206  : 
; 207  :     return string;

  0008d	8b 45 fc	 mov	 eax, DWORD PTR _string$[ebp]
$LN1@newRaw8:

; 208  : }

  00090	5e		 pop	 esi
  00091	83 c4 04	 add	 esp, 4
  00094	3b ec		 cmp	 ebp, esp
  00096	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c3		 ret	 0
_newRaw8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3string.c
;	COMDAT _antlr3StringFactoryNew
_TEXT	SEGMENT
tv78 = -8						; size = 4
_factory$ = -4						; size = 4
_encoding$ = 8						; size = 4
_antlr3StringFactoryNew PROC				; COMDAT

; 99   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 100  : 	pANTLR3_STRING_FACTORY  factory;
; 101  : 
; 102  : 	/* Allocate memory
; 103  : 	*/
; 104  : 	factory	= (pANTLR3_STRING_FACTORY) ANTLR3_CALLOC(1, sizeof(ANTLR3_STRING_FACTORY));

  00015	8b f4		 mov	 esi, esp
  00017	6a 2c		 push	 44			; 0000002cH
  00019	6a 01		 push	 1
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__calloc
  00021	83 c4 08	 add	 esp, 8
  00024	3b f4		 cmp	 esi, esp
  00026	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002b	89 45 fc	 mov	 DWORD PTR _factory$[ebp], eax

; 105  : 
; 106  : 	if	(factory == NULL)

  0002e	83 7d fc 00	 cmp	 DWORD PTR _factory$[ebp], 0
  00032	75 07		 jne	 SHORT $LN4@antlr3Stri

; 107  : 	{
; 108  : 		return	NULL;

  00034	33 c0		 xor	 eax, eax
  00036	e9 2c 01 00 00	 jmp	 $LN1@antlr3Stri
$LN4@antlr3Stri:

; 109  : 	}
; 110  : 
; 111  : 	/* Now we make a new list to track the strings.
; 112  : 	*/
; 113  : 	factory->strings	= antlr3VectorNew(0);

  0003b	6a 00		 push	 0
  0003d	e8 00 00 00 00	 call	 _antlr3VectorNew
  00042	83 c4 04	 add	 esp, 4
  00045	8b 4d fc	 mov	 ecx, DWORD PTR _factory$[ebp]
  00048	89 01		 mov	 DWORD PTR [ecx], eax

; 114  : 	factory->index	= 0;

  0004a	8b 55 fc	 mov	 edx, DWORD PTR _factory$[ebp]
  0004d	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 115  : 
; 116  : 	if	(factory->strings == NULL)

  00054	8b 45 fc	 mov	 eax, DWORD PTR _factory$[ebp]
  00057	83 38 00	 cmp	 DWORD PTR [eax], 0
  0005a	75 1d		 jne	 SHORT $LN5@antlr3Stri

; 117  : 	{
; 118  : 		ANTLR3_FREE(factory);

  0005c	8b f4		 mov	 esi, esp
  0005e	8b 4d fc	 mov	 ecx, DWORD PTR _factory$[ebp]
  00061	51		 push	 ecx
  00062	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00068	83 c4 04	 add	 esp, 4
  0006b	3b f4		 cmp	 esi, esp
  0006d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 119  : 		return	NULL;

  00072	33 c0		 xor	 eax, eax
  00074	e9 ee 00 00 00	 jmp	 $LN1@antlr3Stri
$LN5@antlr3Stri:

; 120  : 	}
; 121  : 
; 122  :     // Install the API
; 123  :     //
; 124  :     // TODO: These encodings need equivalent functions to
; 125  :     // UTF16 and 8Bit if I am going to support those encodings in the STRING stuff.
; 126  : 	// The STRING stuff was intended as a quick and dirty hack for people that did not
; 127  : 	// want to worry about memory and performance very much, but nobody ever reads the 
; 128  : 	// notes or comments or uses the email list search. I want to discourage using these
; 129  : 	// interfaces as it is much more efficient to use the pointers within the tokens
; 130  : 	// directly, so I am not implementing the string stuff for the newer encodings.
; 131  :     // We install the standard 8 and 16 bit functions for the UTF 8 and 16 but they
; 132  : 	// will not be useful beyond returning the text.
; 133  : 	// 
; 134  :     switch(encoding)

  00079	8b 55 08	 mov	 edx, DWORD PTR _encoding$[ebp]
  0007c	89 55 f8	 mov	 DWORD PTR tv78[ebp], edx
  0007f	8b 45 f8	 mov	 eax, DWORD PTR tv78[ebp]
  00082	83 e8 04	 sub	 eax, 4
  00085	89 45 f8	 mov	 DWORD PTR tv78[ebp], eax
  00088	83 7d f8 3c	 cmp	 DWORD PTR tv78[ebp], 60	; 0000003cH
  0008c	77 7c		 ja	 SHORT $LN12@antlr3Stri
  0008e	8b 4d f8	 mov	 ecx, DWORD PTR tv78[ebp]
  00091	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR $LN17@antlr3Stri[ecx]
  00098	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN18@antlr3Stri[edx*4]
$LN6@antlr3Stri:

; 135  :     {
; 136  : 		case    ANTLR3_ENC_UTF32:
; 137  : 			break;

  0009f	e9 c0 00 00 00	 jmp	 $LN2@antlr3Stri
$LN7@antlr3Stri:

; 138  : 
; 139  : 		case    ANTLR3_ENC_UTF32BE:
; 140  : 			break;

  000a4	e9 bb 00 00 00	 jmp	 $LN2@antlr3Stri
$LN8@antlr3Stri:

; 141  : 
; 142  : 		case    ANTLR3_ENC_UTF32LE:
; 143  : 			break;

  000a9	e9 b6 00 00 00	 jmp	 $LN2@antlr3Stri
$LN9@antlr3Stri:

; 144  : 
; 145  : 		case    ANTLR3_ENC_UTF16BE:
; 146  : 		case    ANTLR3_ENC_UTF16LE:
; 147  : 		case    ANTLR3_ENC_UTF16:
; 148  : 
; 149  : 			factory->newRaw	    =  newRawUTF16;

  000ae	8b 45 fc	 mov	 eax, DWORD PTR _factory$[ebp]
  000b1	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], OFFSET _newRawUTF16

; 150  : 			factory->newSize	=  newSizeUTF16;

  000b8	8b 4d fc	 mov	 ecx, DWORD PTR _factory$[ebp]
  000bb	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], OFFSET _newSizeUTF16

; 151  : 			factory->newPtr	    =  newPtrUTF16_UTF16;

  000c2	8b 55 fc	 mov	 edx, DWORD PTR _factory$[ebp]
  000c5	c7 42 10 00 00
	00 00		 mov	 DWORD PTR [edx+16], OFFSET _newPtrUTF16_UTF16

; 152  : 			factory->newPtr8	=  newPtrUTF16_8;

  000cc	8b 45 fc	 mov	 eax, DWORD PTR _factory$[ebp]
  000cf	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], OFFSET _newPtrUTF16_8

; 153  : 			factory->newStr	    =  newStrUTF16_UTF16;

  000d6	8b 4d fc	 mov	 ecx, DWORD PTR _factory$[ebp]
  000d9	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET _newStrUTF16_UTF16

; 154  : 			factory->newStr8	=  newStrUTF16_8;

  000e0	8b 55 fc	 mov	 edx, DWORD PTR _factory$[ebp]
  000e3	c7 42 1c 00 00
	00 00		 mov	 DWORD PTR [edx+28], OFFSET _newStrUTF16_8

; 155  : 			factory->printable	=  printableUTF16;

  000ea	8b 45 fc	 mov	 eax, DWORD PTR _factory$[ebp]
  000ed	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], OFFSET _printableUTF16

; 156  : 			factory->destroy	=  destroy;

  000f4	8b 4d fc	 mov	 ecx, DWORD PTR _factory$[ebp]
  000f7	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], OFFSET _destroy

; 157  : 			factory->close	    =  closeFactory;

  000fe	8b 55 fc	 mov	 edx, DWORD PTR _factory$[ebp]
  00101	c7 42 28 00 00
	00 00		 mov	 DWORD PTR [edx+40], OFFSET _closeFactory

; 158  : 			break;

  00108	eb 5a		 jmp	 SHORT $LN2@antlr3Stri
$LN12@antlr3Stri:

; 159  : 	 
; 160  : 		case    ANTLR3_ENC_UTF8:
; 161  : 		case    ANTLR3_ENC_EBCDIC:
; 162  : 		case    ANTLR3_ENC_8BIT:
; 163  : 		default:
; 164  : 
; 165  : 			factory->newRaw	    =  newRaw8;

  0010a	8b 45 fc	 mov	 eax, DWORD PTR _factory$[ebp]
  0010d	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], OFFSET _newRaw8

; 166  : 			factory->newSize	=  newSize8;

  00114	8b 4d fc	 mov	 ecx, DWORD PTR _factory$[ebp]
  00117	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], OFFSET _newSize8

; 167  : 			factory->newPtr	    =  newPtr8;

  0011e	8b 55 fc	 mov	 edx, DWORD PTR _factory$[ebp]
  00121	c7 42 10 00 00
	00 00		 mov	 DWORD PTR [edx+16], OFFSET _newPtr8

; 168  : 			factory->newPtr8	=  newPtr8;

  00128	8b 45 fc	 mov	 eax, DWORD PTR _factory$[ebp]
  0012b	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], OFFSET _newPtr8

; 169  : 			factory->newStr	    =  newStr8;

  00132	8b 4d fc	 mov	 ecx, DWORD PTR _factory$[ebp]
  00135	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET _newStr8

; 170  : 			factory->newStr8	=  newStr8;

  0013c	8b 55 fc	 mov	 edx, DWORD PTR _factory$[ebp]
  0013f	c7 42 1c 00 00
	00 00		 mov	 DWORD PTR [edx+28], OFFSET _newStr8

; 171  : 			factory->printable	=  printable8;

  00146	8b 45 fc	 mov	 eax, DWORD PTR _factory$[ebp]
  00149	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], OFFSET _printable8

; 172  : 			factory->destroy	=  destroy;

  00150	8b 4d fc	 mov	 ecx, DWORD PTR _factory$[ebp]
  00153	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], OFFSET _destroy

; 173  : 			factory->close	    =  closeFactory;

  0015a	8b 55 fc	 mov	 edx, DWORD PTR _factory$[ebp]
  0015d	c7 42 28 00 00
	00 00		 mov	 DWORD PTR [edx+40], OFFSET _closeFactory
$LN2@antlr3Stri:

; 174  : 			break;
; 175  :     }
; 176  : 	return  factory;

  00164	8b 45 fc	 mov	 eax, DWORD PTR _factory$[ebp]
$LN1@antlr3Stri:

; 177  : }

  00167	5e		 pop	 esi
  00168	83 c4 08	 add	 esp, 8
  0016b	3b ec		 cmp	 ebp, esp
  0016d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00172	8b e5		 mov	 esp, ebp
  00174	5d		 pop	 ebp
  00175	c3		 ret	 0
  00176	66 90		 npad	 2
$LN18@antlr3Stri:
  00178	00 00 00 00	 DD	 $LN12@antlr3Stri
  0017c	00 00 00 00	 DD	 $LN9@antlr3Stri
  00180	00 00 00 00	 DD	 $LN6@antlr3Stri
  00184	00 00 00 00	 DD	 $LN7@antlr3Stri
  00188	00 00 00 00	 DD	 $LN8@antlr3Stri
  0018c	00 00 00 00	 DD	 $LN12@antlr3Stri
$LN17@antlr3Stri:
  00190	00		 DB	 0
  00191	05		 DB	 5
  00192	05		 DB	 5
  00193	05		 DB	 5
  00194	00		 DB	 0
  00195	05		 DB	 5
  00196	05		 DB	 5
  00197	05		 DB	 5
  00198	05		 DB	 5
  00199	05		 DB	 5
  0019a	05		 DB	 5
  0019b	05		 DB	 5
  0019c	01		 DB	 1
  0019d	01		 DB	 1
  0019e	01		 DB	 1
  0019f	05		 DB	 5
  001a0	05		 DB	 5
  001a1	05		 DB	 5
  001a2	05		 DB	 5
  001a3	05		 DB	 5
  001a4	05		 DB	 5
  001a5	05		 DB	 5
  001a6	05		 DB	 5
  001a7	05		 DB	 5
  001a8	05		 DB	 5
  001a9	05		 DB	 5
  001aa	05		 DB	 5
  001ab	05		 DB	 5
  001ac	02		 DB	 2
  001ad	03		 DB	 3
  001ae	04		 DB	 4
  001af	05		 DB	 5
  001b0	05		 DB	 5
  001b1	05		 DB	 5
  001b2	05		 DB	 5
  001b3	05		 DB	 5
  001b4	05		 DB	 5
  001b5	05		 DB	 5
  001b6	05		 DB	 5
  001b7	05		 DB	 5
  001b8	05		 DB	 5
  001b9	05		 DB	 5
  001ba	05		 DB	 5
  001bb	05		 DB	 5
  001bc	05		 DB	 5
  001bd	05		 DB	 5
  001be	05		 DB	 5
  001bf	05		 DB	 5
  001c0	05		 DB	 5
  001c1	05		 DB	 5
  001c2	05		 DB	 5
  001c3	05		 DB	 5
  001c4	05		 DB	 5
  001c5	05		 DB	 5
  001c6	05		 DB	 5
  001c7	05		 DB	 5
  001c8	05		 DB	 5
  001c9	05		 DB	 5
  001ca	05		 DB	 5
  001cb	05		 DB	 5
  001cc	00		 DB	 0
_antlr3StringFactoryNew ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1771 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 1772 :         int _Result;
; 1773 :         va_list _ArgList;
; 1774 :         __crt_va_start(_ArgList, _Format);

  00014	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00017	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1775 : 
; 1776 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  0001a	8b 4d f8	 mov	 ecx, DWORD PTR __ArgList$[ebp]
  0001d	51		 push	 ecx
  0001e	6a 00		 push	 0
  00020	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00023	52		 push	 edx
  00024	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 __vsprintf_l
  0002d	83 c4 10	 add	 esp, 16			; 00000010H
  00030	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1777 : 
; 1778 :         __crt_va_end(_ArgList);

  00033	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 1779 :         return _Result;

  0003a	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 1780 :     }

  0003d	83 c4 08	 add	 esp, 8
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1458 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1459 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00003	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  0000e	52		 push	 edx
  0000f	6a ff		 push	 -1
  00011	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 __vsnprintf_l
  0001a	83 c4 14	 add	 esp, 20			; 00000014H

; 1460 :     }

  0001d	3b ec		 cmp	 ebp, esp
  0001f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1391 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 1392 :         int const _Result = __stdio_common_vsprintf(

  00015	8b f4		 mov	 esi, esp
  00017	8b 45 18	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0001a	50		 push	 eax
  0001b	8b 4d 14	 mov	 ecx, DWORD PTR __Locale$[ebp]
  0001e	51		 push	 ecx
  0001f	8b 55 10	 mov	 edx, DWORD PTR __Format$[ebp]
  00022	52		 push	 edx
  00023	8b 45 0c	 mov	 eax, DWORD PTR __BufferCount$[ebp]
  00026	50		 push	 eax
  00027	8b 4d 08	 mov	 ecx, DWORD PTR __Buffer$[ebp]
  0002a	51		 push	 ecx
  0002b	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00030	8b 10		 mov	 edx, DWORD PTR [eax]
  00032	83 ca 01	 or	 edx, 1
  00035	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00038	50		 push	 eax
  00039	52		 push	 edx
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsprintf
  00040	83 c4 1c	 add	 esp, 28			; 0000001cH
  00043	3b f4		 cmp	 esi, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

  0004d	83 7d fc 00	 cmp	 DWORD PTR __Result$[ebp], 0
  00051	7d 09		 jge	 SHORT $LN3@vsnprintf_
  00053	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR tv74[ebp], -1
  0005a	eb 06		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  0005c	8b 4d fc	 mov	 ecx, DWORD PTR __Result$[ebp]
  0005f	89 4d f8	 mov	 DWORD PTR tv74[ebp], ecx
$LN4@vsnprintf_:
  00062	8b 45 f8	 mov	 eax, DWORD PTR tv74[ebp]

; 1397 :     }

  00065	5e		 pop	 esi
  00066	83 c4 08	 add	 esp, 8
  00069	3b ec		 cmp	 ebp, esp
  0006b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 90   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00003	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
