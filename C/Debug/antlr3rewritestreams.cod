; Listing generated by Microsoft (R) Optimizing Compiler Version 19.42.34436.0 

	TITLE	C:\SPO_labs\C\Debug\antlr3rewritestreams.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	___local_stdio_printf_options
PUBLIC	__vfprintf_l
PUBLIC	_fprintf
PUBLIC	_antlr3RewriteRuleTOKENStreamNewAE
PUBLIC	_antlr3RewriteRuleTOKENStreamNewAEE
PUBLIC	_antlr3RewriteRuleTOKENStreamNewAEV
PUBLIC	_antlr3RewriteRuleNODEStreamNewAE
PUBLIC	_antlr3RewriteRuleNODEStreamNewAEE
PUBLIC	_antlr3RewriteRuleNODEStreamNewAEV
PUBLIC	_antlr3RewriteRuleSubtreeStreamNewAE
PUBLIC	_antlr3RewriteRuleSubtreeStreamNewAEE
PUBLIC	_antlr3RewriteRuleSubtreeStreamNewAEV
PUBLIC	??_C@_0DD@LIOGJBJJ@dup?$CI?$CJ?5cannot?5be?5called?5on?5a?5tok@ ; `string'
PUBLIC	??_C@_0DD@CBGJDPN@dup?$CI?$CJ?5cannot?5be?5called?5on?5a?5nod@ ; `string'
PUBLIC	??_C@_0BB@MGOOFBLH@?$DMunknown?5source?$DO@	; `string'
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0BB@MGOOFBLH@?$DMunknown?5source?$DO@
CONST	SEGMENT
??_C@_0BB@MGOOFBLH@?$DMunknown?5source?$DO@ DB '<unknown source>', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@CBGJDPN@dup?$CI?$CJ?5cannot?5be?5called?5on?5a?5nod@
CONST	SEGMENT
??_C@_0DD@CBGJDPN@dup?$CI?$CJ?5cannot?5be?5called?5on?5a?5nod@ DB 'dup() '
	DB	'cannot be called on a node rewrite stream!!!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@LIOGJBJJ@dup?$CI?$CJ?5cannot?5be?5called?5on?5a?5tok@
CONST	SEGMENT
??_C@_0DD@LIOGJBJJ@dup?$CI?$CJ?5cannot?5be?5called?5on?5a?5tok@ DB 'dup()'
	DB	' cannot be called on a token rewrite stream!!', 00H ; `string'
CONST	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3rewritestreams.c
;	COMDAT _antlr3RewriteRuleElementStreamNewAEV
_TEXT	SEGMENT
_stream$ = -4						; size = 4
_adaptor$ = 8						; size = 4
_rec$ = 12						; size = 4
_description$ = 16					; size = 4
_vector$ = 20						; size = 4
_antlr3RewriteRuleElementStreamNewAEV PROC		; COMDAT

; 281  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 282  : 	pANTLR3_REWRITE_RULE_ELEMENT_STREAM	stream;
; 283  : 
; 284  : 	// First job is to create the memory we need.
; 285  : 	//
; 286  : 	stream	= antlr3RewriteRuleElementStreamNewAE(adaptor, rec, description);

  0000c	8b 45 10	 mov	 eax, DWORD PTR _description$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR _rec$[ebp]
  00013	51		 push	 ecx
  00014	8b 55 08	 mov	 edx, DWORD PTR _adaptor$[ebp]
  00017	52		 push	 edx
  00018	e8 00 00 00 00	 call	 _antlr3RewriteRuleElementStreamNewAE
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00020	89 45 fc	 mov	 DWORD PTR _stream$[ebp], eax

; 287  : 
; 288  : 	if (stream == NULL)

  00023	83 7d fc 00	 cmp	 DWORD PTR _stream$[ebp], 0
  00027	75 05		 jne	 SHORT $LN2@antlr3Rewr

; 289  : 	{
; 290  : 		return stream;

  00029	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  0002c	eb 5b		 jmp	 SHORT $LN1@antlr3Rewr
$LN2@antlr3Rewr:

; 291  : 	}
; 292  : 
; 293  : 	// Stream seems good so we need to install the vector we were
; 294  : 	// given. We assume that someone else is going to free the
; 295  : 	// vector.
; 296  : 	//
; 297  : 	if	(stream->elements != NULL && stream->elements->factoryMade == ANTLR3_FALSE && stream->freeElements == ANTLR3_TRUE )

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  00031	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00035	74 3f		 je	 SHORT $LN3@antlr3Rewr
  00037	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  0003a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0003d	0f b6 82 88 00
	00 00		 movzx	 eax, BYTE PTR [edx+136]
  00044	85 c0		 test	 eax, eax
  00046	75 2e		 jne	 SHORT $LN3@antlr3Rewr
  00048	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  0004b	0f b6 51 0c	 movzx	 edx, BYTE PTR [ecx+12]
  0004f	83 fa 01	 cmp	 edx, 1
  00052	75 22		 jne	 SHORT $LN3@antlr3Rewr

; 298  : 	{
; 299  : 		stream->elements->free(stream->elements);

  00054	8b f4		 mov	 esi, esp
  00056	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  00059	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0005c	51		 push	 ecx
  0005d	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  00060	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00063	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  00069	ff d1		 call	 ecx
  0006b	83 c4 04	 add	 esp, 4
  0006e	3b f4		 cmp	 esi, esp
  00070	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00075	90		 npad	 1
$LN3@antlr3Rewr:

; 300  : 	}
; 301  : 	stream->elements		= vector;

  00076	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  00079	8b 45 14	 mov	 eax, DWORD PTR _vector$[ebp]
  0007c	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 302  : 	stream->freeElements	= ANTLR3_FALSE;

  0007f	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  00082	c6 41 0c 00	 mov	 BYTE PTR [ecx+12], 0

; 303  : 	return stream;

  00086	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
$LN1@antlr3Rewr:

; 304  : }

  00089	5e		 pop	 esi
  0008a	83 c4 04	 add	 esp, 4
  0008d	3b ec		 cmp	 ebp, esp
  0008f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c3		 ret	 0
_antlr3RewriteRuleElementStreamNewAEV ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3rewritestreams.c
;	COMDAT _antlr3RewriteRuleElementStreamNewAEE
_TEXT	SEGMENT
_stream$ = -4						; size = 4
_adaptor$ = 8						; size = 4
_rec$ = 12						; size = 4
_description$ = 16					; size = 4
_oneElement$ = 20					; size = 4
_antlr3RewriteRuleElementStreamNewAEE PROC		; COMDAT

; 258  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 259  : 	pANTLR3_REWRITE_RULE_ELEMENT_STREAM	stream;
; 260  : 
; 261  : 	// First job is to create the memory we need.
; 262  : 	//
; 263  : 	stream	= antlr3RewriteRuleElementStreamNewAE(adaptor, rec, description);

  0000c	8b 45 10	 mov	 eax, DWORD PTR _description$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR _rec$[ebp]
  00013	51		 push	 ecx
  00014	8b 55 08	 mov	 edx, DWORD PTR _adaptor$[ebp]
  00017	52		 push	 edx
  00018	e8 00 00 00 00	 call	 _antlr3RewriteRuleElementStreamNewAE
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00020	89 45 fc	 mov	 DWORD PTR _stream$[ebp], eax

; 264  : 
; 265  : 	if (stream == NULL)

  00023	83 7d fc 00	 cmp	 DWORD PTR _stream$[ebp], 0
  00027	75 04		 jne	 SHORT $LN2@antlr3Rewr

; 266  : 	{
; 267  : 		return NULL;

  00029	33 c0		 xor	 eax, eax
  0002b	eb 28		 jmp	 SHORT $LN1@antlr3Rewr
$LN2@antlr3Rewr:

; 268  : 	}
; 269  : 
; 270  : 	// Stream seems good so we need to add the supplied element
; 271  : 	//
; 272  : 	if	(oneElement != NULL)

  0002d	83 7d 14 00	 cmp	 DWORD PTR _oneElement$[ebp], 0
  00031	74 1f		 je	 SHORT $LN3@antlr3Rewr

; 273  : 	{
; 274  : 		stream->add(stream, oneElement, NULL);

  00033	8b f4		 mov	 esi, esp
  00035	6a 00		 push	 0
  00037	8b 45 14	 mov	 eax, DWORD PTR _oneElement$[ebp]
  0003a	50		 push	 eax
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  0003e	51		 push	 ecx
  0003f	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  00042	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00045	ff d0		 call	 eax
  00047	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004a	3b f4		 cmp	 esi, esp
  0004c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00051	90		 npad	 1
$LN3@antlr3Rewr:

; 275  : 	}
; 276  : 	return stream;

  00052	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
$LN1@antlr3Rewr:

; 277  : }

  00055	5e		 pop	 esi
  00056	83 c4 04	 add	 esp, 4
  00059	3b ec		 cmp	 ebp, esp
  0005b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
_antlr3RewriteRuleElementStreamNewAEE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3rewritestreams.c
;	COMDAT _antlr3RewriteRuleElementStreamNewAE
_TEXT	SEGMENT
_stream$ = -4						; size = 4
_adaptor$ = 8						; size = 4
_rec$ = 12						; size = 4
_description$ = 16					; size = 4
_antlr3RewriteRuleElementStreamNewAE PROC		; COMDAT

; 188  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 189  : 	pANTLR3_REWRITE_RULE_ELEMENT_STREAM	stream;
; 190  : 
; 191  : 	// First - do we already have a rewrite stream that was returned
; 192  : 	// to the pool? If we do, then we will just reuse it by resetting
; 193  : 	// the generic interface.
; 194  : 	//
; 195  : 	if	(rec->state->rStreams->count > 0)

  0000c	8b 45 0c	 mov	 eax, DWORD PTR _rec$[ebp]
  0000f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00012	8b 51 68	 mov	 edx, DWORD PTR [ecx+104]
  00015	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  00019	76 3c		 jbe	 SHORT $LN2@antlr3Rewr

; 196  : 	{
; 197  : 		// Remove the entry from the vector. We do not
; 198  : 		// cause it to be freed by using remove.
; 199  : 		//
; 200  : 		stream = (pANTLR3_REWRITE_RULE_ELEMENT_STREAM)rec->state->rStreams->remove(rec->state->rStreams, rec->state->rStreams->count - 1);

  0001b	8b 45 0c	 mov	 eax, DWORD PTR _rec$[ebp]
  0001e	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00021	8b 51 68	 mov	 edx, DWORD PTR [ecx+104]
  00024	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00027	83 e8 01	 sub	 eax, 1
  0002a	8b f4		 mov	 esi, esp
  0002c	50		 push	 eax
  0002d	8b 4d 0c	 mov	 ecx, DWORD PTR _rec$[ebp]
  00030	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00033	8b 42 68	 mov	 eax, DWORD PTR [edx+104]
  00036	50		 push	 eax
  00037	8b 4d 0c	 mov	 ecx, DWORD PTR _rec$[ebp]
  0003a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0003d	8b 42 68	 mov	 eax, DWORD PTR [edx+104]
  00040	8b 88 9c 00 00
	00		 mov	 ecx, DWORD PTR [eax+156]
  00046	ff d1		 call	 ecx
  00048	83 c4 08	 add	 esp, 8
  0004b	3b f4		 cmp	 esi, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	89 45 fc	 mov	 DWORD PTR _stream$[ebp], eax

; 201  : 
; 202  : 		// We found a stream we can reuse.
; 203  : 		// If the stream had a vector, then it will have been cleared
; 204  : 		// when the freeRS was called that put it in this stack
; 205  : 		//
; 206  : 	}

  00055	eb 35		 jmp	 SHORT $LN3@antlr3Rewr
$LN2@antlr3Rewr:

; 207  : 	else
; 208  : 	{
; 209  : 		// Ok, we need to allocate a new one as there were none on the stack.
; 210  : 		// First job is to create the memory we need.
; 211  : 		//
; 212  : 		stream	= (pANTLR3_REWRITE_RULE_ELEMENT_STREAM) ANTLR3_MALLOC((size_t)(sizeof(ANTLR3_REWRITE_RULE_ELEMENT_STREAM)));

  00057	8b f4		 mov	 esi, esp
  00059	6a 54		 push	 84			; 00000054H
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00061	83 c4 04	 add	 esp, 4
  00064	3b f4		 cmp	 esi, esp
  00066	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006b	89 45 fc	 mov	 DWORD PTR _stream$[ebp], eax

; 213  : 
; 214  : 		if	(stream == NULL)

  0006e	83 7d fc 00	 cmp	 DWORD PTR _stream$[ebp], 0
  00072	75 07		 jne	 SHORT $LN4@antlr3Rewr

; 215  : 		{
; 216  : 			return	NULL;

  00074	33 c0		 xor	 eax, eax
  00076	e9 c1 00 00 00	 jmp	 $LN1@antlr3Rewr
$LN4@antlr3Rewr:

; 217  : 		}
; 218  : 		stream->elements		= NULL;

  0007b	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  0007e	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 219  : 		stream->freeElements	= ANTLR3_FALSE;

  00085	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  00088	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0
$LN3@antlr3Rewr:

; 220  : 	}
; 221  : 
; 222  : 	// Populate the generic interface
; 223  : 	//
; 224  : 	stream->rec				= rec;

  0008c	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  0008f	8b 55 0c	 mov	 edx, DWORD PTR _rec$[ebp]
  00092	89 51 1c	 mov	 DWORD PTR [ecx+28], edx

; 225  : 	stream->reset			= reset;

  00095	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  00098	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], OFFSET _reset

; 226  : 	stream->add				= add;

  0009f	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  000a2	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], OFFSET _add

; 227  : 	stream->next			= next;

  000a9	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  000ac	c7 42 28 00 00
	00 00		 mov	 DWORD PTR [edx+40], OFFSET _next

; 228  : 	stream->nextTree		= nextTree;

  000b3	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  000b6	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], OFFSET _nextTree

; 229  : 	stream->nextNode		= nextNode;

  000bd	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  000c0	c7 41 44 00 00
	00 00		 mov	 DWORD PTR [ecx+68], OFFSET _nextNode

; 230  : 	stream->nextToken		= nextToken;

  000c7	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  000ca	c7 42 30 00 00
	00 00		 mov	 DWORD PTR [edx+48], OFFSET _nextToken

; 231  : 	stream->_next			= _next;

  000d1	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  000d4	c7 40 34 00 00
	00 00		 mov	 DWORD PTR [eax+52], OFFSET __next

; 232  : 	stream->hasNext			= hasNext;

  000db	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  000de	c7 41 40 00 00
	00 00		 mov	 DWORD PTR [ecx+64], OFFSET _hasNext

; 233  : 	stream->size			= size;

  000e5	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  000e8	c7 42 48 00 00
	00 00		 mov	 DWORD PTR [edx+72], OFFSET _size

; 234  : 	stream->getDescription  = getDescription;

  000ef	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  000f2	c7 40 4c 00 00
	00 00		 mov	 DWORD PTR [eax+76], OFFSET _getDescription

; 235  : 	stream->toTree			= toTree;

  000f9	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  000fc	c7 41 3c 00 00
	00 00		 mov	 DWORD PTR [ecx+60], OFFSET _toTree

; 236  : 	stream->free			= freeRS;

  00103	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  00106	c7 42 50 00 00
	00 00		 mov	 DWORD PTR [edx+80], OFFSET _freeRS

; 237  : 	stream->singleElement	= NULL;

  0010d	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  00110	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 238  : 
; 239  : 	// Reset the stream to empty.
; 240  : 	//
; 241  : 
; 242  : 	stream->cursor			= 0;

  00117	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  0011a	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 243  : 	stream->dirty			= ANTLR3_FALSE;

  00120	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  00123	c6 42 18 00	 mov	 BYTE PTR [edx+24], 0

; 244  : 
; 245  : 	// Install the description
; 246  : 	//
; 247  : 	stream->elementDescription	= description;

  00127	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  0012a	8b 4d 10	 mov	 ecx, DWORD PTR _description$[ebp]
  0012d	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 248  : 
; 249  : 	// Install the adaptor
; 250  : 	//
; 251  : 	stream->adaptor		= adaptor;

  00130	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  00133	8b 45 08	 mov	 eax, DWORD PTR _adaptor$[ebp]
  00136	89 42 14	 mov	 DWORD PTR [edx+20], eax

; 252  : 
; 253  : 	return stream;

  00139	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
$LN1@antlr3Rewr:

; 254  : }

  0013c	5e		 pop	 esi
  0013d	83 c4 04	 add	 esp, 4
  00140	3b ec		 cmp	 ebp, esp
  00142	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00147	8b e5		 mov	 esp, ebp
  00149	5d		 pop	 ebp
  0014a	c3		 ret	 0
_antlr3RewriteRuleElementStreamNewAE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3rewritestreams.c
;	COMDAT _freeNodeRS
_TEXT	SEGMENT
_factory$1 = -12					; size = 4
_i$2 = -8						; size = 4
_tree$ = -4						; size = 4
_stream$ = 8						; size = 4
_freeNodeRS PROC					; COMDAT

; 109  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000e	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00015	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 110  :     pANTLR3_BASE_TREE tree;
; 111  : 
; 112  :     // Before placing the stream back in the pool, we
; 113  : 	// need to clear any vector it has. This is so any
; 114  : 	// free pointers that are associated with the
; 115  : 	// entires are called. However, if this particular function is called
; 116  :     // then we know that the entries in the stream are definately
; 117  :     // tree nodes. Hence we check to see if any of them were nilNodes as
; 118  :     // if they were, we can reuse them.
; 119  : 	//
; 120  : 	if	(stream->elements != NULL)

  0001c	8b 45 08	 mov	 eax, DWORD PTR _stream$[ebp]
  0001f	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00023	0f 84 d3 00 00
	00		 je	 $LN5@freeNodeRS

; 121  : 	{
; 122  :         // We have some elements to traverse
; 123  :         //
; 124  :         ANTLR3_UINT32 i;
; 125  : 
; 126  :         for (i = 1; i<= stream->elements->count; i++)

  00029	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _i$2[ebp], 1
  00030	eb 09		 jmp	 SHORT $LN4@freeNodeRS
$LN2@freeNodeRS:
  00032	8b 4d f8	 mov	 ecx, DWORD PTR _i$2[ebp]
  00035	83 c1 01	 add	 ecx, 1
  00038	89 4d f8	 mov	 DWORD PTR _i$2[ebp], ecx
$LN4@freeNodeRS:
  0003b	8b 55 08	 mov	 edx, DWORD PTR _stream$[ebp]
  0003e	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00041	8b 4d f8	 mov	 ecx, DWORD PTR _i$2[ebp]
  00044	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00047	77 32		 ja	 SHORT $LN3@freeNodeRS

; 127  :         {
; 128  :             tree = (pANTLR3_BASE_TREE)(stream->elements->elements[i-1].element);

  00049	8b 55 08	 mov	 edx, DWORD PTR _stream$[ebp]
  0004c	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0004f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00051	8b 55 f8	 mov	 edx, DWORD PTR _i$2[ebp]
  00054	8b 44 d1 f8	 mov	 eax, DWORD PTR [ecx+edx*8-8]
  00058	89 45 fc	 mov	 DWORD PTR _tree$[ebp], eax

; 129  :             if  (tree != NULL && tree->isNilNode(tree))

  0005b	83 7d fc 00	 cmp	 DWORD PTR _tree$[ebp], 0
  0005f	74 18		 je	 SHORT $LN7@freeNodeRS
  00061	8b f4		 mov	 esi, esp
  00063	8b 4d fc	 mov	 ecx, DWORD PTR _tree$[ebp]
  00066	51		 push	 ecx
  00067	8b 55 fc	 mov	 edx, DWORD PTR _tree$[ebp]
  0006a	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  0006d	ff d0		 call	 eax
  0006f	83 c4 04	 add	 esp, 4
  00072	3b f4		 cmp	 esi, esp
  00074	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN7@freeNodeRS:

; 130  :             {
; 131  :                 // Had to remove this for now, check is not comprehensive enough
; 132  :                 // tree->reuse(tree);
; 133  :             }
; 134  : 
; 135  :         }

  00079	eb b7		 jmp	 SHORT $LN2@freeNodeRS
$LN3@freeNodeRS:

; 136  : 		// Factory generated vectors can be returned to the
; 137  : 		// vector factory for later reuse.
; 138  : 		//
; 139  : 		if	(stream->elements->factoryMade == ANTLR3_TRUE)

  0007b	8b 55 08	 mov	 edx, DWORD PTR _stream$[ebp]
  0007e	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00081	0f b6 88 88 00
	00 00		 movzx	 ecx, BYTE PTR [eax+136]
  00088	83 f9 01	 cmp	 ecx, 1
  0008b	75 45		 jne	 SHORT $LN8@freeNodeRS

; 140  : 		{
; 141  : 			pANTLR3_VECTOR_FACTORY factory = ((pANTLR3_COMMON_TREE_ADAPTOR)(stream->adaptor->super))->arboretum->vFactory;

  0008d	8b 55 08	 mov	 edx, DWORD PTR _stream$[ebp]
  00090	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00093	8b 08		 mov	 ecx, DWORD PTR [eax]
  00095	8b 91 b0 00 00
	00		 mov	 edx, DWORD PTR [ecx+176]
  0009b	8b 82 a8 00 00
	00		 mov	 eax, DWORD PTR [edx+168]
  000a1	89 45 f4	 mov	 DWORD PTR _factory$1[ebp], eax

; 142  : 			factory->returnVector(factory, stream->elements);

  000a4	8b f4		 mov	 esi, esp
  000a6	8b 4d 08	 mov	 ecx, DWORD PTR _stream$[ebp]
  000a9	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000ac	52		 push	 edx
  000ad	8b 45 f4	 mov	 eax, DWORD PTR _factory$1[ebp]
  000b0	50		 push	 eax
  000b1	8b 4d f4	 mov	 ecx, DWORD PTR _factory$1[ebp]
  000b4	8b 91 cc 00 00
	00		 mov	 edx, DWORD PTR [ecx+204]
  000ba	ff d2		 call	 edx
  000bc	83 c4 08	 add	 esp, 8
  000bf	3b f4		 cmp	 esi, esp
  000c1	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 143  : 
; 144  : 			stream->elements = NULL;

  000c6	8b 45 08	 mov	 eax, DWORD PTR _stream$[ebp]
  000c9	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 145  : 		} 

  000d0	eb 28		 jmp	 SHORT $LN9@freeNodeRS
$LN8@freeNodeRS:

; 146  : 		else
; 147  : 		{
; 148  : 			stream->elements->clear(stream->elements);

  000d2	8b f4		 mov	 esi, esp
  000d4	8b 4d 08	 mov	 ecx, DWORD PTR _stream$[ebp]
  000d7	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000da	52		 push	 edx
  000db	8b 45 08	 mov	 eax, DWORD PTR _stream$[ebp]
  000de	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000e1	8b 91 a0 00 00
	00		 mov	 edx, DWORD PTR [ecx+160]
  000e7	ff d2		 call	 edx
  000e9	83 c4 04	 add	 esp, 4
  000ec	3b f4		 cmp	 esi, esp
  000ee	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 149  : 			stream->freeElements = ANTLR3_TRUE;

  000f3	8b 45 08	 mov	 eax, DWORD PTR _stream$[ebp]
  000f6	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1
$LN9@freeNodeRS:

; 150  : 		}
; 151  : 	}

  000fa	eb 3b		 jmp	 SHORT $LN6@freeNodeRS
$LN5@freeNodeRS:

; 152  : 	else
; 153  : 	{
; 154  :         if  (stream->singleElement != NULL)

  000fc	8b 4d 08	 mov	 ecx, DWORD PTR _stream$[ebp]
  000ff	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00103	74 21		 je	 SHORT $LN11@freeNodeRS

; 155  :         {
; 156  :             tree = (pANTLR3_BASE_TREE)(stream->singleElement);

  00105	8b 55 08	 mov	 edx, DWORD PTR _stream$[ebp]
  00108	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0010b	89 45 fc	 mov	 DWORD PTR _tree$[ebp], eax

; 157  :             if  (tree->isNilNode(tree))

  0010e	8b f4		 mov	 esi, esp
  00110	8b 4d fc	 mov	 ecx, DWORD PTR _tree$[ebp]
  00113	51		 push	 ecx
  00114	8b 55 fc	 mov	 edx, DWORD PTR _tree$[ebp]
  00117	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  0011a	ff d0		 call	 eax
  0011c	83 c4 04	 add	 esp, 4
  0011f	3b f4		 cmp	 esi, esp
  00121	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN11@freeNodeRS:

; 158  :             {
; 159  :                 // Had to remove this for now, check is not comprehensive enough
; 160  :               //   tree->reuse(tree);
; 161  :             }
; 162  :         }
; 163  :         stream->singleElement = NULL;

  00126	8b 55 08	 mov	 edx, DWORD PTR _stream$[ebp]
  00129	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 164  : 		stream->freeElements = ANTLR3_FALSE; // Just in case

  00130	8b 45 08	 mov	 eax, DWORD PTR _stream$[ebp]
  00133	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0
$LN6@freeNodeRS:

; 165  : 	}
; 166  : 
; 167  : 	// Add the stream into the recognizer stream stack vector
; 168  : 	// adding the stream memory free routine so that
; 169  : 	// it is thrown away when the stack vector is destroyed
; 170  : 	//
; 171  : 	stream->rec->state->rStreams->add(stream->rec->state->rStreams, stream, (void(*)(void *))expungeRS);

  00137	8b f4		 mov	 esi, esp
  00139	68 00 00 00 00	 push	 OFFSET _expungeRS
  0013e	8b 4d 08	 mov	 ecx, DWORD PTR _stream$[ebp]
  00141	51		 push	 ecx
  00142	8b 55 08	 mov	 edx, DWORD PTR _stream$[ebp]
  00145	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00148	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0014b	8b 51 68	 mov	 edx, DWORD PTR [ecx+104]
  0014e	52		 push	 edx
  0014f	8b 45 08	 mov	 eax, DWORD PTR _stream$[ebp]
  00152	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00155	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00158	8b 42 68	 mov	 eax, DWORD PTR [edx+104]
  0015b	8b 88 a8 00 00
	00		 mov	 ecx, DWORD PTR [eax+168]
  00161	ff d1		 call	 ecx
  00163	83 c4 0c	 add	 esp, 12			; 0000000cH
  00166	3b f4		 cmp	 esi, esp
  00168	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0016d	90		 npad	 1

; 172  : }

  0016e	5e		 pop	 esi
  0016f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00172	3b ec		 cmp	 ebp, esp
  00174	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00179	8b e5		 mov	 esp, ebp
  0017b	5d		 pop	 ebp
  0017c	c3		 ret	 0
_freeNodeRS ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3rewritestreams.c
;	COMDAT _expungeRS
_TEXT	SEGMENT
_stream$ = 8						; size = 4
_expungeRS PROC						; COMDAT

; 175  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 176  : 
; 177  : 	if (stream->freeElements == ANTLR3_TRUE && stream->elements != NULL)

  00004	8b 45 08	 mov	 eax, DWORD PTR _stream$[ebp]
  00007	0f b6 48 0c	 movzx	 ecx, BYTE PTR [eax+12]
  0000b	83 f9 01	 cmp	 ecx, 1
  0000e	75 2b		 jne	 SHORT $LN2@expungeRS
  00010	8b 55 08	 mov	 edx, DWORD PTR _stream$[ebp]
  00013	83 7a 08 00	 cmp	 DWORD PTR [edx+8], 0
  00017	74 22		 je	 SHORT $LN2@expungeRS

; 178  : 	{
; 179  : 		stream->elements->free(stream->elements);

  00019	8b f4		 mov	 esi, esp
  0001b	8b 45 08	 mov	 eax, DWORD PTR _stream$[ebp]
  0001e	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00021	51		 push	 ecx
  00022	8b 55 08	 mov	 edx, DWORD PTR _stream$[ebp]
  00025	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00028	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  0002e	ff d1		 call	 ecx
  00030	83 c4 04	 add	 esp, 4
  00033	3b f4		 cmp	 esi, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	90		 npad	 1
$LN2@expungeRS:

; 180  : 	}
; 181  : 	ANTLR3_FREE(stream);

  0003b	8b f4		 mov	 esi, esp
  0003d	8b 55 08	 mov	 edx, DWORD PTR _stream$[ebp]
  00040	52		 push	 edx
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00047	83 c4 04	 add	 esp, 4
  0004a	3b f4		 cmp	 esi, esp
  0004c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00051	90		 npad	 1

; 182  : }

  00052	5e		 pop	 esi
  00053	3b ec		 cmp	 ebp, esp
  00055	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
_expungeRS ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3rewritestreams.c
;	COMDAT _freeRS
_TEXT	SEGMENT
_factory$1 = -4						; size = 4
_stream$ = 8						; size = 4
_freeRS	PROC						; COMDAT

; 66   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 67   : 	// Before placing the stream back in the pool, we
; 68   : 	// need to clear any vector it has. This is so any
; 69   : 	// free pointers that are associated with the
; 70   : 	// entires are called.
; 71   : 	//
; 72   : 	if	(stream->elements != NULL)

  0000c	8b 45 08	 mov	 eax, DWORD PTR _stream$[ebp]
  0000f	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00013	0f 84 81 00 00
	00		 je	 $LN2@freeRS

; 73   : 	{
; 74   : 		// Factory generated vectors can be returned to the
; 75   : 		// vector factory for later reuse.
; 76   : 		//
; 77   : 		if	(stream->elements->factoryMade == ANTLR3_TRUE)

  00019	8b 4d 08	 mov	 ecx, DWORD PTR _stream$[ebp]
  0001c	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0001f	0f b6 82 88 00
	00 00		 movzx	 eax, BYTE PTR [edx+136]
  00026	83 f8 01	 cmp	 eax, 1
  00029	75 45		 jne	 SHORT $LN4@freeRS

; 78   : 		{
; 79   : 			pANTLR3_VECTOR_FACTORY factory = ((pANTLR3_COMMON_TREE_ADAPTOR)(stream->adaptor->super))->arboretum->vFactory;

  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _stream$[ebp]
  0002e	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00031	8b 02		 mov	 eax, DWORD PTR [edx]
  00033	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  00039	8b 91 a8 00 00
	00		 mov	 edx, DWORD PTR [ecx+168]
  0003f	89 55 fc	 mov	 DWORD PTR _factory$1[ebp], edx

; 80   : 			factory->returnVector(factory, stream->elements);

  00042	8b f4		 mov	 esi, esp
  00044	8b 45 08	 mov	 eax, DWORD PTR _stream$[ebp]
  00047	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0004a	51		 push	 ecx
  0004b	8b 55 fc	 mov	 edx, DWORD PTR _factory$1[ebp]
  0004e	52		 push	 edx
  0004f	8b 45 fc	 mov	 eax, DWORD PTR _factory$1[ebp]
  00052	8b 88 cc 00 00
	00		 mov	 ecx, DWORD PTR [eax+204]
  00058	ff d1		 call	 ecx
  0005a	83 c4 08	 add	 esp, 8
  0005d	3b f4		 cmp	 esi, esp
  0005f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 81   : 
; 82   : 			stream->elements = NULL;

  00064	8b 55 08	 mov	 edx, DWORD PTR _stream$[ebp]
  00067	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 83   : 		} 

  0006e	eb 28		 jmp	 SHORT $LN5@freeRS
$LN4@freeRS:

; 84   : 		else
; 85   : 		{
; 86   : 			// Other vectors we clear and allow to be reused if they come off the
; 87   : 			// rewrite stream free stack and are reused.
; 88   : 			//
; 89   : 			stream->elements->clear(stream->elements);

  00070	8b f4		 mov	 esi, esp
  00072	8b 45 08	 mov	 eax, DWORD PTR _stream$[ebp]
  00075	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00078	51		 push	 ecx
  00079	8b 55 08	 mov	 edx, DWORD PTR _stream$[ebp]
  0007c	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0007f	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [eax+160]
  00085	ff d1		 call	 ecx
  00087	83 c4 04	 add	 esp, 4
  0008a	3b f4		 cmp	 esi, esp
  0008c	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 90   : 			stream->freeElements = ANTLR3_TRUE;

  00091	8b 55 08	 mov	 edx, DWORD PTR _stream$[ebp]
  00094	c6 42 0c 01	 mov	 BYTE PTR [edx+12], 1
$LN5@freeRS:

; 91   : 		}
; 92   : 	}

  00098	eb 07		 jmp	 SHORT $LN3@freeRS
$LN2@freeRS:

; 93   : 	else
; 94   : 	{
; 95   : 		stream->freeElements = ANTLR3_FALSE; // Just in case

  0009a	8b 45 08	 mov	 eax, DWORD PTR _stream$[ebp]
  0009d	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0
$LN3@freeRS:

; 96   : 	}
; 97   : 
; 98   : 	// Add the stream into the recognizer stream stack vector
; 99   : 	// adding the stream memory free routine so that
; 100  : 	// it is thrown away when the stack vector is destroyed
; 101  : 	//
; 102  : 	stream->rec->state->rStreams->add(stream->rec->state->rStreams, stream, (void(*)(void *))expungeRS);

  000a1	8b f4		 mov	 esi, esp
  000a3	68 00 00 00 00	 push	 OFFSET _expungeRS
  000a8	8b 4d 08	 mov	 ecx, DWORD PTR _stream$[ebp]
  000ab	51		 push	 ecx
  000ac	8b 55 08	 mov	 edx, DWORD PTR _stream$[ebp]
  000af	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  000b2	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000b5	8b 51 68	 mov	 edx, DWORD PTR [ecx+104]
  000b8	52		 push	 edx
  000b9	8b 45 08	 mov	 eax, DWORD PTR _stream$[ebp]
  000bc	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  000bf	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000c2	8b 42 68	 mov	 eax, DWORD PTR [edx+104]
  000c5	8b 88 a8 00 00
	00		 mov	 ecx, DWORD PTR [eax+168]
  000cb	ff d1		 call	 ecx
  000cd	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d0	3b f4		 cmp	 esi, esp
  000d2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d7	90		 npad	 1

; 103  : }

  000d8	5e		 pop	 esi
  000d9	83 c4 04	 add	 esp, 4
  000dc	3b ec		 cmp	 ebp, esp
  000de	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e3	8b e5		 mov	 esp, ebp
  000e5	5d		 pop	 ebp
  000e6	c3		 ret	 0
_freeRS	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3rewritestreams.c
;	COMDAT _getDescription
_TEXT	SEGMENT
_stream$ = 8						; size = 4
_getDescription PROC					; COMDAT

; 837  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 838  : 	if (stream->elementDescription == NULL)

  00003	8b 45 08	 mov	 eax, DWORD PTR _stream$[ebp]
  00006	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  0000a	75 0a		 jne	 SHORT $LN2@getDescrip

; 839  : 	{
; 840  : 		stream->elementDescription = (void*)"<unknown source>";

  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _stream$[ebp]
  0000f	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], OFFSET ??_C@_0BB@MGOOFBLH@?$DMunknown?5source?$DO@
$LN2@getDescrip:

; 841  : 	}
; 842  : 
; 843  : 	return  stream->elementDescription;

  00016	8b 55 08	 mov	 edx, DWORD PTR _stream$[ebp]
  00019	8b 42 10	 mov	 eax, DWORD PTR [edx+16]

; 844  : }

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
_getDescription ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3rewritestreams.c
;	COMDAT _size
_TEXT	SEGMENT
_n$ = -4						; size = 4
_stream$ = 8						; size = 4
_size	PROC						; COMDAT

; 812  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 813  : 	ANTLR3_UINT32   n = 0;

  00004	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0

; 814  : 
; 815  : 	/// Should be a count of one if singleElement is set. I copied this
; 816  : 	/// logic from the java implementation, which I suspect is just guarding
; 817  : 	/// against someone setting singleElement and forgetting to NULL it out
; 818  : 	///
; 819  : 	if (stream->singleElement != NULL)

  0000b	8b 45 08	 mov	 eax, DWORD PTR _stream$[ebp]
  0000e	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00012	74 09		 je	 SHORT $LN2@size

; 820  : 	{
; 821  : 		n = 1;

  00014	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _n$[ebp], 1

; 822  : 	}

  0001b	eb 14		 jmp	 SHORT $LN4@size
$LN2@size:

; 823  : 	else
; 824  : 	{
; 825  : 		if (stream->elements != NULL)

  0001d	8b 4d 08	 mov	 ecx, DWORD PTR _stream$[ebp]
  00020	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  00024	74 0b		 je	 SHORT $LN4@size

; 826  : 		{
; 827  : 			return (ANTLR3_UINT32)(stream->elements->count);

  00026	8b 55 08	 mov	 edx, DWORD PTR _stream$[ebp]
  00029	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0002c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002f	eb 03		 jmp	 SHORT $LN1@size
$LN4@size:

; 828  : 		}
; 829  : 	}
; 830  : 	return n;

  00031	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
$LN1@size:

; 831  : }

  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
_size	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3rewritestreams.c
;	COMDAT _nextNodeToken
_TEXT	SEGMENT
_stream$ = 8						; size = 4
_nextNodeToken PROC					; COMDAT

; 768  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 769  : 	return (pANTLR3_BASE_TREE)stream->adaptor->create(stream->adaptor, (pANTLR3_COMMON_TOKEN)stream->_next(stream));

  00004	8b f4		 mov	 esi, esp
  00006	8b 45 08	 mov	 eax, DWORD PTR _stream$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _stream$[ebp]
  0000d	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00010	ff d2		 call	 edx
  00012	83 c4 04	 add	 esp, 4
  00015	3b f4		 cmp	 esi, esp
  00017	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001c	8b f4		 mov	 esi, esp
  0001e	50		 push	 eax
  0001f	8b 45 08	 mov	 eax, DWORD PTR _stream$[ebp]
  00022	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00025	51		 push	 ecx
  00026	8b 55 08	 mov	 edx, DWORD PTR _stream$[ebp]
  00029	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0002c	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  0002f	ff d1		 call	 ecx
  00031	83 c4 08	 add	 esp, 8
  00034	3b f4		 cmp	 esi, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 770  : }

  0003b	5e		 pop	 esi
  0003c	3b ec		 cmp	 ebp, esp
  0003e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
_nextNodeToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3rewritestreams.c
;	COMDAT _nextNodeNode
_TEXT	SEGMENT
_stream$ = 8						; size = 4
_nextNodeNode PROC					; COMDAT

; 774  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 775  : 	return (pANTLR3_BASE_TREE)stream->_next(stream);

  00004	8b f4		 mov	 esi, esp
  00006	8b 45 08	 mov	 eax, DWORD PTR _stream$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _stream$[ebp]
  0000d	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00010	ff d2		 call	 edx
  00012	83 c4 04	 add	 esp, 4
  00015	3b f4		 cmp	 esi, esp
  00017	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 776  : }

  0001c	5e		 pop	 esi
  0001d	3b ec		 cmp	 ebp, esp
  0001f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
_nextNodeNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3rewritestreams.c
;	COMDAT _nextNode
_TEXT	SEGMENT
_el$ = -8						; size = 4
_n$ = -4						; size = 4
_stream$ = 8						; size = 4
_nextNode PROC						; COMDAT

; 789  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 790  : 
; 791  : 	ANTLR3_UINT32	n;
; 792  : 	pANTLR3_BASE_TREE	el = (pANTLR3_BASE_TREE)stream->_next(stream);

  00015	8b f4		 mov	 esi, esp
  00017	8b 45 08	 mov	 eax, DWORD PTR _stream$[ebp]
  0001a	50		 push	 eax
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR _stream$[ebp]
  0001e	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00021	ff d2		 call	 edx
  00023	83 c4 04	 add	 esp, 4
  00026	3b f4		 cmp	 esi, esp
  00028	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002d	89 45 f8	 mov	 DWORD PTR _el$[ebp], eax

; 793  : 
; 794  : 	n = stream->size(stream);

  00030	8b f4		 mov	 esi, esp
  00032	8b 45 08	 mov	 eax, DWORD PTR _stream$[ebp]
  00035	50		 push	 eax
  00036	8b 4d 08	 mov	 ecx, DWORD PTR _stream$[ebp]
  00039	8b 51 48	 mov	 edx, DWORD PTR [ecx+72]
  0003c	ff d2		 call	 edx
  0003e	83 c4 04	 add	 esp, 4
  00041	3b f4		 cmp	 esi, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax

; 795  : 	if (stream->dirty == ANTLR3_TRUE || (stream->cursor > n && n == 1))

  0004b	8b 45 08	 mov	 eax, DWORD PTR _stream$[ebp]
  0004e	0f b6 48 18	 movzx	 ecx, BYTE PTR [eax+24]
  00052	83 f9 01	 cmp	 ecx, 1
  00055	74 10		 je	 SHORT $LN3@nextNode
  00057	8b 55 08	 mov	 edx, DWORD PTR _stream$[ebp]
  0005a	8b 02		 mov	 eax, DWORD PTR [edx]
  0005c	3b 45 fc	 cmp	 eax, DWORD PTR _n$[ebp]
  0005f	76 2a		 jbe	 SHORT $LN2@nextNode
  00061	83 7d fc 01	 cmp	 DWORD PTR _n$[ebp], 1
  00065	75 24		 jne	 SHORT $LN2@nextNode
$LN3@nextNode:

; 796  : 	{
; 797  : 		// We are out of elements and the size is 1, which means we just 
; 798  : 		// dup the node that we have
; 799  : 		//
; 800  : 		return	(pANTLR3_BASE_TREE)stream->adaptor->dupNode(stream->adaptor, el);

  00067	8b f4		 mov	 esi, esp
  00069	8b 4d f8	 mov	 ecx, DWORD PTR _el$[ebp]
  0006c	51		 push	 ecx
  0006d	8b 55 08	 mov	 edx, DWORD PTR _stream$[ebp]
  00070	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00073	50		 push	 eax
  00074	8b 4d 08	 mov	 ecx, DWORD PTR _stream$[ebp]
  00077	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0007a	8b 42 50	 mov	 eax, DWORD PTR [edx+80]
  0007d	ff d0		 call	 eax
  0007f	83 c4 08	 add	 esp, 8
  00082	3b f4		 cmp	 esi, esp
  00084	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00089	eb 03		 jmp	 SHORT $LN1@nextNode
$LN2@nextNode:

; 801  : 	}
; 802  : 
; 803  : 	// We were not out of nodes, so the one we received is the one to return
; 804  : 	//
; 805  : 	return  el;

  0008b	8b 45 f8	 mov	 eax, DWORD PTR _el$[ebp]
$LN1@nextNode:

; 806  : }

  0008e	5e		 pop	 esi
  0008f	83 c4 08	 add	 esp, 8
  00092	3b ec		 cmp	 ebp, esp
  00094	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00099	8b e5		 mov	 esp, ebp
  0009b	5d		 pop	 ebp
  0009c	c3		 ret	 0
_nextNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3rewritestreams.c
;	COMDAT _hasNext
_TEXT	SEGMENT
_stream$ = 8						; size = 4
_hasNext PROC						; COMDAT

; 751  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 752  : 	if (	(stream->singleElement != NULL && stream->cursor < 1)
; 753  : 		||	(stream->elements != NULL && stream->cursor < stream->elements->size(stream->elements)))

  00004	8b 45 08	 mov	 eax, DWORD PTR _stream$[ebp]
  00007	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000b	74 08		 je	 SHORT $LN5@hasNext
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _stream$[ebp]
  00010	83 39 01	 cmp	 DWORD PTR [ecx], 1
  00013	72 31		 jb	 SHORT $LN4@hasNext
$LN5@hasNext:
  00015	8b 55 08	 mov	 edx, DWORD PTR _stream$[ebp]
  00018	83 7a 08 00	 cmp	 DWORD PTR [edx+8], 0
  0001c	74 2e		 je	 SHORT $LN2@hasNext
  0001e	8b f4		 mov	 esi, esp
  00020	8b 45 08	 mov	 eax, DWORD PTR _stream$[ebp]
  00023	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00026	51		 push	 ecx
  00027	8b 55 08	 mov	 edx, DWORD PTR _stream$[ebp]
  0002a	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0002d	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  00033	ff d1		 call	 ecx
  00035	83 c4 04	 add	 esp, 4
  00038	3b f4		 cmp	 esi, esp
  0003a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003f	8b 55 08	 mov	 edx, DWORD PTR _stream$[ebp]
  00042	39 02		 cmp	 DWORD PTR [edx], eax
  00044	73 06		 jae	 SHORT $LN2@hasNext
$LN4@hasNext:

; 754  : 	{
; 755  : 		return ANTLR3_TRUE;

  00046	b0 01		 mov	 al, 1
  00048	eb 04		 jmp	 SHORT $LN3@hasNext

; 756  : 	}

  0004a	eb 02		 jmp	 SHORT $LN3@hasNext
$LN2@hasNext:

; 757  : 	else
; 758  : 	{
; 759  : 		return ANTLR3_FALSE;

  0004c	32 c0		 xor	 al, al
$LN3@hasNext:

; 760  : 	}
; 761  : }

  0004e	5e		 pop	 esi
  0004f	3b ec		 cmp	 ebp, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
_hasNext ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3rewritestreams.c
;	COMDAT _toTreeNode
_TEXT	SEGMENT
_stream$ = 8						; size = 4
_element$ = 12						; size = 4
_toTreeNode PROC					; COMDAT

; 739  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 740  : 	return (pANTLR3_BASE_TREE)stream->adaptor->dupNode(stream->adaptor, (pANTLR3_BASE_TREE)element);

  00004	8b f4		 mov	 esi, esp
  00006	8b 45 0c	 mov	 eax, DWORD PTR _element$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _stream$[ebp]
  0000d	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00010	52		 push	 edx
  00011	8b 45 08	 mov	 eax, DWORD PTR _stream$[ebp]
  00014	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00017	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  0001a	ff d2		 call	 edx
  0001c	83 c4 08	 add	 esp, 8
  0001f	3b f4		 cmp	 esi, esp
  00021	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 741  : }

  00026	5e		 pop	 esi
  00027	3b ec		 cmp	 ebp, esp
  00029	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
_toTreeNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3rewritestreams.c
;	COMDAT _toTree
_TEXT	SEGMENT
_stream$ = 8						; size = 4
_element$ = 12						; size = 4
_toTree	PROC						; COMDAT

; 722  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 723  : 	return (pANTLR3_BASE_TREE)element;

  00003	8b 45 0c	 mov	 eax, DWORD PTR _element$[ebp]

; 724  : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
_toTree	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3rewritestreams.c
;	COMDAT _dupTreeNode
_TEXT	SEGMENT
_stream$ = 8						; size = 4
_element$ = 12						; size = 4
_dupTreeNode PROC					; COMDAT

; 711  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 712  : 	ANTLR3_FPRINTF(stderr, "dup() cannot be called on a node rewrite stream!!!");

  00004	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@CBGJDPN@dup?$CI?$CJ?5cannot?5be?5called?5on?5a?5nod@
  00009	8b f4		 mov	 esi, esp
  0000b	6a 02		 push	 2
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  00013	83 c4 04	 add	 esp, 4
  00016	3b f4		 cmp	 esi, esp
  00018	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 _fprintf
  00023	83 c4 08	 add	 esp, 8

; 713  : 	return NULL;

  00026	33 c0		 xor	 eax, eax

; 714  : }

  00028	5e		 pop	 esi
  00029	3b ec		 cmp	 ebp, esp
  0002b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
_dupTreeNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3rewritestreams.c
;	COMDAT _dupTree
_TEXT	SEGMENT
_stream$ = 8						; size = 4
_element$ = 12						; size = 4
_dupTree PROC						; COMDAT

; 697  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 698  : 	return stream->adaptor->dupNode(stream->adaptor, (pANTLR3_BASE_TREE)element);

  00004	8b f4		 mov	 esi, esp
  00006	8b 45 0c	 mov	 eax, DWORD PTR _element$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _stream$[ebp]
  0000d	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00010	52		 push	 edx
  00011	8b 45 08	 mov	 eax, DWORD PTR _stream$[ebp]
  00014	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00017	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  0001a	ff d2		 call	 edx
  0001c	83 c4 08	 add	 esp, 8
  0001f	3b f4		 cmp	 esi, esp
  00021	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 699  : }

  00026	5e		 pop	 esi
  00027	3b ec		 cmp	 ebp, esp
  00029	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
_dupTree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3rewritestreams.c
;	COMDAT _dupTok
_TEXT	SEGMENT
_stream$ = 8						; size = 4
_el$ = 12						; size = 4
_dupTok	PROC						; COMDAT

; 683  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 684  : 	ANTLR3_FPRINTF(stderr, "dup() cannot be called on a token rewrite stream!!");

  00004	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@LIOGJBJJ@dup?$CI?$CJ?5cannot?5be?5called?5on?5a?5tok@
  00009	8b f4		 mov	 esi, esp
  0000b	6a 02		 push	 2
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  00013	83 c4 04	 add	 esp, 4
  00016	3b f4		 cmp	 esi, esp
  00018	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 _fprintf
  00023	83 c4 08	 add	 esp, 8

; 685  : 	return NULL;

  00026	33 c0		 xor	 eax, eax

; 686  : }

  00028	5e		 pop	 esi
  00029	3b ec		 cmp	 ebp, esp
  0002b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
_dupTok	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3rewritestreams.c
;	COMDAT __next
_TEXT	SEGMENT
_t$ = -8						; size = 4
_n$ = -4						; size = 4
_stream$ = 8						; size = 4
__next	PROC						; COMDAT

; 626  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 627  : 	ANTLR3_UINT32		n;
; 628  : 	pANTLR3_BASE_TREE	t;
; 629  : 
; 630  : 	n = stream->size(stream);

  00015	8b f4		 mov	 esi, esp
  00017	8b 45 08	 mov	 eax, DWORD PTR _stream$[ebp]
  0001a	50		 push	 eax
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR _stream$[ebp]
  0001e	8b 51 48	 mov	 edx, DWORD PTR [ecx+72]
  00021	ff d2		 call	 edx
  00023	83 c4 04	 add	 esp, 4
  00026	3b f4		 cmp	 esi, esp
  00028	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002d	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax

; 631  : 
; 632  : 	if (n == 0)

  00030	83 7d fc 00	 cmp	 DWORD PTR _n$[ebp], 0
  00034	75 07		 jne	 SHORT $LN2@next

; 633  : 	{
; 634  : 		// This means that the stream is empty
; 635  : 		//
; 636  : 		return NULL;	// Caller must cope with this

  00036	33 c0		 xor	 eax, eax
  00038	e9 c5 00 00 00	 jmp	 $LN1@next
$LN2@next:

; 637  : 	}
; 638  : 
; 639  : 	// Traversed all the available elements already?
; 640  : 	//
; 641  : 	if (stream->cursor >= n)

  0003d	8b 45 08	 mov	 eax, DWORD PTR _stream$[ebp]
  00040	8b 08		 mov	 ecx, DWORD PTR [eax]
  00042	3b 4d fc	 cmp	 ecx, DWORD PTR _n$[ebp]
  00045	72 31		 jb	 SHORT $LN3@next

; 642  : 	{
; 643  : 		if (n == 1)

  00047	83 7d fc 01	 cmp	 DWORD PTR _n$[ebp], 1
  0004b	75 24		 jne	 SHORT $LN4@next

; 644  : 		{
; 645  : 			// Special case when size is single element, it will just dup a lot
; 646  : 			//
; 647  : 			return stream->toTree(stream, stream->singleElement);

  0004d	8b f4		 mov	 esi, esp
  0004f	8b 55 08	 mov	 edx, DWORD PTR _stream$[ebp]
  00052	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00055	50		 push	 eax
  00056	8b 4d 08	 mov	 ecx, DWORD PTR _stream$[ebp]
  00059	51		 push	 ecx
  0005a	8b 55 08	 mov	 edx, DWORD PTR _stream$[ebp]
  0005d	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  00060	ff d0		 call	 eax
  00062	83 c4 08	 add	 esp, 8
  00065	3b f4		 cmp	 esi, esp
  00067	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006c	e9 91 00 00 00	 jmp	 $LN1@next
$LN4@next:

; 648  : 		}
; 649  : 
; 650  : 		// Out of elements and the size is not 1, so we cannot assume
; 651  : 		// that we just duplicate the entry n times (such as ID ent+ -> ^(ID ent)+)
; 652  : 		// This means we ran out of elements earlier than was expected.
; 653  : 		//
; 654  : 		return NULL;	// Caller must cope with this

  00071	33 c0		 xor	 eax, eax
  00073	e9 8a 00 00 00	 jmp	 $LN1@next
$LN3@next:

; 655  : 	}
; 656  : 
; 657  : 	// Elements available either for duping or just available
; 658  : 	//
; 659  : 	if (stream->singleElement != NULL)

  00078	8b 4d 08	 mov	 ecx, DWORD PTR _stream$[ebp]
  0007b	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  0007f	74 2e		 je	 SHORT $LN5@next

; 660  : 	{
; 661  : 		stream->cursor++;   // Cursor advances even for single element as this tells us to dup()

  00081	8b 55 08	 mov	 edx, DWORD PTR _stream$[ebp]
  00084	8b 02		 mov	 eax, DWORD PTR [edx]
  00086	83 c0 01	 add	 eax, 1
  00089	8b 4d 08	 mov	 ecx, DWORD PTR _stream$[ebp]
  0008c	89 01		 mov	 DWORD PTR [ecx], eax

; 662  : 		return stream->toTree(stream, stream->singleElement);

  0008e	8b f4		 mov	 esi, esp
  00090	8b 55 08	 mov	 edx, DWORD PTR _stream$[ebp]
  00093	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00096	50		 push	 eax
  00097	8b 4d 08	 mov	 ecx, DWORD PTR _stream$[ebp]
  0009a	51		 push	 ecx
  0009b	8b 55 08	 mov	 edx, DWORD PTR _stream$[ebp]
  0009e	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  000a1	ff d0		 call	 eax
  000a3	83 c4 08	 add	 esp, 8
  000a6	3b f4		 cmp	 esi, esp
  000a8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ad	eb 53		 jmp	 SHORT $LN1@next
$LN5@next:

; 663  : 	}
; 664  : 
; 665  : 	// More than just a single element so we extract it from the 
; 666  : 	// vector.
; 667  : 	//
; 668  : 	t = stream->toTree(stream, stream->elements->get(stream->elements, stream->cursor));

  000af	8b f4		 mov	 esi, esp
  000b1	8b 4d 08	 mov	 ecx, DWORD PTR _stream$[ebp]
  000b4	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b6	52		 push	 edx
  000b7	8b 45 08	 mov	 eax, DWORD PTR _stream$[ebp]
  000ba	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000bd	51		 push	 ecx
  000be	8b 55 08	 mov	 edx, DWORD PTR _stream$[ebp]
  000c1	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000c4	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [eax+152]
  000ca	ff d1		 call	 ecx
  000cc	83 c4 08	 add	 esp, 8
  000cf	3b f4		 cmp	 esi, esp
  000d1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d6	8b f4		 mov	 esi, esp
  000d8	50		 push	 eax
  000d9	8b 55 08	 mov	 edx, DWORD PTR _stream$[ebp]
  000dc	52		 push	 edx
  000dd	8b 45 08	 mov	 eax, DWORD PTR _stream$[ebp]
  000e0	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  000e3	ff d1		 call	 ecx
  000e5	83 c4 08	 add	 esp, 8
  000e8	3b f4		 cmp	 esi, esp
  000ea	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ef	89 45 f8	 mov	 DWORD PTR _t$[ebp], eax

; 669  : 	stream->cursor++;

  000f2	8b 55 08	 mov	 edx, DWORD PTR _stream$[ebp]
  000f5	8b 02		 mov	 eax, DWORD PTR [edx]
  000f7	83 c0 01	 add	 eax, 1
  000fa	8b 4d 08	 mov	 ecx, DWORD PTR _stream$[ebp]
  000fd	89 01		 mov	 DWORD PTR [ecx], eax

; 670  : 	return t;

  000ff	8b 45 f8	 mov	 eax, DWORD PTR _t$[ebp]
$LN1@next:

; 671  : }

  00102	5e		 pop	 esi
  00103	83 c4 08	 add	 esp, 8
  00106	3b ec		 cmp	 ebp, esp
  00108	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0010d	8b e5		 mov	 esp, ebp
  0010f	5d		 pop	 ebp
  00110	c3		 ret	 0
__next	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3rewritestreams.c
;	COMDAT _nextToken
_TEXT	SEGMENT
_stream$ = 8						; size = 4
_nextToken PROC						; COMDAT

; 593  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 594  : 	return stream->_next(stream);

  00004	8b f4		 mov	 esi, esp
  00006	8b 45 08	 mov	 eax, DWORD PTR _stream$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _stream$[ebp]
  0000d	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00010	ff d2		 call	 edx
  00012	83 c4 04	 add	 esp, 4
  00015	3b f4		 cmp	 esi, esp
  00017	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 595  : }

  0001c	5e		 pop	 esi
  0001d	3b ec		 cmp	 ebp, esp
  0001f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
_nextToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3rewritestreams.c
;	COMDAT _nextTree
_TEXT	SEGMENT
_el$ = -8						; size = 4
_n$ = -4						; size = 4
_stream$ = 8						; size = 4
_nextTree PROC						; COMDAT

; 569  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 570  : 	ANTLR3_UINT32		n;
; 571  : 	void			*  el;
; 572  : 
; 573  : 	n = stream->size(stream);

  00015	8b f4		 mov	 esi, esp
  00017	8b 45 08	 mov	 eax, DWORD PTR _stream$[ebp]
  0001a	50		 push	 eax
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR _stream$[ebp]
  0001e	8b 51 48	 mov	 edx, DWORD PTR [ecx+72]
  00021	ff d2		 call	 edx
  00023	83 c4 04	 add	 esp, 4
  00026	3b f4		 cmp	 esi, esp
  00028	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002d	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax

; 574  : 
; 575  : 	if ( stream->dirty || (stream->cursor >=n && n==1) ) 

  00030	8b 45 08	 mov	 eax, DWORD PTR _stream$[ebp]
  00033	0f b6 48 18	 movzx	 ecx, BYTE PTR [eax+24]
  00037	85 c9		 test	 ecx, ecx
  00039	75 10		 jne	 SHORT $LN3@nextTree
  0003b	8b 55 08	 mov	 edx, DWORD PTR _stream$[ebp]
  0003e	8b 02		 mov	 eax, DWORD PTR [edx]
  00040	3b 45 fc	 cmp	 eax, DWORD PTR _n$[ebp]
  00043	72 3f		 jb	 SHORT $LN2@nextTree
  00045	83 7d fc 01	 cmp	 DWORD PTR _n$[ebp], 1
  00049	75 39		 jne	 SHORT $LN2@nextTree
$LN3@nextTree:

; 576  : 	{
; 577  : 		// if out of elements and size is 1, dup
; 578  : 		//
; 579  : 		el = stream->_next(stream);

  0004b	8b f4		 mov	 esi, esp
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR _stream$[ebp]
  00050	51		 push	 ecx
  00051	8b 55 08	 mov	 edx, DWORD PTR _stream$[ebp]
  00054	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00057	ff d0		 call	 eax
  00059	83 c4 04	 add	 esp, 4
  0005c	3b f4		 cmp	 esi, esp
  0005e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00063	89 45 f8	 mov	 DWORD PTR _el$[ebp], eax

; 580  : 		return (pANTLR3_BASE_TREE)stream->dup(stream, el);

  00066	8b f4		 mov	 esi, esp
  00068	8b 4d f8	 mov	 ecx, DWORD PTR _el$[ebp]
  0006b	51		 push	 ecx
  0006c	8b 55 08	 mov	 edx, DWORD PTR _stream$[ebp]
  0006f	52		 push	 edx
  00070	8b 45 08	 mov	 eax, DWORD PTR _stream$[ebp]
  00073	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00076	ff d1		 call	 ecx
  00078	83 c4 08	 add	 esp, 8
  0007b	3b f4		 cmp	 esi, esp
  0007d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00082	eb 1e		 jmp	 SHORT $LN1@nextTree
$LN2@nextTree:

; 581  : 	}
; 582  : 
; 583  : 	// test size above then fetch
; 584  : 	//
; 585  : 	el = stream->_next(stream);

  00084	8b f4		 mov	 esi, esp
  00086	8b 55 08	 mov	 edx, DWORD PTR _stream$[ebp]
  00089	52		 push	 edx
  0008a	8b 45 08	 mov	 eax, DWORD PTR _stream$[ebp]
  0008d	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00090	ff d1		 call	 ecx
  00092	83 c4 04	 add	 esp, 4
  00095	3b f4		 cmp	 esi, esp
  00097	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009c	89 45 f8	 mov	 DWORD PTR _el$[ebp], eax

; 586  : 	return (pANTLR3_BASE_TREE)el;

  0009f	8b 45 f8	 mov	 eax, DWORD PTR _el$[ebp]
$LN1@nextTree:

; 587  : }

  000a2	5e		 pop	 esi
  000a3	83 c4 08	 add	 esp, 8
  000a6	3b ec		 cmp	 ebp, esp
  000a8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ad	8b e5		 mov	 esp, ebp
  000af	5d		 pop	 ebp
  000b0	c3		 ret	 0
_nextTree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3rewritestreams.c
;	COMDAT _next
_TEXT	SEGMENT
_el$1 = -8						; size = 4
_s$ = -4						; size = 4
_stream$ = 8						; size = 4
_next	PROC						; COMDAT

; 602  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 603  : 	ANTLR3_UINT32   s;
; 604  : 
; 605  : 	s = stream->size(stream);

  00015	8b f4		 mov	 esi, esp
  00017	8b 45 08	 mov	 eax, DWORD PTR _stream$[ebp]
  0001a	50		 push	 eax
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR _stream$[ebp]
  0001e	8b 51 48	 mov	 edx, DWORD PTR [ecx+72]
  00021	ff d2		 call	 edx
  00023	83 c4 04	 add	 esp, 4
  00026	3b f4		 cmp	 esi, esp
  00028	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002d	89 45 fc	 mov	 DWORD PTR _s$[ebp], eax

; 606  : 	if (stream->cursor >= s && s == 1)

  00030	8b 45 08	 mov	 eax, DWORD PTR _stream$[ebp]
  00033	8b 08		 mov	 ecx, DWORD PTR [eax]
  00035	3b 4d fc	 cmp	 ecx, DWORD PTR _s$[ebp]
  00038	72 3f		 jb	 SHORT $LN2@next
  0003a	83 7d fc 01	 cmp	 DWORD PTR _s$[ebp], 1
  0003e	75 39		 jne	 SHORT $LN2@next

; 607  : 	{
; 608  : 		pANTLR3_BASE_TREE el;
; 609  : 
; 610  : 		el = (pANTLR3_BASE_TREE)stream->_next(stream);

  00040	8b f4		 mov	 esi, esp
  00042	8b 55 08	 mov	 edx, DWORD PTR _stream$[ebp]
  00045	52		 push	 edx
  00046	8b 45 08	 mov	 eax, DWORD PTR _stream$[ebp]
  00049	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0004c	ff d1		 call	 ecx
  0004e	83 c4 04	 add	 esp, 4
  00051	3b f4		 cmp	 esi, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00058	89 45 f8	 mov	 DWORD PTR _el$1[ebp], eax

; 611  : 
; 612  : 		return	stream->dup(stream, el);

  0005b	8b f4		 mov	 esi, esp
  0005d	8b 55 f8	 mov	 edx, DWORD PTR _el$1[ebp]
  00060	52		 push	 edx
  00061	8b 45 08	 mov	 eax, DWORD PTR _stream$[ebp]
  00064	50		 push	 eax
  00065	8b 4d 08	 mov	 ecx, DWORD PTR _stream$[ebp]
  00068	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  0006b	ff d2		 call	 edx
  0006d	83 c4 08	 add	 esp, 8
  00070	3b f4		 cmp	 esi, esp
  00072	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00077	eb 18		 jmp	 SHORT $LN1@next
$LN2@next:

; 613  : 	}
; 614  : 
; 615  : 	return stream->_next(stream);

  00079	8b f4		 mov	 esi, esp
  0007b	8b 45 08	 mov	 eax, DWORD PTR _stream$[ebp]
  0007e	50		 push	 eax
  0007f	8b 4d 08	 mov	 ecx, DWORD PTR _stream$[ebp]
  00082	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00085	ff d2		 call	 edx
  00087	83 c4 04	 add	 esp, 4
  0008a	3b f4		 cmp	 esi, esp
  0008c	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@next:

; 616  : }

  00091	5e		 pop	 esi
  00092	83 c4 08	 add	 esp, 8
  00095	3b ec		 cmp	 ebp, esp
  00097	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009c	8b e5		 mov	 esp, ebp
  0009e	5d		 pop	 ebp
  0009f	c3		 ret	 0
_next	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3rewritestreams.c
;	COMDAT _add
_TEXT	SEGMENT
_factory$1 = -4						; size = 4
_stream$ = 8						; size = 4
_el$ = 12						; size = 4
_freePtr$ = 16						; size = 4
_add	PROC						; COMDAT

; 520  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 521  : 	if (el== NULL)

  0000c	83 7d 0c 00	 cmp	 DWORD PTR _el$[ebp], 0
  00010	75 05		 jne	 SHORT $LN2@add

; 522  : 	{
; 523  : 		return;

  00012	e9 02 01 00 00	 jmp	 $LN1@add
$LN2@add:

; 524  : 	}
; 525  : 	// As we may be reusing a stream, we may already have allocated
; 526  : 	// a rewrite stream vector. If we have then is will be empty if
; 527  : 	// we have either zero or just one element in the rewrite stream
; 528  : 	//
; 529  : 	if (stream->elements != NULL && stream->elements->count > 0)

  00017	8b 45 08	 mov	 eax, DWORD PTR _stream$[ebp]
  0001a	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0001e	74 3b		 je	 SHORT $LN3@add
  00020	8b 4d 08	 mov	 ecx, DWORD PTR _stream$[ebp]
  00023	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00026	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  0002a	76 2f		 jbe	 SHORT $LN3@add

; 530  : 	{
; 531  : 		// We already have >1 entries in the stream. So we can just add this new element to the existing
; 532  : 		// collection. 
; 533  : 		//
; 534  : 		stream->elements->add(stream->elements, el, freePtr);

  0002c	8b f4		 mov	 esi, esp
  0002e	8b 45 10	 mov	 eax, DWORD PTR _freePtr$[ebp]
  00031	50		 push	 eax
  00032	8b 4d 0c	 mov	 ecx, DWORD PTR _el$[ebp]
  00035	51		 push	 ecx
  00036	8b 55 08	 mov	 edx, DWORD PTR _stream$[ebp]
  00039	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0003c	50		 push	 eax
  0003d	8b 4d 08	 mov	 ecx, DWORD PTR _stream$[ebp]
  00040	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00043	8b 82 a8 00 00
	00		 mov	 eax, DWORD PTR [edx+168]
  00049	ff d0		 call	 eax
  0004b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004e	3b f4		 cmp	 esi, esp
  00050	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00055	90		 npad	 1

; 535  : 		return;

  00056	e9 be 00 00 00	 jmp	 $LN1@add
$LN3@add:

; 536  : 	}
; 537  : 	if (stream->singleElement == NULL)

  0005b	8b 4d 08	 mov	 ecx, DWORD PTR _stream$[ebp]
  0005e	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00062	75 0e		 jne	 SHORT $LN4@add

; 538  : 	{
; 539  : 		stream->singleElement = el;

  00064	8b 55 08	 mov	 edx, DWORD PTR _stream$[ebp]
  00067	8b 45 0c	 mov	 eax, DWORD PTR _el$[ebp]
  0006a	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 540  : 		return;

  0006d	e9 a7 00 00 00	 jmp	 $LN1@add
$LN4@add:

; 541  : 	}
; 542  : 
; 543  : 	// If we got here then we had only the one element so far
; 544  : 	// and we must now create a vector to hold a collection of them
; 545  : 	//
; 546  : 	if	(stream->elements == NULL)

  00072	8b 4d 08	 mov	 ecx, DWORD PTR _stream$[ebp]
  00075	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  00079	75 3f		 jne	 SHORT $LN5@add

; 547  : 	{
; 548  :         pANTLR3_VECTOR_FACTORY factory = ((pANTLR3_COMMON_TREE_ADAPTOR)(stream->adaptor->super))->arboretum->vFactory;

  0007b	8b 55 08	 mov	 edx, DWORD PTR _stream$[ebp]
  0007e	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00081	8b 08		 mov	 ecx, DWORD PTR [eax]
  00083	8b 91 b0 00 00
	00		 mov	 edx, DWORD PTR [ecx+176]
  00089	8b 82 a8 00 00
	00		 mov	 eax, DWORD PTR [edx+168]
  0008f	89 45 fc	 mov	 DWORD PTR _factory$1[ebp], eax

; 549  : 
; 550  :         
; 551  : 		stream->elements		= factory->newVector(factory);

  00092	8b f4		 mov	 esi, esp
  00094	8b 4d fc	 mov	 ecx, DWORD PTR _factory$1[ebp]
  00097	51		 push	 ecx
  00098	8b 55 fc	 mov	 edx, DWORD PTR _factory$1[ebp]
  0009b	8b 82 c8 00 00
	00		 mov	 eax, DWORD PTR [edx+200]
  000a1	ff d0		 call	 eax
  000a3	83 c4 04	 add	 esp, 4
  000a6	3b f4		 cmp	 esi, esp
  000a8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ad	8b 4d 08	 mov	 ecx, DWORD PTR _stream$[ebp]
  000b0	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 552  : 		stream->freeElements	= ANTLR3_TRUE;			// We 'ummed it, so we play it son.

  000b3	8b 55 08	 mov	 edx, DWORD PTR _stream$[ebp]
  000b6	c6 42 0c 01	 mov	 BYTE PTR [edx+12], 1
$LN5@add:

; 553  : 	}
; 554  :     
; 555  : 	stream->elements->add	(stream->elements, stream->singleElement, freePtr);

  000ba	8b f4		 mov	 esi, esp
  000bc	8b 45 10	 mov	 eax, DWORD PTR _freePtr$[ebp]
  000bf	50		 push	 eax
  000c0	8b 4d 08	 mov	 ecx, DWORD PTR _stream$[ebp]
  000c3	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000c6	52		 push	 edx
  000c7	8b 45 08	 mov	 eax, DWORD PTR _stream$[ebp]
  000ca	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000cd	51		 push	 ecx
  000ce	8b 55 08	 mov	 edx, DWORD PTR _stream$[ebp]
  000d1	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000d4	8b 88 a8 00 00
	00		 mov	 ecx, DWORD PTR [eax+168]
  000da	ff d1		 call	 ecx
  000dc	83 c4 0c	 add	 esp, 12			; 0000000cH
  000df	3b f4		 cmp	 esi, esp
  000e1	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 556  : 	stream->elements->add	(stream->elements, el, freePtr);

  000e6	8b f4		 mov	 esi, esp
  000e8	8b 55 10	 mov	 edx, DWORD PTR _freePtr$[ebp]
  000eb	52		 push	 edx
  000ec	8b 45 0c	 mov	 eax, DWORD PTR _el$[ebp]
  000ef	50		 push	 eax
  000f0	8b 4d 08	 mov	 ecx, DWORD PTR _stream$[ebp]
  000f3	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000f6	52		 push	 edx
  000f7	8b 45 08	 mov	 eax, DWORD PTR _stream$[ebp]
  000fa	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000fd	8b 91 a8 00 00
	00		 mov	 edx, DWORD PTR [ecx+168]
  00103	ff d2		 call	 edx
  00105	83 c4 0c	 add	 esp, 12			; 0000000cH
  00108	3b f4		 cmp	 esi, esp
  0010a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 557  : 	stream->singleElement	= NULL;

  0010f	8b 45 08	 mov	 eax, DWORD PTR _stream$[ebp]
  00112	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
$LN1@add:

; 558  : 
; 559  : 	return;
; 560  : }

  00119	5e		 pop	 esi
  0011a	83 c4 04	 add	 esp, 4
  0011d	3b ec		 cmp	 ebp, esp
  0011f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00124	8b e5		 mov	 esp, ebp
  00126	5d		 pop	 ebp
  00127	c3		 ret	 0
_add	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3rewritestreams.c
;	COMDAT _reset
_TEXT	SEGMENT
_stream$ = 8						; size = 4
_reset	PROC						; COMDAT

; 511  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 512  : 	stream->dirty	= ANTLR3_TRUE;

  00003	8b 45 08	 mov	 eax, DWORD PTR _stream$[ebp]
  00006	c6 40 18 01	 mov	 BYTE PTR [eax+24], 1

; 513  : 	stream->cursor	= 0;

  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _stream$[ebp]
  0000d	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 514  : }

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
_reset	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3rewritestreams.c
;	COMDAT _antlr3RewriteRuleSubtreeStreamNewAEV
_TEXT	SEGMENT
_stream$ = -4						; size = 4
_adaptor$ = 8						; size = 4
_rec$ = 12						; size = 4
_description$ = 16					; size = 4
_vector$ = 20						; size = 4
_antlr3RewriteRuleSubtreeStreamNewAEV PROC		; COMDAT

; 419  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 420  : 	pANTLR3_REWRITE_RULE_SUBTREE_STREAM	stream;
; 421  : 
; 422  : 	// First job is to create the memory we need.
; 423  : 	//
; 424  : 	stream	= antlr3RewriteRuleElementStreamNewAEV(adaptor, rec, description, vector);

  0000b	8b 45 14	 mov	 eax, DWORD PTR _vector$[ebp]
  0000e	50		 push	 eax
  0000f	8b 4d 10	 mov	 ecx, DWORD PTR _description$[ebp]
  00012	51		 push	 ecx
  00013	8b 55 0c	 mov	 edx, DWORD PTR _rec$[ebp]
  00016	52		 push	 edx
  00017	8b 45 08	 mov	 eax, DWORD PTR _adaptor$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 _antlr3RewriteRuleElementStreamNewAEV
  00020	83 c4 10	 add	 esp, 16			; 00000010H
  00023	89 45 fc	 mov	 DWORD PTR _stream$[ebp], eax

; 425  : 
; 426  : 	if (stream == NULL)

  00026	83 7d fc 00	 cmp	 DWORD PTR _stream$[ebp], 0
  0002a	75 04		 jne	 SHORT $LN2@antlr3Rewr

; 427  : 	{
; 428  : 		return NULL;

  0002c	33 c0		 xor	 eax, eax
  0002e	eb 21		 jmp	 SHORT $LN1@antlr3Rewr
$LN2@antlr3Rewr:

; 429  : 	}
; 430  : 
; 431  : 	// Install the subtree based overrides
; 432  : 	//
; 433  : 	stream->dup			= dupTree;

  00030	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  00033	c7 41 38 00 00
	00 00		 mov	 DWORD PTR [ecx+56], OFFSET _dupTree

; 434  : 	stream->nextNode	= nextNode;

  0003a	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  0003d	c7 42 44 00 00
	00 00		 mov	 DWORD PTR [edx+68], OFFSET _nextNode

; 435  :     stream->free        = freeNodeRS;

  00044	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  00047	c7 40 50 00 00
	00 00		 mov	 DWORD PTR [eax+80], OFFSET _freeNodeRS

; 436  : 
; 437  : 	return stream;

  0004e	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
$LN1@antlr3Rewr:

; 438  : }

  00051	83 c4 04	 add	 esp, 4
  00054	3b ec		 cmp	 ebp, esp
  00056	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
_antlr3RewriteRuleSubtreeStreamNewAEV ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3rewritestreams.c
;	COMDAT _antlr3RewriteRuleSubtreeStreamNewAEE
_TEXT	SEGMENT
_stream$ = -4						; size = 4
_adaptor$ = 8						; size = 4
_rec$ = 12						; size = 4
_description$ = 16					; size = 4
_oneElement$ = 20					; size = 4
_antlr3RewriteRuleSubtreeStreamNewAEE PROC		; COMDAT

; 396  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 397  : 	pANTLR3_REWRITE_RULE_SUBTREE_STREAM	stream;
; 398  : 
; 399  : 	// First job is to create the memory we need.
; 400  : 	//
; 401  : 	stream	= antlr3RewriteRuleElementStreamNewAEE(adaptor, rec, description, oneElement);

  0000b	8b 45 14	 mov	 eax, DWORD PTR _oneElement$[ebp]
  0000e	50		 push	 eax
  0000f	8b 4d 10	 mov	 ecx, DWORD PTR _description$[ebp]
  00012	51		 push	 ecx
  00013	8b 55 0c	 mov	 edx, DWORD PTR _rec$[ebp]
  00016	52		 push	 edx
  00017	8b 45 08	 mov	 eax, DWORD PTR _adaptor$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 _antlr3RewriteRuleElementStreamNewAEE
  00020	83 c4 10	 add	 esp, 16			; 00000010H
  00023	89 45 fc	 mov	 DWORD PTR _stream$[ebp], eax

; 402  : 
; 403  : 	if (stream == NULL)

  00026	83 7d fc 00	 cmp	 DWORD PTR _stream$[ebp], 0
  0002a	75 05		 jne	 SHORT $LN2@antlr3Rewr

; 404  : 	{
; 405  : 		return stream;

  0002c	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  0002f	eb 21		 jmp	 SHORT $LN1@antlr3Rewr
$LN2@antlr3Rewr:

; 406  : 	}
; 407  : 
; 408  : 	// Install the subtree based overrides
; 409  : 	//
; 410  : 	stream->dup			= dupTree;

  00031	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  00034	c7 41 38 00 00
	00 00		 mov	 DWORD PTR [ecx+56], OFFSET _dupTree

; 411  : 	stream->nextNode	= nextNode;

  0003b	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  0003e	c7 42 44 00 00
	00 00		 mov	 DWORD PTR [edx+68], OFFSET _nextNode

; 412  :     stream->free        = freeNodeRS;

  00045	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  00048	c7 40 50 00 00
	00 00		 mov	 DWORD PTR [eax+80], OFFSET _freeNodeRS

; 413  : 
; 414  : 	return stream;

  0004f	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
$LN1@antlr3Rewr:

; 415  : }

  00052	83 c4 04	 add	 esp, 4
  00055	3b ec		 cmp	 ebp, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
_antlr3RewriteRuleSubtreeStreamNewAEE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3rewritestreams.c
;	COMDAT _antlr3RewriteRuleSubtreeStreamNewAE
_TEXT	SEGMENT
_stream$ = -4						; size = 4
_adaptor$ = 8						; size = 4
_rec$ = 12						; size = 4
_description$ = 16					; size = 4
_antlr3RewriteRuleSubtreeStreamNewAE PROC		; COMDAT

; 374  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 375  : 	pANTLR3_REWRITE_RULE_SUBTREE_STREAM	stream;
; 376  : 
; 377  : 	// First job is to create the memory we need.
; 378  : 	//
; 379  : 	stream	= antlr3RewriteRuleElementStreamNewAE(adaptor, rec, description);

  0000b	8b 45 10	 mov	 eax, DWORD PTR _description$[ebp]
  0000e	50		 push	 eax
  0000f	8b 4d 0c	 mov	 ecx, DWORD PTR _rec$[ebp]
  00012	51		 push	 ecx
  00013	8b 55 08	 mov	 edx, DWORD PTR _adaptor$[ebp]
  00016	52		 push	 edx
  00017	e8 00 00 00 00	 call	 _antlr3RewriteRuleElementStreamNewAE
  0001c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001f	89 45 fc	 mov	 DWORD PTR _stream$[ebp], eax

; 380  : 
; 381  : 	if (stream == NULL)

  00022	83 7d fc 00	 cmp	 DWORD PTR _stream$[ebp], 0
  00026	75 05		 jne	 SHORT $LN2@antlr3Rewr

; 382  : 	{
; 383  : 		return stream;

  00028	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  0002b	eb 21		 jmp	 SHORT $LN1@antlr3Rewr
$LN2@antlr3Rewr:

; 384  : 	}
; 385  : 
; 386  : 	// Install the subtree based overrides
; 387  : 	//
; 388  : 	stream->dup			= dupTree;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  00030	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [eax+56], OFFSET _dupTree

; 389  : 	stream->nextNode	= nextNode;

  00037	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  0003a	c7 41 44 00 00
	00 00		 mov	 DWORD PTR [ecx+68], OFFSET _nextNode

; 390  :     stream->free        = freeNodeRS;

  00041	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  00044	c7 42 50 00 00
	00 00		 mov	 DWORD PTR [edx+80], OFFSET _freeNodeRS

; 391  : 	return stream;

  0004b	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
$LN1@antlr3Rewr:

; 392  : 
; 393  : }

  0004e	83 c4 04	 add	 esp, 4
  00051	3b ec		 cmp	 ebp, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
_antlr3RewriteRuleSubtreeStreamNewAE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3rewritestreams.c
;	COMDAT _antlr3RewriteRuleNODEStreamNewAEV
_TEXT	SEGMENT
_stream$ = -4						; size = 4
_adaptor$ = 8						; size = 4
_rec$ = 12						; size = 4
_description$ = 16					; size = 4
_vector$ = 20						; size = 4
_antlr3RewriteRuleNODEStreamNewAEV PROC			; COMDAT

; 486  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 487  : 	pANTLR3_REWRITE_RULE_NODE_STREAM	stream;
; 488  : 
; 489  : 	// First job is to create the memory we need.
; 490  : 	//
; 491  : 	stream	= antlr3RewriteRuleElementStreamNewAEV(adaptor, rec, description, vector);

  0000b	8b 45 14	 mov	 eax, DWORD PTR _vector$[ebp]
  0000e	50		 push	 eax
  0000f	8b 4d 10	 mov	 ecx, DWORD PTR _description$[ebp]
  00012	51		 push	 ecx
  00013	8b 55 0c	 mov	 edx, DWORD PTR _rec$[ebp]
  00016	52		 push	 edx
  00017	8b 45 08	 mov	 eax, DWORD PTR _adaptor$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 _antlr3RewriteRuleElementStreamNewAEV
  00020	83 c4 10	 add	 esp, 16			; 00000010H
  00023	89 45 fc	 mov	 DWORD PTR _stream$[ebp], eax

; 492  : 
; 493  : 	// Install the Node based overrides
; 494  : 	//
; 495  : 	stream->dup			= dupTreeNode;

  00026	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  00029	c7 41 38 00 00
	00 00		 mov	 DWORD PTR [ecx+56], OFFSET _dupTreeNode

; 496  : 	stream->toTree		= toTreeNode;

  00030	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  00033	c7 42 3c 00 00
	00 00		 mov	 DWORD PTR [edx+60], OFFSET _toTreeNode

; 497  : 	stream->nextNode	= nextNodeNode;

  0003a	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  0003d	c7 40 44 00 00
	00 00		 mov	 DWORD PTR [eax+68], OFFSET _nextNodeNode

; 498  :     stream->free        = freeNodeRS;

  00044	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  00047	c7 41 50 00 00
	00 00		 mov	 DWORD PTR [ecx+80], OFFSET _freeNodeRS

; 499  :     
; 500  : 	return stream;

  0004e	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]

; 501  : }

  00051	83 c4 04	 add	 esp, 4
  00054	3b ec		 cmp	 ebp, esp
  00056	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
_antlr3RewriteRuleNODEStreamNewAEV ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3rewritestreams.c
;	COMDAT _antlr3RewriteRuleNODEStreamNewAEE
_TEXT	SEGMENT
_stream$ = -4						; size = 4
_adaptor$ = 8						; size = 4
_rec$ = 12						; size = 4
_description$ = 16					; size = 4
_oneElement$ = 20					; size = 4
_antlr3RewriteRuleNODEStreamNewAEE PROC			; COMDAT

; 467  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 468  : 	pANTLR3_REWRITE_RULE_NODE_STREAM	stream;
; 469  : 
; 470  : 	// First job is to create the memory we need.
; 471  : 	//
; 472  : 	stream	= antlr3RewriteRuleElementStreamNewAEE(adaptor, rec, description, oneElement);

  0000b	8b 45 14	 mov	 eax, DWORD PTR _oneElement$[ebp]
  0000e	50		 push	 eax
  0000f	8b 4d 10	 mov	 ecx, DWORD PTR _description$[ebp]
  00012	51		 push	 ecx
  00013	8b 55 0c	 mov	 edx, DWORD PTR _rec$[ebp]
  00016	52		 push	 edx
  00017	8b 45 08	 mov	 eax, DWORD PTR _adaptor$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 _antlr3RewriteRuleElementStreamNewAEE
  00020	83 c4 10	 add	 esp, 16			; 00000010H
  00023	89 45 fc	 mov	 DWORD PTR _stream$[ebp], eax

; 473  : 
; 474  : 	// Install the node based overrides
; 475  : 	//
; 476  : 	stream->dup			= dupTreeNode;

  00026	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  00029	c7 41 38 00 00
	00 00		 mov	 DWORD PTR [ecx+56], OFFSET _dupTreeNode

; 477  : 	stream->toTree		= toTreeNode;

  00030	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  00033	c7 42 3c 00 00
	00 00		 mov	 DWORD PTR [edx+60], OFFSET _toTreeNode

; 478  : 	stream->nextNode	= nextNodeNode;

  0003a	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  0003d	c7 40 44 00 00
	00 00		 mov	 DWORD PTR [eax+68], OFFSET _nextNodeNode

; 479  :     stream->free        = freeNodeRS;

  00044	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  00047	c7 41 50 00 00
	00 00		 mov	 DWORD PTR [ecx+80], OFFSET _freeNodeRS

; 480  : 
; 481  : 	return stream;

  0004e	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]

; 482  : }

  00051	83 c4 04	 add	 esp, 4
  00054	3b ec		 cmp	 ebp, esp
  00056	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
_antlr3RewriteRuleNODEStreamNewAEE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3rewritestreams.c
;	COMDAT _antlr3RewriteRuleNODEStreamNewAE
_TEXT	SEGMENT
_stream$ = -4						; size = 4
_adaptor$ = 8						; size = 4
_rec$ = 12						; size = 4
_description$ = 16					; size = 4
_antlr3RewriteRuleNODEStreamNewAE PROC			; COMDAT

; 443  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 444  : 	pANTLR3_REWRITE_RULE_NODE_STREAM	stream;
; 445  : 
; 446  : 	// First job is to create the memory we need.
; 447  : 	//
; 448  : 	stream	= antlr3RewriteRuleElementStreamNewAE(adaptor, rec, description);

  0000b	8b 45 10	 mov	 eax, DWORD PTR _description$[ebp]
  0000e	50		 push	 eax
  0000f	8b 4d 0c	 mov	 ecx, DWORD PTR _rec$[ebp]
  00012	51		 push	 ecx
  00013	8b 55 08	 mov	 edx, DWORD PTR _adaptor$[ebp]
  00016	52		 push	 edx
  00017	e8 00 00 00 00	 call	 _antlr3RewriteRuleElementStreamNewAE
  0001c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001f	89 45 fc	 mov	 DWORD PTR _stream$[ebp], eax

; 449  : 
; 450  : 	if (stream == NULL)

  00022	83 7d fc 00	 cmp	 DWORD PTR _stream$[ebp], 0
  00026	75 05		 jne	 SHORT $LN2@antlr3Rewr

; 451  : 	{
; 452  : 		return stream;

  00028	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  0002b	eb 2b		 jmp	 SHORT $LN1@antlr3Rewr
$LN2@antlr3Rewr:

; 453  : 	}
; 454  : 
; 455  : 	// Install the node based overrides
; 456  : 	//
; 457  : 	stream->dup			= dupTreeNode;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  00030	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [eax+56], OFFSET _dupTreeNode

; 458  : 	stream->toTree		= toTreeNode;

  00037	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  0003a	c7 41 3c 00 00
	00 00		 mov	 DWORD PTR [ecx+60], OFFSET _toTreeNode

; 459  : 	stream->nextNode	= nextNodeNode;

  00041	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  00044	c7 42 44 00 00
	00 00		 mov	 DWORD PTR [edx+68], OFFSET _nextNodeNode

; 460  :     stream->free        = freeNodeRS;

  0004b	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  0004e	c7 40 50 00 00
	00 00		 mov	 DWORD PTR [eax+80], OFFSET _freeNodeRS

; 461  : 
; 462  : 	return stream;

  00055	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
$LN1@antlr3Rewr:

; 463  : }

  00058	83 c4 04	 add	 esp, 4
  0005b	3b ec		 cmp	 ebp, esp
  0005d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
_antlr3RewriteRuleNODEStreamNewAE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3rewritestreams.c
;	COMDAT _antlr3RewriteRuleTOKENStreamNewAEV
_TEXT	SEGMENT
_stream$ = -4						; size = 4
_adaptor$ = 8						; size = 4
_rec$ = 12						; size = 4
_description$ = 16					; size = 4
_vector$ = 20						; size = 4
_antlr3RewriteRuleTOKENStreamNewAEV PROC		; COMDAT

; 353  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 354  : 	pANTLR3_REWRITE_RULE_TOKEN_STREAM	stream;
; 355  : 
; 356  : 	// First job is to create the memory we need.
; 357  : 	//
; 358  : 	stream	= antlr3RewriteRuleElementStreamNewAEV(adaptor, rec, description, vector);

  0000b	8b 45 14	 mov	 eax, DWORD PTR _vector$[ebp]
  0000e	50		 push	 eax
  0000f	8b 4d 10	 mov	 ecx, DWORD PTR _description$[ebp]
  00012	51		 push	 ecx
  00013	8b 55 0c	 mov	 edx, DWORD PTR _rec$[ebp]
  00016	52		 push	 edx
  00017	8b 45 08	 mov	 eax, DWORD PTR _adaptor$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 _antlr3RewriteRuleElementStreamNewAEV
  00020	83 c4 10	 add	 esp, 16			; 00000010H
  00023	89 45 fc	 mov	 DWORD PTR _stream$[ebp], eax

; 359  : 
; 360  : 	// Install the token based overrides
; 361  : 	//
; 362  : 	stream->dup			= dupTok;

  00026	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  00029	c7 41 38 00 00
	00 00		 mov	 DWORD PTR [ecx+56], OFFSET _dupTok

; 363  : 	stream->nextNode	= nextNodeToken;

  00030	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  00033	c7 42 44 00 00
	00 00		 mov	 DWORD PTR [edx+68], OFFSET _nextNodeToken

; 364  : 
; 365  : 	// No nextNode implementation for a token rewrite stream
; 366  : 	//
; 367  : 	return stream;

  0003a	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]

; 368  : }

  0003d	83 c4 04	 add	 esp, 4
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
_antlr3RewriteRuleTOKENStreamNewAEV ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3rewritestreams.c
;	COMDAT _antlr3RewriteRuleTOKENStreamNewAEE
_TEXT	SEGMENT
_stream$ = -4						; size = 4
_adaptor$ = 8						; size = 4
_rec$ = 12						; size = 4
_description$ = 16					; size = 4
_oneElement$ = 20					; size = 4
_antlr3RewriteRuleTOKENStreamNewAEE PROC		; COMDAT

; 334  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 335  : 	pANTLR3_REWRITE_RULE_TOKEN_STREAM	stream;
; 336  : 
; 337  : 	// First job is to create the memory we need.
; 338  : 	//
; 339  : 	stream	= antlr3RewriteRuleElementStreamNewAEE(adaptor, rec, description, oneElement);

  0000b	8b 45 14	 mov	 eax, DWORD PTR _oneElement$[ebp]
  0000e	50		 push	 eax
  0000f	8b 4d 10	 mov	 ecx, DWORD PTR _description$[ebp]
  00012	51		 push	 ecx
  00013	8b 55 0c	 mov	 edx, DWORD PTR _rec$[ebp]
  00016	52		 push	 edx
  00017	8b 45 08	 mov	 eax, DWORD PTR _adaptor$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 _antlr3RewriteRuleElementStreamNewAEE
  00020	83 c4 10	 add	 esp, 16			; 00000010H
  00023	89 45 fc	 mov	 DWORD PTR _stream$[ebp], eax

; 340  : 
; 341  : 	// Install the token based overrides
; 342  : 	//
; 343  : 	stream->dup			= dupTok;

  00026	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  00029	c7 41 38 00 00
	00 00		 mov	 DWORD PTR [ecx+56], OFFSET _dupTok

; 344  : 	stream->nextNode	= nextNodeToken;

  00030	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  00033	c7 42 44 00 00
	00 00		 mov	 DWORD PTR [edx+68], OFFSET _nextNodeToken

; 345  : 
; 346  : 	// No nextNode implementation for a token rewrite stream
; 347  : 	//
; 348  : 	return stream;

  0003a	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]

; 349  : }

  0003d	83 c4 04	 add	 esp, 4
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
_antlr3RewriteRuleTOKENStreamNewAEE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3rewritestreams.c
;	COMDAT _antlr3RewriteRuleTOKENStreamNewAE
_TEXT	SEGMENT
_stream$ = -4						; size = 4
_adaptor$ = 8						; size = 4
_rec$ = 12						; size = 4
_description$ = 16					; size = 4
_antlr3RewriteRuleTOKENStreamNewAE PROC			; COMDAT

; 310  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 311  : 	pANTLR3_REWRITE_RULE_TOKEN_STREAM	stream;
; 312  : 
; 313  : 	// First job is to create the memory we need.
; 314  : 	//
; 315  : 	stream	= antlr3RewriteRuleElementStreamNewAE(adaptor, rec, description);

  0000b	8b 45 10	 mov	 eax, DWORD PTR _description$[ebp]
  0000e	50		 push	 eax
  0000f	8b 4d 0c	 mov	 ecx, DWORD PTR _rec$[ebp]
  00012	51		 push	 ecx
  00013	8b 55 08	 mov	 edx, DWORD PTR _adaptor$[ebp]
  00016	52		 push	 edx
  00017	e8 00 00 00 00	 call	 _antlr3RewriteRuleElementStreamNewAE
  0001c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001f	89 45 fc	 mov	 DWORD PTR _stream$[ebp], eax

; 316  : 
; 317  : 	if (stream == NULL)

  00022	83 7d fc 00	 cmp	 DWORD PTR _stream$[ebp], 0
  00026	75 05		 jne	 SHORT $LN2@antlr3Rewr

; 318  : 	{
; 319  : 		return stream;

  00028	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  0002b	eb 17		 jmp	 SHORT $LN1@antlr3Rewr
$LN2@antlr3Rewr:

; 320  : 	}
; 321  : 
; 322  : 	// Install the token based overrides
; 323  : 	//
; 324  : 	stream->dup			= dupTok;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  00030	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [eax+56], OFFSET _dupTok

; 325  : 	stream->nextNode	= nextNodeToken;

  00037	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  0003a	c7 41 44 00 00
	00 00		 mov	 DWORD PTR [ecx+68], OFFSET _nextNodeToken

; 326  : 
; 327  : 	// No nextNode implementation for a token rewrite stream
; 328  : 	//
; 329  : 	return stream;

  00041	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
$LN1@antlr3Rewr:

; 330  : }

  00044	83 c4 04	 add	 esp, 4
  00047	3b ec		 cmp	 ebp, esp
  00049	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
_antlr3RewriteRuleTOKENStreamNewAE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 837  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 838  :         int _Result;
; 839  :         va_list _ArgList;
; 840  :         __crt_va_start(_ArgList, _Format);

  00014	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00017	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 841  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

  0001a	8b 4d f8	 mov	 ecx, DWORD PTR __ArgList$[ebp]
  0001d	51		 push	 ecx
  0001e	6a 00		 push	 0
  00020	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00023	52		 push	 edx
  00024	8b 45 08	 mov	 eax, DWORD PTR __Stream$[ebp]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 __vfprintf_l
  0002d	83 c4 10	 add	 esp, 16			; 00000010H
  00030	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 842  :         __crt_va_end(_ArgList);

  00033	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 843  :         return _Result;

  0003a	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 844  :     }

  0003d	83 c4 08	 add	 esp, 8
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 644  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00004	8b f4		 mov	 esi, esp
  00006	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  0000d	51		 push	 ecx
  0000e	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00011	52		 push	 edx
  00012	8b 45 08	 mov	 eax, DWORD PTR __Stream$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  0001b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001e	51		 push	 ecx
  0001f	8b 10		 mov	 edx, DWORD PTR [eax]
  00021	52		 push	 edx
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vfprintf
  00028	83 c4 18	 add	 esp, 24			; 00000018H
  0002b	3b f4		 cmp	 esi, esp
  0002d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 646  :     }

  00032	5e		 pop	 esi
  00033	3b ec		 cmp	 ebp, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 90   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00003	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
