; Listing generated by Microsoft (R) Optimizing Compiler Version 19.42.34436.0 

	TITLE	C:\SPO_labs\C\Debug\antlr3commontreenodestream.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_antlr3CommonTreeNodeStreamNewTree
PUBLIC	_antlr3CommonTreeNodeStreamNew
PUBLIC	_antlr3CommonTreeNodeStreamNewStream
PUBLIC	_antlr3TreeNodeStreamNew
PUBLIC	??_C@_02NAHCJHOC@UP@				; `string'
PUBLIC	??_C@_04FANAOELO@DOWN@				; `string'
PUBLIC	??_C@_03KPJEKKJC@EOF@				; `string'
PUBLIC	??_C@_07DNODLGKM@INVALID@			; `string'
EXTRN	__imp__calloc:PROC
EXTRN	__imp__free:PROC
EXTRN	_antlr3VectorNew:PROC
EXTRN	_antlr3StackNew:PROC
EXTRN	_antlr3IntStreamNew:PROC
EXTRN	_antlr3CommonTokenNew:PROC
EXTRN	_ANTLR3_TREE_ADAPTORNew:PROC
EXTRN	_antlr3CommonTreeNewFromToken:PROC
EXTRN	_antlr3SetCTAPI:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_07DNODLGKM@INVALID@
CONST	SEGMENT
??_C@_07DNODLGKM@INVALID@ DB 'INVALID', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03KPJEKKJC@EOF@
CONST	SEGMENT
??_C@_03KPJEKKJC@EOF@ DB 'EOF', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04FANAOELO@DOWN@
CONST	SEGMENT
??_C@_04FANAOELO@DOWN@ DB 'DOWN', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02NAHCJHOC@UP@
CONST	SEGMENT
??_C@_02NAHCJHOC@UP@ DB 'UP', 00H			; `string'
CONST	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontreenodestream.c
;	COMDAT _LB
_TEXT	SEGMENT
_tns$ = 8						; size = 4
_k$ = 12						; size = 4
_LB	PROC						; COMDAT

; 552  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 553  : 	if	( k==0)

  00004	83 7d 0c 00	 cmp	 DWORD PTR _k$[ebp], 0
  00008	75 0c		 jne	 SHORT $LN2@LB

; 554  : 	{
; 555  : 		return	&(tns->ctns->INVALID_NODE.baseTree);

  0000a	8b 45 08	 mov	 eax, DWORD PTR _tns$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	05 fc 01 00 00	 add	 eax, 508		; 000001fcH
  00014	eb 56		 jmp	 SHORT $LN1@LB
$LN2@LB:

; 556  : 	}
; 557  : 
; 558  : 	if	( (tns->ctns->p - k) < 0)

  00016	8b 4d 08	 mov	 ecx, DWORD PTR _tns$[ebp]
  00019	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001b	8b 82 90 02 00
	00		 mov	 eax, DWORD PTR [edx+656]
  00021	2b 45 0c	 sub	 eax, DWORD PTR _k$[ebp]
  00024	79 0c		 jns	 SHORT $LN3@LB

; 559  : 	{
; 560  : 		return	&(tns->ctns->INVALID_NODE.baseTree);

  00026	8b 4d 08	 mov	 ecx, DWORD PTR _tns$[ebp]
  00029	8b 01		 mov	 eax, DWORD PTR [ecx]
  0002b	05 fc 01 00 00	 add	 eax, 508		; 000001fcH
  00030	eb 3a		 jmp	 SHORT $LN1@LB
$LN3@LB:

; 561  : 	}
; 562  : 
; 563  : 	return (pANTLR3_BASE_TREE)tns->ctns->nodes->get(tns->ctns->nodes, tns->ctns->p - k);

  00032	8b 55 08	 mov	 edx, DWORD PTR _tns$[ebp]
  00035	8b 02		 mov	 eax, DWORD PTR [edx]
  00037	8b 88 90 02 00
	00		 mov	 ecx, DWORD PTR [eax+656]
  0003d	2b 4d 0c	 sub	 ecx, DWORD PTR _k$[ebp]
  00040	8b f4		 mov	 esi, esp
  00042	51		 push	 ecx
  00043	8b 55 08	 mov	 edx, DWORD PTR _tns$[ebp]
  00046	8b 02		 mov	 eax, DWORD PTR [edx]
  00048	8b 88 7c 02 00
	00		 mov	 ecx, DWORD PTR [eax+636]
  0004e	51		 push	 ecx
  0004f	8b 55 08	 mov	 edx, DWORD PTR _tns$[ebp]
  00052	8b 02		 mov	 eax, DWORD PTR [edx]
  00054	8b 88 7c 02 00
	00		 mov	 ecx, DWORD PTR [eax+636]
  0005a	8b 91 98 00 00
	00		 mov	 edx, DWORD PTR [ecx+152]
  00060	ff d2		 call	 edx
  00062	83 c4 08	 add	 esp, 8
  00065	3b f4		 cmp	 esi, esp
  00067	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@LB:

; 564  : }

  0006c	5e		 pop	 esi
  0006d	3b ec		 cmp	 ebp, esp
  0006f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
_LB	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontreenodestream.c
;	COMDAT _antlr3CommonTreeNodeStreamFree
_TEXT	SEGMENT
_ctns$ = 8						; size = 4
_antlr3CommonTreeNodeStreamFree PROC			; COMDAT

; 421  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 422  : 
; 423  : 	// If this is a rewrting stream, then certain resources
; 424  : 	// belong to the originating node stream and we do not
; 425  : 	// free them here.
; 426  : 	//
; 427  : 	if	(ctns->isRewriter != ANTLR3_TRUE)

  00004	8b 45 08	 mov	 eax, DWORD PTR _ctns$[ebp]
  00007	0f b6 88 f8 02
	00 00		 movzx	 ecx, BYTE PTR [eax+760]
  0000e	83 f9 01	 cmp	 ecx, 1
  00011	0f 84 c6 00 00
	00		 je	 $LN2@antlr3Comm

; 428  : 	{
; 429  : 		ctns->adaptor			->free  (ctns->adaptor);

  00017	8b f4		 mov	 esi, esp
  00019	8b 55 08	 mov	 edx, DWORD PTR _ctns$[ebp]
  0001c	8b 82 88 02 00
	00		 mov	 eax, DWORD PTR [edx+648]
  00022	50		 push	 eax
  00023	8b 4d 08	 mov	 ecx, DWORD PTR _ctns$[ebp]
  00026	8b 91 88 02 00
	00		 mov	 edx, DWORD PTR [ecx+648]
  0002c	8b 82 a8 00 00
	00		 mov	 eax, DWORD PTR [edx+168]
  00032	ff d0		 call	 eax
  00034	83 c4 04	 add	 esp, 4
  00037	3b f4		 cmp	 esi, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 430  : 
; 431  : 		if	(ctns->nodeStack != NULL)

  0003e	8b 4d 08	 mov	 ecx, DWORD PTR _ctns$[ebp]
  00041	83 b9 8c 02 00
	00 00		 cmp	 DWORD PTR [ecx+652], 0
  00048	74 25		 je	 SHORT $LN3@antlr3Comm

; 432  : 		{
; 433  : 			ctns->nodeStack->free(ctns->nodeStack);

  0004a	8b f4		 mov	 esi, esp
  0004c	8b 55 08	 mov	 edx, DWORD PTR _ctns$[ebp]
  0004f	8b 82 8c 02 00
	00		 mov	 eax, DWORD PTR [edx+652]
  00055	50		 push	 eax
  00056	8b 4d 08	 mov	 ecx, DWORD PTR _ctns$[ebp]
  00059	8b 91 8c 02 00
	00		 mov	 edx, DWORD PTR [ecx+652]
  0005f	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00062	ff d0		 call	 eax
  00064	83 c4 04	 add	 esp, 4
  00067	3b f4		 cmp	 esi, esp
  00069	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006e	90		 npad	 1
$LN3@antlr3Comm:

; 434  : 		}
; 435  : 
; 436  : 		ANTLR3_FREE(ctns->INVALID_NODE.token);

  0006f	8b f4		 mov	 esi, esp
  00071	8b 4d 08	 mov	 ecx, DWORD PTR _ctns$[ebp]
  00074	8b 91 ec 01 00
	00		 mov	 edx, DWORD PTR [ecx+492]
  0007a	52		 push	 edx
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00081	83 c4 04	 add	 esp, 4
  00084	3b f4		 cmp	 esi, esp
  00086	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 437  : 		ANTLR3_FREE(ctns->EOF_NODE.token);

  0008b	8b f4		 mov	 esi, esp
  0008d	8b 45 08	 mov	 eax, DWORD PTR _ctns$[ebp]
  00090	8b 88 50 01 00
	00		 mov	 ecx, DWORD PTR [eax+336]
  00096	51		 push	 ecx
  00097	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0009d	83 c4 04	 add	 esp, 4
  000a0	3b f4		 cmp	 esi, esp
  000a2	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 438  : 		ANTLR3_FREE(ctns->DOWN.token);

  000a7	8b f4		 mov	 esi, esp
  000a9	8b 55 08	 mov	 edx, DWORD PTR _ctns$[ebp]
  000ac	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  000af	50		 push	 eax
  000b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  000b6	83 c4 04	 add	 esp, 4
  000b9	3b f4		 cmp	 esi, esp
  000bb	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 439  : 		ANTLR3_FREE(ctns->UP.token);

  000c0	8b f4		 mov	 esi, esp
  000c2	8b 4d 08	 mov	 ecx, DWORD PTR _ctns$[ebp]
  000c5	8b 91 b4 00 00
	00		 mov	 edx, DWORD PTR [ecx+180]
  000cb	52		 push	 edx
  000cc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  000d2	83 c4 04	 add	 esp, 4
  000d5	3b f4		 cmp	 esi, esp
  000d7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000dc	90		 npad	 1
$LN2@antlr3Comm:

; 440  : 	}
; 441  : 	
; 442  : 	if	(ctns->nodes != NULL)

  000dd	8b 45 08	 mov	 eax, DWORD PTR _ctns$[ebp]
  000e0	83 b8 7c 02 00
	00 00		 cmp	 DWORD PTR [eax+636], 0
  000e7	74 28		 je	 SHORT $LN4@antlr3Comm

; 443  : 	{
; 444  : 		ctns->nodes			->free  (ctns->nodes);

  000e9	8b f4		 mov	 esi, esp
  000eb	8b 4d 08	 mov	 ecx, DWORD PTR _ctns$[ebp]
  000ee	8b 91 7c 02 00
	00		 mov	 edx, DWORD PTR [ecx+636]
  000f4	52		 push	 edx
  000f5	8b 45 08	 mov	 eax, DWORD PTR _ctns$[ebp]
  000f8	8b 88 7c 02 00
	00		 mov	 ecx, DWORD PTR [eax+636]
  000fe	8b 91 90 00 00
	00		 mov	 edx, DWORD PTR [ecx+144]
  00104	ff d2		 call	 edx
  00106	83 c4 04	 add	 esp, 4
  00109	3b f4		 cmp	 esi, esp
  0010b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00110	90		 npad	 1
$LN4@antlr3Comm:

; 445  : 	}
; 446  : 	ctns->tnstream->istream ->free  (ctns->tnstream->istream);

  00111	8b 45 08	 mov	 eax, DWORD PTR _ctns$[ebp]
  00114	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00117	8b f4		 mov	 esi, esp
  00119	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0011c	52		 push	 edx
  0011d	8b 45 08	 mov	 eax, DWORD PTR _ctns$[ebp]
  00120	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00123	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00126	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  00129	ff d0		 call	 eax
  0012b	83 c4 04	 add	 esp, 4
  0012e	3b f4		 cmp	 esi, esp
  00130	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 447  :     ctns->tnstream			->free  (ctns->tnstream);

  00135	8b f4		 mov	 esi, esp
  00137	8b 4d 08	 mov	 ecx, DWORD PTR _ctns$[ebp]
  0013a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0013d	52		 push	 edx
  0013e	8b 45 08	 mov	 eax, DWORD PTR _ctns$[ebp]
  00141	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00144	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00147	ff d2		 call	 edx
  00149	83 c4 04	 add	 esp, 4
  0014c	3b f4		 cmp	 esi, esp
  0014e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 448  : 
; 449  : 
; 450  :     ANTLR3_FREE(ctns);

  00153	8b f4		 mov	 esi, esp
  00155	8b 45 08	 mov	 eax, DWORD PTR _ctns$[ebp]
  00158	50		 push	 eax
  00159	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0015f	83 c4 04	 add	 esp, 4
  00162	3b f4		 cmp	 esi, esp
  00164	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00169	90		 npad	 1

; 451  : }

  0016a	5e		 pop	 esi
  0016b	3b ec		 cmp	 ebp, esp
  0016d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00172	5d		 pop	 ebp
  00173	c3		 ret	 0
_antlr3CommonTreeNodeStreamFree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontreenodestream.c
;	COMDAT _antlr3TreeNodeStreamFree
_TEXT	SEGMENT
_stream$ = 8						; size = 4
_antlr3TreeNodeStreamFree PROC				; COMDAT

; 111  : {   

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 112  :     ANTLR3_FREE(stream);

  00004	8b f4		 mov	 esi, esp
  00006	8b 45 08	 mov	 eax, DWORD PTR _stream$[ebp]
  00009	50		 push	 eax
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00010	83 c4 04	 add	 esp, 4
  00013	3b f4		 cmp	 esi, esp
  00015	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001a	90		 npad	 1

; 113  : }

  0001b	5e		 pop	 esi
  0001c	3b ec		 cmp	 ebp, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
_antlr3TreeNodeStreamFree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontreenodestream.c
;	COMDAT _fillBufferRoot
_TEXT	SEGMENT
_ctns$ = 8						; size = 4
_fillBufferRoot PROC					; COMDAT

; 461  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 462  : 	// Call the generic buffer routine with the root as the
; 463  : 	// argument
; 464  : 	//
; 465  : 	fillBuffer(ctns, ctns->root);

  00003	8b 45 08	 mov	 eax, DWORD PTR _ctns$[ebp]
  00006	8b 88 84 02 00
	00		 mov	 ecx, DWORD PTR [eax+644]
  0000c	51		 push	 ecx
  0000d	8b 55 08	 mov	 edx, DWORD PTR _ctns$[ebp]
  00010	52		 push	 edx
  00011	e8 00 00 00 00	 call	 _fillBuffer
  00016	83 c4 08	 add	 esp, 8

; 466  : 	ctns->p = 0;					// Indicate we are at buffer start

  00019	8b 45 08	 mov	 eax, DWORD PTR _ctns$[ebp]
  0001c	c7 80 90 02 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+656], 0

; 467  : }

  00026	3b ec		 cmp	 ebp, esp
  00028	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
_fillBufferRoot ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontreenodestream.c
;	COMDAT _fillBuffer
_TEXT	SEGMENT
_c$ = -12						; size = 4
_nCount$ = -8						; size = 4
_nilNode$ = -1						; size = 1
_ctns$ = 8						; size = 4
_t$ = 12						; size = 4
_fillBuffer PROC					; COMDAT

; 475  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000e	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00015	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 476  : 	ANTLR3_BOOLEAN	nilNode;
; 477  : 	ANTLR3_UINT32	nCount;
; 478  : 	ANTLR3_UINT32	c;
; 479  : 
; 480  : 	nilNode = ctns->adaptor->isNilNode(ctns->adaptor, t);

  0001c	8b f4		 mov	 esi, esp
  0001e	8b 45 0c	 mov	 eax, DWORD PTR _t$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 08	 mov	 ecx, DWORD PTR _ctns$[ebp]
  00025	8b 91 88 02 00
	00		 mov	 edx, DWORD PTR [ecx+648]
  0002b	52		 push	 edx
  0002c	8b 45 08	 mov	 eax, DWORD PTR _ctns$[ebp]
  0002f	8b 88 88 02 00
	00		 mov	 ecx, DWORD PTR [eax+648]
  00035	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00038	ff d2		 call	 edx
  0003a	83 c4 08	 add	 esp, 8
  0003d	3b f4		 cmp	 esi, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	88 45 ff	 mov	 BYTE PTR _nilNode$[ebp], al

; 481  : 
; 482  : 	// If the supplied node is not a nil (list) node then we
; 483  : 	// add in the node itself to the vector
; 484  : 	//
; 485  : 	if	(nilNode == ANTLR3_FALSE)

  00047	0f b6 45 ff	 movzx	 eax, BYTE PTR _nilNode$[ebp]
  0004b	85 c0		 test	 eax, eax
  0004d	75 2e		 jne	 SHORT $LN5@fillBuffer

; 486  : 	{
; 487  : 		ctns->nodes->add(ctns->nodes, t, NULL);	

  0004f	8b f4		 mov	 esi, esp
  00051	6a 00		 push	 0
  00053	8b 4d 0c	 mov	 ecx, DWORD PTR _t$[ebp]
  00056	51		 push	 ecx
  00057	8b 55 08	 mov	 edx, DWORD PTR _ctns$[ebp]
  0005a	8b 82 7c 02 00
	00		 mov	 eax, DWORD PTR [edx+636]
  00060	50		 push	 eax
  00061	8b 4d 08	 mov	 ecx, DWORD PTR _ctns$[ebp]
  00064	8b 91 7c 02 00
	00		 mov	 edx, DWORD PTR [ecx+636]
  0006a	8b 82 a8 00 00
	00		 mov	 eax, DWORD PTR [edx+168]
  00070	ff d0		 call	 eax
  00072	83 c4 0c	 add	 esp, 12			; 0000000cH
  00075	3b f4		 cmp	 esi, esp
  00077	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007c	90		 npad	 1
$LN5@fillBuffer:

; 488  : 	}
; 489  : 
; 490  : 	// Only add a DOWN node if the tree is not a nil tree and
; 491  : 	// the tree does have children.
; 492  : 	//
; 493  : 	nCount = t->getChildCount(t);

  0007d	8b f4		 mov	 esi, esp
  0007f	8b 4d 0c	 mov	 ecx, DWORD PTR _t$[ebp]
  00082	51		 push	 ecx
  00083	8b 55 0c	 mov	 edx, DWORD PTR _t$[ebp]
  00086	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  00089	ff d0		 call	 eax
  0008b	83 c4 04	 add	 esp, 4
  0008e	3b f4		 cmp	 esi, esp
  00090	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00095	89 45 f8	 mov	 DWORD PTR _nCount$[ebp], eax

; 494  : 
; 495  : 	if	(nilNode == ANTLR3_FALSE && nCount>0)

  00098	0f b6 4d ff	 movzx	 ecx, BYTE PTR _nilNode$[ebp]
  0009c	85 c9		 test	 ecx, ecx
  0009e	75 24		 jne	 SHORT $LN6@fillBuffer
  000a0	83 7d f8 00	 cmp	 DWORD PTR _nCount$[ebp], 0
  000a4	76 1e		 jbe	 SHORT $LN6@fillBuffer

; 496  : 	{
; 497  : 		ctns->addNavigationNode(ctns, ANTLR3_TOKEN_DOWN);

  000a6	8b f4		 mov	 esi, esp
  000a8	6a 02		 push	 2
  000aa	8b 55 08	 mov	 edx, DWORD PTR _ctns$[ebp]
  000ad	52		 push	 edx
  000ae	8b 45 08	 mov	 eax, DWORD PTR _ctns$[ebp]
  000b1	8b 88 d0 02 00
	00		 mov	 ecx, DWORD PTR [eax+720]
  000b7	ff d1		 call	 ecx
  000b9	83 c4 08	 add	 esp, 8
  000bc	3b f4		 cmp	 esi, esp
  000be	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c3	90		 npad	 1
$LN6@fillBuffer:

; 498  : 	}
; 499  : 
; 500  : 	// We always add any children the tree contains, which is
; 501  : 	// a recursive call to this function, which will cause similar
; 502  : 	// recursion and implement a depth first addition
; 503  : 	//
; 504  : 	for	(c = 0; c < nCount; c++)

  000c4	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _c$[ebp], 0
  000cb	eb 09		 jmp	 SHORT $LN4@fillBuffer
$LN2@fillBuffer:
  000cd	8b 55 f4	 mov	 edx, DWORD PTR _c$[ebp]
  000d0	83 c2 01	 add	 edx, 1
  000d3	89 55 f4	 mov	 DWORD PTR _c$[ebp], edx
$LN4@fillBuffer:
  000d6	8b 45 f4	 mov	 eax, DWORD PTR _c$[ebp]
  000d9	3b 45 f8	 cmp	 eax, DWORD PTR _nCount$[ebp]
  000dc	73 3b		 jae	 SHORT $LN3@fillBuffer

; 505  : 	{
; 506  : 		fillBuffer(ctns, (pANTLR3_BASE_TREE)ctns->adaptor->getChild(ctns->adaptor, t, c));

  000de	8b f4		 mov	 esi, esp
  000e0	8b 4d f4	 mov	 ecx, DWORD PTR _c$[ebp]
  000e3	51		 push	 ecx
  000e4	8b 55 0c	 mov	 edx, DWORD PTR _t$[ebp]
  000e7	52		 push	 edx
  000e8	8b 45 08	 mov	 eax, DWORD PTR _ctns$[ebp]
  000eb	8b 88 88 02 00
	00		 mov	 ecx, DWORD PTR [eax+648]
  000f1	51		 push	 ecx
  000f2	8b 55 08	 mov	 edx, DWORD PTR _ctns$[ebp]
  000f5	8b 82 88 02 00
	00		 mov	 eax, DWORD PTR [edx+648]
  000fb	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  000fe	ff d1		 call	 ecx
  00100	83 c4 0c	 add	 esp, 12			; 0000000cH
  00103	3b f4		 cmp	 esi, esp
  00105	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0010a	50		 push	 eax
  0010b	8b 55 08	 mov	 edx, DWORD PTR _ctns$[ebp]
  0010e	52		 push	 edx
  0010f	e8 00 00 00 00	 call	 _fillBuffer
  00114	83 c4 08	 add	 esp, 8

; 507  : 	}

  00117	eb b4		 jmp	 SHORT $LN2@fillBuffer
$LN3@fillBuffer:

; 508  : 
; 509  : 	// If the tree had children and was not a nil (list) node, then we
; 510  : 	// we need to add an UP node here to match the DOWN node
; 511  : 	//
; 512  : 	if	(nilNode == ANTLR3_FALSE && nCount > 0)

  00119	0f b6 45 ff	 movzx	 eax, BYTE PTR _nilNode$[ebp]
  0011d	85 c0		 test	 eax, eax
  0011f	75 24		 jne	 SHORT $LN7@fillBuffer
  00121	83 7d f8 00	 cmp	 DWORD PTR _nCount$[ebp], 0
  00125	76 1e		 jbe	 SHORT $LN7@fillBuffer

; 513  : 	{
; 514  : 		ctns->addNavigationNode(ctns, ANTLR3_TOKEN_UP);

  00127	8b f4		 mov	 esi, esp
  00129	6a 03		 push	 3
  0012b	8b 4d 08	 mov	 ecx, DWORD PTR _ctns$[ebp]
  0012e	51		 push	 ecx
  0012f	8b 55 08	 mov	 edx, DWORD PTR _ctns$[ebp]
  00132	8b 82 d0 02 00
	00		 mov	 eax, DWORD PTR [edx+720]
  00138	ff d0		 call	 eax
  0013a	83 c4 08	 add	 esp, 8
  0013d	3b f4		 cmp	 esi, esp
  0013f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00144	90		 npad	 1
$LN7@fillBuffer:

; 515  : 	}
; 516  : }

  00145	5e		 pop	 esi
  00146	83 c4 0c	 add	 esp, 12			; 0000000cH
  00149	3b ec		 cmp	 ebp, esp
  0014b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00150	8b e5		 mov	 esp, ebp
  00152	5d		 pop	 ebp
  00153	c3		 ret	 0
_fillBuffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontreenodestream.c
;	COMDAT _size
_TEXT	SEGMENT
_ctns$ = -8						; size = 4
_tns$ = -4						; size = 4
_is$ = 8						; size = 4
_size	PROC						; COMDAT

; 732  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 733  :     pANTLR3_TREE_NODE_STREAM		tns;
; 734  :     pANTLR3_COMMON_TREE_NODE_STREAM	ctns;
; 735  : 
; 736  :     tns	    = (pANTLR3_TREE_NODE_STREAM)(is->super);

  00015	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  00018	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0001b	89 4d fc	 mov	 DWORD PTR _tns$[ebp], ecx

; 737  :     ctns    = tns->ctns;

  0001e	8b 55 fc	 mov	 edx, DWORD PTR _tns$[ebp]
  00021	8b 02		 mov	 eax, DWORD PTR [edx]
  00023	89 45 f8	 mov	 DWORD PTR _ctns$[ebp], eax

; 738  : 
; 739  : 	if	(ctns->p == -1)

  00026	8b 4d f8	 mov	 ecx, DWORD PTR _ctns$[ebp]
  00029	83 b9 90 02 00
	00 ff		 cmp	 DWORD PTR [ecx+656], -1
  00030	75 0c		 jne	 SHORT $LN2@size

; 740  : 	{
; 741  : 		fillBufferRoot(ctns);

  00032	8b 55 f8	 mov	 edx, DWORD PTR _ctns$[ebp]
  00035	52		 push	 edx
  00036	e8 00 00 00 00	 call	 _fillBufferRoot
  0003b	83 c4 04	 add	 esp, 4
$LN2@size:

; 742  : 	}
; 743  : 
; 744  : 	return ctns->nodes->size(ctns->nodes);

  0003e	8b f4		 mov	 esi, esp
  00040	8b 45 f8	 mov	 eax, DWORD PTR _ctns$[ebp]
  00043	8b 88 7c 02 00
	00		 mov	 ecx, DWORD PTR [eax+636]
  00049	51		 push	 ecx
  0004a	8b 55 f8	 mov	 edx, DWORD PTR _ctns$[ebp]
  0004d	8b 82 7c 02 00
	00		 mov	 eax, DWORD PTR [edx+636]
  00053	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  00059	ff d1		 call	 ecx
  0005b	83 c4 04	 add	 esp, 4
  0005e	3b f4		 cmp	 esi, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 745  : }

  00065	5e		 pop	 esi
  00066	83 c4 08	 add	 esp, 8
  00069	3b ec		 cmp	 ebp, esp
  0006b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
_size	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontreenodestream.c
;	COMDAT _seek
_TEXT	SEGMENT
_ctns$ = -8						; size = 4
_tns$ = -4						; size = 4
_is$ = 8						; size = 4
_index$ = 12						; size = 4
_seek	PROC						; COMDAT

; 704  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 705  :     pANTLR3_TREE_NODE_STREAM		tns;
; 706  :     pANTLR3_COMMON_TREE_NODE_STREAM	ctns;
; 707  : 
; 708  :     tns	    = (pANTLR3_TREE_NODE_STREAM)(is->super);

  00006	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  00009	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000c	89 4d fc	 mov	 DWORD PTR _tns$[ebp], ecx

; 709  :     ctns    = tns->ctns;

  0000f	8b 55 fc	 mov	 edx, DWORD PTR _tns$[ebp]
  00012	8b 02		 mov	 eax, DWORD PTR [edx]
  00014	89 45 f8	 mov	 DWORD PTR _ctns$[ebp], eax

; 710  : 
; 711  : 	ctns->p = ANTLR3_UINT32_CAST(index);

  00017	8b 4d f8	 mov	 ecx, DWORD PTR _ctns$[ebp]
  0001a	8b 55 0c	 mov	 edx, DWORD PTR _index$[ebp]
  0001d	89 91 90 02 00
	00		 mov	 DWORD PTR [ecx+656], edx

; 712  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
_seek	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontreenodestream.c
;	COMDAT _rewindLast
_TEXT	SEGMENT
_is$ = 8						; size = 4
_rewindLast PROC					; COMDAT

; 695  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 696  :    is->seek(is, is->lastMarker);

  00004	8b f4		 mov	 esi, esp
  00006	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  00009	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0000c	51		 push	 ecx
  0000d	8b 55 08	 mov	 edx, DWORD PTR _is$[ebp]
  00010	52		 push	 edx
  00011	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  00014	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00017	ff d1		 call	 ecx
  00019	83 c4 08	 add	 esp, 8
  0001c	3b f4		 cmp	 esi, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	90		 npad	 1

; 697  : }

  00024	5e		 pop	 esi
  00025	3b ec		 cmp	 ebp, esp
  00027	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
_rewindLast ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontreenodestream.c
;	COMDAT _rewindMark
_TEXT	SEGMENT
_is$ = 8						; size = 4
_marker$ = 12						; size = 4
_rewindMark PROC					; COMDAT

; 689  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 690  : 	is->seek(is, marker);

  00004	8b f4		 mov	 esi, esp
  00006	8b 45 0c	 mov	 eax, DWORD PTR _marker$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _is$[ebp]
  0000d	51		 push	 ecx
  0000e	8b 55 08	 mov	 edx, DWORD PTR _is$[ebp]
  00011	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  00014	ff d0		 call	 eax
  00016	83 c4 08	 add	 esp, 8
  00019	3b f4		 cmp	 esi, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	90		 npad	 1

; 691  : }

  00021	5e		 pop	 esi
  00022	3b ec		 cmp	 ebp, esp
  00024	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
_rewindMark ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontreenodestream.c
;	COMDAT _release
_TEXT	SEGMENT
_is$ = 8						; size = 4
_marker$ = 12						; size = 4
_release PROC						; COMDAT

; 678  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 679  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
_release ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontreenodestream.c
;	COMDAT _mark
_TEXT	SEGMENT
_ctns$ = -8						; size = 4
_tns$ = -4						; size = 4
_is$ = 8						; size = 4
_mark	PROC						; COMDAT

; 657  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 658  : 	pANTLR3_TREE_NODE_STREAM		tns;
; 659  : 	pANTLR3_COMMON_TREE_NODE_STREAM	ctns;
; 660  : 
; 661  : 	tns	    = (pANTLR3_TREE_NODE_STREAM)(is->super);

  00015	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  00018	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0001b	89 4d fc	 mov	 DWORD PTR _tns$[ebp], ecx

; 662  : 	ctns    = tns->ctns;

  0001e	8b 55 fc	 mov	 edx, DWORD PTR _tns$[ebp]
  00021	8b 02		 mov	 eax, DWORD PTR [edx]
  00023	89 45 f8	 mov	 DWORD PTR _ctns$[ebp], eax

; 663  : 
; 664  : 	if	(tns->ctns->p == -1)

  00026	8b 4d fc	 mov	 ecx, DWORD PTR _tns$[ebp]
  00029	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002b	83 ba 90 02 00
	00 ff		 cmp	 DWORD PTR [edx+656], -1
  00032	75 0e		 jne	 SHORT $LN2@mark

; 665  : 	{
; 666  : 		fillBufferRoot(tns->ctns);

  00034	8b 45 fc	 mov	 eax, DWORD PTR _tns$[ebp]
  00037	8b 08		 mov	 ecx, DWORD PTR [eax]
  00039	51		 push	 ecx
  0003a	e8 00 00 00 00	 call	 _fillBufferRoot
  0003f	83 c4 04	 add	 esp, 4
$LN2@mark:

; 667  : 	}
; 668  : 
; 669  : 	// Return the current mark point
; 670  : 	//
; 671  : 	ctns->tnstream->istream->lastMarker = ctns->tnstream->istream->index(ctns->tnstream->istream);

  00042	8b 55 f8	 mov	 edx, DWORD PTR _ctns$[ebp]
  00045	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00048	8b f4		 mov	 esi, esp
  0004a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0004d	51		 push	 ecx
  0004e	8b 55 f8	 mov	 edx, DWORD PTR _ctns$[ebp]
  00051	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00054	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00057	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  0005a	ff d2		 call	 edx
  0005c	83 c4 04	 add	 esp, 4
  0005f	3b f4		 cmp	 esi, esp
  00061	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00066	8b 4d f8	 mov	 ecx, DWORD PTR _ctns$[ebp]
  00069	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0006c	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0006f	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 672  : 
; 673  : 	return ctns->tnstream->istream->lastMarker;

  00072	8b 55 f8	 mov	 edx, DWORD PTR _ctns$[ebp]
  00075	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00078	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0007b	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]

; 674  : }

  0007e	5e		 pop	 esi
  0007f	83 c4 08	 add	 esp, 8
  00082	3b ec		 cmp	 ebp, esp
  00084	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c3		 ret	 0
_mark	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontreenodestream.c
;	COMDAT __LA
_TEXT	SEGMENT
_t$ = -8						; size = 4
_tns$ = -4						; size = 4
_is$ = 8						; size = 4
_i$ = 12						; size = 4
__LA	PROC						; COMDAT

; 632  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 633  : 	pANTLR3_TREE_NODE_STREAM		tns;
; 634  : 	pANTLR3_BASE_TREE				t;
; 635  : 
; 636  : 	tns	    = (pANTLR3_TREE_NODE_STREAM)(is->super);

  00015	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  00018	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0001b	89 4d fc	 mov	 DWORD PTR _tns$[ebp], ecx

; 637  : 
; 638  : 	// Ask LT for the 'token' at that position
; 639  : 	//
; 640  : 	t = tns->_LT(tns, i);

  0001e	8b f4		 mov	 esi, esp
  00020	8b 55 0c	 mov	 edx, DWORD PTR _i$[ebp]
  00023	52		 push	 edx
  00024	8b 45 fc	 mov	 eax, DWORD PTR _tns$[ebp]
  00027	50		 push	 eax
  00028	8b 4d fc	 mov	 ecx, DWORD PTR _tns$[ebp]
  0002b	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0002e	ff d2		 call	 edx
  00030	83 c4 08	 add	 esp, 8
  00033	3b f4		 cmp	 esi, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	89 45 f8	 mov	 DWORD PTR _t$[ebp], eax

; 641  : 
; 642  : 	if	(t == NULL)

  0003d	83 7d f8 00	 cmp	 DWORD PTR _t$[ebp], 0
  00041	75 04		 jne	 SHORT $LN2@LA

; 643  : 	{
; 644  : 		return	ANTLR3_TOKEN_INVALID;

  00043	33 c0		 xor	 eax, eax
  00045	eb 18		 jmp	 SHORT $LN1@LA
$LN2@LA:

; 645  : 	}
; 646  : 
; 647  : 	// Token node was there so return the type of it
; 648  : 	//
; 649  : 	return  t->getType(t);

  00047	8b f4		 mov	 esi, esp
  00049	8b 45 f8	 mov	 eax, DWORD PTR _t$[ebp]
  0004c	50		 push	 eax
  0004d	8b 4d f8	 mov	 ecx, DWORD PTR _t$[ebp]
  00050	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  00053	ff d2		 call	 edx
  00055	83 c4 04	 add	 esp, 4
  00058	3b f4		 cmp	 esi, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@LA:

; 650  : }

  0005f	5e		 pop	 esi
  00060	83 c4 08	 add	 esp, 8
  00063	3b ec		 cmp	 ebp, esp
  00065	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
__LA	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontreenodestream.c
;	COMDAT _tindex
_TEXT	SEGMENT
_ctns$ = -8						; size = 4
_tns$ = -4						; size = 4
_is$ = 8						; size = 4
_tindex	PROC						; COMDAT

; 716  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 717  :     pANTLR3_TREE_NODE_STREAM		tns;
; 718  :     pANTLR3_COMMON_TREE_NODE_STREAM	ctns;
; 719  : 
; 720  :     tns	    = (pANTLR3_TREE_NODE_STREAM)(is->super);

  00006	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  00009	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000c	89 4d fc	 mov	 DWORD PTR _tns$[ebp], ecx

; 721  :     ctns    = tns->ctns;

  0000f	8b 55 fc	 mov	 edx, DWORD PTR _tns$[ebp]
  00012	8b 02		 mov	 eax, DWORD PTR [edx]
  00014	89 45 f8	 mov	 DWORD PTR _ctns$[ebp], eax

; 722  : 
; 723  : 	return (ANTLR3_MARKER)(ctns->p);

  00017	8b 4d f8	 mov	 ecx, DWORD PTR _ctns$[ebp]
  0001a	8b 81 90 02 00
	00		 mov	 eax, DWORD PTR [ecx+656]

; 724  : }

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
_tindex	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontreenodestream.c
;	COMDAT _consume
_TEXT	SEGMENT
_ctns$ = -8						; size = 4
_tns$ = -4						; size = 4
_is$ = 8						; size = 4
_consume PROC						; COMDAT

; 616  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 617  :     pANTLR3_TREE_NODE_STREAM		tns;
; 618  :     pANTLR3_COMMON_TREE_NODE_STREAM	ctns;
; 619  : 
; 620  :     tns	    = (pANTLR3_TREE_NODE_STREAM)(is->super);

  00014	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  00017	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0001a	89 4d fc	 mov	 DWORD PTR _tns$[ebp], ecx

; 621  :     ctns    = tns->ctns;

  0001d	8b 55 fc	 mov	 edx, DWORD PTR _tns$[ebp]
  00020	8b 02		 mov	 eax, DWORD PTR [edx]
  00022	89 45 f8	 mov	 DWORD PTR _ctns$[ebp], eax

; 622  : 
; 623  : 	if	(ctns->p == -1)

  00025	8b 4d f8	 mov	 ecx, DWORD PTR _ctns$[ebp]
  00028	83 b9 90 02 00
	00 ff		 cmp	 DWORD PTR [ecx+656], -1
  0002f	75 0c		 jne	 SHORT $LN2@consume

; 624  : 	{
; 625  : 		fillBufferRoot(ctns);

  00031	8b 55 f8	 mov	 edx, DWORD PTR _ctns$[ebp]
  00034	52		 push	 edx
  00035	e8 00 00 00 00	 call	 _fillBufferRoot
  0003a	83 c4 04	 add	 esp, 4
$LN2@consume:

; 626  : 	}
; 627  : 	ctns->p++;

  0003d	8b 45 f8	 mov	 eax, DWORD PTR _ctns$[ebp]
  00040	8b 88 90 02 00
	00		 mov	 ecx, DWORD PTR [eax+656]
  00046	83 c1 01	 add	 ecx, 1
  00049	8b 55 f8	 mov	 edx, DWORD PTR _ctns$[ebp]
  0004c	89 8a 90 02 00
	00		 mov	 DWORD PTR [edx+656], ecx

; 628  : }

  00052	83 c4 08	 add	 esp, 8
  00055	3b ec		 cmp	 ebp, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
_consume ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontreenodestream.c
;	COMDAT _replaceChildren
_TEXT	SEGMENT
_cta$1 = -8						; size = 4
_adaptor$2 = -4						; size = 4
_tns$ = 8						; size = 4
_parent$ = 12						; size = 4
_startChildIndex$ = 16					; size = 4
_stopChildIndex$ = 20					; size = 4
_t$ = 24						; size = 4
_replaceChildren PROC					; COMDAT

; 929  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 930  : 	if	(parent != NULL)

  00015	83 7d 0c 00	 cmp	 DWORD PTR _parent$[ebp], 0
  00019	74 4f		 je	 SHORT $LN2@replaceChi

; 931  : 	{
; 932  : 		pANTLR3_BASE_TREE_ADAPTOR	adaptor;
; 933  : 		pANTLR3_COMMON_TREE_ADAPTOR	cta;
; 934  : 
; 935  : 		adaptor	= tns->getTreeAdaptor(tns);

  0001b	8b f4		 mov	 esi, esp
  0001d	8b 45 08	 mov	 eax, DWORD PTR _tns$[ebp]
  00020	50		 push	 eax
  00021	8b 4d 08	 mov	 ecx, DWORD PTR _tns$[ebp]
  00024	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00027	ff d2		 call	 edx
  00029	83 c4 04	 add	 esp, 4
  0002c	3b f4		 cmp	 esi, esp
  0002e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00033	89 45 fc	 mov	 DWORD PTR _adaptor$2[ebp], eax

; 936  : 		cta		= (pANTLR3_COMMON_TREE_ADAPTOR)(adaptor->super);

  00036	8b 45 fc	 mov	 eax, DWORD PTR _adaptor$2[ebp]
  00039	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003b	89 4d f8	 mov	 DWORD PTR _cta$1[ebp], ecx

; 937  : 
; 938  : 		adaptor->replaceChildren(adaptor, parent, startChildIndex, stopChildIndex, t);

  0003e	8b f4		 mov	 esi, esp
  00040	8b 55 18	 mov	 edx, DWORD PTR _t$[ebp]
  00043	52		 push	 edx
  00044	8b 45 14	 mov	 eax, DWORD PTR _stopChildIndex$[ebp]
  00047	50		 push	 eax
  00048	8b 4d 10	 mov	 ecx, DWORD PTR _startChildIndex$[ebp]
  0004b	51		 push	 ecx
  0004c	8b 55 0c	 mov	 edx, DWORD PTR _parent$[ebp]
  0004f	52		 push	 edx
  00050	8b 45 fc	 mov	 eax, DWORD PTR _adaptor$2[ebp]
  00053	50		 push	 eax
  00054	8b 4d fc	 mov	 ecx, DWORD PTR _adaptor$2[ebp]
  00057	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  0005d	ff d2		 call	 edx
  0005f	83 c4 14	 add	 esp, 20			; 00000014H
  00062	3b f4		 cmp	 esi, esp
  00064	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00069	90		 npad	 1
$LN2@replaceChi:

; 939  : 	}
; 940  : }

  0006a	5e		 pop	 esi
  0006b	83 c4 08	 add	 esp, 8
  0006e	3b ec		 cmp	 ebp, esp
  00070	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c3		 ret	 0
_replaceChildren ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontreenodestream.c
;	COMDAT _toStringWork
_TEXT	SEGMENT
_child$1 = -16						; size = 4
_text$2 = -12						; size = 4
_c$ = -8						; size = 4
_n$ = -4						; size = 4
_tns$ = 8						; size = 4
_p$ = 12						; size = 4
_stop$ = 16						; size = 4
_buf$ = 20						; size = 4
_toStringWork PROC					; COMDAT

; 831  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000f	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00012	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00015	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 832  : 
; 833  : 	ANTLR3_UINT32   n;
; 834  : 	ANTLR3_UINT32   c;
; 835  : 
; 836  : 	if	(!p->isNilNode(p) )

  00018	8b f4		 mov	 esi, esp
  0001a	8b 45 0c	 mov	 eax, DWORD PTR _p$[ebp]
  0001d	50		 push	 eax
  0001e	8b 4d 0c	 mov	 ecx, DWORD PTR _p$[ebp]
  00021	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  00024	ff d2		 call	 edx
  00026	83 c4 04	 add	 esp, 4
  00029	3b f4		 cmp	 esi, esp
  0002b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00030	0f b6 c0	 movzx	 eax, al
  00033	85 c0		 test	 eax, eax
  00035	0f 85 af 00 00
	00		 jne	 $LN5@toStringWo

; 837  : 	{
; 838  : 		pANTLR3_STRING	text;
; 839  : 
; 840  : 		text	= p->toString(p);

  0003b	8b f4		 mov	 esi, esp
  0003d	8b 4d 0c	 mov	 ecx, DWORD PTR _p$[ebp]
  00040	51		 push	 ecx
  00041	8b 55 0c	 mov	 edx, DWORD PTR _p$[ebp]
  00044	8b 42 6c	 mov	 eax, DWORD PTR [edx+108]
  00047	ff d0		 call	 eax
  00049	83 c4 04	 add	 esp, 4
  0004c	3b f4		 cmp	 esi, esp
  0004e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00053	89 45 f4	 mov	 DWORD PTR _text$2[ebp], eax

; 841  : 
; 842  : 		if  (text == NULL)

  00056	83 7d f4 00	 cmp	 DWORD PTR _text$2[ebp], 0
  0005a	75 71		 jne	 SHORT $LN6@toStringWo

; 843  : 		{
; 844  : 			text = tns->ctns->stringFactory->newRaw(tns->ctns->stringFactory);

  0005c	8b 4d 08	 mov	 ecx, DWORD PTR _tns$[ebp]
  0005f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00061	8b f4		 mov	 esi, esp
  00063	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00066	50		 push	 eax
  00067	8b 4d 08	 mov	 ecx, DWORD PTR _tns$[ebp]
  0006a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0006c	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0006f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00072	ff d1		 call	 ecx
  00074	83 c4 04	 add	 esp, 4
  00077	3b f4		 cmp	 esi, esp
  00079	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007e	89 45 f4	 mov	 DWORD PTR _text$2[ebp], eax

; 845  : 
; 846  : 			text->addc	(text, ' ');

  00081	8b f4		 mov	 esi, esp
  00083	6a 20		 push	 32			; 00000020H
  00085	8b 55 f4	 mov	 edx, DWORD PTR _text$2[ebp]
  00088	52		 push	 edx
  00089	8b 45 f4	 mov	 eax, DWORD PTR _text$2[ebp]
  0008c	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  0008f	ff d1		 call	 ecx
  00091	83 c4 08	 add	 esp, 8
  00094	3b f4		 cmp	 esi, esp
  00096	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 847  : 			text->addi	(text, p->getType(p));

  0009b	8b f4		 mov	 esi, esp
  0009d	8b 55 0c	 mov	 edx, DWORD PTR _p$[ebp]
  000a0	52		 push	 edx
  000a1	8b 45 0c	 mov	 eax, DWORD PTR _p$[ebp]
  000a4	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  000a7	ff d1		 call	 ecx
  000a9	83 c4 04	 add	 esp, 4
  000ac	3b f4		 cmp	 esi, esp
  000ae	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b3	8b f4		 mov	 esi, esp
  000b5	50		 push	 eax
  000b6	8b 55 f4	 mov	 edx, DWORD PTR _text$2[ebp]
  000b9	52		 push	 edx
  000ba	8b 45 f4	 mov	 eax, DWORD PTR _text$2[ebp]
  000bd	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  000c0	ff d1		 call	 ecx
  000c2	83 c4 08	 add	 esp, 8
  000c5	3b f4		 cmp	 esi, esp
  000c7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000cc	90		 npad	 1
$LN6@toStringWo:

; 848  : 		}
; 849  : 
; 850  : 		buf->appendS(buf, text);

  000cd	8b f4		 mov	 esi, esp
  000cf	8b 55 f4	 mov	 edx, DWORD PTR _text$2[ebp]
  000d2	52		 push	 edx
  000d3	8b 45 14	 mov	 eax, DWORD PTR _buf$[ebp]
  000d6	50		 push	 eax
  000d7	8b 4d 14	 mov	 ecx, DWORD PTR _buf$[ebp]
  000da	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  000dd	ff d2		 call	 edx
  000df	83 c4 08	 add	 esp, 8
  000e2	3b f4		 cmp	 esi, esp
  000e4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e9	90		 npad	 1
$LN5@toStringWo:

; 851  : 	}
; 852  : 
; 853  : 	if	(p == stop)

  000ea	8b 45 0c	 mov	 eax, DWORD PTR _p$[ebp]
  000ed	3b 45 10	 cmp	 eax, DWORD PTR _stop$[ebp]
  000f0	75 05		 jne	 SHORT $LN7@toStringWo

; 854  : 	{
; 855  : 		return;		/* Finished */

  000f2	e9 2f 01 00 00	 jmp	 $LN9@toStringWo
$LN7@toStringWo:

; 856  : 	}
; 857  : 
; 858  : 	n = p->getChildCount(p);

  000f7	8b f4		 mov	 esi, esp
  000f9	8b 4d 0c	 mov	 ecx, DWORD PTR _p$[ebp]
  000fc	51		 push	 ecx
  000fd	8b 55 0c	 mov	 edx, DWORD PTR _p$[ebp]
  00100	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  00103	ff d0		 call	 eax
  00105	83 c4 04	 add	 esp, 4
  00108	3b f4		 cmp	 esi, esp
  0010a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0010f	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax

; 859  : 
; 860  : 	if	(n > 0 && ! p->isNilNode(p) )

  00112	83 7d fc 00	 cmp	 DWORD PTR _n$[ebp], 0
  00116	76 54		 jbe	 SHORT $LN8@toStringWo
  00118	8b f4		 mov	 esi, esp
  0011a	8b 4d 0c	 mov	 ecx, DWORD PTR _p$[ebp]
  0011d	51		 push	 ecx
  0011e	8b 55 0c	 mov	 edx, DWORD PTR _p$[ebp]
  00121	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  00124	ff d0		 call	 eax
  00126	83 c4 04	 add	 esp, 4
  00129	3b f4		 cmp	 esi, esp
  0012b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00130	0f b6 c8	 movzx	 ecx, al
  00133	85 c9		 test	 ecx, ecx
  00135	75 35		 jne	 SHORT $LN8@toStringWo

; 861  : 	{
; 862  : 		buf->addc   (buf, ' ');

  00137	8b f4		 mov	 esi, esp
  00139	6a 20		 push	 32			; 00000020H
  0013b	8b 55 14	 mov	 edx, DWORD PTR _buf$[ebp]
  0013e	52		 push	 edx
  0013f	8b 45 14	 mov	 eax, DWORD PTR _buf$[ebp]
  00142	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  00145	ff d1		 call	 ecx
  00147	83 c4 08	 add	 esp, 8
  0014a	3b f4		 cmp	 esi, esp
  0014c	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 863  : 		buf->addi   (buf, ANTLR3_TOKEN_DOWN);

  00151	8b f4		 mov	 esi, esp
  00153	6a 02		 push	 2
  00155	8b 55 14	 mov	 edx, DWORD PTR _buf$[ebp]
  00158	52		 push	 edx
  00159	8b 45 14	 mov	 eax, DWORD PTR _buf$[ebp]
  0015c	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  0015f	ff d1		 call	 ecx
  00161	83 c4 08	 add	 esp, 8
  00164	3b f4		 cmp	 esi, esp
  00166	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0016b	90		 npad	 1
$LN8@toStringWo:

; 864  : 	}
; 865  : 
; 866  : 	for	(c = 0; c<n ; c++)

  0016c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _c$[ebp], 0
  00173	eb 09		 jmp	 SHORT $LN4@toStringWo
$LN2@toStringWo:
  00175	8b 55 f8	 mov	 edx, DWORD PTR _c$[ebp]
  00178	83 c2 01	 add	 edx, 1
  0017b	89 55 f8	 mov	 DWORD PTR _c$[ebp], edx
$LN4@toStringWo:
  0017e	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  00181	3b 45 fc	 cmp	 eax, DWORD PTR _n$[ebp]
  00184	73 46		 jae	 SHORT $LN3@toStringWo

; 867  : 	{
; 868  : 		pANTLR3_BASE_TREE   child;
; 869  : 
; 870  : 		child = (pANTLR3_BASE_TREE)p->getChild(p, c);

  00186	8b f4		 mov	 esi, esp
  00188	8b 4d f8	 mov	 ecx, DWORD PTR _c$[ebp]
  0018b	51		 push	 ecx
  0018c	8b 55 0c	 mov	 edx, DWORD PTR _p$[ebp]
  0018f	52		 push	 edx
  00190	8b 45 0c	 mov	 eax, DWORD PTR _p$[ebp]
  00193	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00196	ff d1		 call	 ecx
  00198	83 c4 08	 add	 esp, 8
  0019b	3b f4		 cmp	 esi, esp
  0019d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001a2	89 45 f0	 mov	 DWORD PTR _child$1[ebp], eax

; 871  : 		tns->toStringWork(tns, child, stop, buf);

  001a5	8b f4		 mov	 esi, esp
  001a7	8b 55 14	 mov	 edx, DWORD PTR _buf$[ebp]
  001aa	52		 push	 edx
  001ab	8b 45 10	 mov	 eax, DWORD PTR _stop$[ebp]
  001ae	50		 push	 eax
  001af	8b 4d f0	 mov	 ecx, DWORD PTR _child$1[ebp]
  001b2	51		 push	 ecx
  001b3	8b 55 08	 mov	 edx, DWORD PTR _tns$[ebp]
  001b6	52		 push	 edx
  001b7	8b 45 08	 mov	 eax, DWORD PTR _tns$[ebp]
  001ba	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  001bd	ff d1		 call	 ecx
  001bf	83 c4 10	 add	 esp, 16			; 00000010H
  001c2	3b f4		 cmp	 esi, esp
  001c4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001c9	90		 npad	 1

; 872  : 	}

  001ca	eb a9		 jmp	 SHORT $LN2@toStringWo
$LN3@toStringWo:

; 873  : 
; 874  : 	if	(n > 0 && ! p->isNilNode(p) )

  001cc	83 7d fc 00	 cmp	 DWORD PTR _n$[ebp], 0
  001d0	76 54		 jbe	 SHORT $LN9@toStringWo
  001d2	8b f4		 mov	 esi, esp
  001d4	8b 55 0c	 mov	 edx, DWORD PTR _p$[ebp]
  001d7	52		 push	 edx
  001d8	8b 45 0c	 mov	 eax, DWORD PTR _p$[ebp]
  001db	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  001de	ff d1		 call	 ecx
  001e0	83 c4 04	 add	 esp, 4
  001e3	3b f4		 cmp	 esi, esp
  001e5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001ea	0f b6 d0	 movzx	 edx, al
  001ed	85 d2		 test	 edx, edx
  001ef	75 35		 jne	 SHORT $LN9@toStringWo

; 875  : 	{
; 876  : 		buf->addc   (buf, ' ');

  001f1	8b f4		 mov	 esi, esp
  001f3	6a 20		 push	 32			; 00000020H
  001f5	8b 45 14	 mov	 eax, DWORD PTR _buf$[ebp]
  001f8	50		 push	 eax
  001f9	8b 4d 14	 mov	 ecx, DWORD PTR _buf$[ebp]
  001fc	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  001ff	ff d2		 call	 edx
  00201	83 c4 08	 add	 esp, 8
  00204	3b f4		 cmp	 esi, esp
  00206	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 877  : 		buf->addi   (buf, ANTLR3_TOKEN_UP);

  0020b	8b f4		 mov	 esi, esp
  0020d	6a 03		 push	 3
  0020f	8b 45 14	 mov	 eax, DWORD PTR _buf$[ebp]
  00212	50		 push	 eax
  00213	8b 4d 14	 mov	 ecx, DWORD PTR _buf$[ebp]
  00216	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  00219	ff d2		 call	 edx
  0021b	83 c4 08	 add	 esp, 8
  0021e	3b f4		 cmp	 esi, esp
  00220	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00225	90		 npad	 1
$LN9@toStringWo:

; 878  : 	}
; 879  : }

  00226	5e		 pop	 esi
  00227	83 c4 10	 add	 esp, 16			; 00000010H
  0022a	3b ec		 cmp	 ebp, esp
  0022c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00231	8b e5		 mov	 esp, ebp
  00233	5d		 pop	 ebp
  00234	c3		 ret	 0
_toStringWork ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontreenodestream.c
;	COMDAT _toStringSS
_TEXT	SEGMENT
_buf$ = -4						; size = 4
_tns$ = 8						; size = 4
_start$ = 12						; size = 4
_stop$ = 16						; size = 4
_toStringSS PROC					; COMDAT

; 819  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 820  :     pANTLR3_STRING  buf;
; 821  : 
; 822  :     buf = tns->ctns->stringFactory->newRaw(tns->ctns->stringFactory);

  0000c	8b 45 08	 mov	 eax, DWORD PTR _tns$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	8b f4		 mov	 esi, esp
  00013	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00016	52		 push	 edx
  00017	8b 45 08	 mov	 eax, DWORD PTR _tns$[ebp]
  0001a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001c	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0001f	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00022	ff d0		 call	 eax
  00024	83 c4 04	 add	 esp, 4
  00027	3b f4		 cmp	 esi, esp
  00029	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002e	89 45 fc	 mov	 DWORD PTR _buf$[ebp], eax

; 823  : 
; 824  :     tns->toStringWork(tns, start, stop, buf);

  00031	8b f4		 mov	 esi, esp
  00033	8b 4d fc	 mov	 ecx, DWORD PTR _buf$[ebp]
  00036	51		 push	 ecx
  00037	8b 55 10	 mov	 edx, DWORD PTR _stop$[ebp]
  0003a	52		 push	 edx
  0003b	8b 45 0c	 mov	 eax, DWORD PTR _start$[ebp]
  0003e	50		 push	 eax
  0003f	8b 4d 08	 mov	 ecx, DWORD PTR _tns$[ebp]
  00042	51		 push	 ecx
  00043	8b 55 08	 mov	 edx, DWORD PTR _tns$[ebp]
  00046	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00049	ff d0		 call	 eax
  0004b	83 c4 10	 add	 esp, 16			; 00000010H
  0004e	3b f4		 cmp	 esi, esp
  00050	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 825  : 
; 826  :     return  buf;

  00055	8b 45 fc	 mov	 eax, DWORD PTR _buf$[ebp]

; 827  : }

  00058	5e		 pop	 esi
  00059	83 c4 04	 add	 esp, 4
  0005c	3b ec		 cmp	 ebp, esp
  0005e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
_toStringSS ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontreenodestream.c
;	COMDAT _toString
_TEXT	SEGMENT
_tns$ = 8						; size = 4
_toString PROC						; COMDAT

; 812  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 813  : 
; 814  :     return  tns->toStringSS(tns, tns->ctns->root, NULL);

  00004	8b f4		 mov	 esi, esp
  00006	6a 00		 push	 0
  00008	8b 45 08	 mov	 eax, DWORD PTR _tns$[ebp]
  0000b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000d	8b 91 84 02 00
	00		 mov	 edx, DWORD PTR [ecx+644]
  00013	52		 push	 edx
  00014	8b 45 08	 mov	 eax, DWORD PTR _tns$[ebp]
  00017	50		 push	 eax
  00018	8b 4d 08	 mov	 ecx, DWORD PTR _tns$[ebp]
  0001b	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0001e	ff d2		 call	 edx
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	3b f4		 cmp	 esi, esp
  00025	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 815  : }

  0002a	5e		 pop	 esi
  0002b	3b ec		 cmp	 ebp, esp
  0002d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
_toString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontreenodestream.c
;	COMDAT _setUniqueNavigationNodes
_TEXT	SEGMENT
_tns$ = 8						; size = 4
_uniqueNavigationNodes$ = 12				; size = 1
_setUniqueNavigationNodes PROC				; COMDAT

; 801  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 802  :     tns->ctns->uniqueNavigationNodes = uniqueNavigationNodes;

  00003	8b 45 08	 mov	 eax, DWORD PTR _tns$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	8a 55 0c	 mov	 dl, BYTE PTR _uniqueNavigationNodes$[ebp]
  0000b	88 91 80 02 00
	00		 mov	 BYTE PTR [ecx+640], dl

; 803  : }

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
_setUniqueNavigationNodes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontreenodestream.c
;	COMDAT _get
_TEXT	SEGMENT
_tns$ = 8						; size = 4
_k$ = 12						; size = 4
_get	PROC						; COMDAT

; 944  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 945  : 	if	(tns->ctns->p == -1)

  00004	8b 45 08	 mov	 eax, DWORD PTR _tns$[ebp]
  00007	8b 08		 mov	 ecx, DWORD PTR [eax]
  00009	83 b9 90 02 00
	00 ff		 cmp	 DWORD PTR [ecx+656], -1
  00010	75 0e		 jne	 SHORT $LN2@get

; 946  : 	{
; 947  : 		fillBufferRoot(tns->ctns);

  00012	8b 55 08	 mov	 edx, DWORD PTR _tns$[ebp]
  00015	8b 02		 mov	 eax, DWORD PTR [edx]
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 _fillBufferRoot
  0001d	83 c4 04	 add	 esp, 4
$LN2@get:

; 948  : 	}
; 949  : 
; 950  : 	return (pANTLR3_BASE_TREE)tns->ctns->nodes->get(tns->ctns->nodes, k);

  00020	8b f4		 mov	 esi, esp
  00022	8b 4d 0c	 mov	 ecx, DWORD PTR _k$[ebp]
  00025	51		 push	 ecx
  00026	8b 55 08	 mov	 edx, DWORD PTR _tns$[ebp]
  00029	8b 02		 mov	 eax, DWORD PTR [edx]
  0002b	8b 88 7c 02 00
	00		 mov	 ecx, DWORD PTR [eax+636]
  00031	51		 push	 ecx
  00032	8b 55 08	 mov	 edx, DWORD PTR _tns$[ebp]
  00035	8b 02		 mov	 eax, DWORD PTR [edx]
  00037	8b 88 7c 02 00
	00		 mov	 ecx, DWORD PTR [eax+636]
  0003d	8b 91 98 00 00
	00		 mov	 edx, DWORD PTR [ecx+152]
  00043	ff d2		 call	 edx
  00045	83 c4 08	 add	 esp, 8
  00048	3b f4		 cmp	 esi, esp
  0004a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 951  : }

  0004f	5e		 pop	 esi
  00050	3b ec		 cmp	 ebp, esp
  00052	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
_get	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontreenodestream.c
;	COMDAT __LT
_TEXT	SEGMENT
_tns$ = 8						; size = 4
_k$ = 12						; size = 4
__LT	PROC						; COMDAT

; 578  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 579  : 	if	(tns->ctns->p == -1)

  00004	8b 45 08	 mov	 eax, DWORD PTR _tns$[ebp]
  00007	8b 08		 mov	 ecx, DWORD PTR [eax]
  00009	83 b9 90 02 00
	00 ff		 cmp	 DWORD PTR [ecx+656], -1
  00010	75 0e		 jne	 SHORT $LN2@LT

; 580  : 	{
; 581  : 		fillBufferRoot(tns->ctns);

  00012	8b 55 08	 mov	 edx, DWORD PTR _tns$[ebp]
  00015	8b 02		 mov	 eax, DWORD PTR [edx]
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 _fillBufferRoot
  0001d	83 c4 04	 add	 esp, 4
$LN2@LT:

; 582  : 	}
; 583  : 
; 584  : 	if	(k < 0)

  00020	83 7d 0c 00	 cmp	 DWORD PTR _k$[ebp], 0
  00024	7d 19		 jge	 SHORT $LN3@LT

; 585  : 	{
; 586  : 		return LB(tns, -k);

  00026	8b 4d 0c	 mov	 ecx, DWORD PTR _k$[ebp]
  00029	f7 d9		 neg	 ecx
  0002b	51		 push	 ecx
  0002c	8b 55 08	 mov	 edx, DWORD PTR _tns$[ebp]
  0002f	52		 push	 edx
  00030	e8 00 00 00 00	 call	 _LB
  00035	83 c4 08	 add	 esp, 8
  00038	e9 80 00 00 00	 jmp	 $LN1@LT

; 587  : 	}

  0003d	eb 12		 jmp	 SHORT $LN5@LT
$LN3@LT:

; 588  : 	else if	(k == 0)

  0003f	83 7d 0c 00	 cmp	 DWORD PTR _k$[ebp], 0
  00043	75 0c		 jne	 SHORT $LN5@LT

; 589  : 	{
; 590  : 		return	&(tns->ctns->INVALID_NODE.baseTree);

  00045	8b 45 08	 mov	 eax, DWORD PTR _tns$[ebp]
  00048	8b 00		 mov	 eax, DWORD PTR [eax]
  0004a	05 fc 01 00 00	 add	 eax, 508		; 000001fcH
  0004f	eb 6c		 jmp	 SHORT $LN1@LT
$LN5@LT:

; 591  : 	}
; 592  : 
; 593  : 	// k was a legitimate request, 
; 594  : 	//
; 595  : 	if	(( tns->ctns->p + k - 1) >= (ANTLR3_INT32)(tns->ctns->nodes->count))

  00051	8b 4d 08	 mov	 ecx, DWORD PTR _tns$[ebp]
  00054	8b 11		 mov	 edx, DWORD PTR [ecx]
  00056	8b 82 90 02 00
	00		 mov	 eax, DWORD PTR [edx+656]
  0005c	8b 4d 0c	 mov	 ecx, DWORD PTR _k$[ebp]
  0005f	8d 54 08 ff	 lea	 edx, DWORD PTR [eax+ecx-1]
  00063	8b 45 08	 mov	 eax, DWORD PTR _tns$[ebp]
  00066	8b 08		 mov	 ecx, DWORD PTR [eax]
  00068	8b 81 7c 02 00
	00		 mov	 eax, DWORD PTR [ecx+636]
  0006e	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  00071	7c 0c		 jl	 SHORT $LN6@LT

; 596  : 	{
; 597  : 		return &(tns->ctns->EOF_NODE.baseTree);

  00073	8b 4d 08	 mov	 ecx, DWORD PTR _tns$[ebp]
  00076	8b 01		 mov	 eax, DWORD PTR [ecx]
  00078	05 60 01 00 00	 add	 eax, 352		; 00000160H
  0007d	eb 3e		 jmp	 SHORT $LN1@LT
$LN6@LT:

; 598  : 	}
; 599  : 
; 600  : 	return	(pANTLR3_BASE_TREE)tns->ctns->nodes->get(tns->ctns->nodes, tns->ctns->p + k - 1);

  0007f	8b 55 08	 mov	 edx, DWORD PTR _tns$[ebp]
  00082	8b 02		 mov	 eax, DWORD PTR [edx]
  00084	8b 88 90 02 00
	00		 mov	 ecx, DWORD PTR [eax+656]
  0008a	8b 55 0c	 mov	 edx, DWORD PTR _k$[ebp]
  0008d	8d 44 11 ff	 lea	 eax, DWORD PTR [ecx+edx-1]
  00091	8b f4		 mov	 esi, esp
  00093	50		 push	 eax
  00094	8b 4d 08	 mov	 ecx, DWORD PTR _tns$[ebp]
  00097	8b 11		 mov	 edx, DWORD PTR [ecx]
  00099	8b 82 7c 02 00
	00		 mov	 eax, DWORD PTR [edx+636]
  0009f	50		 push	 eax
  000a0	8b 4d 08	 mov	 ecx, DWORD PTR _tns$[ebp]
  000a3	8b 11		 mov	 edx, DWORD PTR [ecx]
  000a5	8b 82 7c 02 00
	00		 mov	 eax, DWORD PTR [edx+636]
  000ab	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [eax+152]
  000b1	ff d1		 call	 ecx
  000b3	83 c4 08	 add	 esp, 8
  000b6	3b f4		 cmp	 esi, esp
  000b8	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@LT:

; 601  : }

  000bd	5e		 pop	 esi
  000be	3b ec		 cmp	 ebp, esp
  000c0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c5	5d		 pop	 ebp
  000c6	c3		 ret	 0
__LT	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontreenodestream.c
;	COMDAT _getTreeSource
_TEXT	SEGMENT
_tns$ = 8						; size = 4
_getTreeSource PROC					; COMDAT

; 608  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 609  :     return  tns->ctns->root;

  00003	8b 45 08	 mov	 eax, DWORD PTR _tns$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	8b 81 84 02 00
	00		 mov	 eax, DWORD PTR [ecx+644]

; 610  : }

  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
_getTreeSource ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontreenodestream.c
;	COMDAT _getTreeAdaptor
_TEXT	SEGMENT
_tns$ = 8						; size = 4
_getTreeAdaptor PROC					; COMDAT

; 789  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 790  :     return  tns->ctns->adaptor;

  00003	8b 45 08	 mov	 eax, DWORD PTR _tns$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	8b 81 88 02 00
	00		 mov	 eax, DWORD PTR [ecx+648]

; 791  : }

  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
_getTreeAdaptor ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontreenodestream.c
;	COMDAT _getLookaheadSize
_TEXT	SEGMENT
tv75 = -4						; size = 4
_ctns$ = 8						; size = 4
_getLookaheadSize PROC					; COMDAT

; 883  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 884  :     return	ctns->tail < ctns->head 

  00004	8b 45 08	 mov	 eax, DWORD PTR _ctns$[ebp]
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _ctns$[ebp]
  0000a	8b 90 b0 02 00
	00		 mov	 edx, DWORD PTR [eax+688]
  00010	3b 91 ac 02 00
	00		 cmp	 edx, DWORD PTR [ecx+684]
  00016	73 20		 jae	 SHORT $LN3@getLookahe
  00018	8b 45 08	 mov	 eax, DWORD PTR _ctns$[ebp]
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR _ctns$[ebp]
  0001e	8b 90 a8 02 00
	00		 mov	 edx, DWORD PTR [eax+680]
  00024	2b 91 ac 02 00
	00		 sub	 edx, DWORD PTR [ecx+684]
  0002a	8b 45 08	 mov	 eax, DWORD PTR _ctns$[ebp]
  0002d	03 90 b0 02 00
	00		 add	 edx, DWORD PTR [eax+688]
  00033	89 55 fc	 mov	 DWORD PTR tv75[ebp], edx
  00036	eb 15		 jmp	 SHORT $LN4@getLookahe
$LN3@getLookahe:
  00038	8b 4d 08	 mov	 ecx, DWORD PTR _ctns$[ebp]
  0003b	8b 55 08	 mov	 edx, DWORD PTR _ctns$[ebp]
  0003e	8b 81 b0 02 00
	00		 mov	 eax, DWORD PTR [ecx+688]
  00044	2b 82 ac 02 00
	00		 sub	 eax, DWORD PTR [edx+684]
  0004a	89 45 fc	 mov	 DWORD PTR tv75[ebp], eax
$LN4@getLookahe:
  0004d	8b 45 fc	 mov	 eax, DWORD PTR tv75[ebp]

; 885  : 	    ?	(ctns->lookAheadLength - ctns->head + ctns->tail)
; 886  : 	    :	(ctns->tail - ctns->head);
; 887  : }

  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
_getLookaheadSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontreenodestream.c
;	COMDAT _pop
_TEXT	SEGMENT
_retVal$ = -4						; size = 4
_ctns$ = 8						; size = 4
_pop	PROC						; COMDAT

; 962  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 963  : 	ANTLR3_INT32	retVal;
; 964  : 
; 965  : 	retVal = ANTLR3_UINT32_CAST(ctns->nodeStack->pop(ctns->nodeStack));

  0000c	8b f4		 mov	 esi, esp
  0000e	8b 45 08	 mov	 eax, DWORD PTR _ctns$[ebp]
  00011	8b 88 8c 02 00
	00		 mov	 ecx, DWORD PTR [eax+652]
  00017	51		 push	 ecx
  00018	8b 55 08	 mov	 edx, DWORD PTR _ctns$[ebp]
  0001b	8b 82 8c 02 00
	00		 mov	 eax, DWORD PTR [edx+652]
  00021	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00024	ff d1		 call	 ecx
  00026	83 c4 04	 add	 esp, 4
  00029	3b f4		 cmp	 esi, esp
  0002b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00030	89 45 fc	 mov	 DWORD PTR _retVal$[ebp], eax

; 966  : 	ctns->tnstream->istream->seek(ctns->tnstream->istream, retVal);

  00033	8b f4		 mov	 esi, esp
  00035	8b 55 fc	 mov	 edx, DWORD PTR _retVal$[ebp]
  00038	52		 push	 edx
  00039	8b 45 08	 mov	 eax, DWORD PTR _ctns$[ebp]
  0003c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00042	52		 push	 edx
  00043	8b 45 08	 mov	 eax, DWORD PTR _ctns$[ebp]
  00046	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00049	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0004c	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  0004f	ff d0		 call	 eax
  00051	83 c4 08	 add	 esp, 8
  00054	3b f4		 cmp	 esi, esp
  00056	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 967  : 	return retVal;

  0005b	8b 45 fc	 mov	 eax, DWORD PTR _retVal$[ebp]

; 968  : }

  0005e	5e		 pop	 esi
  0005f	83 c4 04	 add	 esp, 4
  00062	3b ec		 cmp	 ebp, esp
  00064	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
_pop	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontreenodestream.c
;	COMDAT _push
_TEXT	SEGMENT
_ctns$ = 8						; size = 4
_index$ = 12						; size = 4
_push	PROC						; COMDAT

; 955  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 956  : 	ctns->nodeStack->push(ctns->nodeStack, ANTLR3_FUNC_PTR(ctns->p), NULL);	// Save current index

  00004	8b f4		 mov	 esi, esp
  00006	6a 00		 push	 0
  00008	8b 45 08	 mov	 eax, DWORD PTR _ctns$[ebp]
  0000b	8b 88 90 02 00
	00		 mov	 ecx, DWORD PTR [eax+656]
  00011	51		 push	 ecx
  00012	8b 55 08	 mov	 edx, DWORD PTR _ctns$[ebp]
  00015	8b 82 8c 02 00
	00		 mov	 eax, DWORD PTR [edx+652]
  0001b	50		 push	 eax
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR _ctns$[ebp]
  0001f	8b 91 8c 02 00
	00		 mov	 edx, DWORD PTR [ecx+652]
  00025	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00028	ff d0		 call	 eax
  0002a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002d	3b f4		 cmp	 esi, esp
  0002f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 957  : 	ctns->tnstream->istream->seek(ctns->tnstream->istream, index);

  00034	8b f4		 mov	 esi, esp
  00036	8b 4d 0c	 mov	 ecx, DWORD PTR _index$[ebp]
  00039	51		 push	 ecx
  0003a	8b 55 08	 mov	 edx, DWORD PTR _ctns$[ebp]
  0003d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00040	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00043	51		 push	 ecx
  00044	8b 55 08	 mov	 edx, DWORD PTR _ctns$[ebp]
  00047	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0004a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0004d	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00050	ff d2		 call	 edx
  00052	83 c4 08	 add	 esp, 8
  00055	3b f4		 cmp	 esi, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005c	90		 npad	 1

; 958  : }

  0005d	5e		 pop	 esi
  0005e	3b ec		 cmp	 ebp, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
_push	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontreenodestream.c
;	COMDAT _reset
_TEXT	SEGMENT
_ctns$ = 8						; size = 4
_reset	PROC						; COMDAT

; 527  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 528  : 	if	(ctns->p != -1)

  00004	8b 45 08	 mov	 eax, DWORD PTR _ctns$[ebp]
  00007	83 b8 90 02 00
	00 ff		 cmp	 DWORD PTR [eax+656], -1
  0000e	74 0d		 je	 SHORT $LN2@reset

; 529  : 	{
; 530  : 		ctns->p									= 0;

  00010	8b 4d 08	 mov	 ecx, DWORD PTR _ctns$[ebp]
  00013	c7 81 90 02 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+656], 0
$LN2@reset:

; 531  : 	}
; 532  : 	ctns->tnstream->istream->lastMarker		= 0;

  0001d	8b 55 08	 mov	 edx, DWORD PTR _ctns$[ebp]
  00020	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00023	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00026	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 533  : 
; 534  : 
; 535  : 	// Free and reset the node stack only if this is not
; 536  : 	// a rewriter, which is going to reuse the originating
; 537  : 	// node streams node stack
; 538  : 	//
; 539  : 	if  (ctns->isRewriter != ANTLR3_TRUE)

  0002d	8b 55 08	 mov	 edx, DWORD PTR _ctns$[ebp]
  00030	0f b6 82 f8 02
	00 00		 movzx	 eax, BYTE PTR [edx+760]
  00037	83 f8 01	 cmp	 eax, 1
  0003a	74 43		 je	 SHORT $LN4@reset

; 540  :     {
; 541  : 		if	(ctns->nodeStack != NULL)

  0003c	8b 4d 08	 mov	 ecx, DWORD PTR _ctns$[ebp]
  0003f	83 b9 8c 02 00
	00 00		 cmp	 DWORD PTR [ecx+652], 0
  00046	74 37		 je	 SHORT $LN4@reset

; 542  : 		{
; 543  : 			ctns->nodeStack->free(ctns->nodeStack);

  00048	8b f4		 mov	 esi, esp
  0004a	8b 55 08	 mov	 edx, DWORD PTR _ctns$[ebp]
  0004d	8b 82 8c 02 00
	00		 mov	 eax, DWORD PTR [edx+652]
  00053	50		 push	 eax
  00054	8b 4d 08	 mov	 ecx, DWORD PTR _ctns$[ebp]
  00057	8b 91 8c 02 00
	00		 mov	 edx, DWORD PTR [ecx+652]
  0005d	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00060	ff d0		 call	 eax
  00062	83 c4 04	 add	 esp, 4
  00065	3b f4		 cmp	 esi, esp
  00067	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 544  : 			ctns->nodeStack = antlr3StackNew(INITIAL_CALL_STACK_SIZE);

  0006c	6a 0a		 push	 10			; 0000000aH
  0006e	e8 00 00 00 00	 call	 _antlr3StackNew
  00073	83 c4 04	 add	 esp, 4
  00076	8b 4d 08	 mov	 ecx, DWORD PTR _ctns$[ebp]
  00079	89 81 8c 02 00
	00		 mov	 DWORD PTR [ecx+652], eax
$LN4@reset:

; 545  : 		}
; 546  : 	}
; 547  : }

  0007f	5e		 pop	 esi
  00080	3b ec		 cmp	 ebp, esp
  00082	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
_reset	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontreenodestream.c
;	COMDAT _newUpNode
_TEXT	SEGMENT
_token$ = -8						; size = 4
_uNode$ = -4						; size = 4
_ctns$ = 8						; size = 4
_newUpNode PROC						; COMDAT

; 905  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 906  :     pANTLR3_COMMON_TREE	    uNode;
; 907  :     pANTLR3_COMMON_TOKEN    token;
; 908  : 
; 909  :     token					= antlr3CommonTokenNew(ANTLR3_TOKEN_UP);

  00014	6a 03		 push	 3
  00016	e8 00 00 00 00	 call	 _antlr3CommonTokenNew
  0001b	83 c4 04	 add	 esp, 4
  0001e	89 45 f8	 mov	 DWORD PTR _token$[ebp], eax

; 910  : 	token->textState		= ANTLR3_TEXT_CHARP;

  00021	8b 45 f8	 mov	 eax, DWORD PTR _token$[ebp]
  00024	c7 40 2c 01 00
	00 00		 mov	 DWORD PTR [eax+44], 1

; 911  : 	token->tokText.chars	= (pANTLR3_UCHAR)"UP";

  0002b	8b 4d f8	 mov	 ecx, DWORD PTR _token$[ebp]
  0002e	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], OFFSET ??_C@_02NAHCJHOC@UP@

; 912  :     uNode					= antlr3CommonTreeNewFromToken(token);

  00035	8b 55 f8	 mov	 edx, DWORD PTR _token$[ebp]
  00038	52		 push	 edx
  00039	e8 00 00 00 00	 call	 _antlr3CommonTreeNewFromToken
  0003e	83 c4 04	 add	 esp, 4
  00041	89 45 fc	 mov	 DWORD PTR _uNode$[ebp], eax

; 913  : 
; 914  :     return  &(uNode->baseTree);

  00044	8b 45 fc	 mov	 eax, DWORD PTR _uNode$[ebp]
  00047	83 c0 1c	 add	 eax, 28			; 0000001cH

; 915  : }

  0004a	83 c4 08	 add	 esp, 8
  0004d	3b ec		 cmp	 ebp, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
_newUpNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontreenodestream.c
;	COMDAT _newDownNode
_TEXT	SEGMENT
_token$ = -8						; size = 4
_dNode$ = -4						; size = 4
_ctns$ = 8						; size = 4
_newDownNode PROC					; COMDAT

; 891  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 892  :     pANTLR3_COMMON_TREE	    dNode;
; 893  :     pANTLR3_COMMON_TOKEN    token;
; 894  : 
; 895  :     token					= antlr3CommonTokenNew(ANTLR3_TOKEN_DOWN);

  00014	6a 02		 push	 2
  00016	e8 00 00 00 00	 call	 _antlr3CommonTokenNew
  0001b	83 c4 04	 add	 esp, 4
  0001e	89 45 f8	 mov	 DWORD PTR _token$[ebp], eax

; 896  : 	token->textState		= ANTLR3_TEXT_CHARP;

  00021	8b 45 f8	 mov	 eax, DWORD PTR _token$[ebp]
  00024	c7 40 2c 01 00
	00 00		 mov	 DWORD PTR [eax+44], 1

; 897  : 	token->tokText.chars	= (pANTLR3_UCHAR)"DOWN";

  0002b	8b 4d f8	 mov	 ecx, DWORD PTR _token$[ebp]
  0002e	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], OFFSET ??_C@_04FANAOELO@DOWN@

; 898  :     dNode					= antlr3CommonTreeNewFromToken(token);

  00035	8b 55 f8	 mov	 edx, DWORD PTR _token$[ebp]
  00038	52		 push	 edx
  00039	e8 00 00 00 00	 call	 _antlr3CommonTreeNewFromToken
  0003e	83 c4 04	 add	 esp, 4
  00041	89 45 fc	 mov	 DWORD PTR _dNode$[ebp], eax

; 899  : 
; 900  :     return  &(dNode->baseTree);

  00044	8b 45 fc	 mov	 eax, DWORD PTR _dNode$[ebp]
  00047	83 c0 1c	 add	 eax, 28			; 0000001cH

; 901  : }

  0004a	83 c4 08	 add	 esp, 8
  0004d	3b ec		 cmp	 ebp, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
_newDownNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontreenodestream.c
;	COMDAT _hasUniqueNavigationNodes
_TEXT	SEGMENT
_ctns$ = 8						; size = 4
_hasUniqueNavigationNodes PROC				; COMDAT

; 795  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 796  :     return  ctns->uniqueNavigationNodes;

  00003	8b 45 08	 mov	 eax, DWORD PTR _ctns$[ebp]
  00006	0f b6 80 80 02
	00 00		 movzx	 eax, BYTE PTR [eax+640]

; 797  : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
_hasUniqueNavigationNodes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontreenodestream.c
;	COMDAT _addNavigationNode
_TEXT	SEGMENT
_node$ = -4						; size = 4
_ctns$ = 8						; size = 4
_ttype$ = 12						; size = 4
_addNavigationNode PROC					; COMDAT

; 753  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 754  : 	pANTLR3_BASE_TREE	    node;
; 755  : 
; 756  : 	node = NULL;

  0000c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _node$[ebp], 0

; 757  : 
; 758  : 	if	(ttype == ANTLR3_TOKEN_DOWN)

  00013	83 7d 0c 02	 cmp	 DWORD PTR _ttype$[ebp], 2
  00017	75 4e		 jne	 SHORT $LN2@addNavigat

; 759  : 	{
; 760  : 		if  (ctns->hasUniqueNavigationNodes(ctns) == ANTLR3_TRUE)

  00019	8b f4		 mov	 esi, esp
  0001b	8b 45 08	 mov	 eax, DWORD PTR _ctns$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 08	 mov	 ecx, DWORD PTR _ctns$[ebp]
  00022	8b 91 e0 02 00
	00		 mov	 edx, DWORD PTR [ecx+736]
  00028	ff d2		 call	 edx
  0002a	83 c4 04	 add	 esp, 4
  0002d	3b f4		 cmp	 esi, esp
  0002f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00034	0f b6 c0	 movzx	 eax, al
  00037	83 f8 01	 cmp	 eax, 1
  0003a	75 20		 jne	 SHORT $LN4@addNavigat

; 761  : 		{
; 762  : 			node    = ctns->newDownNode(ctns);

  0003c	8b f4		 mov	 esi, esp
  0003e	8b 4d 08	 mov	 ecx, DWORD PTR _ctns$[ebp]
  00041	51		 push	 ecx
  00042	8b 55 08	 mov	 edx, DWORD PTR _ctns$[ebp]
  00045	8b 82 d4 02 00
	00		 mov	 eax, DWORD PTR [edx+724]
  0004b	ff d0		 call	 eax
  0004d	83 c4 04	 add	 esp, 4
  00050	3b f4		 cmp	 esi, esp
  00052	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00057	89 45 fc	 mov	 DWORD PTR _node$[ebp], eax

; 763  : 		}

  0005a	eb 09		 jmp	 SHORT $LN5@addNavigat
$LN4@addNavigat:

; 764  : 		else
; 765  : 		{
; 766  : 			node    = &(ctns->DOWN.baseTree);

  0005c	8b 4d 08	 mov	 ecx, DWORD PTR _ctns$[ebp]
  0005f	83 c1 28	 add	 ecx, 40			; 00000028H
  00062	89 4d fc	 mov	 DWORD PTR _node$[ebp], ecx
$LN5@addNavigat:

; 767  : 		}
; 768  : 	}

  00065	eb 4e		 jmp	 SHORT $LN7@addNavigat
$LN2@addNavigat:

; 769  : 	else
; 770  : 	{
; 771  : 		if  (ctns->hasUniqueNavigationNodes(ctns) == ANTLR3_TRUE)

  00067	8b f4		 mov	 esi, esp
  00069	8b 55 08	 mov	 edx, DWORD PTR _ctns$[ebp]
  0006c	52		 push	 edx
  0006d	8b 45 08	 mov	 eax, DWORD PTR _ctns$[ebp]
  00070	8b 88 e0 02 00
	00		 mov	 ecx, DWORD PTR [eax+736]
  00076	ff d1		 call	 ecx
  00078	83 c4 04	 add	 esp, 4
  0007b	3b f4		 cmp	 esi, esp
  0007d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00082	0f b6 d0	 movzx	 edx, al
  00085	83 fa 01	 cmp	 edx, 1
  00088	75 20		 jne	 SHORT $LN6@addNavigat

; 772  : 		{
; 773  : 			node    = ctns->newUpNode(ctns);

  0008a	8b f4		 mov	 esi, esp
  0008c	8b 45 08	 mov	 eax, DWORD PTR _ctns$[ebp]
  0008f	50		 push	 eax
  00090	8b 4d 08	 mov	 ecx, DWORD PTR _ctns$[ebp]
  00093	8b 91 d8 02 00
	00		 mov	 edx, DWORD PTR [ecx+728]
  00099	ff d2		 call	 edx
  0009b	83 c4 04	 add	 esp, 4
  0009e	3b f4		 cmp	 esi, esp
  000a0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a5	89 45 fc	 mov	 DWORD PTR _node$[ebp], eax

; 774  : 		}

  000a8	eb 0b		 jmp	 SHORT $LN7@addNavigat
$LN6@addNavigat:

; 775  : 		else
; 776  : 		{
; 777  : 			node    = &(ctns->UP.baseTree);

  000aa	8b 45 08	 mov	 eax, DWORD PTR _ctns$[ebp]
  000ad	05 c4 00 00 00	 add	 eax, 196		; 000000c4H
  000b2	89 45 fc	 mov	 DWORD PTR _node$[ebp], eax
$LN7@addNavigat:

; 778  : 		}
; 779  : 	}
; 780  : 
; 781  : 	// Now add the node we decided upon.
; 782  : 	//
; 783  : 	ctns->nodes->add(ctns->nodes, node, NULL);

  000b5	8b f4		 mov	 esi, esp
  000b7	6a 00		 push	 0
  000b9	8b 4d fc	 mov	 ecx, DWORD PTR _node$[ebp]
  000bc	51		 push	 ecx
  000bd	8b 55 08	 mov	 edx, DWORD PTR _ctns$[ebp]
  000c0	8b 82 7c 02 00
	00		 mov	 eax, DWORD PTR [edx+636]
  000c6	50		 push	 eax
  000c7	8b 4d 08	 mov	 ecx, DWORD PTR _ctns$[ebp]
  000ca	8b 91 7c 02 00
	00		 mov	 edx, DWORD PTR [ecx+636]
  000d0	8b 82 a8 00 00
	00		 mov	 eax, DWORD PTR [edx+168]
  000d6	ff d0		 call	 eax
  000d8	83 c4 0c	 add	 esp, 12			; 0000000cH
  000db	3b f4		 cmp	 esi, esp
  000dd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e2	90		 npad	 1

; 784  : }

  000e3	5e		 pop	 esi
  000e4	83 c4 04	 add	 esp, 4
  000e7	3b ec		 cmp	 ebp, esp
  000e9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ee	8b e5		 mov	 esp, ebp
  000f0	5d		 pop	 ebp
  000f1	c3		 ret	 0
_addNavigationNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontreenodestream.c
;	COMDAT _antlr3TreeNodeStreamNew
_TEXT	SEGMENT
_stream$ = -4						; size = 4
_antlr3TreeNodeStreamNew PROC				; COMDAT

; 89   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 90   :     pANTLR3_TREE_NODE_STREAM stream;
; 91   : 
; 92   :     // Memory for the interface structure
; 93   :     //
; 94   :     stream  = (pANTLR3_TREE_NODE_STREAM) ANTLR3_CALLOC(1, sizeof(ANTLR3_TREE_NODE_STREAM));

  0000c	8b f4		 mov	 esi, esp
  0000e	6a 30		 push	 48			; 00000030H
  00010	6a 01		 push	 1
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__calloc
  00018	83 c4 08	 add	 esp, 8
  0001b	3b f4		 cmp	 esi, esp
  0001d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00022	89 45 fc	 mov	 DWORD PTR _stream$[ebp], eax

; 95   : 
; 96   :     if	(stream == NULL)

  00025	83 7d fc 00	 cmp	 DWORD PTR _stream$[ebp], 0
  00029	75 04		 jne	 SHORT $LN2@antlr3Tree

; 97   :     {
; 98   : 		return	NULL;

  0002b	33 c0		 xor	 eax, eax
  0002d	eb 17		 jmp	 SHORT $LN1@antlr3Tree
$LN2@antlr3Tree:

; 99   :     }
; 100  : 
; 101  :     // Install basic API 
; 102  :     //
; 103  : 	stream->replaceChildren = replaceChildren;

  0002f	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  00032	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], OFFSET _replaceChildren

; 104  :     stream->free			= antlr3TreeNodeStreamFree;

  00039	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  0003c	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], OFFSET _antlr3TreeNodeStreamFree

; 105  :     
; 106  :     return stream;

  00043	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
$LN1@antlr3Tree:

; 107  : }

  00046	5e		 pop	 esi
  00047	83 c4 04	 add	 esp, 4
  0004a	3b ec		 cmp	 ebp, esp
  0004c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
_antlr3TreeNodeStreamNew ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontreenodestream.c
;	COMDAT _antlr3CommonTreeNodeStreamNewStream
_TEXT	SEGMENT
_stream$ = -4						; size = 4
_inStream$ = 8						; size = 4
_antlr3CommonTreeNodeStreamNewStream PROC		; COMDAT

; 133  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 134  : 	pANTLR3_COMMON_TREE_NODE_STREAM stream;
; 135  : 
; 136  : 	// Memory for the interface structure
; 137  : 	//
; 138  : 	stream  = (pANTLR3_COMMON_TREE_NODE_STREAM) ANTLR3_CALLOC(1, sizeof(ANTLR3_COMMON_TREE_NODE_STREAM));

  0000c	8b f4		 mov	 esi, esp
  0000e	68 fc 02 00 00	 push	 764			; 000002fcH
  00013	6a 01		 push	 1
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__calloc
  0001b	83 c4 08	 add	 esp, 8
  0001e	3b f4		 cmp	 esi, esp
  00020	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00025	89 45 fc	 mov	 DWORD PTR _stream$[ebp], eax

; 139  : 
; 140  : 	if	(stream == NULL)

  00028	83 7d fc 00	 cmp	 DWORD PTR _stream$[ebp], 0
  0002c	75 07		 jne	 SHORT $LN2@antlr3Comm

; 141  : 	{
; 142  : 		return	NULL;

  0002e	33 c0		 xor	 eax, eax
  00030	e9 82 03 00 00	 jmp	 $LN1@antlr3Comm
$LN2@antlr3Comm:

; 143  : 	}
; 144  : 
; 145  : 	// Copy in all the reusable parts of the originating stream and create new
; 146  : 	// pieces where necessary.
; 147  : 	//
; 148  : 
; 149  : 	// String factory for tree walker
; 150  : 	//
; 151  : 	stream->stringFactory		= inStream->stringFactory;

  00035	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  00038	8b 4d 08	 mov	 ecx, DWORD PTR _inStream$[ebp]
  0003b	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0003e	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 152  : 
; 153  : 	// Create an adaptor for the common tree node stream
; 154  : 	//
; 155  : 	stream->adaptor				= inStream->adaptor;

  00041	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  00044	8b 4d 08	 mov	 ecx, DWORD PTR _inStream$[ebp]
  00047	8b 91 88 02 00
	00		 mov	 edx, DWORD PTR [ecx+648]
  0004d	89 90 88 02 00
	00		 mov	 DWORD PTR [eax+648], edx

; 156  : 
; 157  : 	// Create space for the tree node stream interface
; 158  : 	//
; 159  : 	stream->tnstream	    = antlr3TreeNodeStreamNew();

  00053	e8 00 00 00 00	 call	 _antlr3TreeNodeStreamNew
  00058	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  0005b	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 160  : 
; 161  : 	if	(stream->tnstream == NULL)

  0005e	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  00061	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  00065	75 22		 jne	 SHORT $LN3@antlr3Comm

; 162  : 	{
; 163  : 		stream->free				(stream);

  00067	8b f4		 mov	 esi, esp
  00069	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  0006c	50		 push	 eax
  0006d	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  00070	8b 91 f4 02 00
	00		 mov	 edx, DWORD PTR [ecx+756]
  00076	ff d2		 call	 edx
  00078	83 c4 04	 add	 esp, 4
  0007b	3b f4		 cmp	 esi, esp
  0007d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 164  : 
; 165  : 		return	NULL;

  00082	33 c0		 xor	 eax, eax
  00084	e9 2e 03 00 00	 jmp	 $LN1@antlr3Comm
$LN3@antlr3Comm:

; 166  : 	}
; 167  : 
; 168  : 	// Create space for the INT_STREAM interface
; 169  : 	//
; 170  : 	stream->tnstream->istream		    =  antlr3IntStreamNew();

  00089	e8 00 00 00 00	 call	 _antlr3IntStreamNew
  0008e	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  00091	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00094	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 171  : 
; 172  : 	if	(stream->tnstream->istream == NULL)

  00097	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  0009a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0009d	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  000a1	75 40		 jne	 SHORT $LN4@antlr3Comm

; 173  : 	{
; 174  : 		stream->tnstream->free		(stream->tnstream);

  000a3	8b f4		 mov	 esi, esp
  000a5	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  000a8	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000ab	50		 push	 eax
  000ac	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  000af	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000b2	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  000b5	ff d0		 call	 eax
  000b7	83 c4 04	 add	 esp, 4
  000ba	3b f4		 cmp	 esi, esp
  000bc	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 175  : 		stream->free				(stream);

  000c1	8b f4		 mov	 esi, esp
  000c3	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  000c6	51		 push	 ecx
  000c7	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  000ca	8b 82 f4 02 00
	00		 mov	 eax, DWORD PTR [edx+756]
  000d0	ff d0		 call	 eax
  000d2	83 c4 04	 add	 esp, 4
  000d5	3b f4		 cmp	 esi, esp
  000d7	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 176  : 
; 177  : 		return	NULL;

  000dc	33 c0		 xor	 eax, eax
  000de	e9 d4 02 00 00	 jmp	 $LN1@antlr3Comm
$LN4@antlr3Comm:

; 178  : 	}
; 179  : 
; 180  : 	// Install the common tree node stream API
; 181  : 	//
; 182  : 	stream->addNavigationNode		    =  addNavigationNode;

  000e3	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  000e6	c7 81 d0 02 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+720], OFFSET _addNavigationNode

; 183  : 	stream->hasUniqueNavigationNodes    =  hasUniqueNavigationNodes;

  000f0	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  000f3	c7 82 e0 02 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+736], OFFSET _hasUniqueNavigationNodes

; 184  : 	stream->newDownNode					=  newDownNode;

  000fd	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  00100	c7 80 d4 02 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+724], OFFSET _newDownNode

; 185  : 	stream->newUpNode					=  newUpNode;

  0010a	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  0010d	c7 81 d8 02 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+728], OFFSET _newUpNode

; 186  : 	stream->reset						=  reset;

  00117	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  0011a	c7 82 f0 02 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+752], OFFSET _reset

; 187  : 	stream->push						=  push;

  00124	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  00127	c7 80 e8 02 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+744], OFFSET _push

; 188  : 	stream->pop							=  pop;

  00131	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  00134	c7 81 ec 02 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+748], OFFSET _pop

; 189  : 	stream->getLookaheadSize			=  getLookaheadSize;

  0013e	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  00141	c7 82 e4 02 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+740], OFFSET _getLookaheadSize

; 190  : 
; 191  : 	stream->free			    =  antlr3CommonTreeNodeStreamFree;

  0014b	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  0014e	c7 80 f4 02 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+756], OFFSET _antlr3CommonTreeNodeStreamFree

; 192  : 
; 193  : 	// Install the tree node stream API
; 194  : 	//
; 195  : 	stream->tnstream->getTreeAdaptor			=  getTreeAdaptor;

  00158	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  0015b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0015e	c7 42 10 00 00
	00 00		 mov	 DWORD PTR [edx+16], OFFSET _getTreeAdaptor

; 196  : 	stream->tnstream->getTreeSource				=  getTreeSource;

  00165	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  00168	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0016b	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], OFFSET _getTreeSource

; 197  : 	stream->tnstream->_LT						=  _LT;

  00172	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  00175	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00178	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], OFFSET __LT

; 198  : 	stream->tnstream->setUniqueNavigationNodes	=  setUniqueNavigationNodes;

  0017f	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  00182	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00185	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], OFFSET _setUniqueNavigationNodes

; 199  : 	stream->tnstream->toString					=  toString;

  0018c	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  0018f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00192	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET _toString

; 200  : 	stream->tnstream->toStringSS				=  toStringSS;

  00199	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  0019c	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0019f	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], OFFSET _toStringSS

; 201  : 	stream->tnstream->toStringWork				=  toStringWork;

  001a6	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  001a9	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  001ac	c7 42 20 00 00
	00 00		 mov	 DWORD PTR [edx+32], OFFSET _toStringWork

; 202  : 	stream->tnstream->get						=  get;

  001b3	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  001b6	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001b9	c7 41 28 00 00
	00 00		 mov	 DWORD PTR [ecx+40], OFFSET _get

; 203  : 
; 204  : 	// Install INT_STREAM interface
; 205  : 	//
; 206  : 	stream->tnstream->istream->consume	    =  consume;

  001c0	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  001c3	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  001c6	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001c9	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], OFFSET _consume

; 207  : 	stream->tnstream->istream->index	    =  tindex;

  001d0	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  001d3	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  001d6	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001d9	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], OFFSET _tindex

; 208  : 	stream->tnstream->istream->_LA			=  _LA;

  001e0	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  001e3	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  001e6	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001e9	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET __LA

; 209  : 	stream->tnstream->istream->mark			=  mark;

  001f0	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  001f3	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  001f6	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001f9	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], OFFSET _mark

; 210  : 	stream->tnstream->istream->release	    =  release;

  00200	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  00203	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00206	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00209	c7 41 2c 00 00
	00 00		 mov	 DWORD PTR [ecx+44], OFFSET _release

; 211  : 	stream->tnstream->istream->rewind	    =  rewindMark;

  00210	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  00213	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00216	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00219	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], OFFSET _rewindMark

; 212  : 	stream->tnstream->istream->rewindLast   =  rewindLast;

  00220	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  00223	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00226	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00229	c7 41 28 00 00
	00 00		 mov	 DWORD PTR [ecx+40], OFFSET _rewindLast

; 213  : 	stream->tnstream->istream->seek			=  seek;

  00230	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  00233	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00236	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00239	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], OFFSET _seek

; 214  : 	stream->tnstream->istream->size			=  size;

  00240	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  00243	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00246	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00249	c7 41 34 00 00
	00 00		 mov	 DWORD PTR [ecx+52], OFFSET _size

; 215  : 
; 216  : 	// Initialize data elements of INT stream
; 217  : 	//
; 218  : 	stream->tnstream->istream->type			= ANTLR3_COMMONTREENODE;

  00250	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  00253	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00256	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00259	c7 01 04 00 00
	00		 mov	 DWORD PTR [ecx], 4

; 219  : 	stream->tnstream->istream->super	    =  (stream->tnstream);

  0025f	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  00262	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00265	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00268	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  0026b	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0026e	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 220  : 
; 221  : 	// Initialize data elements of TREE stream
; 222  : 	//
; 223  : 	stream->tnstream->ctns =  stream;

  00271	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  00274	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00277	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  0027a	89 02		 mov	 DWORD PTR [edx], eax

; 224  : 
; 225  : 	// Initialize data elements of the COMMON TREE NODE stream
; 226  : 	//
; 227  : 	stream->super					= NULL;

  0027c	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  0027f	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 228  : 	stream->uniqueNavigationNodes	= ANTLR3_FALSE;

  00285	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  00288	c6 82 80 02 00
	00 00		 mov	 BYTE PTR [edx+640], 0

; 229  : 	stream->markers					= NULL;

  0028f	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  00292	c7 80 b4 02 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+692], 0

; 230  : 	stream->nodeStack				= inStream->nodeStack;

  0029c	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  0029f	8b 55 08	 mov	 edx, DWORD PTR _inStream$[ebp]
  002a2	8b 82 8c 02 00
	00		 mov	 eax, DWORD PTR [edx+652]
  002a8	89 81 8c 02 00
	00		 mov	 DWORD PTR [ecx+652], eax

; 231  : 
; 232  : 	// Create the node list map
; 233  : 	//
; 234  : 	stream->nodes	= antlr3VectorNew(DEFAULT_INITIAL_BUFFER_SIZE);

  002ae	6a 64		 push	 100			; 00000064H
  002b0	e8 00 00 00 00	 call	 _antlr3VectorNew
  002b5	83 c4 04	 add	 esp, 4
  002b8	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  002bb	89 81 7c 02 00
	00		 mov	 DWORD PTR [ecx+636], eax

; 235  : 	stream->p		= -1;

  002c1	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  002c4	c7 82 90 02 00
	00 ff ff ff ff	 mov	 DWORD PTR [edx+656], -1

; 236  : 
; 237  : 	// Install the navigation nodes     
; 238  : 	//
; 239  : 	
; 240  : 	// Install the navigation nodes     
; 241  : 	//
; 242  : 	antlr3SetCTAPI(&(stream->UP));

  002ce	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  002d1	05 a8 00 00 00	 add	 eax, 168		; 000000a8H
  002d6	50		 push	 eax
  002d7	e8 00 00 00 00	 call	 _antlr3SetCTAPI
  002dc	83 c4 04	 add	 esp, 4

; 243  : 	antlr3SetCTAPI(&(stream->DOWN));

  002df	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  002e2	83 c1 0c	 add	 ecx, 12			; 0000000cH
  002e5	51		 push	 ecx
  002e6	e8 00 00 00 00	 call	 _antlr3SetCTAPI
  002eb	83 c4 04	 add	 esp, 4

; 244  : 	antlr3SetCTAPI(&(stream->EOF_NODE));

  002ee	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  002f1	81 c2 44 01 00
	00		 add	 edx, 324		; 00000144H
  002f7	52		 push	 edx
  002f8	e8 00 00 00 00	 call	 _antlr3SetCTAPI
  002fd	83 c4 04	 add	 esp, 4

; 245  : 	antlr3SetCTAPI(&(stream->INVALID_NODE));

  00300	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  00303	05 e0 01 00 00	 add	 eax, 480		; 000001e0H
  00308	50		 push	 eax
  00309	e8 00 00 00 00	 call	 _antlr3SetCTAPI
  0030e	83 c4 04	 add	 esp, 4

; 246  : 
; 247  : 	stream->UP.token						= inStream->UP.token;

  00311	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  00314	8b 55 08	 mov	 edx, DWORD PTR _inStream$[ebp]
  00317	8b 82 b4 00 00
	00		 mov	 eax, DWORD PTR [edx+180]
  0031d	89 81 b4 00 00
	00		 mov	 DWORD PTR [ecx+180], eax

; 248  : 	inStream->UP.token->strFactory			= stream->stringFactory;

  00323	8b 4d 08	 mov	 ecx, DWORD PTR _inStream$[ebp]
  00326	8b 91 b4 00 00
	00		 mov	 edx, DWORD PTR [ecx+180]
  0032c	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  0032f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00332	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 249  : 	stream->DOWN.token						= inStream->DOWN.token;

  00335	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  00338	8b 45 08	 mov	 eax, DWORD PTR _inStream$[ebp]
  0033b	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0033e	89 4a 18	 mov	 DWORD PTR [edx+24], ecx

; 250  : 	inStream->DOWN.token->strFactory		= stream->stringFactory;

  00341	8b 55 08	 mov	 edx, DWORD PTR _inStream$[ebp]
  00344	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00347	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  0034a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0034d	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 251  : 	stream->EOF_NODE.token					= inStream->EOF_NODE.token;

  00350	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  00353	8b 4d 08	 mov	 ecx, DWORD PTR _inStream$[ebp]
  00356	8b 91 50 01 00
	00		 mov	 edx, DWORD PTR [ecx+336]
  0035c	89 90 50 01 00
	00		 mov	 DWORD PTR [eax+336], edx

; 252  : 	inStream->EOF_NODE.token->strFactory	= stream->stringFactory;

  00362	8b 45 08	 mov	 eax, DWORD PTR _inStream$[ebp]
  00365	8b 88 50 01 00
	00		 mov	 ecx, DWORD PTR [eax+336]
  0036b	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  0036e	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00371	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 253  : 	stream->INVALID_NODE.token				= inStream->INVALID_NODE.token;

  00374	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  00377	8b 55 08	 mov	 edx, DWORD PTR _inStream$[ebp]
  0037a	8b 82 ec 01 00
	00		 mov	 eax, DWORD PTR [edx+492]
  00380	89 81 ec 01 00
	00		 mov	 DWORD PTR [ecx+492], eax

; 254  : 	inStream->INVALID_NODE.token->strFactory= stream->stringFactory;

  00386	8b 4d 08	 mov	 ecx, DWORD PTR _inStream$[ebp]
  00389	8b 91 ec 01 00
	00		 mov	 edx, DWORD PTR [ecx+492]
  0038f	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  00392	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00395	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 255  : 
; 256  : 	// Reuse the root tree of the originating stream
; 257  : 	//
; 258  : 	stream->root		= inStream->root;

  00398	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  0039b	8b 45 08	 mov	 eax, DWORD PTR _inStream$[ebp]
  0039e	8b 88 84 02 00
	00		 mov	 ecx, DWORD PTR [eax+644]
  003a4	89 8a 84 02 00
	00		 mov	 DWORD PTR [edx+644], ecx

; 259  : 
; 260  : 	// Signal that this is a rewriting stream so we don't
; 261  : 	// free the originating tree. Anything that we rewrite or
; 262  : 	// duplicate here will be done through the adaptor or 
; 263  : 	// the original tree factory.
; 264  : 	//
; 265  : 	stream->isRewriter	= ANTLR3_TRUE;

  003aa	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  003ad	c6 82 f8 02 00
	00 01		 mov	 BYTE PTR [edx+760], 1

; 266  : 	return stream;

  003b4	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
$LN1@antlr3Comm:

; 267  : }

  003b7	5e		 pop	 esi
  003b8	83 c4 04	 add	 esp, 4
  003bb	3b ec		 cmp	 ebp, esp
  003bd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003c2	8b e5		 mov	 esp, ebp
  003c4	5d		 pop	 ebp
  003c5	c3		 ret	 0
_antlr3CommonTreeNodeStreamNewStream ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontreenodestream.c
;	COMDAT _antlr3CommonTreeNodeStreamNew
_TEXT	SEGMENT
_token$ = -8						; size = 4
_stream$ = -4						; size = 4
_strFactory$ = 8					; size = 4
_hint$ = 12						; size = 4
_antlr3CommonTreeNodeStreamNew PROC			; COMDAT

; 271  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 272  : 	pANTLR3_COMMON_TREE_NODE_STREAM stream;
; 273  : 	pANTLR3_COMMON_TOKEN			token;
; 274  : 
; 275  : 	// Memory for the interface structure
; 276  : 	//
; 277  : 	stream  = (pANTLR3_COMMON_TREE_NODE_STREAM) ANTLR3_CALLOC(1, sizeof(ANTLR3_COMMON_TREE_NODE_STREAM));

  00015	8b f4		 mov	 esi, esp
  00017	68 fc 02 00 00	 push	 764			; 000002fcH
  0001c	6a 01		 push	 1
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__calloc
  00024	83 c4 08	 add	 esp, 8
  00027	3b f4		 cmp	 esi, esp
  00029	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002e	89 45 fc	 mov	 DWORD PTR _stream$[ebp], eax

; 278  : 
; 279  : 	if	(stream == NULL)

  00031	83 7d fc 00	 cmp	 DWORD PTR _stream$[ebp], 0
  00035	75 07		 jne	 SHORT $LN2@antlr3Comm

; 280  : 	{
; 281  : 		return	NULL;

  00037	33 c0		 xor	 eax, eax
  00039	e9 33 04 00 00	 jmp	 $LN1@antlr3Comm
$LN2@antlr3Comm:

; 282  : 	}
; 283  : 
; 284  : 	// String factory for tree walker
; 285  : 	//
; 286  : 	stream->stringFactory		= strFactory;

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  00041	8b 4d 08	 mov	 ecx, DWORD PTR _strFactory$[ebp]
  00044	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 287  : 
; 288  : 	// Create an adaptor for the common tree node stream
; 289  : 	//
; 290  : 	stream->adaptor				= ANTLR3_TREE_ADAPTORNew(strFactory);

  00047	8b 55 08	 mov	 edx, DWORD PTR _strFactory$[ebp]
  0004a	52		 push	 edx
  0004b	e8 00 00 00 00	 call	 _ANTLR3_TREE_ADAPTORNew
  00050	83 c4 04	 add	 esp, 4
  00053	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  00056	89 81 88 02 00
	00		 mov	 DWORD PTR [ecx+648], eax

; 291  : 
; 292  : 	if	(stream->adaptor == NULL)

  0005c	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  0005f	83 ba 88 02 00
	00 00		 cmp	 DWORD PTR [edx+648], 0
  00066	75 22		 jne	 SHORT $LN3@antlr3Comm

; 293  : 	{
; 294  : 		stream->free(stream);

  00068	8b f4		 mov	 esi, esp
  0006a	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  0006d	50		 push	 eax
  0006e	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  00071	8b 91 f4 02 00
	00		 mov	 edx, DWORD PTR [ecx+756]
  00077	ff d2		 call	 edx
  00079	83 c4 04	 add	 esp, 4
  0007c	3b f4		 cmp	 esi, esp
  0007e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 295  : 		return	NULL;

  00083	33 c0		 xor	 eax, eax
  00085	e9 e7 03 00 00	 jmp	 $LN1@antlr3Comm
$LN3@antlr3Comm:

; 296  : 	}
; 297  : 
; 298  : 	// Create space for the tree node stream interface
; 299  : 	//
; 300  : 	stream->tnstream	    = antlr3TreeNodeStreamNew();

  0008a	e8 00 00 00 00	 call	 _antlr3TreeNodeStreamNew
  0008f	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  00092	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 301  : 
; 302  : 	if	(stream->tnstream == NULL)

  00095	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  00098	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  0009c	75 49		 jne	 SHORT $LN4@antlr3Comm

; 303  : 	{
; 304  : 		stream->adaptor->free		(stream->adaptor);

  0009e	8b f4		 mov	 esi, esp
  000a0	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  000a3	8b 88 88 02 00
	00		 mov	 ecx, DWORD PTR [eax+648]
  000a9	51		 push	 ecx
  000aa	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  000ad	8b 82 88 02 00
	00		 mov	 eax, DWORD PTR [edx+648]
  000b3	8b 88 a8 00 00
	00		 mov	 ecx, DWORD PTR [eax+168]
  000b9	ff d1		 call	 ecx
  000bb	83 c4 04	 add	 esp, 4
  000be	3b f4		 cmp	 esi, esp
  000c0	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 305  : 		stream->free				(stream);

  000c5	8b f4		 mov	 esi, esp
  000c7	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  000ca	52		 push	 edx
  000cb	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  000ce	8b 88 f4 02 00
	00		 mov	 ecx, DWORD PTR [eax+756]
  000d4	ff d1		 call	 ecx
  000d6	83 c4 04	 add	 esp, 4
  000d9	3b f4		 cmp	 esi, esp
  000db	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 306  : 
; 307  : 		return	NULL;

  000e0	33 c0		 xor	 eax, eax
  000e2	e9 8a 03 00 00	 jmp	 $LN1@antlr3Comm
$LN4@antlr3Comm:

; 308  : 	}
; 309  : 
; 310  : 	// Create space for the INT_STREAM interface
; 311  : 	//
; 312  : 	stream->tnstream->istream		    =  antlr3IntStreamNew();

  000e7	e8 00 00 00 00	 call	 _antlr3IntStreamNew
  000ec	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  000ef	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  000f2	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 313  : 
; 314  : 	if	(stream->tnstream->istream == NULL)

  000f5	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  000f8	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000fb	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  000ff	75 67		 jne	 SHORT $LN5@antlr3Comm

; 315  : 	{
; 316  : 		stream->adaptor->free		(stream->adaptor);

  00101	8b f4		 mov	 esi, esp
  00103	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  00106	8b 91 88 02 00
	00		 mov	 edx, DWORD PTR [ecx+648]
  0010c	52		 push	 edx
  0010d	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  00110	8b 88 88 02 00
	00		 mov	 ecx, DWORD PTR [eax+648]
  00116	8b 91 a8 00 00
	00		 mov	 edx, DWORD PTR [ecx+168]
  0011c	ff d2		 call	 edx
  0011e	83 c4 04	 add	 esp, 4
  00121	3b f4		 cmp	 esi, esp
  00123	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 317  : 		stream->tnstream->free		(stream->tnstream);

  00128	8b f4		 mov	 esi, esp
  0012a	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  0012d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00130	51		 push	 ecx
  00131	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  00134	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00137	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0013a	ff d1		 call	 ecx
  0013c	83 c4 04	 add	 esp, 4
  0013f	3b f4		 cmp	 esi, esp
  00141	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 318  : 		stream->free				(stream);

  00146	8b f4		 mov	 esi, esp
  00148	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  0014b	52		 push	 edx
  0014c	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  0014f	8b 88 f4 02 00
	00		 mov	 ecx, DWORD PTR [eax+756]
  00155	ff d1		 call	 ecx
  00157	83 c4 04	 add	 esp, 4
  0015a	3b f4		 cmp	 esi, esp
  0015c	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 319  : 
; 320  : 		return	NULL;

  00161	33 c0		 xor	 eax, eax
  00163	e9 09 03 00 00	 jmp	 $LN1@antlr3Comm
$LN5@antlr3Comm:

; 321  : 	}
; 322  : 
; 323  : 	// Install the common tree node stream API
; 324  : 	//
; 325  : 	stream->addNavigationNode		    =  addNavigationNode;

  00168	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  0016b	c7 82 d0 02 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+720], OFFSET _addNavigationNode

; 326  : 	stream->hasUniqueNavigationNodes    =  hasUniqueNavigationNodes;

  00175	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  00178	c7 80 e0 02 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+736], OFFSET _hasUniqueNavigationNodes

; 327  : 	stream->newDownNode					=  newDownNode;

  00182	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  00185	c7 81 d4 02 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+724], OFFSET _newDownNode

; 328  : 	stream->newUpNode					=  newUpNode;

  0018f	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  00192	c7 82 d8 02 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+728], OFFSET _newUpNode

; 329  : 	stream->reset						=  reset;

  0019c	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  0019f	c7 80 f0 02 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+752], OFFSET _reset

; 330  : 	stream->push						=  push;

  001a9	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  001ac	c7 81 e8 02 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+744], OFFSET _push

; 331  : 	stream->pop							=  pop;

  001b6	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  001b9	c7 82 ec 02 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+748], OFFSET _pop

; 332  : 
; 333  : 	stream->free			    =  antlr3CommonTreeNodeStreamFree;

  001c3	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  001c6	c7 80 f4 02 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+756], OFFSET _antlr3CommonTreeNodeStreamFree

; 334  : 
; 335  : 	// Install the tree node stream API
; 336  : 	//
; 337  : 	stream->tnstream->getTreeAdaptor			=  getTreeAdaptor;

  001d0	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  001d3	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  001d6	c7 42 10 00 00
	00 00		 mov	 DWORD PTR [edx+16], OFFSET _getTreeAdaptor

; 338  : 	stream->tnstream->getTreeSource				=  getTreeSource;

  001dd	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  001e0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001e3	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], OFFSET _getTreeSource

; 339  : 	stream->tnstream->_LT						=  _LT;

  001ea	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  001ed	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  001f0	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], OFFSET __LT

; 340  : 	stream->tnstream->setUniqueNavigationNodes	=  setUniqueNavigationNodes;

  001f7	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  001fa	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  001fd	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], OFFSET _setUniqueNavigationNodes

; 341  : 	stream->tnstream->toString					=  toString;

  00204	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  00207	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0020a	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET _toString

; 342  : 	stream->tnstream->toStringSS				=  toStringSS;

  00211	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  00214	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00217	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], OFFSET _toStringSS

; 343  : 	stream->tnstream->toStringWork				=  toStringWork;

  0021e	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  00221	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00224	c7 42 20 00 00
	00 00		 mov	 DWORD PTR [edx+32], OFFSET _toStringWork

; 344  : 	stream->tnstream->get						=  get;

  0022b	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  0022e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00231	c7 41 28 00 00
	00 00		 mov	 DWORD PTR [ecx+40], OFFSET _get

; 345  : 
; 346  : 	// Install INT_STREAM interface
; 347  : 	//
; 348  : 	stream->tnstream->istream->consume	    =  consume;

  00238	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  0023b	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0023e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00241	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], OFFSET _consume

; 349  : 	stream->tnstream->istream->index	    =  tindex;

  00248	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  0024b	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0024e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00251	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], OFFSET _tindex

; 350  : 	stream->tnstream->istream->_LA			=  _LA;

  00258	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  0025b	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0025e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00261	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET __LA

; 351  : 	stream->tnstream->istream->mark			=  mark;

  00268	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  0026b	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0026e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00271	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], OFFSET _mark

; 352  : 	stream->tnstream->istream->release	    =  release;

  00278	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  0027b	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0027e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00281	c7 41 2c 00 00
	00 00		 mov	 DWORD PTR [ecx+44], OFFSET _release

; 353  : 	stream->tnstream->istream->rewind	    =  rewindMark;

  00288	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  0028b	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0028e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00291	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], OFFSET _rewindMark

; 354  : 	stream->tnstream->istream->rewindLast   =  rewindLast;

  00298	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  0029b	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0029e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  002a1	c7 41 28 00 00
	00 00		 mov	 DWORD PTR [ecx+40], OFFSET _rewindLast

; 355  : 	stream->tnstream->istream->seek			=  seek;

  002a8	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  002ab	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  002ae	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  002b1	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], OFFSET _seek

; 356  : 	stream->tnstream->istream->size			=  size;

  002b8	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  002bb	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  002be	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  002c1	c7 41 34 00 00
	00 00		 mov	 DWORD PTR [ecx+52], OFFSET _size

; 357  : 
; 358  : 	// Initialize data elements of INT stream
; 359  : 	//
; 360  : 	stream->tnstream->istream->type			= ANTLR3_COMMONTREENODE;

  002c8	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  002cb	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  002ce	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  002d1	c7 01 04 00 00
	00		 mov	 DWORD PTR [ecx], 4

; 361  : 	stream->tnstream->istream->super	    =  (stream->tnstream);

  002d7	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  002da	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  002dd	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  002e0	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  002e3	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  002e6	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 362  : 
; 363  : 	// Initialize data elements of TREE stream
; 364  : 	//
; 365  : 	stream->tnstream->ctns =  stream;

  002e9	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  002ec	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  002ef	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  002f2	89 02		 mov	 DWORD PTR [edx], eax

; 366  : 
; 367  : 	// Initialize data elements of the COMMON TREE NODE stream
; 368  : 	//
; 369  : 	stream->super					= NULL;

  002f4	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  002f7	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 370  : 	stream->uniqueNavigationNodes	= ANTLR3_FALSE;

  002fd	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  00300	c6 82 80 02 00
	00 00		 mov	 BYTE PTR [edx+640], 0

; 371  : 	stream->markers					= NULL;

  00307	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  0030a	c7 80 b4 02 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+692], 0

; 372  : 	stream->nodeStack				= antlr3StackNew(INITIAL_CALL_STACK_SIZE);

  00314	6a 0a		 push	 10			; 0000000aH
  00316	e8 00 00 00 00	 call	 _antlr3StackNew
  0031b	83 c4 04	 add	 esp, 4
  0031e	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  00321	89 81 8c 02 00
	00		 mov	 DWORD PTR [ecx+652], eax

; 373  : 
; 374  : 	// Create the node list map
; 375  : 	//
; 376  : 	if	(hint == 0)

  00327	83 7d 0c 00	 cmp	 DWORD PTR _hint$[ebp], 0
  0032b	75 07		 jne	 SHORT $LN6@antlr3Comm

; 377  : 	{
; 378  : 		hint = DEFAULT_INITIAL_BUFFER_SIZE;

  0032d	c7 45 0c 64 00
	00 00		 mov	 DWORD PTR _hint$[ebp], 100 ; 00000064H
$LN6@antlr3Comm:

; 379  : 	}
; 380  : 	stream->nodes	= antlr3VectorNew(hint);

  00334	8b 55 0c	 mov	 edx, DWORD PTR _hint$[ebp]
  00337	52		 push	 edx
  00338	e8 00 00 00 00	 call	 _antlr3VectorNew
  0033d	83 c4 04	 add	 esp, 4
  00340	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  00343	89 81 7c 02 00
	00		 mov	 DWORD PTR [ecx+636], eax

; 381  : 	stream->p		= -1;

  00349	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  0034c	c7 82 90 02 00
	00 ff ff ff ff	 mov	 DWORD PTR [edx+656], -1

; 382  : 
; 383  : 	// Install the navigation nodes     
; 384  : 	//
; 385  : 	antlr3SetCTAPI(&(stream->UP));

  00356	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  00359	05 a8 00 00 00	 add	 eax, 168		; 000000a8H
  0035e	50		 push	 eax
  0035f	e8 00 00 00 00	 call	 _antlr3SetCTAPI
  00364	83 c4 04	 add	 esp, 4

; 386  : 	antlr3SetCTAPI(&(stream->DOWN));

  00367	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  0036a	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0036d	51		 push	 ecx
  0036e	e8 00 00 00 00	 call	 _antlr3SetCTAPI
  00373	83 c4 04	 add	 esp, 4

; 387  : 	antlr3SetCTAPI(&(stream->EOF_NODE));

  00376	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  00379	81 c2 44 01 00
	00		 add	 edx, 324		; 00000144H
  0037f	52		 push	 edx
  00380	e8 00 00 00 00	 call	 _antlr3SetCTAPI
  00385	83 c4 04	 add	 esp, 4

; 388  : 	antlr3SetCTAPI(&(stream->INVALID_NODE));

  00388	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  0038b	05 e0 01 00 00	 add	 eax, 480		; 000001e0H
  00390	50		 push	 eax
  00391	e8 00 00 00 00	 call	 _antlr3SetCTAPI
  00396	83 c4 04	 add	 esp, 4

; 389  : 
; 390  : 	token						= antlr3CommonTokenNew(ANTLR3_TOKEN_UP);

  00399	6a 03		 push	 3
  0039b	e8 00 00 00 00	 call	 _antlr3CommonTokenNew
  003a0	83 c4 04	 add	 esp, 4
  003a3	89 45 f8	 mov	 DWORD PTR _token$[ebp], eax

; 391  : 	token->strFactory			= strFactory;

  003a6	8b 4d f8	 mov	 ecx, DWORD PTR _token$[ebp]
  003a9	8b 55 08	 mov	 edx, DWORD PTR _strFactory$[ebp]
  003ac	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 392  : 	token->textState			= ANTLR3_TEXT_CHARP;

  003af	8b 45 f8	 mov	 eax, DWORD PTR _token$[ebp]
  003b2	c7 40 2c 01 00
	00 00		 mov	 DWORD PTR [eax+44], 1

; 393  : 	token->tokText.chars		= (pANTLR3_UCHAR)"UP";

  003b9	8b 4d f8	 mov	 ecx, DWORD PTR _token$[ebp]
  003bc	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], OFFSET ??_C@_02NAHCJHOC@UP@

; 394  : 	stream->UP.token			= token;

  003c3	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  003c6	8b 45 f8	 mov	 eax, DWORD PTR _token$[ebp]
  003c9	89 82 b4 00 00
	00		 mov	 DWORD PTR [edx+180], eax

; 395  : 
; 396  : 	token						= antlr3CommonTokenNew(ANTLR3_TOKEN_DOWN);

  003cf	6a 02		 push	 2
  003d1	e8 00 00 00 00	 call	 _antlr3CommonTokenNew
  003d6	83 c4 04	 add	 esp, 4
  003d9	89 45 f8	 mov	 DWORD PTR _token$[ebp], eax

; 397  : 	token->strFactory			= strFactory;

  003dc	8b 4d f8	 mov	 ecx, DWORD PTR _token$[ebp]
  003df	8b 55 08	 mov	 edx, DWORD PTR _strFactory$[ebp]
  003e2	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 398  : 	token->textState			= ANTLR3_TEXT_CHARP;

  003e5	8b 45 f8	 mov	 eax, DWORD PTR _token$[ebp]
  003e8	c7 40 2c 01 00
	00 00		 mov	 DWORD PTR [eax+44], 1

; 399  : 	token->tokText.chars		= (pANTLR3_UCHAR)"DOWN";

  003ef	8b 4d f8	 mov	 ecx, DWORD PTR _token$[ebp]
  003f2	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], OFFSET ??_C@_04FANAOELO@DOWN@

; 400  : 	stream->DOWN.token			= token;

  003f9	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  003fc	8b 45 f8	 mov	 eax, DWORD PTR _token$[ebp]
  003ff	89 42 18	 mov	 DWORD PTR [edx+24], eax

; 401  : 
; 402  : 	token						= antlr3CommonTokenNew(ANTLR3_TOKEN_EOF);

  00402	6a ff		 push	 -1
  00404	e8 00 00 00 00	 call	 _antlr3CommonTokenNew
  00409	83 c4 04	 add	 esp, 4
  0040c	89 45 f8	 mov	 DWORD PTR _token$[ebp], eax

; 403  : 	token->strFactory			= strFactory;

  0040f	8b 4d f8	 mov	 ecx, DWORD PTR _token$[ebp]
  00412	8b 55 08	 mov	 edx, DWORD PTR _strFactory$[ebp]
  00415	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 404  : 	token->textState			= ANTLR3_TEXT_CHARP;

  00418	8b 45 f8	 mov	 eax, DWORD PTR _token$[ebp]
  0041b	c7 40 2c 01 00
	00 00		 mov	 DWORD PTR [eax+44], 1

; 405  : 	token->tokText.chars		= (pANTLR3_UCHAR)"EOF";

  00422	8b 4d f8	 mov	 ecx, DWORD PTR _token$[ebp]
  00425	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], OFFSET ??_C@_03KPJEKKJC@EOF@

; 406  : 	stream->EOF_NODE.token		= token;

  0042c	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  0042f	8b 45 f8	 mov	 eax, DWORD PTR _token$[ebp]
  00432	89 82 50 01 00
	00		 mov	 DWORD PTR [edx+336], eax

; 407  : 
; 408  : 	token						= antlr3CommonTokenNew(ANTLR3_TOKEN_INVALID);

  00438	6a 00		 push	 0
  0043a	e8 00 00 00 00	 call	 _antlr3CommonTokenNew
  0043f	83 c4 04	 add	 esp, 4
  00442	89 45 f8	 mov	 DWORD PTR _token$[ebp], eax

; 409  : 	token->strFactory			= strFactory;

  00445	8b 4d f8	 mov	 ecx, DWORD PTR _token$[ebp]
  00448	8b 55 08	 mov	 edx, DWORD PTR _strFactory$[ebp]
  0044b	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 410  : 	token->textState			= ANTLR3_TEXT_CHARP;

  0044e	8b 45 f8	 mov	 eax, DWORD PTR _token$[ebp]
  00451	c7 40 2c 01 00
	00 00		 mov	 DWORD PTR [eax+44], 1

; 411  : 	token->tokText.chars		= (pANTLR3_UCHAR)"INVALID";

  00458	8b 4d f8	 mov	 ecx, DWORD PTR _token$[ebp]
  0045b	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], OFFSET ??_C@_07DNODLGKM@INVALID@

; 412  : 	stream->INVALID_NODE.token	= token;

  00462	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  00465	8b 45 f8	 mov	 eax, DWORD PTR _token$[ebp]
  00468	89 82 ec 01 00
	00		 mov	 DWORD PTR [edx+492], eax

; 413  : 
; 414  : 
; 415  : 	return  stream;

  0046e	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
$LN1@antlr3Comm:

; 416  : }

  00471	5e		 pop	 esi
  00472	83 c4 08	 add	 esp, 8
  00475	3b ec		 cmp	 ebp, esp
  00477	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0047c	8b e5		 mov	 esp, ebp
  0047e	5d		 pop	 ebp
  0047f	c3		 ret	 0
_antlr3CommonTreeNodeStreamNew ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontreenodestream.c
;	COMDAT _antlr3CommonTreeNodeStreamNewTree
_TEXT	SEGMENT
_stream$ = -4						; size = 4
_tree$ = 8						; size = 4
_hint$ = 12						; size = 4
_antlr3CommonTreeNodeStreamNewTree PROC			; COMDAT

; 117  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 118  : 	pANTLR3_COMMON_TREE_NODE_STREAM stream;
; 119  : 
; 120  : 	stream = antlr3CommonTreeNodeStreamNew(tree->strFactory, hint);

  0000b	8b 45 0c	 mov	 eax, DWORD PTR _hint$[ebp]
  0000e	50		 push	 eax
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _tree$[ebp]
  00012	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00015	52		 push	 edx
  00016	e8 00 00 00 00	 call	 _antlr3CommonTreeNodeStreamNew
  0001b	83 c4 08	 add	 esp, 8
  0001e	89 45 fc	 mov	 DWORD PTR _stream$[ebp], eax

; 121  : 
; 122  : 	if	(stream == NULL)

  00021	83 7d fc 00	 cmp	 DWORD PTR _stream$[ebp], 0
  00025	75 04		 jne	 SHORT $LN2@antlr3Comm

; 123  : 	{
; 124  : 		return	NULL;

  00027	33 c0		 xor	 eax, eax
  00029	eb 0f		 jmp	 SHORT $LN1@antlr3Comm
$LN2@antlr3Comm:

; 125  : 	}
; 126  : 	stream->root    = tree;

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  0002e	8b 4d 08	 mov	 ecx, DWORD PTR _tree$[ebp]
  00031	89 88 84 02 00
	00		 mov	 DWORD PTR [eax+644], ecx

; 127  : 
; 128  : 	return stream;

  00037	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
$LN1@antlr3Comm:

; 129  : }

  0003a	83 c4 04	 add	 esp, 4
  0003d	3b ec		 cmp	 ebp, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
_antlr3CommonTreeNodeStreamNewTree ENDP
_TEXT	ENDS
END
