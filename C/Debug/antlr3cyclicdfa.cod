; Listing generated by Microsoft (R) Optimizing Compiler Version 19.42.34436.0 

	TITLE	C:\SPO_labs\C\Debug\antlr3cyclicdfa.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_antlr3dfaspecialTransition
PUBLIC	_antlr3dfaspecialStateTransition
PUBLIC	_antlr3dfapredict
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3cyclicdfa.c
;	COMDAT _noViableAlt
_TEXT	SEGMENT
_rec$ = 8						; size = 4
_cdfa$ = 12						; size = 4
_s$ = 16						; size = 4
_noViableAlt PROC					; COMDAT

; 54   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 55   : 	// In backtracking mode, we just set the failed flag so that the
; 56   : 	// alt can just exit right now. If we are parsing though, then 
; 57   : 	// we want the exception to be raised.
; 58   : 	//
; 59   :     if	(rec->state->backtracking > 0)

  00004	8b 45 08	 mov	 eax, DWORD PTR _rec$[ebp]
  00007	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000a	83 79 20 00	 cmp	 DWORD PTR [ecx+32], 0
  0000e	7e 0c		 jle	 SHORT $LN2@noViableAl

; 60   :     {
; 61   : 		rec->state->failed = ANTLR3_TRUE;

  00010	8b 55 08	 mov	 edx, DWORD PTR _rec$[ebp]
  00013	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00016	c6 40 18 01	 mov	 BYTE PTR [eax+24], 1

; 62   :     }

  0001a	eb 5c		 jmp	 SHORT $LN3@noViableAl
$LN2@noViableAl:

; 63   : 	else
; 64   : 	{
; 65   : 		rec->exConstruct(rec);

  0001c	8b f4		 mov	 esi, esp
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR _rec$[ebp]
  00021	51		 push	 ecx
  00022	8b 55 08	 mov	 edx, DWORD PTR _rec$[ebp]
  00025	8b 82 88 00 00
	00		 mov	 eax, DWORD PTR [edx+136]
  0002b	ff d0		 call	 eax
  0002d	83 c4 04	 add	 esp, 4
  00030	3b f4		 cmp	 esi, esp
  00032	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 66   : 		rec->state->exception->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;

  00037	8b 4d 08	 mov	 ecx, DWORD PTR _rec$[ebp]
  0003a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0003d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00040	c7 00 03 00 00
	00		 mov	 DWORD PTR [eax], 3

; 67   : 		rec->state->exception->message      = cdfa->description;

  00046	8b 4d 08	 mov	 ecx, DWORD PTR _rec$[ebp]
  00049	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0004c	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0004f	8b 4d 0c	 mov	 ecx, DWORD PTR _cdfa$[ebp]
  00052	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00055	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 68   : 		rec->state->exception->decisionNum  = cdfa->decisionNumber;

  00058	8b 45 08	 mov	 eax, DWORD PTR _rec$[ebp]
  0005b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0005e	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00061	8b 45 0c	 mov	 eax, DWORD PTR _cdfa$[ebp]
  00064	8b 08		 mov	 ecx, DWORD PTR [eax]
  00066	89 4a 34	 mov	 DWORD PTR [edx+52], ecx

; 69   : 		rec->state->exception->state        = s;

  00069	8b 55 08	 mov	 edx, DWORD PTR _rec$[ebp]
  0006c	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0006f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00072	8b 55 10	 mov	 edx, DWORD PTR _s$[ebp]
  00075	89 51 38	 mov	 DWORD PTR [ecx+56], edx
$LN3@noViableAl:

; 70   : 	}
; 71   : }

  00078	5e		 pop	 esi
  00079	3b ec		 cmp	 ebp, esp
  0007b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00080	5d		 pop	 ebp
  00081	c3		 ret	 0
_noViableAlt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3cyclicdfa.c
;	COMDAT _antlr3dfapredict
_TEXT	SEGMENT
_snext$1 = -20						; size = 4
_c$ = -16						; size = 4
_specialState$ = -12					; size = 4
_s$ = -8						; size = 4
_mark$ = -4						; size = 4
_ctx$ = 8						; size = 4
_rec$ = 12						; size = 4
_is$ = 16						; size = 4
_cdfa$ = 20						; size = 4
_antlr3dfapredict PROC					; COMDAT

; 80   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0000f	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00012	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00015	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00018	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 81   :     ANTLR3_MARKER	mark;
; 82   :     ANTLR3_INT32	s;
; 83   :     ANTLR3_INT32	specialState;
; 84   :     ANTLR3_INT32	c;
; 85   : 
; 86   :     mark	= is->mark(is);	    /* Store where we are right now	*/

  0001b	8b f4		 mov	 esi, esp
  0001d	8b 45 10	 mov	 eax, DWORD PTR _is$[ebp]
  00020	50		 push	 eax
  00021	8b 4d 10	 mov	 ecx, DWORD PTR _is$[ebp]
  00024	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00027	ff d2		 call	 edx
  00029	83 c4 04	 add	 esp, 4
  0002c	3b f4		 cmp	 esi, esp
  0002e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00033	89 45 fc	 mov	 DWORD PTR _mark$[ebp], eax

; 87   :     s		= 0;		    /* Always start with state 0	*/

  00036	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _s$[ebp], 0
$LN2@antlr3dfap:

; 88   :     
; 89   : 	for (;;)
; 90   : 	{
; 91   : 		/* Pick out any special state entry for this state
; 92   : 		 */
; 93   : 		specialState	= cdfa->special[s];

  0003d	8b 45 14	 mov	 eax, DWORD PTR _cdfa$[ebp]
  00040	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00043	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  00046	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  00049	89 45 f4	 mov	 DWORD PTR _specialState$[ebp], eax

; 94   : 
; 95   : 		/* Transition the special state and consume an input token
; 96   : 		 */
; 97   : 		if  (specialState >= 0)

  0004c	83 7d f4 00	 cmp	 DWORD PTR _specialState$[ebp], 0
  00050	0f 8c 94 00 00
	00		 jl	 $LN5@antlr3dfap

; 98   : 		{
; 99   : 			s = cdfa->specialStateTransition(ctx, rec, is, cdfa, specialState);

  00056	8b f4		 mov	 esi, esp
  00058	8b 4d f4	 mov	 ecx, DWORD PTR _specialState$[ebp]
  0005b	51		 push	 ecx
  0005c	8b 55 14	 mov	 edx, DWORD PTR _cdfa$[ebp]
  0005f	52		 push	 edx
  00060	8b 45 10	 mov	 eax, DWORD PTR _is$[ebp]
  00063	50		 push	 eax
  00064	8b 4d 0c	 mov	 ecx, DWORD PTR _rec$[ebp]
  00067	51		 push	 ecx
  00068	8b 55 08	 mov	 edx, DWORD PTR _ctx$[ebp]
  0006b	52		 push	 edx
  0006c	8b 45 14	 mov	 eax, DWORD PTR _cdfa$[ebp]
  0006f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00072	ff d1		 call	 ecx
  00074	83 c4 14	 add	 esp, 20			; 00000014H
  00077	3b f4		 cmp	 esi, esp
  00079	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007e	89 45 f8	 mov	 DWORD PTR _s$[ebp], eax

; 100  : 
; 101  : 			// Error?
; 102  : 			//
; 103  : 			if	(s<0)

  00081	83 7d f8 00	 cmp	 DWORD PTR _s$[ebp], 0
  00085	7d 45		 jge	 SHORT $LN6@antlr3dfap

; 104  : 			{
; 105  : 				// If the predicate/rule raised an exception then we leave it
; 106  : 				// in tact, else we have an NVA.
; 107  : 				//
; 108  : 				if	(rec->state->error != ANTLR3_TRUE)

  00087	8b 55 0c	 mov	 edx, DWORD PTR _rec$[ebp]
  0008a	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0008d	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00090	83 f9 01	 cmp	 ecx, 1
  00093	74 14		 je	 SHORT $LN7@antlr3dfap

; 109  : 				{
; 110  : 					noViableAlt(rec,cdfa, s);

  00095	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  00098	52		 push	 edx
  00099	8b 45 14	 mov	 eax, DWORD PTR _cdfa$[ebp]
  0009c	50		 push	 eax
  0009d	8b 4d 0c	 mov	 ecx, DWORD PTR _rec$[ebp]
  000a0	51		 push	 ecx
  000a1	e8 00 00 00 00	 call	 _noViableAlt
  000a6	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@antlr3dfap:

; 111  : 				}
; 112  : 				is->rewind(is, mark);

  000a9	8b f4		 mov	 esi, esp
  000ab	8b 55 fc	 mov	 edx, DWORD PTR _mark$[ebp]
  000ae	52		 push	 edx
  000af	8b 45 10	 mov	 eax, DWORD PTR _is$[ebp]
  000b2	50		 push	 eax
  000b3	8b 4d 10	 mov	 ecx, DWORD PTR _is$[ebp]
  000b6	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  000b9	ff d2		 call	 edx
  000bb	83 c4 08	 add	 esp, 8
  000be	3b f4		 cmp	 esi, esp
  000c0	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 113  : 				return	0;

  000c5	33 c0		 xor	 eax, eax
  000c7	e9 1c 02 00 00	 jmp	 $LN3@antlr3dfap
$LN6@antlr3dfap:

; 114  : 			}
; 115  : 			is->consume(is);

  000cc	8b f4		 mov	 esi, esp
  000ce	8b 45 10	 mov	 eax, DWORD PTR _is$[ebp]
  000d1	50		 push	 eax
  000d2	8b 4d 10	 mov	 ecx, DWORD PTR _is$[ebp]
  000d5	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  000d8	ff d2		 call	 edx
  000da	83 c4 04	 add	 esp, 4
  000dd	3b f4		 cmp	 esi, esp
  000df	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e4	90		 npad	 1

; 116  : 			continue;

  000e5	e9 53 ff ff ff	 jmp	 $LN2@antlr3dfap
$LN5@antlr3dfap:

; 117  : 		}
; 118  : 
; 119  : 		/* Accept state?
; 120  : 		 */
; 121  : 		if  (cdfa->accept[s] >= 1)

  000ea	8b 45 14	 mov	 eax, DWORD PTR _cdfa$[ebp]
  000ed	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  000f0	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  000f3	83 3c 91 01	 cmp	 DWORD PTR [ecx+edx*4], 1
  000f7	7c 2d		 jl	 SHORT $LN8@antlr3dfap

; 122  : 		{
; 123  : 			is->rewind(is, mark);

  000f9	8b f4		 mov	 esi, esp
  000fb	8b 45 fc	 mov	 eax, DWORD PTR _mark$[ebp]
  000fe	50		 push	 eax
  000ff	8b 4d 10	 mov	 ecx, DWORD PTR _is$[ebp]
  00102	51		 push	 ecx
  00103	8b 55 10	 mov	 edx, DWORD PTR _is$[ebp]
  00106	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00109	ff d0		 call	 eax
  0010b	83 c4 08	 add	 esp, 8
  0010e	3b f4		 cmp	 esi, esp
  00110	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 124  : 			return  cdfa->accept[s];

  00115	8b 4d 14	 mov	 ecx, DWORD PTR _cdfa$[ebp]
  00118	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  0011b	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  0011e	8b 04 82	 mov	 eax, DWORD PTR [edx+eax*4]
  00121	e9 c2 01 00 00	 jmp	 $LN3@antlr3dfap
$LN8@antlr3dfap:

; 125  : 		}
; 126  : 
; 127  : 		/* Look for a normal transition state based upon the input token element
; 128  : 		 */
; 129  : 		c = is->_LA(is, 1);

  00126	8b f4		 mov	 esi, esp
  00128	6a 01		 push	 1
  0012a	8b 4d 10	 mov	 ecx, DWORD PTR _is$[ebp]
  0012d	51		 push	 ecx
  0012e	8b 55 10	 mov	 edx, DWORD PTR _is$[ebp]
  00131	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00134	ff d0		 call	 eax
  00136	83 c4 08	 add	 esp, 8
  00139	3b f4		 cmp	 esi, esp
  0013b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00140	89 45 f0	 mov	 DWORD PTR _c$[ebp], eax

; 130  : 
; 131  : 		/* Check against min and max for this state
; 132  : 		 */
; 133  : 		if  (c>= cdfa->min[s] && c <= cdfa->max[s])

  00143	8b 4d 14	 mov	 ecx, DWORD PTR _cdfa$[ebp]
  00146	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00149	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  0014c	8b 4d f0	 mov	 ecx, DWORD PTR _c$[ebp]
  0014f	3b 0c 82	 cmp	 ecx, DWORD PTR [edx+eax*4]
  00152	0f 8c d3 00 00
	00		 jl	 $LN9@antlr3dfap
  00158	8b 55 14	 mov	 edx, DWORD PTR _cdfa$[ebp]
  0015b	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0015e	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  00161	8b 55 f0	 mov	 edx, DWORD PTR _c$[ebp]
  00164	3b 14 88	 cmp	 edx, DWORD PTR [eax+ecx*4]
  00167	0f 8f be 00 00
	00		 jg	 $LN9@antlr3dfap

; 134  : 		{
; 135  : 			ANTLR3_INT32   snext;
; 136  : 
; 137  : 			/* What is the next state?
; 138  : 			 */
; 139  : 			snext = cdfa->transition[s][c - cdfa->min[s]];

  0016d	8b 45 14	 mov	 eax, DWORD PTR _cdfa$[ebp]
  00170	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  00173	8b 55 14	 mov	 edx, DWORD PTR _cdfa$[ebp]
  00176	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00179	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  0017c	8b 75 f0	 mov	 esi, DWORD PTR _c$[ebp]
  0017f	2b 34 90	 sub	 esi, DWORD PTR [eax+edx*4]
  00182	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  00185	8b 0c 81	 mov	 ecx, DWORD PTR [ecx+eax*4]
  00188	8b 14 b1	 mov	 edx, DWORD PTR [ecx+esi*4]
  0018b	89 55 ec	 mov	 DWORD PTR _snext$1[ebp], edx

; 140  : 
; 141  : 			if	(snext < 0)

  0018e	83 7d ec 00	 cmp	 DWORD PTR _snext$1[ebp], 0
  00192	7d 73		 jge	 SHORT $LN10@antlr3dfap

; 142  : 			{
; 143  : 				/* Was in range but not a normal transition
; 144  : 				 * must check EOT, which is like the else clause.
; 145  : 				 * eot[s]>=0 indicates that an EOT edge goes to another
; 146  : 				 * state.
; 147  : 				 */
; 148  : 				if  (cdfa->eot[s] >= 0)

  00194	8b 45 14	 mov	 eax, DWORD PTR _cdfa$[ebp]
  00197	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0019a	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  0019d	83 3c 91 00	 cmp	 DWORD PTR [ecx+edx*4], 0
  001a1	7c 2d		 jl	 SHORT $LN11@antlr3dfap

; 149  : 				{
; 150  : 					s = cdfa->eot[s];

  001a3	8b 45 14	 mov	 eax, DWORD PTR _cdfa$[ebp]
  001a6	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  001a9	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  001ac	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  001af	89 45 f8	 mov	 DWORD PTR _s$[ebp], eax

; 151  : 					is->consume(is);

  001b2	8b f4		 mov	 esi, esp
  001b4	8b 4d 10	 mov	 ecx, DWORD PTR _is$[ebp]
  001b7	51		 push	 ecx
  001b8	8b 55 10	 mov	 edx, DWORD PTR _is$[ebp]
  001bb	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  001be	ff d0		 call	 eax
  001c0	83 c4 04	 add	 esp, 4
  001c3	3b f4		 cmp	 esi, esp
  001c5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001ca	90		 npad	 1

; 152  : 					continue;

  001cb	e9 6d fe ff ff	 jmp	 $LN2@antlr3dfap
$LN11@antlr3dfap:

; 153  : 				}
; 154  : 				noViableAlt(rec,cdfa, s);

  001d0	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  001d3	51		 push	 ecx
  001d4	8b 55 14	 mov	 edx, DWORD PTR _cdfa$[ebp]
  001d7	52		 push	 edx
  001d8	8b 45 0c	 mov	 eax, DWORD PTR _rec$[ebp]
  001db	50		 push	 eax
  001dc	e8 00 00 00 00	 call	 _noViableAlt
  001e1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 155  : 				is->rewind(is, mark);

  001e4	8b f4		 mov	 esi, esp
  001e6	8b 4d fc	 mov	 ecx, DWORD PTR _mark$[ebp]
  001e9	51		 push	 ecx
  001ea	8b 55 10	 mov	 edx, DWORD PTR _is$[ebp]
  001ed	52		 push	 edx
  001ee	8b 45 10	 mov	 eax, DWORD PTR _is$[ebp]
  001f1	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  001f4	ff d1		 call	 ecx
  001f6	83 c4 08	 add	 esp, 8
  001f9	3b f4		 cmp	 esi, esp
  001fb	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 156  : 				return	0;

  00200	33 c0		 xor	 eax, eax
  00202	e9 e1 00 00 00	 jmp	 $LN3@antlr3dfap
$LN10@antlr3dfap:

; 157  : 			}
; 158  : 
; 159  : 			/* New current state - move to it
; 160  : 			 */
; 161  : 			s	= snext;

  00207	8b 55 ec	 mov	 edx, DWORD PTR _snext$1[ebp]
  0020a	89 55 f8	 mov	 DWORD PTR _s$[ebp], edx

; 162  : 			is->consume(is);

  0020d	8b f4		 mov	 esi, esp
  0020f	8b 45 10	 mov	 eax, DWORD PTR _is$[ebp]
  00212	50		 push	 eax
  00213	8b 4d 10	 mov	 ecx, DWORD PTR _is$[ebp]
  00216	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00219	ff d2		 call	 edx
  0021b	83 c4 04	 add	 esp, 4
  0021e	3b f4		 cmp	 esi, esp
  00220	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00225	90		 npad	 1

; 163  : 			continue;

  00226	e9 12 fe ff ff	 jmp	 $LN2@antlr3dfap
$LN9@antlr3dfap:

; 164  : 		}
; 165  : 		/* EOT Transition?
; 166  : 		 */
; 167  : 		if  (cdfa->eot[s] >= 0)

  0022b	8b 45 14	 mov	 eax, DWORD PTR _cdfa$[ebp]
  0022e	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00231	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  00234	83 3c 91 00	 cmp	 DWORD PTR [ecx+edx*4], 0
  00238	7c 2d		 jl	 SHORT $LN12@antlr3dfap

; 168  : 		{
; 169  : 			s	= cdfa->eot[s];

  0023a	8b 45 14	 mov	 eax, DWORD PTR _cdfa$[ebp]
  0023d	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00240	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  00243	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  00246	89 45 f8	 mov	 DWORD PTR _s$[ebp], eax

; 170  : 			is->consume(is);

  00249	8b f4		 mov	 esi, esp
  0024b	8b 4d 10	 mov	 ecx, DWORD PTR _is$[ebp]
  0024e	51		 push	 ecx
  0024f	8b 55 10	 mov	 edx, DWORD PTR _is$[ebp]
  00252	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00255	ff d0		 call	 eax
  00257	83 c4 04	 add	 esp, 4
  0025a	3b f4		 cmp	 esi, esp
  0025c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00261	90		 npad	 1

; 171  : 			continue;

  00262	e9 d6 fd ff ff	 jmp	 $LN2@antlr3dfap
$LN12@antlr3dfap:

; 172  : 		}
; 173  : 		/* EOF transition to accept state?
; 174  : 		 */
; 175  : 		if  ( c == ANTLR3_TOKEN_EOF && cdfa->eof[s] >= 0)

  00267	83 7d f0 ff	 cmp	 DWORD PTR _c$[ebp], -1
  0026b	75 42		 jne	 SHORT $LN13@antlr3dfap
  0026d	8b 4d 14	 mov	 ecx, DWORD PTR _cdfa$[ebp]
  00270	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00273	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  00276	83 3c 82 00	 cmp	 DWORD PTR [edx+eax*4], 0
  0027a	7c 33		 jl	 SHORT $LN13@antlr3dfap

; 176  : 		{
; 177  : 			is->rewind(is, mark);

  0027c	8b f4		 mov	 esi, esp
  0027e	8b 4d fc	 mov	 ecx, DWORD PTR _mark$[ebp]
  00281	51		 push	 ecx
  00282	8b 55 10	 mov	 edx, DWORD PTR _is$[ebp]
  00285	52		 push	 edx
  00286	8b 45 10	 mov	 eax, DWORD PTR _is$[ebp]
  00289	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0028c	ff d1		 call	 ecx
  0028e	83 c4 08	 add	 esp, 8
  00291	3b f4		 cmp	 esi, esp
  00293	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 178  : 			return  cdfa->accept[cdfa->eof[s]];

  00298	8b 55 14	 mov	 edx, DWORD PTR _cdfa$[ebp]
  0029b	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0029e	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  002a1	8b 14 88	 mov	 edx, DWORD PTR [eax+ecx*4]
  002a4	8b 45 14	 mov	 eax, DWORD PTR _cdfa$[ebp]
  002a7	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  002aa	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  002ad	eb 39		 jmp	 SHORT $LN3@antlr3dfap
$LN13@antlr3dfap:

; 179  : 		}
; 180  : 
; 181  : 		/* No alt, so bomb
; 182  : 		 */
; 183  : 		noViableAlt(rec, cdfa, s);

  002af	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  002b2	52		 push	 edx
  002b3	8b 45 14	 mov	 eax, DWORD PTR _cdfa$[ebp]
  002b6	50		 push	 eax
  002b7	8b 4d 0c	 mov	 ecx, DWORD PTR _rec$[ebp]
  002ba	51		 push	 ecx
  002bb	e8 00 00 00 00	 call	 _noViableAlt
  002c0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 184  : 		is->rewind(is, mark);

  002c3	8b f4		 mov	 esi, esp
  002c5	8b 55 fc	 mov	 edx, DWORD PTR _mark$[ebp]
  002c8	52		 push	 edx
  002c9	8b 45 10	 mov	 eax, DWORD PTR _is$[ebp]
  002cc	50		 push	 eax
  002cd	8b 4d 10	 mov	 ecx, DWORD PTR _is$[ebp]
  002d0	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  002d3	ff d2		 call	 edx
  002d5	83 c4 08	 add	 esp, 8
  002d8	3b f4		 cmp	 esi, esp
  002da	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 185  : 		return 0;

  002df	33 c0		 xor	 eax, eax
  002e1	eb 05		 jmp	 SHORT $LN3@antlr3dfap

; 186  : 	}

  002e3	e9 55 fd ff ff	 jmp	 $LN2@antlr3dfap
$LN3@antlr3dfap:

; 187  : 
; 188  : }

  002e8	5e		 pop	 esi
  002e9	83 c4 14	 add	 esp, 20			; 00000014H
  002ec	3b ec		 cmp	 ebp, esp
  002ee	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002f3	8b e5		 mov	 esp, ebp
  002f5	5d		 pop	 ebp
  002f6	c3		 ret	 0
_antlr3dfapredict ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3cyclicdfa.c
;	COMDAT _antlr3dfaspecialStateTransition
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_recognizer$ = 12					; size = 4
_is$ = 16						; size = 4
_dfa$ = 20						; size = 4
_s$ = 24						; size = 4
_antlr3dfaspecialStateTransition PROC			; COMDAT

; 194  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 195  :     return -1;

  00003	83 c8 ff	 or	 eax, -1

; 196  : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
_antlr3dfaspecialStateTransition ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3cyclicdfa.c
;	COMDAT _antlr3dfaspecialTransition
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_recognizer$ = 12					; size = 4
_is$ = 16						; size = 4
_dfa$ = 20						; size = 4
_s$ = 24						; size = 4
_antlr3dfaspecialTransition PROC			; COMDAT

; 202  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 203  :     return 0;

  00003	33 c0		 xor	 eax, eax

; 204  : }

  00005	5d		 pop	 ebp
  00006	c3		 ret	 0
_antlr3dfaspecialTransition ENDP
_TEXT	ENDS
END
