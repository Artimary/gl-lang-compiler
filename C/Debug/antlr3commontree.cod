; Listing generated by Microsoft (R) Optimizing Compiler Version 19.42.34436.0 

	TITLE	C:\SPO_labs\C\Debug\antlr3commontree.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_antlr3CommonTreeNew
PUBLIC	_antlr3CommonTreeNewFromToken
PUBLIC	_antlr3ArboretumNew
PUBLIC	_antlr3SetCTAPI
PUBLIC	??_C@_03ILAMHENH@nil@				; `string'
EXTRN	__imp__calloc:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp__realloc:PROC
EXTRN	_antlr3VectorFactoryNew:PROC
EXTRN	_antlr3StackNew:PROC
EXTRN	_antlr3BaseTreeNew:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_03ILAMHENH@nil@
CONST	SEGMENT
??_C@_03ILAMHENH@nil@ DB 'nil', 00H			; `string'
CONST	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontree.c
;	COMDAT _factoryClose
_TEXT	SEGMENT
_poolCount$ = -4					; size = 4
_factory$ = 8						; size = 4
_factoryClose PROC					; COMDAT

; 272  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 273  : 	ANTLR3_INT32	    poolCount;
; 274  : 
; 275  : 	// First close the vector factory that supplied all the child pointer
; 276  : 	// vectors.
; 277  : 	//
; 278  : 	factory->vFactory->close(factory->vFactory);

  0000c	8b f4		 mov	 esi, esp
  0000e	8b 45 08	 mov	 eax, DWORD PTR _factory$[ebp]
  00011	8b 88 a8 00 00
	00		 mov	 ecx, DWORD PTR [eax+168]
  00017	51		 push	 ecx
  00018	8b 55 08	 mov	 edx, DWORD PTR _factory$[ebp]
  0001b	8b 82 a8 00 00
	00		 mov	 eax, DWORD PTR [edx+168]
  00021	8b 88 c4 00 00
	00		 mov	 ecx, DWORD PTR [eax+196]
  00027	ff d1		 call	 ecx
  00029	83 c4 04	 add	 esp, 4
  0002c	3b f4		 cmp	 esi, esp
  0002e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 279  : 
; 280  :     if  (factory->nilStack !=  NULL)

  00033	8b 55 08	 mov	 edx, DWORD PTR _factory$[ebp]
  00036	83 ba ac 00 00
	00 00		 cmp	 DWORD PTR [edx+172], 0
  0003d	74 25		 je	 SHORT $LN5@factoryClo

; 281  :     {
; 282  :         factory->nilStack->free(factory->nilStack);

  0003f	8b f4		 mov	 esi, esp
  00041	8b 45 08	 mov	 eax, DWORD PTR _factory$[ebp]
  00044	8b 88 ac 00 00
	00		 mov	 ecx, DWORD PTR [eax+172]
  0004a	51		 push	 ecx
  0004b	8b 55 08	 mov	 edx, DWORD PTR _factory$[ebp]
  0004e	8b 82 ac 00 00
	00		 mov	 eax, DWORD PTR [edx+172]
  00054	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00057	ff d1		 call	 ecx
  00059	83 c4 04	 add	 esp, 4
  0005c	3b f4		 cmp	 esi, esp
  0005e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00063	90		 npad	 1
$LN5@factoryClo:

; 283  :     }
; 284  : 
; 285  : 	// We now JUST free the pools because the C runtime CommonToken based tree
; 286  : 	// cannot contain anything that was not made by this factory.
; 287  : 	//
; 288  : 	for	(poolCount = 0; poolCount <= factory->thisPool; poolCount++)

  00064	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _poolCount$[ebp], 0
  0006b	eb 09		 jmp	 SHORT $LN4@factoryClo
$LN2@factoryClo:
  0006d	8b 55 fc	 mov	 edx, DWORD PTR _poolCount$[ebp]
  00070	83 c2 01	 add	 edx, 1
  00073	89 55 fc	 mov	 DWORD PTR _poolCount$[ebp], edx
$LN4@factoryClo:
  00076	8b 45 08	 mov	 eax, DWORD PTR _factory$[ebp]
  00079	8b 4d fc	 mov	 ecx, DWORD PTR _poolCount$[ebp]
  0007c	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  0007f	7f 2f		 jg	 SHORT $LN3@factoryClo

; 289  : 	{
; 290  : 		// We can now free this pool allocation
; 291  : 		//
; 292  : 		ANTLR3_FREE(factory->pools[poolCount]);

  00081	8b 55 08	 mov	 edx, DWORD PTR _factory$[ebp]
  00084	8b 02		 mov	 eax, DWORD PTR [edx]
  00086	8b f4		 mov	 esi, esp
  00088	8b 4d fc	 mov	 ecx, DWORD PTR _poolCount$[ebp]
  0008b	8b 14 88	 mov	 edx, DWORD PTR [eax+ecx*4]
  0008e	52		 push	 edx
  0008f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00095	83 c4 04	 add	 esp, 4
  00098	3b f4		 cmp	 esi, esp
  0009a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 293  : 		factory->pools[poolCount] = NULL;

  0009f	8b 45 08	 mov	 eax, DWORD PTR _factory$[ebp]
  000a2	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a4	8b 55 fc	 mov	 edx, DWORD PTR _poolCount$[ebp]
  000a7	c7 04 91 00 00
	00 00		 mov	 DWORD PTR [ecx+edx*4], 0

; 294  : 	}

  000ae	eb bd		 jmp	 SHORT $LN2@factoryClo
$LN3@factoryClo:

; 295  : 
; 296  : 	// All the pools are deallocated we can free the pointers to the pools
; 297  : 	// now.
; 298  : 	//
; 299  : 	ANTLR3_FREE(factory->pools);

  000b0	8b f4		 mov	 esi, esp
  000b2	8b 45 08	 mov	 eax, DWORD PTR _factory$[ebp]
  000b5	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b7	51		 push	 ecx
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  000be	83 c4 04	 add	 esp, 4
  000c1	3b f4		 cmp	 esi, esp
  000c3	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 300  : 
; 301  : 	// Finally, we can free the space for the factory itself
; 302  : 	//
; 303  : 	ANTLR3_FREE(factory);

  000c8	8b f4		 mov	 esi, esp
  000ca	8b 55 08	 mov	 edx, DWORD PTR _factory$[ebp]
  000cd	52		 push	 edx
  000ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  000d4	83 c4 04	 add	 esp, 4
  000d7	3b f4		 cmp	 esi, esp
  000d9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000de	90		 npad	 1

; 304  : }

  000df	5e		 pop	 esi
  000e0	83 c4 04	 add	 esp, 4
  000e3	3b ec		 cmp	 ebp, esp
  000e5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ea	8b e5		 mov	 esp, ebp
  000ec	5d		 pop	 ebp
  000ed	c3		 ret	 0
_factoryClose ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontree.c
;	COMDAT _newFromToken
_TEXT	SEGMENT
_newTree$ = -4						; size = 4
_factory$ = 8						; size = 4
_token$ = 12						; size = 4
_newFromToken PROC					; COMDAT

; 253  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 254  : 	pANTLR3_BASE_TREE	newTree;
; 255  : 
; 256  : 	newTree = factory->newTree(factory);

  0000c	8b f4		 mov	 esi, esp
  0000e	8b 45 08	 mov	 eax, DWORD PTR _factory$[ebp]
  00011	50		 push	 eax
  00012	8b 4d 08	 mov	 ecx, DWORD PTR _factory$[ebp]
  00015	8b 91 b0 00 00
	00		 mov	 edx, DWORD PTR [ecx+176]
  0001b	ff d2		 call	 edx
  0001d	83 c4 04	 add	 esp, 4
  00020	3b f4		 cmp	 esi, esp
  00022	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00027	89 45 fc	 mov	 DWORD PTR _newTree$[ebp], eax

; 257  : 
; 258  : 	if	(newTree == NULL)

  0002a	83 7d fc 00	 cmp	 DWORD PTR _newTree$[ebp], 0
  0002e	75 04		 jne	 SHORT $LN2@newFromTok

; 259  : 	{
; 260  : 		return	NULL;

  00030	33 c0		 xor	 eax, eax
  00032	eb 0e		 jmp	 SHORT $LN1@newFromTok
$LN2@newFromTok:

; 261  : 	}
; 262  : 
; 263  : 	// Pick up the payload we had in the supplied tree
; 264  : 	//
; 265  : 	((pANTLR3_COMMON_TREE)(newTree->super))->token = token;

  00034	8b 45 fc	 mov	 eax, DWORD PTR _newTree$[ebp]
  00037	8b 08		 mov	 ecx, DWORD PTR [eax]
  00039	8b 55 0c	 mov	 edx, DWORD PTR _token$[ebp]
  0003c	89 51 0c	 mov	 DWORD PTR [ecx+12], edx

; 266  : 
; 267  : 	return newTree;

  0003f	8b 45 fc	 mov	 eax, DWORD PTR _newTree$[ebp]
$LN1@newFromTok:

; 268  : }

  00042	5e		 pop	 esi
  00043	83 c4 04	 add	 esp, 4
  00046	3b ec		 cmp	 ebp, esp
  00048	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c3		 ret	 0
_newFromToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontree.c
;	COMDAT _newFromTree
_TEXT	SEGMENT
_newTree$ = -4						; size = 4
_factory$ = 8						; size = 4
_tree$ = 12						; size = 4
_newFromTree PROC					; COMDAT

; 233  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 234  : 	pANTLR3_BASE_TREE	newTree;
; 235  : 
; 236  : 	newTree = factory->newTree(factory);

  0000c	8b f4		 mov	 esi, esp
  0000e	8b 45 08	 mov	 eax, DWORD PTR _factory$[ebp]
  00011	50		 push	 eax
  00012	8b 4d 08	 mov	 ecx, DWORD PTR _factory$[ebp]
  00015	8b 91 b0 00 00
	00		 mov	 edx, DWORD PTR [ecx+176]
  0001b	ff d2		 call	 edx
  0001d	83 c4 04	 add	 esp, 4
  00020	3b f4		 cmp	 esi, esp
  00022	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00027	89 45 fc	 mov	 DWORD PTR _newTree$[ebp], eax

; 237  : 
; 238  : 	if	(newTree == NULL)

  0002a	83 7d fc 00	 cmp	 DWORD PTR _newTree$[ebp], 0
  0002e	75 04		 jne	 SHORT $LN2@newFromTre

; 239  : 	{
; 240  : 		return	NULL;

  00030	33 c0		 xor	 eax, eax
  00032	eb 1d		 jmp	 SHORT $LN1@newFromTre
$LN2@newFromTre:

; 241  : 	}
; 242  : 
; 243  : 	// Pick up the payload we had in the supplied tree
; 244  : 	//
; 245  : 	((pANTLR3_COMMON_TREE)(newTree->super))->token   = tree->token;

  00034	8b 45 fc	 mov	 eax, DWORD PTR _newTree$[ebp]
  00037	8b 08		 mov	 ecx, DWORD PTR [eax]
  00039	8b 55 0c	 mov	 edx, DWORD PTR _tree$[ebp]
  0003c	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0003f	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 246  : 	newTree->u		    = tree->baseTree.u;							// Copy any user pointer

  00042	8b 4d fc	 mov	 ecx, DWORD PTR _newTree$[ebp]
  00045	8b 55 0c	 mov	 edx, DWORD PTR _tree$[ebp]
  00048	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0004b	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 247  : 
; 248  : 	return  newTree;

  0004e	8b 45 fc	 mov	 eax, DWORD PTR _newTree$[ebp]
$LN1@newFromTre:

; 249  : }

  00051	5e		 pop	 esi
  00052	83 c4 04	 add	 esp, 4
  00055	3b ec		 cmp	 ebp, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
_newFromTree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontree.c
;	COMDAT _newPoolTree
_TEXT	SEGMENT
_tree$ = -4						; size = 4
_factory$ = 8						; size = 4
_newPoolTree PROC					; COMDAT

; 170  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 171  : 	pANTLR3_COMMON_TREE    tree;
; 172  : 
; 173  :     // If we have anything on the re claim stack, reuse that sucker first
; 174  :     //
; 175  :     tree = (pANTLR3_COMMON_TREE)factory->nilStack->peek(factory->nilStack);

  0000c	8b f4		 mov	 esi, esp
  0000e	8b 45 08	 mov	 eax, DWORD PTR _factory$[ebp]
  00011	8b 88 ac 00 00
	00		 mov	 ecx, DWORD PTR [eax+172]
  00017	51		 push	 ecx
  00018	8b 55 08	 mov	 edx, DWORD PTR _factory$[ebp]
  0001b	8b 82 ac 00 00
	00		 mov	 eax, DWORD PTR [edx+172]
  00021	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00024	ff d1		 call	 ecx
  00026	83 c4 04	 add	 esp, 4
  00029	3b f4		 cmp	 esi, esp
  0002b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00030	89 45 fc	 mov	 DWORD PTR _tree$[ebp], eax

; 176  : 
; 177  :     if  (tree != NULL)

  00033	83 7d fc 00	 cmp	 DWORD PTR _tree$[ebp], 0
  00037	74 29		 je	 SHORT $LN2@newPoolTre

; 178  :     {
; 179  :         // Cool we got something we could reuse, it will have been cleaned up by
; 180  :         // whatever put it back on the stack (for instance if it had a child vector,
; 181  :         // that will have been cleared to hold zero entries and that vector will get reused too.
; 182  :         // It is the basetree pointer that is placed on the stack of course
; 183  :         //
; 184  :         factory->nilStack->pop(factory->nilStack);

  00039	8b f4		 mov	 esi, esp
  0003b	8b 55 08	 mov	 edx, DWORD PTR _factory$[ebp]
  0003e	8b 82 ac 00 00
	00		 mov	 eax, DWORD PTR [edx+172]
  00044	50		 push	 eax
  00045	8b 4d 08	 mov	 ecx, DWORD PTR _factory$[ebp]
  00048	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR [ecx+172]
  0004e	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00051	ff d0		 call	 eax
  00053	83 c4 04	 add	 esp, 4
  00056	3b f4		 cmp	 esi, esp
  00058	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 185  :         return (pANTLR3_BASE_TREE)tree;

  0005d	8b 45 fc	 mov	 eax, DWORD PTR _tree$[ebp]
  00060	eb 7d		 jmp	 SHORT $LN1@newPoolTre
$LN2@newPoolTre:

; 186  : 
; 187  :     }
; 188  : 	// See if we need a new tree pool before allocating a new tree
; 189  : 	//
; 190  : 	if	(factory->nextTree >= ANTLR3_FACTORY_POOL_SIZE)

  00062	8b 4d 08	 mov	 ecx, DWORD PTR _factory$[ebp]
  00065	81 79 08 00 04
	00 00		 cmp	 DWORD PTR [ecx+8], 1024	; 00000400H
  0006c	72 17		 jb	 SHORT $LN4@newPoolTre

; 191  : 	{
; 192  : 		// We ran out of tokens in the current pool, so we need a new pool
; 193  : 		//
; 194  : 		if (!newPool(factory))

  0006e	8b 55 08	 mov	 edx, DWORD PTR _factory$[ebp]
  00071	52		 push	 edx
  00072	e8 00 00 00 00	 call	 _newPool
  00077	83 c4 04	 add	 esp, 4
  0007a	0f b6 c0	 movzx	 eax, al
  0007d	85 c0		 test	 eax, eax
  0007f	75 04		 jne	 SHORT $LN4@newPoolTre

; 195  : 		{
; 196  : 			// new pool creation failed
; 197  : 			return NULL;

  00081	33 c0		 xor	 eax, eax
  00083	eb 5a		 jmp	 SHORT $LN1@newPoolTre
$LN4@newPoolTre:

; 198  : 		}
; 199  : 	}
; 200  : 
; 201  : 	// Assuming everything went well - we are trying for performance here so doing minimal
; 202  : 	// error checking - then we can work out what the pointer is to the next commontree.
; 203  : 	//
; 204  : 	tree   = factory->pools[factory->thisPool] + factory->nextTree;

  00085	8b 4d 08	 mov	 ecx, DWORD PTR _factory$[ebp]
  00088	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0008b	8b 45 08	 mov	 eax, DWORD PTR _factory$[ebp]
  0008e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00090	8b 45 08	 mov	 eax, DWORD PTR _factory$[ebp]
  00093	69 40 08 9c 00
	00 00		 imul	 eax, DWORD PTR [eax+8], 156
  0009a	03 04 91	 add	 eax, DWORD PTR [ecx+edx*4]
  0009d	89 45 fc	 mov	 DWORD PTR _tree$[ebp], eax

; 205  : 	factory->nextTree++;

  000a0	8b 4d 08	 mov	 ecx, DWORD PTR _factory$[ebp]
  000a3	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000a6	83 c2 01	 add	 edx, 1
  000a9	8b 45 08	 mov	 eax, DWORD PTR _factory$[ebp]
  000ac	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 206  : 
; 207  : 	// We have our token pointer now, so we can initialize it to the predefined model.
; 208  : 	//
; 209  :     antlr3SetCTAPI(tree);

  000af	8b 4d fc	 mov	 ecx, DWORD PTR _tree$[ebp]
  000b2	51		 push	 ecx
  000b3	e8 00 00 00 00	 call	 _antlr3SetCTAPI
  000b8	83 c4 04	 add	 esp, 4

; 210  : 
; 211  :     // Set some initial variables for future copying, including a string factory
; 212  :     // that we can use later for converting trees to strings.
; 213  :     //
; 214  : 	tree->factory				= factory;

  000bb	8b 55 fc	 mov	 edx, DWORD PTR _tree$[ebp]
  000be	8b 45 08	 mov	 eax, DWORD PTR _factory$[ebp]
  000c1	89 42 18	 mov	 DWORD PTR [edx+24], eax

; 215  :     tree->baseTree.strFactory	= factory->unTruc.baseTree.strFactory;

  000c4	8b 4d fc	 mov	 ecx, DWORD PTR _tree$[ebp]
  000c7	8b 55 08	 mov	 edx, DWORD PTR _factory$[ebp]
  000ca	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  000cd	89 41 2c	 mov	 DWORD PTR [ecx+44], eax

; 216  : 
; 217  : 	// The super points to the common tree so we must override the one used by
; 218  : 	// by the pre-built tree as otherwise we will always poitn to the same initial
; 219  : 	// common tree and we might spend 3 hours trying to debug why - this would never
; 220  : 	// happen to me of course! :-(
; 221  : 	//
; 222  : 	tree->baseTree.super	= tree;

  000d0	8b 4d fc	 mov	 ecx, DWORD PTR _tree$[ebp]
  000d3	8b 55 fc	 mov	 edx, DWORD PTR _tree$[ebp]
  000d6	89 51 1c	 mov	 DWORD PTR [ecx+28], edx

; 223  : 
; 224  : 
; 225  : 	// And we are done
; 226  : 	//
; 227  : 	return  &(tree->baseTree);

  000d9	8b 45 fc	 mov	 eax, DWORD PTR _tree$[ebp]
  000dc	83 c0 1c	 add	 eax, 28			; 0000001cH
$LN1@newPoolTre:

; 228  : }

  000df	5e		 pop	 esi
  000e0	83 c4 04	 add	 esp, 4
  000e3	3b ec		 cmp	 ebp, esp
  000e5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ea	8b e5		 mov	 esp, ebp
  000ec	5d		 pop	 ebp
  000ed	c3		 ret	 0
_newPoolTree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontree.c
;	COMDAT _newPool
_TEXT	SEGMENT
_newPools$ = -4						; size = 4
_factory$ = 8						; size = 4
_newPool PROC						; COMDAT

; 125  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 126  : 	pANTLR3_COMMON_TREE *newPools;
; 127  : 
; 128  :     // Increment factory count
; 129  :     //
; 130  :     ++factory->thisPool;

  0000c	8b 45 08	 mov	 eax, DWORD PTR _factory$[ebp]
  0000f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00012	83 c1 01	 add	 ecx, 1
  00015	8b 55 08	 mov	 edx, DWORD PTR _factory$[ebp]
  00018	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 131  : 
; 132  :     // Ensure we have enough pointers allocated
; 133  :     //
; 134  :     newPools = (pANTLR3_COMMON_TREE *)

  0001b	8b 45 08	 mov	 eax, DWORD PTR _factory$[ebp]
  0001e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00021	8d 14 8d 04 00
	00 00		 lea	 edx, DWORD PTR [ecx*4+4]
  00028	8b f4		 mov	 esi, esp
  0002a	52		 push	 edx
  0002b	8b 45 08	 mov	 eax, DWORD PTR _factory$[ebp]
  0002e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00030	51		 push	 ecx
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__realloc
  00037	83 c4 08	 add	 esp, 8
  0003a	3b f4		 cmp	 esi, esp
  0003c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00041	89 45 fc	 mov	 DWORD PTR _newPools$[ebp], eax

; 135  : 					ANTLR3_REALLOC(	(void *)factory->pools,										// Current pools pointer (starts at NULL)
; 136  : 					(ANTLR3_UINT32)((factory->thisPool + 1) * sizeof(pANTLR3_COMMON_TREE *))	// Memory for new pool pointers
; 137  : 					);
; 138  : 	if (newPools == NULL)

  00044	83 7d fc 00	 cmp	 DWORD PTR _newPools$[ebp], 0
  00048	75 13		 jne	 SHORT $LN2@newPool

; 139  : 	{
; 140  : 		// realloc failed, but we still have the old allocation
; 141  : 		--factory->thisPool;

  0004a	8b 55 08	 mov	 edx, DWORD PTR _factory$[ebp]
  0004d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00050	83 e8 01	 sub	 eax, 1
  00053	8b 4d 08	 mov	 ecx, DWORD PTR _factory$[ebp]
  00056	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 142  : 		return ANTLR3_FALSE;

  00059	32 c0		 xor	 al, al
  0005b	eb 5d		 jmp	 SHORT $LN1@newPool
$LN2@newPool:

; 143  : 	}
; 144  : 	factory->pools = newPools;

  0005d	8b 55 08	 mov	 edx, DWORD PTR _factory$[ebp]
  00060	8b 45 fc	 mov	 eax, DWORD PTR _newPools$[ebp]
  00063	89 02		 mov	 DWORD PTR [edx], eax

; 145  : 
; 146  :     // Allocate a new pool for the factory
; 147  :     //
; 148  :     factory->pools[factory->thisPool]	=

  00065	8b f4		 mov	 esi, esp
  00067	68 00 70 02 00	 push	 159744			; 00027000H
  0006c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00072	83 c4 04	 add	 esp, 4
  00075	3b f4		 cmp	 esi, esp
  00077	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007c	8b 4d 08	 mov	 ecx, DWORD PTR _factory$[ebp]
  0007f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00082	8b 4d 08	 mov	 ecx, DWORD PTR _factory$[ebp]
  00085	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00087	89 04 91	 mov	 DWORD PTR [ecx+edx*4], eax

; 149  : 			    (pANTLR3_COMMON_TREE) 
; 150  : 				ANTLR3_MALLOC((size_t)(sizeof(ANTLR3_COMMON_TREE) * ANTLR3_FACTORY_POOL_SIZE));
; 151  : 	if (factory->pools[factory->thisPool] == NULL)

  0008a	8b 55 08	 mov	 edx, DWORD PTR _factory$[ebp]
  0008d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00090	8b 4d 08	 mov	 ecx, DWORD PTR _factory$[ebp]
  00093	8b 11		 mov	 edx, DWORD PTR [ecx]
  00095	83 3c 82 00	 cmp	 DWORD PTR [edx+eax*4], 0
  00099	75 13		 jne	 SHORT $LN3@newPool

; 152  : 	{
; 153  : 		// malloc failed
; 154  : 		--factory->thisPool;

  0009b	8b 45 08	 mov	 eax, DWORD PTR _factory$[ebp]
  0009e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000a1	83 e9 01	 sub	 ecx, 1
  000a4	8b 55 08	 mov	 edx, DWORD PTR _factory$[ebp]
  000a7	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 155  : 		return ANTLR3_FALSE;

  000aa	32 c0		 xor	 al, al
  000ac	eb 0c		 jmp	 SHORT $LN1@newPool
$LN3@newPool:

; 156  : 	}
; 157  : 
; 158  : 
; 159  :     // Reset the counters
; 160  :     //
; 161  :     factory->nextTree	= 0;

  000ae	8b 45 08	 mov	 eax, DWORD PTR _factory$[ebp]
  000b1	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 162  :   
; 163  :     // Done
; 164  :     //
; 165  :     return ANTLR3_TRUE;

  000b8	b0 01		 mov	 al, 1
$LN1@newPool:

; 166  : }

  000ba	5e		 pop	 esi
  000bb	83 c4 04	 add	 esp, 4
  000be	3b ec		 cmp	 ebp, esp
  000c0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c5	8b e5		 mov	 esp, ebp
  000c7	5d		 pop	 ebp
  000c8	c3		 ret	 0
_newPool ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontree.c
;	COMDAT _reuse
_TEXT	SEGMENT
_cTree$ = -4						; size = 4
_tree$ = 8						; size = 4
_reuse	PROC						; COMDAT

; 552  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 553  :     pANTLR3_COMMON_TREE	    cTree;
; 554  : 
; 555  : 	cTree   = (pANTLR3_COMMON_TREE)(tree->super);

  0000c	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	89 4d fc	 mov	 DWORD PTR _cTree$[ebp], ecx

; 556  : 
; 557  :     if  (cTree->factory != NULL)

  00014	8b 55 fc	 mov	 edx, DWORD PTR _cTree$[ebp]
  00017	83 7a 18 00	 cmp	 DWORD PTR [edx+24], 0
  0001b	74 5c		 je	 SHORT $LN2@reuse

; 558  :     {
; 559  : 
; 560  :         if  (cTree->baseTree.children != NULL)

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _cTree$[ebp]
  00020	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  00024	74 22		 je	 SHORT $LN3@reuse

; 561  :         {
; 562  :             
; 563  :             cTree->baseTree.children->clear(cTree->baseTree.children);

  00026	8b f4		 mov	 esi, esp
  00028	8b 4d fc	 mov	 ecx, DWORD PTR _cTree$[ebp]
  0002b	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  0002e	52		 push	 edx
  0002f	8b 45 fc	 mov	 eax, DWORD PTR _cTree$[ebp]
  00032	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00035	8b 91 a0 00 00
	00		 mov	 edx, DWORD PTR [ecx+160]
  0003b	ff d2		 call	 edx
  0003d	83 c4 04	 add	 esp, 4
  00040	3b f4		 cmp	 esi, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	90		 npad	 1
$LN3@reuse:

; 564  :         }
; 565  :        cTree->factory->nilStack->push(cTree->factory->nilStack, tree, NULL);

  00048	8b f4		 mov	 esi, esp
  0004a	6a 00		 push	 0
  0004c	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  0004f	50		 push	 eax
  00050	8b 4d fc	 mov	 ecx, DWORD PTR _cTree$[ebp]
  00053	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00056	8b 82 ac 00 00
	00		 mov	 eax, DWORD PTR [edx+172]
  0005c	50		 push	 eax
  0005d	8b 4d fc	 mov	 ecx, DWORD PTR _cTree$[ebp]
  00060	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00063	8b 82 ac 00 00
	00		 mov	 eax, DWORD PTR [edx+172]
  00069	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0006c	ff d1		 call	 ecx
  0006e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00071	3b f4		 cmp	 esi, esp
  00073	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00078	90		 npad	 1
$LN2@reuse:

; 566  :        
; 567  :     }
; 568  : }

  00079	5e		 pop	 esi
  0007a	83 c4 04	 add	 esp, 4
  0007d	3b ec		 cmp	 ebp, esp
  0007f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c3		 ret	 0
_reuse	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontree.c
;	COMDAT _createChildrenList
_TEXT	SEGMENT
_tree$ = 8						; size = 4
_createChildrenList PROC				; COMDAT

; 394  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 395  : 	tree->children = ((pANTLR3_COMMON_TREE)(tree->super))->factory->vFactory->newVector(((pANTLR3_COMMON_TREE)(tree->super))->factory->vFactory);

  00004	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  00007	8b 08		 mov	 ecx, DWORD PTR [eax]
  00009	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0000c	8b f4		 mov	 esi, esp
  0000e	8b 82 a8 00 00
	00		 mov	 eax, DWORD PTR [edx+168]
  00014	50		 push	 eax
  00015	8b 4d 08	 mov	 ecx, DWORD PTR _tree$[ebp]
  00018	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001a	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0001d	8b 88 a8 00 00
	00		 mov	 ecx, DWORD PTR [eax+168]
  00023	8b 91 c8 00 00
	00		 mov	 edx, DWORD PTR [ecx+200]
  00029	ff d2		 call	 edx
  0002b	83 c4 04	 add	 esp, 4
  0002e	3b f4		 cmp	 esi, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	8b 4d 08	 mov	 ecx, DWORD PTR _tree$[ebp]
  00038	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 396  : }

  0003b	5e		 pop	 esi
  0003c	3b ec		 cmp	 ebp, esp
  0003e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
_createChildrenList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontree.c
;	COMDAT _getChildIndex
_TEXT	SEGMENT
_tree$ = 8						; size = 4
_getChildIndex PROC					; COMDAT

; 543  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 544  : 	return ((pANTLR3_COMMON_TREE)(tree->super))->childIndex;

  00003	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]

; 545  : }

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
_getChildIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontree.c
;	COMDAT _setChildIndex
_TEXT	SEGMENT
_tree$ = 8						; size = 4
_i$ = 12						; size = 4
_setChildIndex PROC					; COMDAT

; 538  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 539  : 	((pANTLR3_COMMON_TREE)(tree->super))->childIndex = i;

  00003	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	8b 55 0c	 mov	 edx, DWORD PTR _i$[ebp]
  0000b	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 540  : }

  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
_setChildIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontree.c
;	COMDAT _setParent
_TEXT	SEGMENT
tv68 = -4						; size = 4
_tree$ = 8						; size = 4
_parent$ = 12						; size = 4
_setParent PROC						; COMDAT

; 532  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 533  : 	((pANTLR3_COMMON_TREE)(tree->super))->parent = parent == NULL ? NULL : ((pANTLR3_COMMON_TREE)(parent->super));

  00004	83 7d 0c 00	 cmp	 DWORD PTR _parent$[ebp], 0
  00008	75 09		 jne	 SHORT $LN3@setParent
  0000a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
  00011	eb 08		 jmp	 SHORT $LN4@setParent
$LN3@setParent:
  00013	8b 45 0c	 mov	 eax, DWORD PTR _parent$[ebp]
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	89 4d fc	 mov	 DWORD PTR tv68[ebp], ecx
$LN4@setParent:
  0001b	8b 55 08	 mov	 edx, DWORD PTR _tree$[ebp]
  0001e	8b 02		 mov	 eax, DWORD PTR [edx]
  00020	8b 4d fc	 mov	 ecx, DWORD PTR tv68[ebp]
  00023	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 534  : }

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
_setParent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontree.c
;	COMDAT _getParent
_TEXT	SEGMENT
_tree$ = 8						; size = 4
_getParent PROC						; COMDAT

; 524  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 525  : 	if (((pANTLR3_COMMON_TREE)(tree->super))->parent == NULL)

  00003	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  0000c	75 04		 jne	 SHORT $LN2@getParent

; 526  : 		return NULL;

  0000e	33 c0		 xor	 eax, eax
  00010	eb 0b		 jmp	 SHORT $LN1@getParent
$LN2@getParent:

; 527  : 	return & (((pANTLR3_COMMON_TREE)(tree->super))->parent->baseTree);

  00012	8b 55 08	 mov	 edx, DWORD PTR _tree$[ebp]
  00015	8b 02		 mov	 eax, DWORD PTR [edx]
  00017	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0001a	83 c0 1c	 add	 eax, 28			; 0000001cH
$LN1@getParent:

; 528  : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
_getParent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontree.c
;	COMDAT _toString
_TEXT	SEGMENT
_nilNode$1 = -4						; size = 4
_tree$ = 8						; size = 4
_toString PROC						; COMDAT

; 509  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 510  : 	if  (tree->isNilNode(tree) == ANTLR3_TRUE)

  0000c	8b f4		 mov	 esi, esp
  0000e	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  00011	50		 push	 eax
  00012	8b 4d 08	 mov	 ecx, DWORD PTR _tree$[ebp]
  00015	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  00018	ff d2		 call	 edx
  0001a	83 c4 04	 add	 esp, 4
  0001d	3b f4		 cmp	 esi, esp
  0001f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00024	0f b6 c0	 movzx	 eax, al
  00027	83 f8 01	 cmp	 eax, 1
  0002a	75 2d		 jne	 SHORT $LN2@toString

; 511  : 	{
; 512  : 		pANTLR3_STRING  nilNode;
; 513  : 
; 514  : 		nilNode	= tree->strFactory->newPtr(tree->strFactory, (pANTLR3_UINT8)"nil", 3);

  0002c	8b f4		 mov	 esi, esp
  0002e	6a 03		 push	 3
  00030	68 00 00 00 00	 push	 OFFSET ??_C@_03ILAMHENH@nil@
  00035	8b 4d 08	 mov	 ecx, DWORD PTR _tree$[ebp]
  00038	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0003b	52		 push	 edx
  0003c	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  0003f	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00042	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00045	ff d2		 call	 edx
  00047	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004a	3b f4		 cmp	 esi, esp
  0004c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00051	89 45 fc	 mov	 DWORD PTR _nilNode$1[ebp], eax

; 515  : 
; 516  : 		return nilNode;

  00054	8b 45 fc	 mov	 eax, DWORD PTR _nilNode$1[ebp]
  00057	eb 22		 jmp	 SHORT $LN1@toString
$LN2@toString:

; 517  : 	}
; 518  : 
; 519  : 	return	((pANTLR3_COMMON_TREE)(tree->super))->token->getText(((pANTLR3_COMMON_TREE)(tree->super))->token);

  00059	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  0005c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005e	8b f4		 mov	 esi, esp
  00060	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00063	52		 push	 edx
  00064	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  00067	8b 08		 mov	 ecx, DWORD PTR [eax]
  00069	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0006c	8b 42 48	 mov	 eax, DWORD PTR [edx+72]
  0006f	ff d0		 call	 eax
  00071	83 c4 04	 add	 esp, 4
  00074	3b f4		 cmp	 esi, esp
  00076	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@toString:

; 520  : }

  0007b	5e		 pop	 esi
  0007c	83 c4 04	 add	 esp, 4
  0007f	3b ec		 cmp	 ebp, esp
  00081	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c3		 ret	 0
_toString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontree.c
;	COMDAT _getCharPositionInLine
_TEXT	SEGMENT
_child$1 = -8						; size = 4
_token$ = -4						; size = 4
_tree$ = 8						; size = 4
_getCharPositionInLine PROC				; COMDAT

; 488  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 489  : 	pANTLR3_COMMON_TOKEN    token;
; 490  : 
; 491  : 	token   = ((pANTLR3_COMMON_TREE)(tree->super))->token;

  00015	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0001d	89 55 fc	 mov	 DWORD PTR _token$[ebp], edx

; 492  : 
; 493  : 	if	(token == NULL || token->getCharPositionInLine(token) == -1)

  00020	83 7d fc 00	 cmp	 DWORD PTR _token$[ebp], 0
  00024	74 1d		 je	 SHORT $LN3@getCharPos
  00026	8b f4		 mov	 esi, esp
  00028	8b 45 fc	 mov	 eax, DWORD PTR _token$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _token$[ebp]
  0002f	8b 51 64	 mov	 edx, DWORD PTR [ecx+100]
  00032	ff d2		 call	 edx
  00034	83 c4 04	 add	 esp, 4
  00037	3b f4		 cmp	 esi, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	83 f8 ff	 cmp	 eax, -1
  00041	75 57		 jne	 SHORT $LN2@getCharPos
$LN3@getCharPos:

; 494  : 	{
; 495  : 		if  (tree->getChildCount(tree) > 0)

  00043	8b f4		 mov	 esi, esp
  00045	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  00048	50		 push	 eax
  00049	8b 4d 08	 mov	 ecx, DWORD PTR _tree$[ebp]
  0004c	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  0004f	ff d2		 call	 edx
  00051	83 c4 04	 add	 esp, 4
  00054	3b f4		 cmp	 esi, esp
  00056	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005b	85 c0		 test	 eax, eax
  0005d	76 37		 jbe	 SHORT $LN4@getCharPos

; 496  : 		{
; 497  : 			pANTLR3_BASE_TREE	child;
; 498  : 
; 499  : 			child   = (pANTLR3_BASE_TREE)tree->getChild(tree, 0);

  0005f	8b f4		 mov	 esi, esp
  00061	6a 00		 push	 0
  00063	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  00066	50		 push	 eax
  00067	8b 4d 08	 mov	 ecx, DWORD PTR _tree$[ebp]
  0006a	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  0006d	ff d2		 call	 edx
  0006f	83 c4 08	 add	 esp, 8
  00072	3b f4		 cmp	 esi, esp
  00074	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00079	89 45 f8	 mov	 DWORD PTR _child$1[ebp], eax

; 500  : 
; 501  : 			return child->getCharPositionInLine(child);

  0007c	8b f4		 mov	 esi, esp
  0007e	8b 45 f8	 mov	 eax, DWORD PTR _child$1[ebp]
  00081	50		 push	 eax
  00082	8b 4d f8	 mov	 ecx, DWORD PTR _child$1[ebp]
  00085	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00088	ff d2		 call	 edx
  0008a	83 c4 04	 add	 esp, 4
  0008d	3b f4		 cmp	 esi, esp
  0008f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00094	eb 1c		 jmp	 SHORT $LN1@getCharPos
$LN4@getCharPos:

; 502  : 		}
; 503  : 		return 0;

  00096	33 c0		 xor	 eax, eax
  00098	eb 18		 jmp	 SHORT $LN1@getCharPos
$LN2@getCharPos:

; 504  : 	}
; 505  : 	return  token->getCharPositionInLine(token);

  0009a	8b f4		 mov	 esi, esp
  0009c	8b 45 fc	 mov	 eax, DWORD PTR _token$[ebp]
  0009f	50		 push	 eax
  000a0	8b 4d fc	 mov	 ecx, DWORD PTR _token$[ebp]
  000a3	8b 51 64	 mov	 edx, DWORD PTR [ecx+100]
  000a6	ff d2		 call	 edx
  000a8	83 c4 04	 add	 esp, 4
  000ab	3b f4		 cmp	 esi, esp
  000ad	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@getCharPos:

; 506  : }

  000b2	5e		 pop	 esi
  000b3	83 c4 08	 add	 esp, 8
  000b6	3b ec		 cmp	 ebp, esp
  000b8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bd	8b e5		 mov	 esp, ebp
  000bf	5d		 pop	 ebp
  000c0	c3		 ret	 0
_getCharPositionInLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontree.c
;	COMDAT _getLine
_TEXT	SEGMENT
_child$1 = -12						; size = 4
_token$ = -8						; size = 4
_cTree$ = -4						; size = 4
_tree$ = 8						; size = 4
_getLine PROC						; COMDAT

; 465  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000e	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00015	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 466  : 	pANTLR3_COMMON_TREE	    cTree;
; 467  : 	pANTLR3_COMMON_TOKEN    token;
; 468  : 
; 469  : 	cTree   = (pANTLR3_COMMON_TREE)(tree->super);

  0001c	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  0001f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00021	89 4d fc	 mov	 DWORD PTR _cTree$[ebp], ecx

; 470  : 
; 471  : 	token   = cTree->token;

  00024	8b 55 fc	 mov	 edx, DWORD PTR _cTree$[ebp]
  00027	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0002a	89 45 f8	 mov	 DWORD PTR _token$[ebp], eax

; 472  : 
; 473  : 	if	(token == NULL || token->getLine(token) == 0)

  0002d	83 7d f8 00	 cmp	 DWORD PTR _token$[ebp], 0
  00031	74 1c		 je	 SHORT $LN3@getLine
  00033	8b f4		 mov	 esi, esp
  00035	8b 4d f8	 mov	 ecx, DWORD PTR _token$[ebp]
  00038	51		 push	 ecx
  00039	8b 55 f8	 mov	 edx, DWORD PTR _token$[ebp]
  0003c	8b 42 5c	 mov	 eax, DWORD PTR [edx+92]
  0003f	ff d0		 call	 eax
  00041	83 c4 04	 add	 esp, 4
  00044	3b f4		 cmp	 esi, esp
  00046	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004b	85 c0		 test	 eax, eax
  0004d	75 57		 jne	 SHORT $LN2@getLine
$LN3@getLine:

; 474  : 	{
; 475  : 		if  (tree->getChildCount(tree) > 0)

  0004f	8b f4		 mov	 esi, esp
  00051	8b 4d 08	 mov	 ecx, DWORD PTR _tree$[ebp]
  00054	51		 push	 ecx
  00055	8b 55 08	 mov	 edx, DWORD PTR _tree$[ebp]
  00058	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  0005b	ff d0		 call	 eax
  0005d	83 c4 04	 add	 esp, 4
  00060	3b f4		 cmp	 esi, esp
  00062	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00067	85 c0		 test	 eax, eax
  00069	76 37		 jbe	 SHORT $LN4@getLine

; 476  : 		{
; 477  : 			pANTLR3_BASE_TREE	child;
; 478  : 
; 479  : 			child   = (pANTLR3_BASE_TREE)tree->getChild(tree, 0);

  0006b	8b f4		 mov	 esi, esp
  0006d	6a 00		 push	 0
  0006f	8b 4d 08	 mov	 ecx, DWORD PTR _tree$[ebp]
  00072	51		 push	 ecx
  00073	8b 55 08	 mov	 edx, DWORD PTR _tree$[ebp]
  00076	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  00079	ff d0		 call	 eax
  0007b	83 c4 08	 add	 esp, 8
  0007e	3b f4		 cmp	 esi, esp
  00080	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00085	89 45 f4	 mov	 DWORD PTR _child$1[ebp], eax

; 480  : 			return child->getLine(child);

  00088	8b f4		 mov	 esi, esp
  0008a	8b 4d f4	 mov	 ecx, DWORD PTR _child$1[ebp]
  0008d	51		 push	 ecx
  0008e	8b 55 f4	 mov	 edx, DWORD PTR _child$1[ebp]
  00091	8b 42 58	 mov	 eax, DWORD PTR [edx+88]
  00094	ff d0		 call	 eax
  00096	83 c4 04	 add	 esp, 4
  00099	3b f4		 cmp	 esi, esp
  0009b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a0	eb 1c		 jmp	 SHORT $LN1@getLine
$LN4@getLine:

; 481  : 		}
; 482  : 		return 0;

  000a2	33 c0		 xor	 eax, eax
  000a4	eb 18		 jmp	 SHORT $LN1@getLine
$LN2@getLine:

; 483  : 	}
; 484  : 	return  token->getLine(token);

  000a6	8b f4		 mov	 esi, esp
  000a8	8b 4d f8	 mov	 ecx, DWORD PTR _token$[ebp]
  000ab	51		 push	 ecx
  000ac	8b 55 f8	 mov	 edx, DWORD PTR _token$[ebp]
  000af	8b 42 5c	 mov	 eax, DWORD PTR [edx+92]
  000b2	ff d0		 call	 eax
  000b4	83 c4 04	 add	 esp, 4
  000b7	3b f4		 cmp	 esi, esp
  000b9	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@getLine:

; 485  : }

  000be	5e		 pop	 esi
  000bf	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c2	3b ec		 cmp	 ebp, esp
  000c4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c9	8b e5		 mov	 esp, ebp
  000cb	5d		 pop	 ebp
  000cc	c3		 ret	 0
_getLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontree.c
;	COMDAT _getText
_TEXT	SEGMENT
_tree$ = 8						; size = 4
_getText PROC						; COMDAT

; 460  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 461  : 	return	tree->toString(tree);

  00004	8b f4		 mov	 esi, esp
  00006	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _tree$[ebp]
  0000d	8b 51 6c	 mov	 edx, DWORD PTR [ecx+108]
  00010	ff d2		 call	 edx
  00012	83 c4 04	 add	 esp, 4
  00015	3b f4		 cmp	 esi, esp
  00017	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 462  : }

  0001c	5e		 pop	 esi
  0001d	3b ec		 cmp	 ebp, esp
  0001f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
_getText ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontree.c
;	COMDAT _getType
_TEXT	SEGMENT
_theTree$ = -4						; size = 4
_tree$ = 8						; size = 4
_getType PROC						; COMDAT

; 443  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 444  : 	pANTLR3_COMMON_TREE    theTree;
; 445  : 
; 446  : 	theTree = (pANTLR3_COMMON_TREE)(tree->super);

  0000c	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	89 4d fc	 mov	 DWORD PTR _theTree$[ebp], ecx

; 447  : 
; 448  : 	if	(theTree->token == NULL)

  00014	8b 55 fc	 mov	 edx, DWORD PTR _theTree$[ebp]
  00017	83 7a 0c 00	 cmp	 DWORD PTR [edx+12], 0
  0001b	75 06		 jne	 SHORT $LN2@getType

; 449  : 	{
; 450  : 		return	0;

  0001d	33 c0		 xor	 eax, eax
  0001f	eb 20		 jmp	 SHORT $LN3@getType

; 451  : 	}

  00021	eb 1e		 jmp	 SHORT $LN3@getType
$LN2@getType:

; 452  : 	else
; 453  : 	{
; 454  : 		return	theTree->token->getType(theTree->token);

  00023	8b f4		 mov	 esi, esp
  00025	8b 45 fc	 mov	 eax, DWORD PTR _theTree$[ebp]
  00028	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0002b	51		 push	 ecx
  0002c	8b 55 fc	 mov	 edx, DWORD PTR _theTree$[ebp]
  0002f	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00032	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  00035	ff d1		 call	 ecx
  00037	83 c4 04	 add	 esp, 4
  0003a	3b f4		 cmp	 esi, esp
  0003c	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@getType:

; 455  : 	}
; 456  : }

  00041	5e		 pop	 esi
  00042	83 c4 04	 add	 esp, 4
  00045	3b ec		 cmp	 ebp, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
_getType ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontree.c
;	COMDAT _isNilNode
_TEXT	SEGMENT
_tree$ = 8						; size = 4
_isNilNode PROC						; COMDAT

; 428  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 429  : 	// This is a Nil tree if it has no payload (Token in our case)
; 430  : 	//
; 431  : 	if	(((pANTLR3_COMMON_TREE)(tree->super))->token == NULL)

  00003	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  0000c	75 06		 jne	 SHORT $LN2@isNilNode

; 432  : 	{
; 433  : 		return ANTLR3_TRUE;

  0000e	b0 01		 mov	 al, 1
  00010	eb 04		 jmp	 SHORT $LN3@isNilNode

; 434  : 	}

  00012	eb 02		 jmp	 SHORT $LN3@isNilNode
$LN2@isNilNode:

; 435  : 	else
; 436  : 	{
; 437  : 		return ANTLR3_FALSE;

  00014	32 c0		 xor	 al, al
$LN3@isNilNode:

; 438  : 	}
; 439  : }

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
_isNilNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontree.c
;	COMDAT _dupNode
_TEXT	SEGMENT
_theOld$ = -4						; size = 4
_tree$ = 8						; size = 4
_dupNode PROC						; COMDAT

; 413  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 414  :     // The node we are duplicating is in fact the common tree (that's why we are here)
; 415  :     // so we use the super pointer to duplicate.
; 416  :     //
; 417  :     pANTLR3_COMMON_TREE	    theOld;
; 418  :     
; 419  : 	theOld	= (pANTLR3_COMMON_TREE)(tree->super);

  0000c	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	89 4d fc	 mov	 DWORD PTR _theOld$[ebp], ecx

; 420  : 
; 421  : 	// The pointer we return is the base implementation of course
; 422  :     //
; 423  : 	return  theOld->factory->newFromTree(theOld->factory, theOld);

  00014	8b f4		 mov	 esi, esp
  00016	8b 55 fc	 mov	 edx, DWORD PTR _theOld$[ebp]
  00019	52		 push	 edx
  0001a	8b 45 fc	 mov	 eax, DWORD PTR _theOld$[ebp]
  0001d	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00020	51		 push	 ecx
  00021	8b 55 fc	 mov	 edx, DWORD PTR _theOld$[ebp]
  00024	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00027	8b 88 b4 00 00
	00		 mov	 ecx, DWORD PTR [eax+180]
  0002d	ff d1		 call	 ecx
  0002f	83 c4 08	 add	 esp, 8
  00032	3b f4		 cmp	 esi, esp
  00034	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 424  : }

  00039	5e		 pop	 esi
  0003a	83 c4 04	 add	 esp, 4
  0003d	3b ec		 cmp	 ebp, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
_dupNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontree.c
;	COMDAT _getToken
_TEXT	SEGMENT
_tree$ = 8						; size = 4
_getToken PROC						; COMDAT

; 401  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 402  :     // The token is the payload of the common tree or other implementor
; 403  :     // so it is stored within ourselves, which is the super pointer.Note 
; 404  : 	// that whatever the actual token is, it is passed around by its pointer
; 405  : 	// to the common token implementation, which it may of course surround
; 406  : 	// with its own super structure.
; 407  :     //
; 408  :     return  ((pANTLR3_COMMON_TREE)(tree->super))->token;

  00003	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]

; 409  : }

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
_getToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontree.c
;	COMDAT _antlr3SetCTAPI
_TEXT	SEGMENT
_tree$ = 8						; size = 4
_antlr3SetCTAPI PROC					; COMDAT

; 309  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 310  :     // Init base tree
; 311  :     //
; 312  :     antlr3BaseTreeNew(&(tree->baseTree));

  00003	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  00006	83 c0 1c	 add	 eax, 28			; 0000001cH
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _antlr3BaseTreeNew
  0000f	83 c4 04	 add	 esp, 4

; 313  : 
; 314  :     // We need a pointer to ourselves for 
; 315  :     // the payload and few functions that we
; 316  :     // provide.
; 317  :     //
; 318  :     tree->baseTree.super    =  tree;

  00012	8b 4d 08	 mov	 ecx, DWORD PTR _tree$[ebp]
  00015	8b 55 08	 mov	 edx, DWORD PTR _tree$[ebp]
  00018	89 51 1c	 mov	 DWORD PTR [ecx+28], edx

; 319  : 
; 320  :     // Common tree overrides
; 321  : 
; 322  :     tree->baseTree.isNilNode                = isNilNode;

  0001b	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  0001e	c7 40 7c 00 00
	00 00		 mov	 DWORD PTR [eax+124], OFFSET _isNilNode

; 323  :     tree->baseTree.toString					= toString;

  00025	8b 4d 08	 mov	 ecx, DWORD PTR _tree$[ebp]
  00028	c7 81 88 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+136], OFFSET _toString

; 324  :     tree->baseTree.dupNode					= (void *(*)(pANTLR3_BASE_TREE))(dupNode);

  00032	8b 55 08	 mov	 edx, DWORD PTR _tree$[ebp]
  00035	c7 42 48 00 00
	00 00		 mov	 DWORD PTR [edx+72], OFFSET _dupNode

; 325  :     tree->baseTree.getLine					= getLine;

  0003c	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  0003f	c7 40 74 00 00
	00 00		 mov	 DWORD PTR [eax+116], OFFSET _getLine

; 326  :     tree->baseTree.getCharPositionInLine	= getCharPositionInLine;

  00046	8b 4d 08	 mov	 ecx, DWORD PTR _tree$[ebp]
  00049	c7 41 50 00 00
	00 00		 mov	 DWORD PTR [ecx+80], OFFSET _getCharPositionInLine

; 327  :     tree->baseTree.toString					= toString;

  00050	8b 55 08	 mov	 edx, DWORD PTR _tree$[ebp]
  00053	c7 82 88 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+136], OFFSET _toString

; 328  :     tree->baseTree.getType					= getType;

  0005d	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  00060	c7 40 6c 00 00
	00 00		 mov	 DWORD PTR [eax+108], OFFSET _getType

; 329  :     tree->baseTree.getText					= getText;

  00067	8b 4d 08	 mov	 ecx, DWORD PTR _tree$[ebp]
  0006a	c7 41 78 00 00
	00 00		 mov	 DWORD PTR [ecx+120], OFFSET _getText

; 330  :     tree->baseTree.getToken					= getToken;

  00071	8b 55 08	 mov	 edx, DWORD PTR _tree$[ebp]
  00074	c7 42 30 00 00
	00 00		 mov	 DWORD PTR [edx+48], OFFSET _getToken

; 331  : 	tree->baseTree.getParent				= getParent;

  0007b	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  0007e	c7 40 64 00 00
	00 00		 mov	 DWORD PTR [eax+100], OFFSET _getParent

; 332  : 	tree->baseTree.setParent				= setParent;

  00085	8b 4d 08	 mov	 ecx, DWORD PTR _tree$[ebp]
  00088	c7 41 68 00 00
	00 00		 mov	 DWORD PTR [ecx+104], OFFSET _setParent

; 333  : 	tree->baseTree.setChildIndex			= setChildIndex;

  0008f	8b 55 08	 mov	 edx, DWORD PTR _tree$[ebp]
  00092	c7 42 58 00 00
	00 00		 mov	 DWORD PTR [edx+88], OFFSET _setChildIndex

; 334  : 	tree->baseTree.getChildIndex			= getChildIndex;

  00099	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  0009c	c7 40 5c 00 00
	00 00		 mov	 DWORD PTR [eax+92], OFFSET _getChildIndex

; 335  : 	tree->baseTree.createChildrenList		= createChildrenList;

  000a3	8b 4d 08	 mov	 ecx, DWORD PTR _tree$[ebp]
  000a6	c7 41 3c 00 00
	00 00		 mov	 DWORD PTR [ecx+60], OFFSET _createChildrenList

; 336  :     tree->baseTree.reuse                    = reuse;

  000ad	8b 55 08	 mov	 edx, DWORD PTR _tree$[ebp]
  000b0	c7 82 94 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+148], OFFSET _reuse

; 337  : 	tree->baseTree.free						= NULL;	    // Factory trees have no free function

  000ba	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  000bd	c7 80 98 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+152], 0

; 338  :     tree->baseTree.u                        = NULL;     // Initialize user pointer            

  000c7	8b 4d 08	 mov	 ecx, DWORD PTR _tree$[ebp]
  000ca	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 339  : 
; 340  : 	tree->baseTree.children	= NULL;

  000d1	8b 55 08	 mov	 edx, DWORD PTR _tree$[ebp]
  000d4	c7 42 24 00 00
	00 00		 mov	 DWORD PTR [edx+36], 0

; 341  : 
; 342  :     tree->token				= NULL;	// No token as yet

  000db	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  000de	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 343  :     tree->startIndex		= 0;

  000e5	8b 4d 08	 mov	 ecx, DWORD PTR _tree$[ebp]
  000e8	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 344  :     tree->stopIndex			= 0;

  000ef	8b 55 08	 mov	 edx, DWORD PTR _tree$[ebp]
  000f2	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 345  : 	tree->parent			= NULL;	// No parent yet

  000f9	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  000fc	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 346  : 	tree->childIndex		= -1;

  00103	8b 4d 08	 mov	 ecx, DWORD PTR _tree$[ebp]
  00106	c7 41 14 ff ff
	ff ff		 mov	 DWORD PTR [ecx+20], -1

; 347  : 
; 348  :     return;
; 349  : }

  0010d	3b ec		 cmp	 ebp, esp
  0010f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00114	5d		 pop	 ebp
  00115	c3		 ret	 0
_antlr3SetCTAPI ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontree.c
;	COMDAT _antlr3ArboretumNew
_TEXT	SEGMENT
_factory$ = -4						; size = 4
_strFactory$ = 8					; size = 4
_antlr3ArboretumNew PROC				; COMDAT

; 66   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 67   :     pANTLR3_ARBORETUM   factory;
; 68   : 
; 69   :     // Allocate memory
; 70   :     //
; 71   :     factory	= (pANTLR3_ARBORETUM) ANTLR3_MALLOC((size_t)sizeof(ANTLR3_ARBORETUM));

  0000c	8b f4		 mov	 esi, esp
  0000e	68 c0 00 00 00	 push	 192			; 000000c0H
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00019	83 c4 04	 add	 esp, 4
  0001c	3b f4		 cmp	 esi, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	89 45 fc	 mov	 DWORD PTR _factory$[ebp], eax

; 72   :     if	(factory == NULL)

  00026	83 7d fc 00	 cmp	 DWORD PTR _factory$[ebp], 0
  0002a	75 07		 jne	 SHORT $LN2@antlr3Arbo

; 73   :     {
; 74   : 		return	NULL;

  0002c	33 c0		 xor	 eax, eax
  0002e	e9 c6 00 00 00	 jmp	 $LN1@antlr3Arbo
$LN2@antlr3Arbo:

; 75   :     }
; 76   : 
; 77   : 	// Install a vector factory to create, track and free() any child
; 78   : 	// node lists.
; 79   : 	//
; 80   : 	factory->vFactory					= antlr3VectorFactoryNew(0);

  00033	6a 00		 push	 0
  00035	e8 00 00 00 00	 call	 _antlr3VectorFactoryNew
  0003a	83 c4 04	 add	 esp, 4
  0003d	8b 4d fc	 mov	 ecx, DWORD PTR _factory$[ebp]
  00040	89 81 a8 00 00
	00		 mov	 DWORD PTR [ecx+168], eax

; 81   : 	if	(factory->vFactory == NULL)

  00046	8b 55 fc	 mov	 edx, DWORD PTR _factory$[ebp]
  00049	83 ba a8 00 00
	00 00		 cmp	 DWORD PTR [edx+168], 0
  00050	75 1d		 jne	 SHORT $LN3@antlr3Arbo

; 82   : 	{
; 83   : 		free(factory);

  00052	8b f4		 mov	 esi, esp
  00054	8b 45 fc	 mov	 eax, DWORD PTR _factory$[ebp]
  00057	50		 push	 eax
  00058	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0005e	83 c4 04	 add	 esp, 4
  00061	3b f4		 cmp	 esi, esp
  00063	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 84   : 		return	NULL;

  00068	33 c0		 xor	 eax, eax
  0006a	e9 8a 00 00 00	 jmp	 $LN1@antlr3Arbo
$LN3@antlr3Arbo:

; 85   : 	}
; 86   : 
; 87   :     // We also keep a reclaim stack, so that any Nil nodes that are
; 88   :     // orphaned are not just left in the pool but are reused, other wise
; 89   :     // we create 6 times as many nilNodes as ordinary nodes and use loads of
; 90   :     // memory. Perhaps at some point, the analysis phase will generate better
; 91   :     // code and we won't need to do this here.
; 92   :     //
; 93   :     factory->nilStack       =  antlr3StackNew(0);

  0006f	6a 00		 push	 0
  00071	e8 00 00 00 00	 call	 _antlr3StackNew
  00076	83 c4 04	 add	 esp, 4
  00079	8b 4d fc	 mov	 ecx, DWORD PTR _factory$[ebp]
  0007c	89 81 ac 00 00
	00		 mov	 DWORD PTR [ecx+172], eax

; 94   : 
; 95   :     // Install factory API
; 96   :     //
; 97   :     factory->newTree	    =  newPoolTree;

  00082	8b 55 fc	 mov	 edx, DWORD PTR _factory$[ebp]
  00085	c7 82 b0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+176], OFFSET _newPoolTree

; 98   :     factory->newFromTree    =  newFromTree;

  0008f	8b 45 fc	 mov	 eax, DWORD PTR _factory$[ebp]
  00092	c7 80 b4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+180], OFFSET _newFromTree

; 99   :     factory->newFromToken   =  newFromToken;

  0009c	8b 4d fc	 mov	 ecx, DWORD PTR _factory$[ebp]
  0009f	c7 81 b8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+184], OFFSET _newFromToken

; 100  :     factory->close			=  factoryClose;

  000a9	8b 55 fc	 mov	 edx, DWORD PTR _factory$[ebp]
  000ac	c7 82 bc 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+188], OFFSET _factoryClose

; 101  : 
; 102  :     // Allocate the initial pool
; 103  :     //
; 104  :     factory->thisPool	= -1;

  000b6	8b 45 fc	 mov	 eax, DWORD PTR _factory$[ebp]
  000b9	c7 40 04 ff ff
	ff ff		 mov	 DWORD PTR [eax+4], -1

; 105  :     factory->pools		= NULL;

  000c0	8b 4d fc	 mov	 ecx, DWORD PTR _factory$[ebp]
  000c3	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 106  :     newPool(factory);

  000c9	8b 55 fc	 mov	 edx, DWORD PTR _factory$[ebp]
  000cc	52		 push	 edx
  000cd	e8 00 00 00 00	 call	 _newPool
  000d2	83 c4 04	 add	 esp, 4

; 107  : 
; 108  :     // Factory space is good, we now want to initialize our cheating token
; 109  :     // which one it is initialized is the model for all tokens we manufacture
; 110  :     //
; 111  :     antlr3SetCTAPI(&factory->unTruc);

  000d5	8b 45 fc	 mov	 eax, DWORD PTR _factory$[ebp]
  000d8	83 c0 0c	 add	 eax, 12			; 0000000cH
  000db	50		 push	 eax
  000dc	e8 00 00 00 00	 call	 _antlr3SetCTAPI
  000e1	83 c4 04	 add	 esp, 4

; 112  : 
; 113  :     // Set some initial variables for future copying, including a string factory
; 114  :     // that we can use later for converting trees to strings.
; 115  :     //
; 116  : 	factory->unTruc.factory				= factory;

  000e4	8b 4d fc	 mov	 ecx, DWORD PTR _factory$[ebp]
  000e7	8b 55 fc	 mov	 edx, DWORD PTR _factory$[ebp]
  000ea	89 51 24	 mov	 DWORD PTR [ecx+36], edx

; 117  :     factory->unTruc.baseTree.strFactory	= strFactory;

  000ed	8b 45 fc	 mov	 eax, DWORD PTR _factory$[ebp]
  000f0	8b 4d 08	 mov	 ecx, DWORD PTR _strFactory$[ebp]
  000f3	89 48 38	 mov	 DWORD PTR [eax+56], ecx

; 118  : 
; 119  :     return  factory;

  000f6	8b 45 fc	 mov	 eax, DWORD PTR _factory$[ebp]
$LN1@antlr3Arbo:

; 120  : 
; 121  : }

  000f9	5e		 pop	 esi
  000fa	83 c4 04	 add	 esp, 4
  000fd	3b ec		 cmp	 ebp, esp
  000ff	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00104	8b e5		 mov	 esp, ebp
  00106	5d		 pop	 ebp
  00107	c3		 ret	 0
_antlr3ArboretumNew ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontree.c
;	COMDAT _antlr3CommonTreeNewFromToken
_TEXT	SEGMENT
_newTree$ = -4						; size = 4
_token$ = 8						; size = 4
_antlr3CommonTreeNewFromToken PROC			; COMDAT

; 373  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 374  : 	pANTLR3_COMMON_TREE	newTree;
; 375  : 
; 376  : 	newTree = antlr3CommonTreeNew();

  0000b	e8 00 00 00 00	 call	 _antlr3CommonTreeNew
  00010	89 45 fc	 mov	 DWORD PTR _newTree$[ebp], eax

; 377  : 
; 378  : 	if	(newTree == NULL)

  00013	83 7d fc 00	 cmp	 DWORD PTR _newTree$[ebp], 0
  00017	75 04		 jne	 SHORT $LN2@antlr3Comm

; 379  : 	{
; 380  : 		return	NULL;

  00019	33 c0		 xor	 eax, eax
  0001b	eb 0c		 jmp	 SHORT $LN1@antlr3Comm
$LN2@antlr3Comm:

; 381  : 	}
; 382  : 
; 383  : 	//Pick up the payload we had in the supplied tree
; 384  : 	//
; 385  : 	newTree->token = token;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _newTree$[ebp]
  00020	8b 4d 08	 mov	 ecx, DWORD PTR _token$[ebp]
  00023	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 386  : 	return newTree;

  00026	8b 45 fc	 mov	 eax, DWORD PTR _newTree$[ebp]
$LN1@antlr3Comm:

; 387  : }

  00029	83 c4 04	 add	 esp, 4
  0002c	3b ec		 cmp	 ebp, esp
  0002e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
_antlr3CommonTreeNewFromToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontree.c
;	COMDAT _antlr3CommonTreeNew
_TEXT	SEGMENT
_tree$ = -4						; size = 4
_antlr3CommonTreeNew PROC				; COMDAT

; 357  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 358  : 	pANTLR3_COMMON_TREE	tree;
; 359  : 	tree = (pANTLR3_COMMON_TREE)ANTLR3_CALLOC(1, sizeof(ANTLR3_COMMON_TREE));

  0000c	8b f4		 mov	 esi, esp
  0000e	68 9c 00 00 00	 push	 156			; 0000009cH
  00013	6a 01		 push	 1
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__calloc
  0001b	83 c4 08	 add	 esp, 8
  0001e	3b f4		 cmp	 esi, esp
  00020	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00025	89 45 fc	 mov	 DWORD PTR _tree$[ebp], eax

; 360  : 
; 361  : 	if	(tree == NULL)

  00028	83 7d fc 00	 cmp	 DWORD PTR _tree$[ebp], 0
  0002c	75 04		 jne	 SHORT $LN2@antlr3Comm

; 362  : 	{
; 363  : 		return NULL;

  0002e	33 c0		 xor	 eax, eax
  00030	eb 0f		 jmp	 SHORT $LN1@antlr3Comm
$LN2@antlr3Comm:

; 364  : 	}
; 365  : 
; 366  : 	antlr3SetCTAPI(tree);

  00032	8b 45 fc	 mov	 eax, DWORD PTR _tree$[ebp]
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 _antlr3SetCTAPI
  0003b	83 c4 04	 add	 esp, 4

; 367  : 
; 368  : 	return tree;

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _tree$[ebp]
$LN1@antlr3Comm:

; 369  : }

  00041	5e		 pop	 esi
  00042	83 c4 04	 add	 esp, 4
  00045	3b ec		 cmp	 ebp, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
_antlr3CommonTreeNew ENDP
_TEXT	ENDS
END
