; Listing generated by Microsoft (R) Optimizing Compiler Version 19.42.34436.0 

	TITLE	C:\SPO_labs\C\Debug\antlr3basetreeadaptor.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	___local_stdio_printf_options
PUBLIC	__vfprintf_l
PUBLIC	_fprintf
PUBLIC	__vsnprintf_l
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	_antlr3BaseTreeAdaptorInit
PUBLIC	??_C@_0N@DGCKJLE@?7n?$CFp?$FLlabel?$DN?$CC@	; `string'
PUBLIC	??_C@_02MCKKLHBJ@?2?$CC@			; `string'
PUBLIC	??_C@_02JOGGLHBA@?2n@				; `string'
PUBLIC	??_C@_02HIBBOKEN@?2r@				; `string'
PUBLIC	??_C@_03EKALBCDP@?$CC?$FN?6@			; `string'
PUBLIC	??_C@_0BC@PEJKFJFG@?7?7n?$CFp?5?9?$DO?5n?$CFp?7?7?1?1?5@ ; `string'
PUBLIC	??_C@_04BBDFLMDN@?5?9?$DO?5@			; `string'
PUBLIC	??_C@_01EEMJAFIK@?6@				; `string'
PUBLIC	??_C@_0BCG@JAAAKLG@digraph?5?$HL?6?6?7ordering?$DNout?$DL?6?7rank@ ; `string'
PUBLIC	??_C@_0BI@IPCNDJJ@n0?$FLlabel?$DN?$CCEMPTY?5TREE?$CC?$FN?6@ ; `string'
PUBLIC	??_C@_02JHLIKEIA@?6?$HN@			; `string'
PUBLIC	??_C@_0EC@GKDPFFCG@More?5than?5one?5node?5as?5root?$CB?5TOD@ ; `string'
PUBLIC	??_C@_0GH@GODAJKHB@Internal?5error?5?9?5implementor?5of@ ; `string'
PUBLIC	??_C@_0GH@GBLCOHNN@Internal?5error?5?9?5implementor?5of@ ; `string'
PUBLIC	??_C@_0GH@HPJNFAJE@Internal?5error?5?9?5implementor?5of@ ; `string'
PUBLIC	??_C@_0GI@GANAPDHF@Internal?5error?5?9?5implementor?5of@ ; `string'
PUBLIC	??_C@_0GN@PACIMGKB@Internal?5error?5?9?5implementor?5of@ ; `string'
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___security_cookie:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0GN@PACIMGKB@Internal?5error?5?9?5implementor?5of@
CONST	SEGMENT
??_C@_0GN@PACIMGKB@Internal?5error?5?9?5implementor?5of@ DB 'Internal err'
	DB	'or - implementor of superclass containing ANTLR3_TREE_ADAPTOR'
	DB	' did not implement getChildCount()', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GI@GANAPDHF@Internal?5error?5?9?5implementor?5of@
CONST	SEGMENT
??_C@_0GI@GANAPDHF@Internal?5error?5?9?5implementor?5of@ DB 'Internal err'
	DB	'or - implementor of superclass containing ANTLR3_TREE_ADAPTOR'
	DB	' did not implement getChild()', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GH@HPJNFAJE@Internal?5error?5?9?5implementor?5of@
CONST	SEGMENT
??_C@_0GH@HPJNFAJE@Internal?5error?5?9?5implementor?5of@ DB 'Internal err'
	DB	'or - implementor of superclass containing ANTLR3_TREE_ADAPTOR'
	DB	' did not implement setText()', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GH@GBLCOHNN@Internal?5error?5?9?5implementor?5of@
CONST	SEGMENT
??_C@_0GH@GBLCOHNN@Internal?5error?5?9?5implementor?5of@ DB 'Internal err'
	DB	'or - implementor of superclass containing ANTLR3_TREE_ADAPTOR'
	DB	' did not implement getText()', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GH@GODAJKHB@Internal?5error?5?9?5implementor?5of@
CONST	SEGMENT
??_C@_0GH@GODAJKHB@Internal?5error?5?9?5implementor?5of@ DB 'Internal err'
	DB	'or - implementor of superclass containing ANTLR3_TREE_ADAPTOR'
	DB	' did not implement setType()', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@GKDPFFCG@More?5than?5one?5node?5as?5root?$CB?5TOD@
CONST	SEGMENT
??_C@_0EC@GKDPFFCG@More?5than?5one?5node?5as?5root?$CB?5TOD@ DB 'More tha'
	DB	'n one node as root! TODO: Create tree exception handling', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_02JHLIKEIA@?6?$HN@
CONST	SEGMENT
??_C@_02JHLIKEIA@?6?$HN@ DB 0aH, '}', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@IPCNDJJ@n0?$FLlabel?$DN?$CCEMPTY?5TREE?$CC?$FN?6@
CONST	SEGMENT
??_C@_0BI@IPCNDJJ@n0?$FLlabel?$DN?$CCEMPTY?5TREE?$CC?$FN?6@ DB 'n0[label='
	DB	'"EMPTY TREE"]', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BCG@JAAAKLG@digraph?5?$HL?6?6?7ordering?$DNout?$DL?6?7rank@
CONST	SEGMENT
??_C@_0BCG@JAAAKLG@digraph?5?$HL?6?6?7ordering?$DNout?$DL?6?7rank@ DB 'di'
	DB	'graph {', 0aH, 0aH, 09H, 'ordering=out;', 0aH, 09H, 'ranksep='
	DB	'.4;', 0aH, 09H, 'bgcolor="lightgrey";  node [shape=box, fixed'
	DB	'size=false, fontsize=12, fontname="Helvetica-bold", fontcolor'
	DB	'="blue"', 0aH, 09H, 'width=.25, height=.25, color="black", fi'
	DB	'llcolor="white", style="filled, solid, bold"];', 0aH, 0aH, 09H
	DB	'edge [arrowsize=.5, color="black", style="bold"]', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04BBDFLMDN@?5?9?$DO?5@
CONST	SEGMENT
??_C@_04BBDFLMDN@?5?9?$DO?5@ DB ' -> ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@PEJKFJFG@?7?7n?$CFp?5?9?$DO?5n?$CFp?7?7?1?1?5@
CONST	SEGMENT
??_C@_0BC@PEJKFJFG@?7?7n?$CFp?5?9?$DO?5n?$CFp?7?7?1?1?5@ DB 09H, 09H, 'n%'
	DB	'p -> n%p', 09H, 09H, '// ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03EKALBCDP@?$CC?$FN?6@
CONST	SEGMENT
??_C@_03EKALBCDP@?$CC?$FN?6@ DB '"]', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02HIBBOKEN@?2r@
CONST	SEGMENT
??_C@_02HIBBOKEN@?2r@ DB '\r', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JOGGLHBA@?2n@
CONST	SEGMENT
??_C@_02JOGGLHBA@?2n@ DB '\n', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MCKKLHBJ@?2?$CC@
CONST	SEGMENT
??_C@_02MCKKLHBJ@?2?$CC@ DB '\"', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DGCKJLE@?7n?$CFp?$FLlabel?$DN?$CC@
CONST	SEGMENT
??_C@_0N@DGCKJLE@?7n?$CFp?$FLlabel?$DN?$CC@ DB 09H, 'n%p[label="', 00H ; `string'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	024H
	DW	03baH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	01eH
	DW	0214H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	01eH
	DW	0246H
voltbl	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3basetreeadaptor.c
;	COMDAT _simulateTreeConstruction
_TEXT	SEGMENT
_child$ = -12						; size = 4
_i$ = -8						; size = 4
_n$ = -4						; size = 4
_adaptor$ = 8						; size = 4
_tree$ = 12						; size = 4
_simulateTreeConstruction PROC				; COMDAT

; 501  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000e	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00015	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 502  : 	ANTLR3_UINT32		n;
; 503  : 	ANTLR3_UINT32		i;
; 504  : 	pANTLR3_BASE_TREE	child;
; 505  : 
; 506  : 	// Send the create node event
; 507  : 	//
; 508  : 	adaptor->debugger->createNode(adaptor->debugger, tree);

  0001c	8b f4		 mov	 esi, esp
  0001e	8b 45 0c	 mov	 eax, DWORD PTR _tree$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 08	 mov	 ecx, DWORD PTR _adaptor$[ebp]
  00025	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00028	52		 push	 edx
  00029	8b 45 08	 mov	 eax, DWORD PTR _adaptor$[ebp]
  0002c	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0002f	8b 91 8c 00 00
	00		 mov	 edx, DWORD PTR [ecx+140]
  00035	ff d2		 call	 edx
  00037	83 c4 08	 add	 esp, 8
  0003a	3b f4		 cmp	 esi, esp
  0003c	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 509  : 
; 510  : 	n = adaptor->getChildCount(adaptor, tree);

  00041	8b f4		 mov	 esi, esp
  00043	8b 45 0c	 mov	 eax, DWORD PTR _tree$[ebp]
  00046	50		 push	 eax
  00047	8b 4d 08	 mov	 ecx, DWORD PTR _adaptor$[ebp]
  0004a	51		 push	 ecx
  0004b	8b 55 08	 mov	 edx, DWORD PTR _adaptor$[ebp]
  0004e	8b 42 7c	 mov	 eax, DWORD PTR [edx+124]
  00051	ff d0		 call	 eax
  00053	83 c4 08	 add	 esp, 8
  00056	3b f4		 cmp	 esi, esp
  00058	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005d	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax

; 511  : 	for	(i = 0; i < n; i++)

  00060	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00067	eb 09		 jmp	 SHORT $LN4@simulateTr
$LN2@simulateTr:
  00069	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  0006c	83 c1 01	 add	 ecx, 1
  0006f	89 4d f8	 mov	 DWORD PTR _i$[ebp], ecx
$LN4@simulateTr:
  00072	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00075	3b 55 fc	 cmp	 edx, DWORD PTR _n$[ebp]
  00078	73 5f		 jae	 SHORT $LN3@simulateTr

; 512  : 	{
; 513  : 		child = (pANTLR3_BASE_TREE)adaptor->getChild(adaptor, tree, i);

  0007a	8b f4		 mov	 esi, esp
  0007c	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0007f	50		 push	 eax
  00080	8b 4d 0c	 mov	 ecx, DWORD PTR _tree$[ebp]
  00083	51		 push	 ecx
  00084	8b 55 08	 mov	 edx, DWORD PTR _adaptor$[ebp]
  00087	52		 push	 edx
  00088	8b 45 08	 mov	 eax, DWORD PTR _adaptor$[ebp]
  0008b	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  0008e	ff d1		 call	 ecx
  00090	83 c4 0c	 add	 esp, 12			; 0000000cH
  00093	3b f4		 cmp	 esi, esp
  00095	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009a	89 45 f4	 mov	 DWORD PTR _child$[ebp], eax

; 514  : 		simulateTreeConstruction(adaptor, child);

  0009d	8b 55 f4	 mov	 edx, DWORD PTR _child$[ebp]
  000a0	52		 push	 edx
  000a1	8b 45 08	 mov	 eax, DWORD PTR _adaptor$[ebp]
  000a4	50		 push	 eax
  000a5	e8 00 00 00 00	 call	 _simulateTreeConstruction
  000aa	83 c4 08	 add	 esp, 8

; 515  : 		adaptor->debugger->addChild(adaptor->debugger, tree, child);

  000ad	8b f4		 mov	 esi, esp
  000af	8b 4d f4	 mov	 ecx, DWORD PTR _child$[ebp]
  000b2	51		 push	 ecx
  000b3	8b 55 0c	 mov	 edx, DWORD PTR _tree$[ebp]
  000b6	52		 push	 edx
  000b7	8b 45 08	 mov	 eax, DWORD PTR _adaptor$[ebp]
  000ba	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000bd	51		 push	 ecx
  000be	8b 55 08	 mov	 edx, DWORD PTR _adaptor$[ebp]
  000c1	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  000c4	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [eax+152]
  000ca	ff d1		 call	 ecx
  000cc	83 c4 0c	 add	 esp, 12			; 0000000cH
  000cf	3b f4		 cmp	 esi, esp
  000d1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d6	90		 npad	 1

; 516  : 	}

  000d7	eb 90		 jmp	 SHORT $LN2@simulateTr
$LN3@simulateTr:

; 517  : }

  000d9	5e		 pop	 esi
  000da	83 c4 0c	 add	 esp, 12			; 0000000cH
  000dd	3b ec		 cmp	 ebp, esp
  000df	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e4	8b e5		 mov	 esp, ebp
  000e6	5d		 pop	 ebp
  000e7	c3		 ret	 0
_simulateTreeConstruction ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3basetreeadaptor.c
;	COMDAT _defineDotEdges
_TEXT	SEGMENT
tv161 = -168						; size = 4
tv95 = -164						; size = 4
_j$1 = -160						; size = 4
_text$2 = -156						; size = 4
_buff$3 = -148						; size = 128
_child$4 = -16						; size = 4
_i$ = -12						; size = 4
_nCount$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_adaptor$ = 8						; size = 4
_t$ = 12						; size = 4
_dotSpec$ = 16						; size = 4
_defineDotEdges PROC					; COMDAT

; 241  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8d bd 58 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-168]
  00011	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 242  : 	// How many nodes are we talking about?
; 243  : 	//
; 244  : 	int	nCount;
; 245  : 	int i;
; 246  : 
; 247  : 	if	(t == NULL)

  00027	83 7d 0c 00	 cmp	 DWORD PTR _t$[ebp], 0
  0002b	75 05		 jne	 SHORT $LN15@defineDotE

; 248  : 	{
; 249  : 		// No tree, so do nothing
; 250  : 		//
; 251  : 		return;

  0002d	e9 75 03 00 00	 jmp	 $LN1@defineDotE
$LN15@defineDotE:

; 252  : 	}
; 253  : 
; 254  : 	// Count the nodes
; 255  : 	//
; 256  : 	nCount = adaptor->getChildCount(adaptor, t);

  00032	8b f4		 mov	 esi, esp
  00034	8b 45 0c	 mov	 eax, DWORD PTR _t$[ebp]
  00037	50		 push	 eax
  00038	8b 4d 08	 mov	 ecx, DWORD PTR _adaptor$[ebp]
  0003b	51		 push	 ecx
  0003c	8b 55 08	 mov	 edx, DWORD PTR _adaptor$[ebp]
  0003f	8b 42 7c	 mov	 eax, DWORD PTR [edx+124]
  00042	ff d0		 call	 eax
  00044	83 c4 08	 add	 esp, 8
  00047	3b f4		 cmp	 esi, esp
  00049	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004e	89 45 f8	 mov	 DWORD PTR _nCount$[ebp], eax

; 257  : 
; 258  : 	if	(nCount == 0)

  00051	83 7d f8 00	 cmp	 DWORD PTR _nCount$[ebp], 0
  00055	75 05		 jne	 SHORT $LN16@defineDotE

; 259  : 	{
; 260  : 		// This will already have been included as a child of another node
; 261  : 		// so there is nothing to add.
; 262  : 		//
; 263  : 		return;

  00057	e9 4b 03 00 00	 jmp	 $LN1@defineDotE
$LN16@defineDotE:

; 264  : 	}
; 265  : 
; 266  : 	// For each child, define an edge from this parent, then process
; 267  : 	// and children of this child in the same way
; 268  : 	//
; 269  : 	for	(i=0; i<nCount; i++)

  0005c	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00063	eb 09		 jmp	 SHORT $LN4@defineDotE
$LN2@defineDotE:
  00065	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  00068	83 c1 01	 add	 ecx, 1
  0006b	89 4d f4	 mov	 DWORD PTR _i$[ebp], ecx
$LN4@defineDotE:
  0006e	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  00071	3b 55 f8	 cmp	 edx, DWORD PTR _nCount$[ebp]
  00074	0f 8d 2d 03 00
	00		 jge	 $LN3@defineDotE

; 270  : 	{
; 271  : 		pANTLR3_BASE_TREE child;
; 272  : 		char	buff[128];
; 273  :         pANTLR3_STRING text;
; 274  :         int                 j;
; 275  : 
; 276  : 		// Next child
; 277  : 		//
; 278  : 		child	= (pANTLR3_BASE_TREE)adaptor->getChild(adaptor, t, i);

  0007a	8b f4		 mov	 esi, esp
  0007c	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  0007f	50		 push	 eax
  00080	8b 4d 0c	 mov	 ecx, DWORD PTR _t$[ebp]
  00083	51		 push	 ecx
  00084	8b 55 08	 mov	 edx, DWORD PTR _adaptor$[ebp]
  00087	52		 push	 edx
  00088	8b 45 08	 mov	 eax, DWORD PTR _adaptor$[ebp]
  0008b	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  0008e	ff d1		 call	 ecx
  00090	83 c4 0c	 add	 esp, 12			; 0000000cH
  00093	3b f4		 cmp	 esi, esp
  00095	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009a	89 45 f0	 mov	 DWORD PTR _child$4[ebp], eax

; 279  : 
; 280  : 		// Create the edge relation
; 281  : 		//
; 282  : 		sprintf(buff, "\t\tn%p -> n%p\t\t// ",  t, child);

  0009d	8b 55 f0	 mov	 edx, DWORD PTR _child$4[ebp]
  000a0	52		 push	 edx
  000a1	8b 45 0c	 mov	 eax, DWORD PTR _t$[ebp]
  000a4	50		 push	 eax
  000a5	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@PEJKFJFG@?7?7n?$CFp?5?9?$DO?5n?$CFp?7?7?1?1?5@
  000aa	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _buff$3[ebp]
  000b0	51		 push	 ecx
  000b1	e8 00 00 00 00	 call	 _sprintf
  000b6	83 c4 10	 add	 esp, 16			; 00000010H

; 283  :         
; 284  : 		dotSpec->append8(dotSpec, buff);

  000b9	8b f4		 mov	 esi, esp
  000bb	8d 95 6c ff ff
	ff		 lea	 edx, DWORD PTR _buff$3[ebp]
  000c1	52		 push	 edx
  000c2	8b 45 10	 mov	 eax, DWORD PTR _dotSpec$[ebp]
  000c5	50		 push	 eax
  000c6	8b 4d 10	 mov	 ecx, DWORD PTR _dotSpec$[ebp]
  000c9	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  000cc	ff d2		 call	 edx
  000ce	83 c4 08	 add	 esp, 8
  000d1	3b f4		 cmp	 esi, esp
  000d3	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 285  : 
; 286  : 		// Document the relationship
; 287  : 		//
; 288  :         text = adaptor->getText(adaptor, t);

  000d8	8b f4		 mov	 esi, esp
  000da	8b 45 0c	 mov	 eax, DWORD PTR _t$[ebp]
  000dd	50		 push	 eax
  000de	8b 4d 08	 mov	 ecx, DWORD PTR _adaptor$[ebp]
  000e1	51		 push	 ecx
  000e2	8b 55 08	 mov	 edx, DWORD PTR _adaptor$[ebp]
  000e5	8b 42 5c	 mov	 eax, DWORD PTR [edx+92]
  000e8	ff d0		 call	 eax
  000ea	83 c4 08	 add	 esp, 8
  000ed	3b f4		 cmp	 esi, esp
  000ef	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f4	89 85 64 ff ff
	ff		 mov	 DWORD PTR _text$2[ebp], eax

; 289  : 		for (j = 0; j < (ANTLR3_INT32)(text->len); j++)

  000fa	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _j$1[ebp], 0
  00104	eb 0f		 jmp	 SHORT $LN7@defineDotE
$LN5@defineDotE:
  00106	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _j$1[ebp]
  0010c	83 c1 01	 add	 ecx, 1
  0010f	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _j$1[ebp], ecx
$LN7@defineDotE:
  00115	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR _text$2[ebp]
  0011b	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _j$1[ebp]
  00121	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  00124	0f 8d ec 00 00
	00		 jge	 $LN6@defineDotE

; 290  :         {
; 291  :                 switch(text->charAt(text, j))

  0012a	8b f4		 mov	 esi, esp
  0012c	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _j$1[ebp]
  00132	51		 push	 ecx
  00133	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR _text$2[ebp]
  00139	52		 push	 edx
  0013a	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _text$2[ebp]
  00140	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  00143	ff d1		 call	 ecx
  00145	83 c4 08	 add	 esp, 8
  00148	3b f4		 cmp	 esi, esp
  0014a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0014f	89 85 5c ff ff
	ff		 mov	 DWORD PTR tv95[ebp], eax
  00155	83 bd 5c ff ff
	ff 0a		 cmp	 DWORD PTR tv95[ebp], 10	; 0000000aH
  0015c	74 34		 je	 SHORT $LN18@defineDotE
  0015e	83 bd 5c ff ff
	ff 0d		 cmp	 DWORD PTR tv95[ebp], 13	; 0000000dH
  00165	74 4b		 je	 SHORT $LN19@defineDotE
  00167	83 bd 5c ff ff
	ff 22		 cmp	 DWORD PTR tv95[ebp], 34	; 00000022H
  0016e	74 02		 je	 SHORT $LN17@defineDotE
  00170	eb 60		 jmp	 SHORT $LN20@defineDotE
$LN17@defineDotE:

; 292  :                 {
; 293  :                     case '"':
; 294  : 
; 295  :                         dotSpec->append8(dotSpec, "\\\"");

  00172	8b f4		 mov	 esi, esp
  00174	68 00 00 00 00	 push	 OFFSET ??_C@_02MCKKLHBJ@?2?$CC@
  00179	8b 55 10	 mov	 edx, DWORD PTR _dotSpec$[ebp]
  0017c	52		 push	 edx
  0017d	8b 45 10	 mov	 eax, DWORD PTR _dotSpec$[ebp]
  00180	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00183	ff d1		 call	 ecx
  00185	83 c4 08	 add	 esp, 8
  00188	3b f4		 cmp	 esi, esp
  0018a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0018f	90		 npad	 1

; 296  :                         break;

  00190	eb 7f		 jmp	 SHORT $LN8@defineDotE
$LN18@defineDotE:

; 297  : 
; 298  :                     case '\n':
; 299  : 
; 300  :                         dotSpec->append8(dotSpec, "\\n");

  00192	8b f4		 mov	 esi, esp
  00194	68 00 00 00 00	 push	 OFFSET ??_C@_02JOGGLHBA@?2n@
  00199	8b 55 10	 mov	 edx, DWORD PTR _dotSpec$[ebp]
  0019c	52		 push	 edx
  0019d	8b 45 10	 mov	 eax, DWORD PTR _dotSpec$[ebp]
  001a0	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  001a3	ff d1		 call	 ecx
  001a5	83 c4 08	 add	 esp, 8
  001a8	3b f4		 cmp	 esi, esp
  001aa	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001af	90		 npad	 1

; 301  :                         break;

  001b0	eb 5f		 jmp	 SHORT $LN8@defineDotE
$LN19@defineDotE:

; 302  : 
; 303  :                     case '\r':
; 304  : 
; 305  :                         dotSpec->append8(dotSpec, "\\r");

  001b2	8b f4		 mov	 esi, esp
  001b4	68 00 00 00 00	 push	 OFFSET ??_C@_02HIBBOKEN@?2r@
  001b9	8b 55 10	 mov	 edx, DWORD PTR _dotSpec$[ebp]
  001bc	52		 push	 edx
  001bd	8b 45 10	 mov	 eax, DWORD PTR _dotSpec$[ebp]
  001c0	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  001c3	ff d1		 call	 ecx
  001c5	83 c4 08	 add	 esp, 8
  001c8	3b f4		 cmp	 esi, esp
  001ca	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001cf	90		 npad	 1

; 306  :                         break;

  001d0	eb 3f		 jmp	 SHORT $LN8@defineDotE
$LN20@defineDotE:

; 307  : 
; 308  :                     default:
; 309  : 
; 310  :                         dotSpec->addc(dotSpec, text->charAt(text, j));

  001d2	8b f4		 mov	 esi, esp
  001d4	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _j$1[ebp]
  001da	52		 push	 edx
  001db	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _text$2[ebp]
  001e1	50		 push	 eax
  001e2	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _text$2[ebp]
  001e8	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  001eb	ff d2		 call	 edx
  001ed	83 c4 08	 add	 esp, 8
  001f0	3b f4		 cmp	 esi, esp
  001f2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001f7	8b f4		 mov	 esi, esp
  001f9	50		 push	 eax
  001fa	8b 45 10	 mov	 eax, DWORD PTR _dotSpec$[ebp]
  001fd	50		 push	 eax
  001fe	8b 4d 10	 mov	 ecx, DWORD PTR _dotSpec$[ebp]
  00201	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  00204	ff d2		 call	 edx
  00206	83 c4 08	 add	 esp, 8
  00209	3b f4		 cmp	 esi, esp
  0020b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00210	90		 npad	 1
$LN8@defineDotE:

; 311  :                         break;
; 312  :                 }
; 313  :         }

  00211	e9 f0 fe ff ff	 jmp	 $LN5@defineDotE
$LN6@defineDotE:

; 314  : 
; 315  :         dotSpec->append8(dotSpec, " -> ");

  00216	8b f4		 mov	 esi, esp
  00218	68 00 00 00 00	 push	 OFFSET ??_C@_04BBDFLMDN@?5?9?$DO?5@
  0021d	8b 45 10	 mov	 eax, DWORD PTR _dotSpec$[ebp]
  00220	50		 push	 eax
  00221	8b 4d 10	 mov	 ecx, DWORD PTR _dotSpec$[ebp]
  00224	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00227	ff d2		 call	 edx
  00229	83 c4 08	 add	 esp, 8
  0022c	3b f4		 cmp	 esi, esp
  0022e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 316  : 
; 317  :         text = adaptor->getText(adaptor, child);

  00233	8b f4		 mov	 esi, esp
  00235	8b 45 f0	 mov	 eax, DWORD PTR _child$4[ebp]
  00238	50		 push	 eax
  00239	8b 4d 08	 mov	 ecx, DWORD PTR _adaptor$[ebp]
  0023c	51		 push	 ecx
  0023d	8b 55 08	 mov	 edx, DWORD PTR _adaptor$[ebp]
  00240	8b 42 5c	 mov	 eax, DWORD PTR [edx+92]
  00243	ff d0		 call	 eax
  00245	83 c4 08	 add	 esp, 8
  00248	3b f4		 cmp	 esi, esp
  0024a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0024f	89 85 64 ff ff
	ff		 mov	 DWORD PTR _text$2[ebp], eax

; 318  :         for (j = 0; j < (ANTLR3_INT32)(text->len); j++)

  00255	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _j$1[ebp], 0
  0025f	eb 0f		 jmp	 SHORT $LN12@defineDotE
$LN10@defineDotE:
  00261	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _j$1[ebp]
  00267	83 c1 01	 add	 ecx, 1
  0026a	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _j$1[ebp], ecx
$LN12@defineDotE:
  00270	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR _text$2[ebp]
  00276	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _j$1[ebp]
  0027c	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  0027f	0f 8d ec 00 00
	00		 jge	 $LN11@defineDotE

; 319  :         {
; 320  :                 switch(text->charAt(text, j))

  00285	8b f4		 mov	 esi, esp
  00287	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _j$1[ebp]
  0028d	51		 push	 ecx
  0028e	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR _text$2[ebp]
  00294	52		 push	 edx
  00295	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _text$2[ebp]
  0029b	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  0029e	ff d1		 call	 ecx
  002a0	83 c4 08	 add	 esp, 8
  002a3	3b f4		 cmp	 esi, esp
  002a5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002aa	89 85 58 ff ff
	ff		 mov	 DWORD PTR tv161[ebp], eax
  002b0	83 bd 58 ff ff
	ff 0a		 cmp	 DWORD PTR tv161[ebp], 10 ; 0000000aH
  002b7	74 34		 je	 SHORT $LN22@defineDotE
  002b9	83 bd 58 ff ff
	ff 0d		 cmp	 DWORD PTR tv161[ebp], 13 ; 0000000dH
  002c0	74 4b		 je	 SHORT $LN23@defineDotE
  002c2	83 bd 58 ff ff
	ff 22		 cmp	 DWORD PTR tv161[ebp], 34 ; 00000022H
  002c9	74 02		 je	 SHORT $LN21@defineDotE
  002cb	eb 60		 jmp	 SHORT $LN24@defineDotE
$LN21@defineDotE:

; 321  :                 {
; 322  :                     case '"':
; 323  : 
; 324  :                         dotSpec->append8(dotSpec, "\\\"");

  002cd	8b f4		 mov	 esi, esp
  002cf	68 00 00 00 00	 push	 OFFSET ??_C@_02MCKKLHBJ@?2?$CC@
  002d4	8b 55 10	 mov	 edx, DWORD PTR _dotSpec$[ebp]
  002d7	52		 push	 edx
  002d8	8b 45 10	 mov	 eax, DWORD PTR _dotSpec$[ebp]
  002db	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  002de	ff d1		 call	 ecx
  002e0	83 c4 08	 add	 esp, 8
  002e3	3b f4		 cmp	 esi, esp
  002e5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002ea	90		 npad	 1

; 325  :                         break;

  002eb	eb 7f		 jmp	 SHORT $LN13@defineDotE
$LN22@defineDotE:

; 326  : 
; 327  :                     case '\n':
; 328  : 
; 329  :                         dotSpec->append8(dotSpec, "\\n");

  002ed	8b f4		 mov	 esi, esp
  002ef	68 00 00 00 00	 push	 OFFSET ??_C@_02JOGGLHBA@?2n@
  002f4	8b 55 10	 mov	 edx, DWORD PTR _dotSpec$[ebp]
  002f7	52		 push	 edx
  002f8	8b 45 10	 mov	 eax, DWORD PTR _dotSpec$[ebp]
  002fb	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  002fe	ff d1		 call	 ecx
  00300	83 c4 08	 add	 esp, 8
  00303	3b f4		 cmp	 esi, esp
  00305	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0030a	90		 npad	 1

; 330  :                         break;

  0030b	eb 5f		 jmp	 SHORT $LN13@defineDotE
$LN23@defineDotE:

; 331  : 
; 332  :                     case '\r':
; 333  : 
; 334  :                         dotSpec->append8(dotSpec, "\\r");

  0030d	8b f4		 mov	 esi, esp
  0030f	68 00 00 00 00	 push	 OFFSET ??_C@_02HIBBOKEN@?2r@
  00314	8b 55 10	 mov	 edx, DWORD PTR _dotSpec$[ebp]
  00317	52		 push	 edx
  00318	8b 45 10	 mov	 eax, DWORD PTR _dotSpec$[ebp]
  0031b	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0031e	ff d1		 call	 ecx
  00320	83 c4 08	 add	 esp, 8
  00323	3b f4		 cmp	 esi, esp
  00325	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0032a	90		 npad	 1

; 335  :                         break;

  0032b	eb 3f		 jmp	 SHORT $LN13@defineDotE
$LN24@defineDotE:

; 336  : 
; 337  :                     default:
; 338  : 
; 339  :                         dotSpec->addc(dotSpec, text->charAt(text, j));

  0032d	8b f4		 mov	 esi, esp
  0032f	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _j$1[ebp]
  00335	52		 push	 edx
  00336	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _text$2[ebp]
  0033c	50		 push	 eax
  0033d	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _text$2[ebp]
  00343	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  00346	ff d2		 call	 edx
  00348	83 c4 08	 add	 esp, 8
  0034b	3b f4		 cmp	 esi, esp
  0034d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00352	8b f4		 mov	 esi, esp
  00354	50		 push	 eax
  00355	8b 45 10	 mov	 eax, DWORD PTR _dotSpec$[ebp]
  00358	50		 push	 eax
  00359	8b 4d 10	 mov	 ecx, DWORD PTR _dotSpec$[ebp]
  0035c	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  0035f	ff d2		 call	 edx
  00361	83 c4 08	 add	 esp, 8
  00364	3b f4		 cmp	 esi, esp
  00366	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0036b	90		 npad	 1
$LN13@defineDotE:

; 340  :                         break;
; 341  :                 }
; 342  :         }

  0036c	e9 f0 fe ff ff	 jmp	 $LN10@defineDotE
$LN11@defineDotE:

; 343  : 		dotSpec->append8(dotSpec, "\n");

  00371	8b f4		 mov	 esi, esp
  00373	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6@
  00378	8b 45 10	 mov	 eax, DWORD PTR _dotSpec$[ebp]
  0037b	50		 push	 eax
  0037c	8b 4d 10	 mov	 ecx, DWORD PTR _dotSpec$[ebp]
  0037f	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00382	ff d2		 call	 edx
  00384	83 c4 08	 add	 esp, 8
  00387	3b f4		 cmp	 esi, esp
  00389	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 344  : 
; 345  :         
; 346  : 		// Define edges for this child
; 347  : 		//
; 348  : 		defineDotEdges(adaptor, child, dotSpec);

  0038e	8b 45 10	 mov	 eax, DWORD PTR _dotSpec$[ebp]
  00391	50		 push	 eax
  00392	8b 4d f0	 mov	 ecx, DWORD PTR _child$4[ebp]
  00395	51		 push	 ecx
  00396	8b 55 08	 mov	 edx, DWORD PTR _adaptor$[ebp]
  00399	52		 push	 edx
  0039a	e8 00 00 00 00	 call	 _defineDotEdges
  0039f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 349  : 	}

  003a2	e9 be fc ff ff	 jmp	 $LN2@defineDotE
$LN3@defineDotE:
$LN1@defineDotE:

; 350  : 
; 351  : 	// Done
; 352  : 	//
; 353  : 	return;
; 354  : }

  003a7	52		 push	 edx
  003a8	8b cd		 mov	 ecx, ebp
  003aa	50		 push	 eax
  003ab	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN28@defineDotE
  003b1	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  003b6	58		 pop	 eax
  003b7	5a		 pop	 edx
  003b8	5f		 pop	 edi
  003b9	5e		 pop	 esi
  003ba	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003bd	33 cd		 xor	 ecx, ebp
  003bf	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003c4	81 c4 a8 00 00
	00		 add	 esp, 168		; 000000a8H
  003ca	3b ec		 cmp	 ebp, esp
  003cc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003d1	8b e5		 mov	 esp, ebp
  003d3	5d		 pop	 ebp
  003d4	c3		 ret	 0
  003d5	0f 1f 00	 npad	 3
$LN28@defineDotE:
  003d8	01 00 00 00	 DD	 1
  003dc	00 00 00 00	 DD	 $LN27@defineDotE
$LN27@defineDotE:
  003e0	6c ff ff ff	 DD	 -148			; ffffff6cH
  003e4	80 00 00 00	 DD	 128			; 00000080H
  003e8	00 00 00 00	 DD	 $LN26@defineDotE
$LN26@defineDotE:
  003ec	62		 DB	 98			; 00000062H
  003ed	75		 DB	 117			; 00000075H
  003ee	66		 DB	 102			; 00000066H
  003ef	66		 DB	 102			; 00000066H
  003f0	00		 DB	 0
_defineDotEdges ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3basetreeadaptor.c
;	COMDAT _defineDotNodes
_TEXT	SEGMENT
tv93 = -100						; size = 4
_j$ = -96						; size = 4
_text$ = -92						; size = 4
_buff$ = -84						; size = 64
_child$ = -16						; size = 4
_i$ = -12						; size = 4
_nCount$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_adaptor$ = 8						; size = 4
_t$ = 12						; size = 4
_dotSpec$ = 16						; size = 4
_defineDotNodes PROC					; COMDAT

; 161  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8d 7d 9c	 lea	 edi, DWORD PTR [ebp-100]
  0000b	b9 19 00 00 00	 mov	 ecx, 25			; 00000019H
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 162  : 	// How many nodes are we talking about?
; 163  : 	//
; 164  : 	int	nCount;
; 165  : 	int i;
; 166  :     pANTLR3_BASE_TREE child;
; 167  : 	char	buff[64];
; 168  : 	pANTLR3_STRING	text;
; 169  : 	int		j;
; 170  : 
; 171  : 
; 172  : 
; 173  : 
; 174  : 
; 175  : 	// Count the nodes
; 176  : 	//
; 177  : 	nCount = adaptor->getChildCount(adaptor, t);

  00021	8b f4		 mov	 esi, esp
  00023	8b 45 0c	 mov	 eax, DWORD PTR _t$[ebp]
  00026	50		 push	 eax
  00027	8b 4d 08	 mov	 ecx, DWORD PTR _adaptor$[ebp]
  0002a	51		 push	 ecx
  0002b	8b 55 08	 mov	 edx, DWORD PTR _adaptor$[ebp]
  0002e	8b 42 7c	 mov	 eax, DWORD PTR [edx+124]
  00031	ff d0		 call	 eax
  00033	83 c4 08	 add	 esp, 8
  00036	3b f4		 cmp	 esi, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	89 45 f8	 mov	 DWORD PTR _nCount$[ebp], eax

; 178  : 
; 179  : 	if	(nCount == 0)

  00040	83 7d f8 00	 cmp	 DWORD PTR _nCount$[ebp], 0
  00044	75 05		 jne	 SHORT $LN10@defineDotN

; 180  : 	{
; 181  : 		// This will already have been included as a child of another node
; 182  : 		// so there is nothing to add.
; 183  : 		//
; 184  : 		return;

  00046	e9 b6 01 00 00	 jmp	 $LN1@defineDotN
$LN10@defineDotN:

; 185  : 	}
; 186  : 
; 187  : 	// For each child of the current tree, define a node using the
; 188  : 	// memory address of the node to name it
; 189  : 	//
; 190  : 	for	(i = 0; i<nCount; i++)

  0004b	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00052	eb 09		 jmp	 SHORT $LN4@defineDotN
$LN2@defineDotN:
  00054	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  00057	83 c1 01	 add	 ecx, 1
  0005a	89 4d f4	 mov	 DWORD PTR _i$[ebp], ecx
$LN4@defineDotN:
  0005d	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  00060	3b 55 f8	 cmp	 edx, DWORD PTR _nCount$[ebp]
  00063	0f 8d 98 01 00
	00		 jge	 $LN3@defineDotN

; 191  : 	{
; 192  : 
; 193  : 		// Pick up a pointer for the child
; 194  : 		//
; 195  : 		child = (pANTLR3_BASE_TREE)adaptor->getChild(adaptor, t, i);

  00069	8b f4		 mov	 esi, esp
  0006b	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  0006e	50		 push	 eax
  0006f	8b 4d 0c	 mov	 ecx, DWORD PTR _t$[ebp]
  00072	51		 push	 ecx
  00073	8b 55 08	 mov	 edx, DWORD PTR _adaptor$[ebp]
  00076	52		 push	 edx
  00077	8b 45 08	 mov	 eax, DWORD PTR _adaptor$[ebp]
  0007a	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  0007d	ff d1		 call	 ecx
  0007f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00082	3b f4		 cmp	 esi, esp
  00084	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00089	89 45 f0	 mov	 DWORD PTR _child$[ebp], eax

; 196  : 
; 197  : 		// Name the node
; 198  : 		//
; 199  : 		sprintf(buff, "\tn%p[label=\"", child);

  0008c	8b 55 f0	 mov	 edx, DWORD PTR _child$[ebp]
  0008f	52		 push	 edx
  00090	68 00 00 00 00	 push	 OFFSET ??_C@_0N@DGCKJLE@?7n?$CFp?$FLlabel?$DN?$CC@
  00095	8d 45 ac	 lea	 eax, DWORD PTR _buff$[ebp]
  00098	50		 push	 eax
  00099	e8 00 00 00 00	 call	 _sprintf
  0009e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 200  : 		dotSpec->append8(dotSpec, buff);

  000a1	8b f4		 mov	 esi, esp
  000a3	8d 4d ac	 lea	 ecx, DWORD PTR _buff$[ebp]
  000a6	51		 push	 ecx
  000a7	8b 55 10	 mov	 edx, DWORD PTR _dotSpec$[ebp]
  000aa	52		 push	 edx
  000ab	8b 45 10	 mov	 eax, DWORD PTR _dotSpec$[ebp]
  000ae	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  000b1	ff d1		 call	 ecx
  000b3	83 c4 08	 add	 esp, 8
  000b6	3b f4		 cmp	 esi, esp
  000b8	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 201  : 		text = adaptor->getText(adaptor, child);

  000bd	8b f4		 mov	 esi, esp
  000bf	8b 55 f0	 mov	 edx, DWORD PTR _child$[ebp]
  000c2	52		 push	 edx
  000c3	8b 45 08	 mov	 eax, DWORD PTR _adaptor$[ebp]
  000c6	50		 push	 eax
  000c7	8b 4d 08	 mov	 ecx, DWORD PTR _adaptor$[ebp]
  000ca	8b 51 5c	 mov	 edx, DWORD PTR [ecx+92]
  000cd	ff d2		 call	 edx
  000cf	83 c4 08	 add	 esp, 8
  000d2	3b f4		 cmp	 esi, esp
  000d4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d9	89 45 a4	 mov	 DWORD PTR _text$[ebp], eax

; 202  : 		for (j = 0; j < (ANTLR3_INT32)(text->len); j++)

  000dc	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  000e3	eb 09		 jmp	 SHORT $LN7@defineDotN
$LN5@defineDotN:
  000e5	8b 45 a0	 mov	 eax, DWORD PTR _j$[ebp]
  000e8	83 c0 01	 add	 eax, 1
  000eb	89 45 a0	 mov	 DWORD PTR _j$[ebp], eax
$LN7@defineDotN:
  000ee	8b 4d a4	 mov	 ecx, DWORD PTR _text$[ebp]
  000f1	8b 55 a0	 mov	 edx, DWORD PTR _j$[ebp]
  000f4	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  000f7	0f 8d ce 00 00
	00		 jge	 $LN6@defineDotN

; 203  : 		{
; 204  :             switch(text->charAt(text, j))

  000fd	8b f4		 mov	 esi, esp
  000ff	8b 45 a0	 mov	 eax, DWORD PTR _j$[ebp]
  00102	50		 push	 eax
  00103	8b 4d a4	 mov	 ecx, DWORD PTR _text$[ebp]
  00106	51		 push	 ecx
  00107	8b 55 a4	 mov	 edx, DWORD PTR _text$[ebp]
  0010a	8b 42 54	 mov	 eax, DWORD PTR [edx+84]
  0010d	ff d0		 call	 eax
  0010f	83 c4 08	 add	 esp, 8
  00112	3b f4		 cmp	 esi, esp
  00114	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00119	89 45 9c	 mov	 DWORD PTR tv93[ebp], eax
  0011c	83 7d 9c 0a	 cmp	 DWORD PTR tv93[ebp], 10	; 0000000aH
  00120	74 2e		 je	 SHORT $LN12@defineDotN
  00122	83 7d 9c 0d	 cmp	 DWORD PTR tv93[ebp], 13	; 0000000dH
  00126	74 48		 je	 SHORT $LN13@defineDotN
  00128	83 7d 9c 22	 cmp	 DWORD PTR tv93[ebp], 34	; 00000022H
  0012c	74 02		 je	 SHORT $LN11@defineDotN
  0012e	eb 60		 jmp	 SHORT $LN14@defineDotN
$LN11@defineDotN:

; 205  :             {
; 206  :                 case '"':
; 207  : 
; 208  :                     dotSpec->append8(dotSpec, "\\\"");

  00130	8b f4		 mov	 esi, esp
  00132	68 00 00 00 00	 push	 OFFSET ??_C@_02MCKKLHBJ@?2?$CC@
  00137	8b 4d 10	 mov	 ecx, DWORD PTR _dotSpec$[ebp]
  0013a	51		 push	 ecx
  0013b	8b 55 10	 mov	 edx, DWORD PTR _dotSpec$[ebp]
  0013e	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00141	ff d0		 call	 eax
  00143	83 c4 08	 add	 esp, 8
  00146	3b f4		 cmp	 esi, esp
  00148	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0014d	90		 npad	 1

; 209  :                     break;

  0014e	eb 76		 jmp	 SHORT $LN8@defineDotN
$LN12@defineDotN:

; 210  : 
; 211  :                 case '\n':
; 212  : 
; 213  :                     dotSpec->append8(dotSpec, "\\n");

  00150	8b f4		 mov	 esi, esp
  00152	68 00 00 00 00	 push	 OFFSET ??_C@_02JOGGLHBA@?2n@
  00157	8b 4d 10	 mov	 ecx, DWORD PTR _dotSpec$[ebp]
  0015a	51		 push	 ecx
  0015b	8b 55 10	 mov	 edx, DWORD PTR _dotSpec$[ebp]
  0015e	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00161	ff d0		 call	 eax
  00163	83 c4 08	 add	 esp, 8
  00166	3b f4		 cmp	 esi, esp
  00168	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0016d	90		 npad	 1

; 214  :                     break;

  0016e	eb 56		 jmp	 SHORT $LN8@defineDotN
$LN13@defineDotN:

; 215  : 
; 216  :                 case '\r':
; 217  : 
; 218  :                     dotSpec->append8(dotSpec, "\\r");

  00170	8b f4		 mov	 esi, esp
  00172	68 00 00 00 00	 push	 OFFSET ??_C@_02HIBBOKEN@?2r@
  00177	8b 4d 10	 mov	 ecx, DWORD PTR _dotSpec$[ebp]
  0017a	51		 push	 ecx
  0017b	8b 55 10	 mov	 edx, DWORD PTR _dotSpec$[ebp]
  0017e	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00181	ff d0		 call	 eax
  00183	83 c4 08	 add	 esp, 8
  00186	3b f4		 cmp	 esi, esp
  00188	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0018d	90		 npad	 1

; 219  :                     break;

  0018e	eb 36		 jmp	 SHORT $LN8@defineDotN
$LN14@defineDotN:

; 220  : 
; 221  :                 default:
; 222  : 
; 223  :                     dotSpec->addc(dotSpec, text->charAt(text, j));

  00190	8b f4		 mov	 esi, esp
  00192	8b 4d a0	 mov	 ecx, DWORD PTR _j$[ebp]
  00195	51		 push	 ecx
  00196	8b 55 a4	 mov	 edx, DWORD PTR _text$[ebp]
  00199	52		 push	 edx
  0019a	8b 45 a4	 mov	 eax, DWORD PTR _text$[ebp]
  0019d	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  001a0	ff d1		 call	 ecx
  001a2	83 c4 08	 add	 esp, 8
  001a5	3b f4		 cmp	 esi, esp
  001a7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001ac	8b f4		 mov	 esi, esp
  001ae	50		 push	 eax
  001af	8b 55 10	 mov	 edx, DWORD PTR _dotSpec$[ebp]
  001b2	52		 push	 edx
  001b3	8b 45 10	 mov	 eax, DWORD PTR _dotSpec$[ebp]
  001b6	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  001b9	ff d1		 call	 ecx
  001bb	83 c4 08	 add	 esp, 8
  001be	3b f4		 cmp	 esi, esp
  001c0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001c5	90		 npad	 1
$LN8@defineDotN:

; 224  :                     break;
; 225  :             }
; 226  : 		}

  001c6	e9 1a ff ff ff	 jmp	 $LN5@defineDotN
$LN6@defineDotN:

; 227  : 		dotSpec->append8(dotSpec, "\"]\n");

  001cb	8b f4		 mov	 esi, esp
  001cd	68 00 00 00 00	 push	 OFFSET ??_C@_03EKALBCDP@?$CC?$FN?6@
  001d2	8b 55 10	 mov	 edx, DWORD PTR _dotSpec$[ebp]
  001d5	52		 push	 edx
  001d6	8b 45 10	 mov	 eax, DWORD PTR _dotSpec$[ebp]
  001d9	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  001dc	ff d1		 call	 ecx
  001de	83 c4 08	 add	 esp, 8
  001e1	3b f4		 cmp	 esi, esp
  001e3	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 228  : 
; 229  : 		// And now define the children of this child (if any)
; 230  : 		//
; 231  : 		defineDotNodes(adaptor, child, dotSpec);

  001e8	8b 55 10	 mov	 edx, DWORD PTR _dotSpec$[ebp]
  001eb	52		 push	 edx
  001ec	8b 45 f0	 mov	 eax, DWORD PTR _child$[ebp]
  001ef	50		 push	 eax
  001f0	8b 4d 08	 mov	 ecx, DWORD PTR _adaptor$[ebp]
  001f3	51		 push	 ecx
  001f4	e8 00 00 00 00	 call	 _defineDotNodes
  001f9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 232  : 	}

  001fc	e9 53 fe ff ff	 jmp	 $LN2@defineDotN
$LN3@defineDotN:
$LN1@defineDotN:

; 233  : 	
; 234  : 	// Done
; 235  : 	//
; 236  : 	return;
; 237  : }

  00201	52		 push	 edx
  00202	8b cd		 mov	 ecx, ebp
  00204	50		 push	 eax
  00205	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN18@defineDotN
  0020b	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00210	58		 pop	 eax
  00211	5a		 pop	 edx
  00212	5f		 pop	 edi
  00213	5e		 pop	 esi
  00214	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00217	33 cd		 xor	 ecx, ebp
  00219	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0021e	83 c4 64	 add	 esp, 100		; 00000064H
  00221	3b ec		 cmp	 ebp, esp
  00223	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00228	8b e5		 mov	 esp, ebp
  0022a	5d		 pop	 ebp
  0022b	c3		 ret	 0
$LN18@defineDotN:
  0022c	01 00 00 00	 DD	 1
  00230	00 00 00 00	 DD	 $LN17@defineDotN
$LN17@defineDotN:
  00234	ac ff ff ff	 DD	 -84			; ffffffacH
  00238	40 00 00 00	 DD	 64			; 00000040H
  0023c	00 00 00 00	 DD	 $LN16@defineDotN
$LN16@defineDotN:
  00240	62		 DB	 98			; 00000062H
  00241	75		 DB	 117			; 00000075H
  00242	66		 DB	 102			; 00000066H
  00243	66		 DB	 102			; 00000066H
  00244	00		 DB	 0
_defineDotNodes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3basetreeadaptor.c
;	COMDAT _makeDot
_TEXT	SEGMENT
tv91 = -92						; size = 4
_j$ = -88						; size = 4
_text$ = -84						; size = 4
_buff$ = -76						; size = 64
_dotSpec$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_adaptor$ = 8						; size = 4
_theTree$ = 12						; size = 4
_makeDot PROC						; COMDAT

; 360  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8d 7d a4	 lea	 edi, DWORD PTR [ebp-92]
  0000b	b9 17 00 00 00	 mov	 ecx, 23			; 00000017H
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 361  : 	// The string we are building up
; 362  : 	//
; 363  : 	pANTLR3_STRING		dotSpec;
; 364  : 	char                buff[64];
; 365  : 	pANTLR3_STRING      text;
; 366  : 	int                 j;
; 367  : 
; 368  : 	dotSpec = adaptor->strFactory->newStr8

  00021	8b f4		 mov	 esi, esp
  00023	68 00 00 00 00	 push	 OFFSET ??_C@_0BCG@JAAAKLG@digraph?5?$HL?6?6?7ordering?$DNout?$DL?6?7rank@
  00028	8b 45 08	 mov	 eax, DWORD PTR _adaptor$[ebp]
  0002b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0002e	51		 push	 ecx
  0002f	8b 55 08	 mov	 edx, DWORD PTR _adaptor$[ebp]
  00032	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00035	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00038	ff d1		 call	 ecx
  0003a	83 c4 08	 add	 esp, 8
  0003d	3b f4		 cmp	 esi, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	89 45 f8	 mov	 DWORD PTR _dotSpec$[ebp], eax

; 369  : 		
; 370  : 		(
; 371  : 			adaptor->strFactory,
; 372  : 
; 373  : 			// Default look and feel
; 374  : 			//
; 375  : 			(pANTLR3_UINT8)
; 376  : 			"digraph {\n\n"
; 377  : 			"\tordering=out;\n"
; 378  : 			"\tranksep=.4;\n"
; 379  : 			"\tbgcolor=\"lightgrey\";  node [shape=box, fixedsize=false, fontsize=12, fontname=\"Helvetica-bold\", fontcolor=\"blue\"\n"
; 380  : 			"\twidth=.25, height=.25, color=\"black\", fillcolor=\"white\", style=\"filled, solid, bold\"];\n\n"
; 381  : 			"\tedge [arrowsize=.5, color=\"black\", style=\"bold\"]\n\n"
; 382  : 		);
; 383  : 
; 384  :     if	(theTree == NULL)

  00047	83 7d 0c 00	 cmp	 DWORD PTR _theTree$[ebp], 0
  0004b	75 25		 jne	 SHORT $LN7@makeDot

; 385  : 	{
; 386  : 		// No tree, so create a blank spec
; 387  : 		//
; 388  : 		dotSpec->append8(dotSpec, "n0[label=\"EMPTY TREE\"]\n");

  0004d	8b f4		 mov	 esi, esp
  0004f	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@IPCNDJJ@n0?$FLlabel?$DN?$CCEMPTY?5TREE?$CC?$FN?6@
  00054	8b 55 f8	 mov	 edx, DWORD PTR _dotSpec$[ebp]
  00057	52		 push	 edx
  00058	8b 45 f8	 mov	 eax, DWORD PTR _dotSpec$[ebp]
  0005b	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0005e	ff d1		 call	 ecx
  00060	83 c4 08	 add	 esp, 8
  00063	3b f4		 cmp	 esi, esp
  00065	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 389  : 		return dotSpec;

  0006a	8b 45 f8	 mov	 eax, DWORD PTR _dotSpec$[ebp]
  0006d	e9 c1 01 00 00	 jmp	 $LN1@makeDot
$LN7@makeDot:

; 390  : 	}
; 391  : 
; 392  :     sprintf(buff, "\tn%p[label=\"", theTree);

  00072	8b 55 0c	 mov	 edx, DWORD PTR _theTree$[ebp]
  00075	52		 push	 edx
  00076	68 00 00 00 00	 push	 OFFSET ??_C@_0N@DGCKJLE@?7n?$CFp?$FLlabel?$DN?$CC@
  0007b	8d 45 b4	 lea	 eax, DWORD PTR _buff$[ebp]
  0007e	50		 push	 eax
  0007f	e8 00 00 00 00	 call	 _sprintf
  00084	83 c4 0c	 add	 esp, 12			; 0000000cH

; 393  : 	dotSpec->append8(dotSpec, buff);

  00087	8b f4		 mov	 esi, esp
  00089	8d 4d b4	 lea	 ecx, DWORD PTR _buff$[ebp]
  0008c	51		 push	 ecx
  0008d	8b 55 f8	 mov	 edx, DWORD PTR _dotSpec$[ebp]
  00090	52		 push	 edx
  00091	8b 45 f8	 mov	 eax, DWORD PTR _dotSpec$[ebp]
  00094	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00097	ff d1		 call	 ecx
  00099	83 c4 08	 add	 esp, 8
  0009c	3b f4		 cmp	 esi, esp
  0009e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 394  :     text = adaptor->getText(adaptor, theTree);

  000a3	8b f4		 mov	 esi, esp
  000a5	8b 55 0c	 mov	 edx, DWORD PTR _theTree$[ebp]
  000a8	52		 push	 edx
  000a9	8b 45 08	 mov	 eax, DWORD PTR _adaptor$[ebp]
  000ac	50		 push	 eax
  000ad	8b 4d 08	 mov	 ecx, DWORD PTR _adaptor$[ebp]
  000b0	8b 51 5c	 mov	 edx, DWORD PTR [ecx+92]
  000b3	ff d2		 call	 edx
  000b5	83 c4 08	 add	 esp, 8
  000b8	3b f4		 cmp	 esi, esp
  000ba	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bf	89 45 ac	 mov	 DWORD PTR _text$[ebp], eax

; 395  :     for (j = 0; j < (ANTLR3_INT32)(text->len); j++)

  000c2	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  000c9	eb 09		 jmp	 SHORT $LN4@makeDot
$LN2@makeDot:
  000cb	8b 45 a8	 mov	 eax, DWORD PTR _j$[ebp]
  000ce	83 c0 01	 add	 eax, 1
  000d1	89 45 a8	 mov	 DWORD PTR _j$[ebp], eax
$LN4@makeDot:
  000d4	8b 4d ac	 mov	 ecx, DWORD PTR _text$[ebp]
  000d7	8b 55 a8	 mov	 edx, DWORD PTR _j$[ebp]
  000da	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  000dd	0f 8d ce 00 00
	00		 jge	 $LN3@makeDot

; 396  :     {
; 397  :             switch(text->charAt(text, j))

  000e3	8b f4		 mov	 esi, esp
  000e5	8b 45 a8	 mov	 eax, DWORD PTR _j$[ebp]
  000e8	50		 push	 eax
  000e9	8b 4d ac	 mov	 ecx, DWORD PTR _text$[ebp]
  000ec	51		 push	 ecx
  000ed	8b 55 ac	 mov	 edx, DWORD PTR _text$[ebp]
  000f0	8b 42 54	 mov	 eax, DWORD PTR [edx+84]
  000f3	ff d0		 call	 eax
  000f5	83 c4 08	 add	 esp, 8
  000f8	3b f4		 cmp	 esi, esp
  000fa	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ff	89 45 a4	 mov	 DWORD PTR tv91[ebp], eax
  00102	83 7d a4 0a	 cmp	 DWORD PTR tv91[ebp], 10	; 0000000aH
  00106	74 2e		 je	 SHORT $LN9@makeDot
  00108	83 7d a4 0d	 cmp	 DWORD PTR tv91[ebp], 13	; 0000000dH
  0010c	74 48		 je	 SHORT $LN10@makeDot
  0010e	83 7d a4 22	 cmp	 DWORD PTR tv91[ebp], 34	; 00000022H
  00112	74 02		 je	 SHORT $LN8@makeDot
  00114	eb 60		 jmp	 SHORT $LN11@makeDot
$LN8@makeDot:

; 398  :             {
; 399  :                 case '"':
; 400  : 
; 401  :                     dotSpec->append8(dotSpec, "\\\"");

  00116	8b f4		 mov	 esi, esp
  00118	68 00 00 00 00	 push	 OFFSET ??_C@_02MCKKLHBJ@?2?$CC@
  0011d	8b 4d f8	 mov	 ecx, DWORD PTR _dotSpec$[ebp]
  00120	51		 push	 ecx
  00121	8b 55 f8	 mov	 edx, DWORD PTR _dotSpec$[ebp]
  00124	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00127	ff d0		 call	 eax
  00129	83 c4 08	 add	 esp, 8
  0012c	3b f4		 cmp	 esi, esp
  0012e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00133	90		 npad	 1

; 402  :                     break;

  00134	eb 76		 jmp	 SHORT $LN5@makeDot
$LN9@makeDot:

; 403  : 
; 404  :                 case '\n':
; 405  : 
; 406  :                     dotSpec->append8(dotSpec, "\\n");

  00136	8b f4		 mov	 esi, esp
  00138	68 00 00 00 00	 push	 OFFSET ??_C@_02JOGGLHBA@?2n@
  0013d	8b 4d f8	 mov	 ecx, DWORD PTR _dotSpec$[ebp]
  00140	51		 push	 ecx
  00141	8b 55 f8	 mov	 edx, DWORD PTR _dotSpec$[ebp]
  00144	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00147	ff d0		 call	 eax
  00149	83 c4 08	 add	 esp, 8
  0014c	3b f4		 cmp	 esi, esp
  0014e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00153	90		 npad	 1

; 407  :                     break;

  00154	eb 56		 jmp	 SHORT $LN5@makeDot
$LN10@makeDot:

; 408  : 
; 409  :                 case '\r':
; 410  : 
; 411  :                     dotSpec->append8(dotSpec, "\\r");

  00156	8b f4		 mov	 esi, esp
  00158	68 00 00 00 00	 push	 OFFSET ??_C@_02HIBBOKEN@?2r@
  0015d	8b 4d f8	 mov	 ecx, DWORD PTR _dotSpec$[ebp]
  00160	51		 push	 ecx
  00161	8b 55 f8	 mov	 edx, DWORD PTR _dotSpec$[ebp]
  00164	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00167	ff d0		 call	 eax
  00169	83 c4 08	 add	 esp, 8
  0016c	3b f4		 cmp	 esi, esp
  0016e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00173	90		 npad	 1

; 412  :                     break;

  00174	eb 36		 jmp	 SHORT $LN5@makeDot
$LN11@makeDot:

; 413  : 
; 414  :                 default:
; 415  : 
; 416  :                     dotSpec->addc(dotSpec, text->charAt(text, j));

  00176	8b f4		 mov	 esi, esp
  00178	8b 4d a8	 mov	 ecx, DWORD PTR _j$[ebp]
  0017b	51		 push	 ecx
  0017c	8b 55 ac	 mov	 edx, DWORD PTR _text$[ebp]
  0017f	52		 push	 edx
  00180	8b 45 ac	 mov	 eax, DWORD PTR _text$[ebp]
  00183	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  00186	ff d1		 call	 ecx
  00188	83 c4 08	 add	 esp, 8
  0018b	3b f4		 cmp	 esi, esp
  0018d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00192	8b f4		 mov	 esi, esp
  00194	50		 push	 eax
  00195	8b 55 f8	 mov	 edx, DWORD PTR _dotSpec$[ebp]
  00198	52		 push	 edx
  00199	8b 45 f8	 mov	 eax, DWORD PTR _dotSpec$[ebp]
  0019c	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  0019f	ff d1		 call	 ecx
  001a1	83 c4 08	 add	 esp, 8
  001a4	3b f4		 cmp	 esi, esp
  001a6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001ab	90		 npad	 1
$LN5@makeDot:

; 417  :                     break;
; 418  :             }
; 419  :     }

  001ac	e9 1a ff ff ff	 jmp	 $LN2@makeDot
$LN3@makeDot:

; 420  : 	dotSpec->append8(dotSpec, "\"]\n");

  001b1	8b f4		 mov	 esi, esp
  001b3	68 00 00 00 00	 push	 OFFSET ??_C@_03EKALBCDP@?$CC?$FN?6@
  001b8	8b 55 f8	 mov	 edx, DWORD PTR _dotSpec$[ebp]
  001bb	52		 push	 edx
  001bc	8b 45 f8	 mov	 eax, DWORD PTR _dotSpec$[ebp]
  001bf	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  001c2	ff d1		 call	 ecx
  001c4	83 c4 08	 add	 esp, 8
  001c7	3b f4		 cmp	 esi, esp
  001c9	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 421  : 
; 422  : 	// First produce the node defintions
; 423  : 	//
; 424  : 	defineDotNodes(adaptor, theTree, dotSpec);

  001ce	8b 55 f8	 mov	 edx, DWORD PTR _dotSpec$[ebp]
  001d1	52		 push	 edx
  001d2	8b 45 0c	 mov	 eax, DWORD PTR _theTree$[ebp]
  001d5	50		 push	 eax
  001d6	8b 4d 08	 mov	 ecx, DWORD PTR _adaptor$[ebp]
  001d9	51		 push	 ecx
  001da	e8 00 00 00 00	 call	 _defineDotNodes
  001df	83 c4 0c	 add	 esp, 12			; 0000000cH

; 425  : 	dotSpec->append8(dotSpec, "\n");

  001e2	8b f4		 mov	 esi, esp
  001e4	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6@
  001e9	8b 55 f8	 mov	 edx, DWORD PTR _dotSpec$[ebp]
  001ec	52		 push	 edx
  001ed	8b 45 f8	 mov	 eax, DWORD PTR _dotSpec$[ebp]
  001f0	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  001f3	ff d1		 call	 ecx
  001f5	83 c4 08	 add	 esp, 8
  001f8	3b f4		 cmp	 esi, esp
  001fa	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 426  : 	defineDotEdges(adaptor, theTree, dotSpec);

  001ff	8b 55 f8	 mov	 edx, DWORD PTR _dotSpec$[ebp]
  00202	52		 push	 edx
  00203	8b 45 0c	 mov	 eax, DWORD PTR _theTree$[ebp]
  00206	50		 push	 eax
  00207	8b 4d 08	 mov	 ecx, DWORD PTR _adaptor$[ebp]
  0020a	51		 push	 ecx
  0020b	e8 00 00 00 00	 call	 _defineDotEdges
  00210	83 c4 0c	 add	 esp, 12			; 0000000cH

; 427  : 	
; 428  : 	// Terminate the spec
; 429  : 	//
; 430  : 	dotSpec->append8(dotSpec, "\n}");

  00213	8b f4		 mov	 esi, esp
  00215	68 00 00 00 00	 push	 OFFSET ??_C@_02JHLIKEIA@?6?$HN@
  0021a	8b 55 f8	 mov	 edx, DWORD PTR _dotSpec$[ebp]
  0021d	52		 push	 edx
  0021e	8b 45 f8	 mov	 eax, DWORD PTR _dotSpec$[ebp]
  00221	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00224	ff d1		 call	 ecx
  00226	83 c4 08	 add	 esp, 8
  00229	3b f4		 cmp	 esi, esp
  0022b	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 431  : 
; 432  : 	// Result
; 433  : 	//
; 434  : 	return dotSpec;

  00230	8b 45 f8	 mov	 eax, DWORD PTR _dotSpec$[ebp]
$LN1@makeDot:

; 435  : }

  00233	52		 push	 edx
  00234	8b cd		 mov	 ecx, ebp
  00236	50		 push	 eax
  00237	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN15@makeDot
  0023d	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00242	58		 pop	 eax
  00243	5a		 pop	 edx
  00244	5f		 pop	 edi
  00245	5e		 pop	 esi
  00246	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00249	33 cd		 xor	 ecx, ebp
  0024b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00250	83 c4 5c	 add	 esp, 92			; 0000005cH
  00253	3b ec		 cmp	 ebp, esp
  00255	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0025a	8b e5		 mov	 esp, ebp
  0025c	5d		 pop	 ebp
  0025d	c3		 ret	 0
  0025e	66 90		 npad	 2
$LN15@makeDot:
  00260	01 00 00 00	 DD	 1
  00264	00 00 00 00	 DD	 $LN14@makeDot
$LN14@makeDot:
  00268	b4 ff ff ff	 DD	 -76			; ffffffb4H
  0026c	40 00 00 00	 DD	 64			; 00000040H
  00270	00 00 00 00	 DD	 $LN13@makeDot
$LN13@makeDot:
  00274	62		 DB	 98			; 00000062H
  00275	75		 DB	 117			; 00000075H
  00276	66		 DB	 102			; 00000066H
  00277	66		 DB	 102			; 00000066H
  00278	00		 DB	 0
_makeDot ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3basetreeadaptor.c
;	COMDAT _isNilNode
_TEXT	SEGMENT
_adaptor$ = 8						; size = 4
_t$ = 12						; size = 4
_isNilNode PROC						; COMDAT

; 907  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 908  : 	return t->isNilNode(t);

  00004	8b f4		 mov	 esi, esp
  00006	8b 45 0c	 mov	 eax, DWORD PTR _t$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _t$[ebp]
  0000d	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  00010	ff d2		 call	 edx
  00012	83 c4 04	 add	 esp, 4
  00015	3b f4		 cmp	 esi, esp
  00017	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 909  : }

  0001c	5e		 pop	 esi
  0001d	3b ec		 cmp	 ebp, esp
  0001f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
_isNilNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3basetreeadaptor.c
;	COMDAT _getUniqueID
_TEXT	SEGMENT
_adaptor$ = 8						; size = 4
_node$ = 12						; size = 4
_getUniqueID PROC					; COMDAT

; 901  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 902  : 	return	ANTLR3_UINT32_CAST(node);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _node$[ebp]

; 903  : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
_getUniqueID ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3basetreeadaptor.c
;	COMDAT _getChildCount
_TEXT	SEGMENT
_adaptor$ = 8						; size = 4
_tree$ = 12						; size = 4
_getChildCount PROC					; COMDAT

; 891  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 892  : 	ANTLR3_FPRINTF(stderr, "Internal error - implementor of superclass containing ANTLR3_TREE_ADAPTOR did not implement getChildCount()\n");

  00004	68 00 00 00 00	 push	 OFFSET ??_C@_0GN@PACIMGKB@Internal?5error?5?9?5implementor?5of@
  00009	8b f4		 mov	 esi, esp
  0000b	6a 02		 push	 2
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  00013	83 c4 04	 add	 esp, 4
  00016	3b f4		 cmp	 esi, esp
  00018	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 _fprintf
  00023	83 c4 08	 add	 esp, 8

; 893  : 	return 0;

  00026	33 c0		 xor	 eax, eax

; 894  : }

  00028	5e		 pop	 esi
  00029	3b ec		 cmp	 ebp, esp
  0002b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
_getChildCount ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3basetreeadaptor.c
;	COMDAT _getChild
_TEXT	SEGMENT
_adaptor$ = 8						; size = 4
_tree$ = 12						; size = 4
_i$ = 16						; size = 4
_getChild PROC						; COMDAT

; 884  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 885  : 	ANTLR3_FPRINTF(stderr, "Internal error - implementor of superclass containing ANTLR3_TREE_ADAPTOR did not implement getChild()\n");

  00004	68 00 00 00 00	 push	 OFFSET ??_C@_0GI@GANAPDHF@Internal?5error?5?9?5implementor?5of@
  00009	8b f4		 mov	 esi, esp
  0000b	6a 02		 push	 2
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  00013	83 c4 04	 add	 esp, 4
  00016	3b f4		 cmp	 esi, esp
  00018	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 _fprintf
  00023	83 c4 08	 add	 esp, 8

; 886  : 	return NULL;

  00026	33 c0		 xor	 eax, eax

; 887  : }

  00028	5e		 pop	 esi
  00029	3b ec		 cmp	 ebp, esp
  0002b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
_getChild ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3basetreeadaptor.c
;	COMDAT _setText8
_TEXT	SEGMENT
_adaptor$ = 8						; size = 4
_t$ = 12						; size = 4
_setText8 PROC						; COMDAT

; 878  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 879  : 	ANTLR3_FPRINTF(stderr, "Internal error - implementor of superclass containing ANTLR3_TREE_ADAPTOR did not implement setText()\n");

  00004	68 00 00 00 00	 push	 OFFSET ??_C@_0GH@HPJNFAJE@Internal?5error?5?9?5implementor?5of@
  00009	8b f4		 mov	 esi, esp
  0000b	6a 02		 push	 2
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  00013	83 c4 04	 add	 esp, 4
  00016	3b f4		 cmp	 esi, esp
  00018	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 _fprintf
  00023	83 c4 08	 add	 esp, 8

; 880  : }

  00026	5e		 pop	 esi
  00027	3b ec		 cmp	 ebp, esp
  00029	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
_setText8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3basetreeadaptor.c
;	COMDAT _setText
_TEXT	SEGMENT
_adaptor$ = 8						; size = 4
_t$ = 12						; size = 4
_setText PROC						; COMDAT

; 871  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 872  : 	ANTLR3_FPRINTF(stderr, "Internal error - implementor of superclass containing ANTLR3_TREE_ADAPTOR did not implement setText()\n");

  00004	68 00 00 00 00	 push	 OFFSET ??_C@_0GH@HPJNFAJE@Internal?5error?5?9?5implementor?5of@
  00009	8b f4		 mov	 esi, esp
  0000b	6a 02		 push	 2
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  00013	83 c4 04	 add	 esp, 4
  00016	3b f4		 cmp	 esi, esp
  00018	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 _fprintf
  00023	83 c4 08	 add	 esp, 8

; 873  : }

  00026	5e		 pop	 esi
  00027	3b ec		 cmp	 ebp, esp
  00029	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
_setText ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3basetreeadaptor.c
;	COMDAT _getText
_TEXT	SEGMENT
_adaptor$ = 8						; size = 4
_t$ = 12						; size = 4
_getText PROC						; COMDAT

; 862  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 863  : 	ANTLR3_FPRINTF(stderr, "Internal error - implementor of superclass containing ANTLR3_TREE_ADAPTOR did not implement getText()\n");

  00004	68 00 00 00 00	 push	 OFFSET ??_C@_0GH@GBLCOHNN@Internal?5error?5?9?5implementor?5of@
  00009	8b f4		 mov	 esi, esp
  0000b	6a 02		 push	 2
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  00013	83 c4 04	 add	 esp, 4
  00016	3b f4		 cmp	 esi, esp
  00018	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 _fprintf
  00023	83 c4 08	 add	 esp, 8

; 864  : 	return	NULL;

  00026	33 c0		 xor	 eax, eax

; 865  : }

  00028	5e		 pop	 esi
  00029	3b ec		 cmp	 ebp, esp
  0002b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
_getText ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3basetreeadaptor.c
;	COMDAT _setType
_TEXT	SEGMENT
_adaptor$ = 8						; size = 4
_t$ = 12						; size = 4
_type$ = 16						; size = 4
_setType PROC						; COMDAT

; 854  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 855  : 	ANTLR3_FPRINTF(stderr, "Internal error - implementor of superclass containing ANTLR3_TREE_ADAPTOR did not implement setType()\n");

  00004	68 00 00 00 00	 push	 OFFSET ??_C@_0GH@GODAJKHB@Internal?5error?5?9?5implementor?5of@
  00009	8b f4		 mov	 esi, esp
  0000b	6a 02		 push	 2
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  00013	83 c4 04	 add	 esp, 4
  00016	3b f4		 cmp	 esi, esp
  00018	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 _fprintf
  00023	83 c4 08	 add	 esp, 8

; 856  : }

  00026	5e		 pop	 esi
  00027	3b ec		 cmp	 ebp, esp
  00029	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
_setType ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3basetreeadaptor.c
;	COMDAT _getType
_TEXT	SEGMENT
_adaptor$ = 8						; size = 4
_t$ = 12						; size = 4
_getType PROC						; COMDAT

; 846  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 847  : 	return	0;

  00003	33 c0		 xor	 eax, eax

; 848  : }

  00005	5d		 pop	 ebp
  00006	c3		 ret	 0
_getType ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3basetreeadaptor.c
;	COMDAT _dbgCreateTypeText
_TEXT	SEGMENT
_t$ = -4						; size = 4
_adaptor$ = 8						; size = 4
_tokenType$ = 12					; size = 4
_text$ = 16						; size = 4
_dbgCreateTypeText PROC					; COMDAT

; 832  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 833  : 	pANTLR3_BASE_TREE t;
; 834  : 
; 835  : 	t = createTypeText(adaptor, tokenType, text);

  0000c	8b 45 10	 mov	 eax, DWORD PTR _text$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR _tokenType$[ebp]
  00013	51		 push	 ecx
  00014	8b 55 08	 mov	 edx, DWORD PTR _adaptor$[ebp]
  00017	52		 push	 edx
  00018	e8 00 00 00 00	 call	 _createTypeText
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00020	89 45 fc	 mov	 DWORD PTR _t$[ebp], eax

; 836  : 
; 837  : 	adaptor->debugger->createNode(adaptor->debugger, t);

  00023	8b f4		 mov	 esi, esp
  00025	8b 45 fc	 mov	 eax, DWORD PTR _t$[ebp]
  00028	50		 push	 eax
  00029	8b 4d 08	 mov	 ecx, DWORD PTR _adaptor$[ebp]
  0002c	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0002f	52		 push	 edx
  00030	8b 45 08	 mov	 eax, DWORD PTR _adaptor$[ebp]
  00033	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00036	8b 91 8c 00 00
	00		 mov	 edx, DWORD PTR [ecx+140]
  0003c	ff d2		 call	 edx
  0003e	83 c4 08	 add	 esp, 8
  00041	3b f4		 cmp	 esi, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 838  : 
; 839  : 	return t;

  00048	8b 45 fc	 mov	 eax, DWORD PTR _t$[ebp]

; 840  : 
; 841  : }

  0004b	5e		 pop	 esi
  0004c	83 c4 04	 add	 esp, 4
  0004f	3b ec		 cmp	 ebp, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
_dbgCreateTypeText ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3basetreeadaptor.c
;	COMDAT _createTypeText
_TEXT	SEGMENT
_fromToken$ = -4					; size = 4
_adaptor$ = 8						; size = 4
_tokenType$ = 12					; size = 4
_text$ = 16						; size = 4
_createTypeText PROC					; COMDAT

; 819  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 820  : 	pANTLR3_COMMON_TOKEN	fromToken;
; 821  : 
; 822  : 	/* Create the new token
; 823  : 	 */
; 824  : 	fromToken = adaptor->createToken(adaptor, tokenType, text);

  0000c	8b f4		 mov	 esi, esp
  0000e	8b 45 10	 mov	 eax, DWORD PTR _text$[ebp]
  00011	50		 push	 eax
  00012	8b 4d 0c	 mov	 ecx, DWORD PTR _tokenType$[ebp]
  00015	51		 push	 ecx
  00016	8b 55 08	 mov	 edx, DWORD PTR _adaptor$[ebp]
  00019	52		 push	 edx
  0001a	8b 45 08	 mov	 eax, DWORD PTR _adaptor$[ebp]
  0001d	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  00023	ff d1		 call	 ecx
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH
  00028	3b f4		 cmp	 esi, esp
  0002a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002f	89 45 fc	 mov	 DWORD PTR _fromToken$[ebp], eax

; 825  : 
; 826  : 	/* Return a new node based upon this token
; 827  : 	 */
; 828  : 	return	(pANTLR3_BASE_TREE)adaptor->create(adaptor, fromToken);

  00032	8b f4		 mov	 esi, esp
  00034	8b 55 fc	 mov	 edx, DWORD PTR _fromToken$[ebp]
  00037	52		 push	 edx
  00038	8b 45 08	 mov	 eax, DWORD PTR _adaptor$[ebp]
  0003b	50		 push	 eax
  0003c	8b 4d 08	 mov	 ecx, DWORD PTR _adaptor$[ebp]
  0003f	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  00042	ff d2		 call	 edx
  00044	83 c4 08	 add	 esp, 8
  00047	3b f4		 cmp	 esi, esp
  00049	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 829  : }

  0004e	5e		 pop	 esi
  0004f	83 c4 04	 add	 esp, 4
  00052	3b ec		 cmp	 ebp, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
_createTypeText ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3basetreeadaptor.c
;	COMDAT _dbgCreateTypeTokenText
_TEXT	SEGMENT
_t$ = -4						; size = 4
_adaptor$ = 8						; size = 4
_tokenType$ = 12					; size = 4
_fromToken$ = 16					; size = 4
_text$ = 20						; size = 4
_dbgCreateTypeTokenText PROC				; COMDAT

; 807  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 808  : 	pANTLR3_BASE_TREE t;
; 809  : 
; 810  : 	t = createTypeTokenText(adaptor, tokenType, fromToken, text);

  0000c	8b 45 14	 mov	 eax, DWORD PTR _text$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 10	 mov	 ecx, DWORD PTR _fromToken$[ebp]
  00013	51		 push	 ecx
  00014	8b 55 0c	 mov	 edx, DWORD PTR _tokenType$[ebp]
  00017	52		 push	 edx
  00018	8b 45 08	 mov	 eax, DWORD PTR _adaptor$[ebp]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _createTypeTokenText
  00021	83 c4 10	 add	 esp, 16			; 00000010H
  00024	89 45 fc	 mov	 DWORD PTR _t$[ebp], eax

; 811  : 
; 812  : 	adaptor->debugger->createNode(adaptor->debugger, t);

  00027	8b f4		 mov	 esi, esp
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _t$[ebp]
  0002c	51		 push	 ecx
  0002d	8b 55 08	 mov	 edx, DWORD PTR _adaptor$[ebp]
  00030	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00033	50		 push	 eax
  00034	8b 4d 08	 mov	 ecx, DWORD PTR _adaptor$[ebp]
  00037	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0003a	8b 82 8c 00 00
	00		 mov	 eax, DWORD PTR [edx+140]
  00040	ff d0		 call	 eax
  00042	83 c4 08	 add	 esp, 8
  00045	3b f4		 cmp	 esi, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 813  : 
; 814  : 	return t;

  0004c	8b 45 fc	 mov	 eax, DWORD PTR _t$[ebp]

; 815  : }

  0004f	5e		 pop	 esi
  00050	83 c4 04	 add	 esp, 4
  00053	3b ec		 cmp	 ebp, esp
  00055	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
_dbgCreateTypeTokenText ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3basetreeadaptor.c
;	COMDAT _createTypeTokenText
_TEXT	SEGMENT
_adaptor$ = 8						; size = 4
_tokenType$ = 12					; size = 4
_fromToken$ = 16					; size = 4
_text$ = 20						; size = 4
_createTypeTokenText PROC				; COMDAT

; 788  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 789  : 	/* Create the new token
; 790  : 	 */
; 791  : 	fromToken = adaptor->createTokenFromToken(adaptor, fromToken);

  00004	8b f4		 mov	 esi, esp
  00006	8b 45 10	 mov	 eax, DWORD PTR _fromToken$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _adaptor$[ebp]
  0000d	51		 push	 ecx
  0000e	8b 55 08	 mov	 edx, DWORD PTR _adaptor$[ebp]
  00011	8b 82 88 00 00
	00		 mov	 eax, DWORD PTR [edx+136]
  00017	ff d0		 call	 eax
  00019	83 c4 08	 add	 esp, 8
  0001c	3b f4		 cmp	 esi, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	89 45 10	 mov	 DWORD PTR _fromToken$[ebp], eax

; 792  : 
; 793  : 	/* Set the type of the new token to that supplied
; 794  : 	 */
; 795  : 	fromToken->setType(fromToken, tokenType);

  00026	8b f4		 mov	 esi, esp
  00028	8b 4d 0c	 mov	 ecx, DWORD PTR _tokenType$[ebp]
  0002b	51		 push	 ecx
  0002c	8b 55 10	 mov	 edx, DWORD PTR _fromToken$[ebp]
  0002f	52		 push	 edx
  00030	8b 45 10	 mov	 eax, DWORD PTR _fromToken$[ebp]
  00033	8b 48 58	 mov	 ecx, DWORD PTR [eax+88]
  00036	ff d1		 call	 ecx
  00038	83 c4 08	 add	 esp, 8
  0003b	3b f4		 cmp	 esi, esp
  0003d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 796  : 
; 797  : 	/* Set the text of the token accordingly
; 798  : 	 */
; 799  : 	fromToken->setText8(fromToken, text);

  00042	8b f4		 mov	 esi, esp
  00044	8b 55 14	 mov	 edx, DWORD PTR _text$[ebp]
  00047	52		 push	 edx
  00048	8b 45 10	 mov	 eax, DWORD PTR _fromToken$[ebp]
  0004b	50		 push	 eax
  0004c	8b 4d 10	 mov	 ecx, DWORD PTR _fromToken$[ebp]
  0004f	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  00052	ff d2		 call	 edx
  00054	83 c4 08	 add	 esp, 8
  00057	3b f4		 cmp	 esi, esp
  00059	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 800  : 
; 801  : 	/* Return a new node based upon this token
; 802  : 	 */
; 803  : 	return	(pANTLR3_BASE_TREE)adaptor->create(adaptor, fromToken);

  0005e	8b f4		 mov	 esi, esp
  00060	8b 45 10	 mov	 eax, DWORD PTR _fromToken$[ebp]
  00063	50		 push	 eax
  00064	8b 4d 08	 mov	 ecx, DWORD PTR _adaptor$[ebp]
  00067	51		 push	 ecx
  00068	8b 55 08	 mov	 edx, DWORD PTR _adaptor$[ebp]
  0006b	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  0006e	ff d0		 call	 eax
  00070	83 c4 08	 add	 esp, 8
  00073	3b f4		 cmp	 esi, esp
  00075	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 804  : }

  0007a	5e		 pop	 esi
  0007b	3b ec		 cmp	 ebp, esp
  0007d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00082	5d		 pop	 ebp
  00083	c3		 ret	 0
_createTypeTokenText ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3basetreeadaptor.c
;	COMDAT _dbgCreateTypeToken
_TEXT	SEGMENT
_t$ = -4						; size = 4
_adaptor$ = 8						; size = 4
_tokenType$ = 12					; size = 4
_fromToken$ = 16					; size = 4
_dbgCreateTypeToken PROC				; COMDAT

; 776  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 777  : 	pANTLR3_BASE_TREE t;
; 778  : 
; 779  : 	t = createTypeToken(adaptor, tokenType, fromToken);

  0000c	8b 45 10	 mov	 eax, DWORD PTR _fromToken$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR _tokenType$[ebp]
  00013	51		 push	 ecx
  00014	8b 55 08	 mov	 edx, DWORD PTR _adaptor$[ebp]
  00017	52		 push	 edx
  00018	e8 00 00 00 00	 call	 _createTypeToken
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00020	89 45 fc	 mov	 DWORD PTR _t$[ebp], eax

; 780  : 
; 781  : 	adaptor->debugger->createNode(adaptor->debugger, t);

  00023	8b f4		 mov	 esi, esp
  00025	8b 45 fc	 mov	 eax, DWORD PTR _t$[ebp]
  00028	50		 push	 eax
  00029	8b 4d 08	 mov	 ecx, DWORD PTR _adaptor$[ebp]
  0002c	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0002f	52		 push	 edx
  00030	8b 45 08	 mov	 eax, DWORD PTR _adaptor$[ebp]
  00033	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00036	8b 91 8c 00 00
	00		 mov	 edx, DWORD PTR [ecx+140]
  0003c	ff d2		 call	 edx
  0003e	83 c4 08	 add	 esp, 8
  00041	3b f4		 cmp	 esi, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 782  : 
; 783  : 	return t;

  00048	8b 45 fc	 mov	 eax, DWORD PTR _t$[ebp]

; 784  : }

  0004b	5e		 pop	 esi
  0004c	83 c4 04	 add	 esp, 4
  0004f	3b ec		 cmp	 ebp, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
_dbgCreateTypeToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3basetreeadaptor.c
;	COMDAT _createTypeToken
_TEXT	SEGMENT
_adaptor$ = 8						; size = 4
_tokenType$ = 12					; size = 4
_fromToken$ = 16					; size = 4
_createTypeToken PROC					; COMDAT

; 761  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 762  : 	/* Create the new token
; 763  : 	 */
; 764  : 	fromToken = adaptor->createTokenFromToken(adaptor, fromToken);

  00004	8b f4		 mov	 esi, esp
  00006	8b 45 10	 mov	 eax, DWORD PTR _fromToken$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _adaptor$[ebp]
  0000d	51		 push	 ecx
  0000e	8b 55 08	 mov	 edx, DWORD PTR _adaptor$[ebp]
  00011	8b 82 88 00 00
	00		 mov	 eax, DWORD PTR [edx+136]
  00017	ff d0		 call	 eax
  00019	83 c4 08	 add	 esp, 8
  0001c	3b f4		 cmp	 esi, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	89 45 10	 mov	 DWORD PTR _fromToken$[ebp], eax

; 765  : 
; 766  : 	/* Set the type of the new token to that supplied
; 767  : 	 */
; 768  : 	fromToken->setType(fromToken, tokenType);

  00026	8b f4		 mov	 esi, esp
  00028	8b 4d 0c	 mov	 ecx, DWORD PTR _tokenType$[ebp]
  0002b	51		 push	 ecx
  0002c	8b 55 10	 mov	 edx, DWORD PTR _fromToken$[ebp]
  0002f	52		 push	 edx
  00030	8b 45 10	 mov	 eax, DWORD PTR _fromToken$[ebp]
  00033	8b 48 58	 mov	 ecx, DWORD PTR [eax+88]
  00036	ff d1		 call	 ecx
  00038	83 c4 08	 add	 esp, 8
  0003b	3b f4		 cmp	 esi, esp
  0003d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 769  : 
; 770  : 	/* Return a new node based upon this token
; 771  : 	 */
; 772  : 	return	(pANTLR3_BASE_TREE)adaptor->create(adaptor, fromToken);

  00042	8b f4		 mov	 esi, esp
  00044	8b 55 10	 mov	 edx, DWORD PTR _fromToken$[ebp]
  00047	52		 push	 edx
  00048	8b 45 08	 mov	 eax, DWORD PTR _adaptor$[ebp]
  0004b	50		 push	 eax
  0004c	8b 4d 08	 mov	 ecx, DWORD PTR _adaptor$[ebp]
  0004f	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  00052	ff d2		 call	 edx
  00054	83 c4 08	 add	 esp, 8
  00057	3b f4		 cmp	 esi, esp
  00059	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 773  : }

  0005e	5e		 pop	 esi
  0005f	3b ec		 cmp	 ebp, esp
  00061	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
_createTypeToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3basetreeadaptor.c
;	COMDAT _dbgBecomeRootToken
_TEXT	SEGMENT
_t$ = -4						; size = 4
_adaptor$ = 8						; size = 4
_newRoot$ = 12						; size = 4
_oldRoot$ = 16						; size = 4
_dbgBecomeRootToken PROC				; COMDAT

; 746  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 747  : 	pANTLR3_BASE_TREE	t;
; 748  : 
; 749  : 	t =	(pANTLR3_BASE_TREE)adaptor->becomeRoot(adaptor, adaptor->create(adaptor, (pANTLR3_COMMON_TOKEN)newRoot), oldRoot);

  0000d	8b f4		 mov	 esi, esp
  0000f	8b 45 10	 mov	 eax, DWORD PTR _oldRoot$[ebp]
  00012	50		 push	 eax
  00013	8b fc		 mov	 edi, esp
  00015	8b 4d 0c	 mov	 ecx, DWORD PTR _newRoot$[ebp]
  00018	51		 push	 ecx
  00019	8b 55 08	 mov	 edx, DWORD PTR _adaptor$[ebp]
  0001c	52		 push	 edx
  0001d	8b 45 08	 mov	 eax, DWORD PTR _adaptor$[ebp]
  00020	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  00023	ff d1		 call	 ecx
  00025	83 c4 08	 add	 esp, 8
  00028	3b fc		 cmp	 edi, esp
  0002a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002f	50		 push	 eax
  00030	8b 55 08	 mov	 edx, DWORD PTR _adaptor$[ebp]
  00033	52		 push	 edx
  00034	8b 45 08	 mov	 eax, DWORD PTR _adaptor$[ebp]
  00037	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0003a	ff d1		 call	 ecx
  0003c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003f	3b f4		 cmp	 esi, esp
  00041	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00046	89 45 fc	 mov	 DWORD PTR _t$[ebp], eax

; 750  : 
; 751  : 	adaptor->debugger->becomeRoot(adaptor->debugger,t, oldRoot);

  00049	8b f4		 mov	 esi, esp
  0004b	8b 55 10	 mov	 edx, DWORD PTR _oldRoot$[ebp]
  0004e	52		 push	 edx
  0004f	8b 45 fc	 mov	 eax, DWORD PTR _t$[ebp]
  00052	50		 push	 eax
  00053	8b 4d 08	 mov	 ecx, DWORD PTR _adaptor$[ebp]
  00056	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00059	52		 push	 edx
  0005a	8b 45 08	 mov	 eax, DWORD PTR _adaptor$[ebp]
  0005d	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00060	8b 91 94 00 00
	00		 mov	 edx, DWORD PTR [ecx+148]
  00066	ff d2		 call	 edx
  00068	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006b	3b f4		 cmp	 esi, esp
  0006d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 752  : 
; 753  : 	return t;

  00072	8b 45 fc	 mov	 eax, DWORD PTR _t$[ebp]

; 754  : }

  00075	5f		 pop	 edi
  00076	5e		 pop	 esi
  00077	83 c4 04	 add	 esp, 4
  0007a	3b ec		 cmp	 ebp, esp
  0007c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c3		 ret	 0
_dbgBecomeRootToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3basetreeadaptor.c
;	COMDAT _becomeRootToken
_TEXT	SEGMENT
_adaptor$ = 8						; size = 4
_newRoot$ = 12						; size = 4
_oldRoot$ = 16						; size = 4
_becomeRootToken PROC					; COMDAT

; 741  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 742  : 	return	(pANTLR3_BASE_TREE)adaptor->becomeRoot(adaptor, adaptor->create(adaptor, (pANTLR3_COMMON_TOKEN)newRoot), oldRoot);

  00005	8b f4		 mov	 esi, esp
  00007	8b 45 10	 mov	 eax, DWORD PTR _oldRoot$[ebp]
  0000a	50		 push	 eax
  0000b	8b fc		 mov	 edi, esp
  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR _newRoot$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 08	 mov	 edx, DWORD PTR _adaptor$[ebp]
  00014	52		 push	 edx
  00015	8b 45 08	 mov	 eax, DWORD PTR _adaptor$[ebp]
  00018	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  0001b	ff d1		 call	 ecx
  0001d	83 c4 08	 add	 esp, 8
  00020	3b fc		 cmp	 edi, esp
  00022	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00027	50		 push	 eax
  00028	8b 55 08	 mov	 edx, DWORD PTR _adaptor$[ebp]
  0002b	52		 push	 edx
  0002c	8b 45 08	 mov	 eax, DWORD PTR _adaptor$[ebp]
  0002f	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00032	ff d1		 call	 ecx
  00034	83 c4 0c	 add	 esp, 12			; 0000000cH
  00037	3b f4		 cmp	 esi, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 743  : }

  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
_becomeRootToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3basetreeadaptor.c
;	COMDAT _dbgAddChildToken
_TEXT	SEGMENT
_tc$ = -4						; size = 4
_adaptor$ = 8						; size = 4
_t$ = 12						; size = 4
_child$ = 16						; size = 4
_dbgAddChildToken PROC					; COMDAT

; 576  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 577  : 	pANTLR3_BASE_TREE	tc;
; 578  : 
; 579  : 	if	(t != NULL && child != NULL)

  0000c	83 7d 0c 00	 cmp	 DWORD PTR _t$[ebp], 0
  00010	74 6f		 je	 SHORT $LN2@dbgAddChil
  00012	83 7d 10 00	 cmp	 DWORD PTR _child$[ebp], 0
  00016	74 69		 je	 SHORT $LN2@dbgAddChil

; 580  : 	{
; 581  : 		tc = (pANTLR3_BASE_TREE)adaptor->create(adaptor, child);

  00018	8b f4		 mov	 esi, esp
  0001a	8b 45 10	 mov	 eax, DWORD PTR _child$[ebp]
  0001d	50		 push	 eax
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR _adaptor$[ebp]
  00021	51		 push	 ecx
  00022	8b 55 08	 mov	 edx, DWORD PTR _adaptor$[ebp]
  00025	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  00028	ff d0		 call	 eax
  0002a	83 c4 08	 add	 esp, 8
  0002d	3b f4		 cmp	 esi, esp
  0002f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00034	89 45 fc	 mov	 DWORD PTR _tc$[ebp], eax

; 582  : 		adaptor->addChild(adaptor, t, tc);

  00037	8b f4		 mov	 esi, esp
  00039	8b 4d fc	 mov	 ecx, DWORD PTR _tc$[ebp]
  0003c	51		 push	 ecx
  0003d	8b 55 0c	 mov	 edx, DWORD PTR _t$[ebp]
  00040	52		 push	 edx
  00041	8b 45 08	 mov	 eax, DWORD PTR _adaptor$[ebp]
  00044	50		 push	 eax
  00045	8b 4d 08	 mov	 ecx, DWORD PTR _adaptor$[ebp]
  00048	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0004b	ff d2		 call	 edx
  0004d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00050	3b f4		 cmp	 esi, esp
  00052	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 583  : 		adaptor->debugger->addChild(adaptor->debugger, t, tc);

  00057	8b f4		 mov	 esi, esp
  00059	8b 45 fc	 mov	 eax, DWORD PTR _tc$[ebp]
  0005c	50		 push	 eax
  0005d	8b 4d 0c	 mov	 ecx, DWORD PTR _t$[ebp]
  00060	51		 push	 ecx
  00061	8b 55 08	 mov	 edx, DWORD PTR _adaptor$[ebp]
  00064	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00067	50		 push	 eax
  00068	8b 4d 08	 mov	 ecx, DWORD PTR _adaptor$[ebp]
  0006b	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0006e	8b 82 98 00 00
	00		 mov	 eax, DWORD PTR [edx+152]
  00074	ff d0		 call	 eax
  00076	83 c4 0c	 add	 esp, 12			; 0000000cH
  00079	3b f4		 cmp	 esi, esp
  0007b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00080	90		 npad	 1
$LN2@dbgAddChil:

; 584  : 	}
; 585  : }

  00081	5e		 pop	 esi
  00082	83 c4 04	 add	 esp, 4
  00085	3b ec		 cmp	 ebp, esp
  00087	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c3		 ret	 0
_dbgAddChildToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3basetreeadaptor.c
;	COMDAT _addChildToken
_TEXT	SEGMENT
_adaptor$ = 8						; size = 4
_t$ = 12						; size = 4
_child$ = 16						; size = 4
_addChildToken PROC					; COMDAT

; 568  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 569  : 	if	(t != NULL && child != NULL)

  00004	83 7d 0c 00	 cmp	 DWORD PTR _t$[ebp], 0
  00008	74 40		 je	 SHORT $LN2@addChildTo
  0000a	83 7d 10 00	 cmp	 DWORD PTR _child$[ebp], 0
  0000e	74 3a		 je	 SHORT $LN2@addChildTo

; 570  : 	{
; 571  : 		adaptor->addChild(adaptor, t, adaptor->create(adaptor, child));

  00010	8b f4		 mov	 esi, esp
  00012	8b 45 10	 mov	 eax, DWORD PTR _child$[ebp]
  00015	50		 push	 eax
  00016	8b 4d 08	 mov	 ecx, DWORD PTR _adaptor$[ebp]
  00019	51		 push	 ecx
  0001a	8b 55 08	 mov	 edx, DWORD PTR _adaptor$[ebp]
  0001d	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  00020	ff d0		 call	 eax
  00022	83 c4 08	 add	 esp, 8
  00025	3b f4		 cmp	 esi, esp
  00027	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002c	8b f4		 mov	 esi, esp
  0002e	50		 push	 eax
  0002f	8b 4d 0c	 mov	 ecx, DWORD PTR _t$[ebp]
  00032	51		 push	 ecx
  00033	8b 55 08	 mov	 edx, DWORD PTR _adaptor$[ebp]
  00036	52		 push	 edx
  00037	8b 45 08	 mov	 eax, DWORD PTR _adaptor$[ebp]
  0003a	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0003d	ff d1		 call	 ecx
  0003f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00042	3b f4		 cmp	 esi, esp
  00044	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00049	90		 npad	 1
$LN2@addChildTo:

; 572  : 	}
; 573  : }

  0004a	5e		 pop	 esi
  0004b	3b ec		 cmp	 ebp, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
_addChildToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3basetreeadaptor.c
;	COMDAT _rulePostProcessing
_TEXT	SEGMENT
_saveRoot$ = -4						; size = 4
_adaptor$ = 8						; size = 4
_root$ = 12						; size = 4
_rulePostProcessing PROC				; COMDAT

; 705  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 706  :     pANTLR3_BASE_TREE saveRoot;
; 707  : 
; 708  :     // Keep track of the root we are given. If it is a nilNode, then we
; 709  :     // can reuse it rather than orphaning it!
; 710  :     //
; 711  :     saveRoot = root;

  0000c	8b 45 0c	 mov	 eax, DWORD PTR _root$[ebp]
  0000f	89 45 fc	 mov	 DWORD PTR _saveRoot$[ebp], eax

; 712  : 
; 713  : 	if (root != NULL && root->isNilNode(root))

  00012	83 7d 0c 00	 cmp	 DWORD PTR _root$[ebp], 0
  00016	0f 84 d2 00 00
	00		 je	 $LN5@rulePostPr
  0001c	8b f4		 mov	 esi, esp
  0001e	8b 4d 0c	 mov	 ecx, DWORD PTR _root$[ebp]
  00021	51		 push	 ecx
  00022	8b 55 0c	 mov	 edx, DWORD PTR _root$[ebp]
  00025	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  00028	ff d0		 call	 eax
  0002a	83 c4 04	 add	 esp, 4
  0002d	3b f4		 cmp	 esi, esp
  0002f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00034	0f b6 c8	 movzx	 ecx, al
  00037	85 c9		 test	 ecx, ecx
  00039	0f 84 af 00 00
	00		 je	 $LN5@rulePostPr

; 714  : 	{
; 715  : 		if	(root->getChildCount(root) == 0)

  0003f	8b f4		 mov	 esi, esp
  00041	8b 55 0c	 mov	 edx, DWORD PTR _root$[ebp]
  00044	52		 push	 edx
  00045	8b 45 0c	 mov	 eax, DWORD PTR _root$[ebp]
  00048	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  0004b	ff d1		 call	 ecx
  0004d	83 c4 04	 add	 esp, 4
  00050	3b f4		 cmp	 esi, esp
  00052	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00057	85 c0		 test	 eax, eax
  00059	75 0c		 jne	 SHORT $LN3@rulePostPr

; 716  : 		{
; 717  : 			root = NULL;

  0005b	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _root$[ebp], 0

; 718  : 		}

  00062	e9 87 00 00 00	 jmp	 $LN5@rulePostPr
$LN3@rulePostPr:

; 719  : 		else if	(root->getChildCount(root) == 1)

  00067	8b f4		 mov	 esi, esp
  00069	8b 55 0c	 mov	 edx, DWORD PTR _root$[ebp]
  0006c	52		 push	 edx
  0006d	8b 45 0c	 mov	 eax, DWORD PTR _root$[ebp]
  00070	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  00073	ff d1		 call	 ecx
  00075	83 c4 04	 add	 esp, 4
  00078	3b f4		 cmp	 esi, esp
  0007a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007f	83 f8 01	 cmp	 eax, 1
  00082	75 6a		 jne	 SHORT $LN5@rulePostPr

; 720  : 		{
; 721  : 			root = (pANTLR3_BASE_TREE)root->getChild(root, 0);

  00084	8b f4		 mov	 esi, esp
  00086	6a 00		 push	 0
  00088	8b 55 0c	 mov	 edx, DWORD PTR _root$[ebp]
  0008b	52		 push	 edx
  0008c	8b 45 0c	 mov	 eax, DWORD PTR _root$[ebp]
  0008f	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00092	ff d1		 call	 ecx
  00094	83 c4 08	 add	 esp, 8
  00097	3b f4		 cmp	 esi, esp
  00099	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009e	89 45 0c	 mov	 DWORD PTR _root$[ebp], eax

; 722  : 			root->setParent(root, NULL);

  000a1	8b f4		 mov	 esi, esp
  000a3	6a 00		 push	 0
  000a5	8b 55 0c	 mov	 edx, DWORD PTR _root$[ebp]
  000a8	52		 push	 edx
  000a9	8b 45 0c	 mov	 eax, DWORD PTR _root$[ebp]
  000ac	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  000af	ff d1		 call	 ecx
  000b1	83 c4 08	 add	 esp, 8
  000b4	3b f4		 cmp	 esi, esp
  000b6	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 723  : 			root->setChildIndex(root, -1);

  000bb	8b f4		 mov	 esi, esp
  000bd	6a ff		 push	 -1
  000bf	8b 55 0c	 mov	 edx, DWORD PTR _root$[ebp]
  000c2	52		 push	 edx
  000c3	8b 45 0c	 mov	 eax, DWORD PTR _root$[ebp]
  000c6	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  000c9	ff d1		 call	 ecx
  000cb	83 c4 08	 add	 esp, 8
  000ce	3b f4		 cmp	 esi, esp
  000d0	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 724  : 
; 725  :             // The root we were given was a nil node, wiht one child, which means it has
; 726  :             // been abandoned and would be lost in the node factory. However
; 727  :             // nodes can be flagged as resuable to prevent this terrible waste
; 728  :             //
; 729  :             saveRoot->reuse(saveRoot);

  000d5	8b f4		 mov	 esi, esp
  000d7	8b 55 fc	 mov	 edx, DWORD PTR _saveRoot$[ebp]
  000da	52		 push	 edx
  000db	8b 45 fc	 mov	 eax, DWORD PTR _saveRoot$[ebp]
  000de	8b 48 78	 mov	 ecx, DWORD PTR [eax+120]
  000e1	ff d1		 call	 ecx
  000e3	83 c4 04	 add	 esp, 4
  000e6	3b f4		 cmp	 esi, esp
  000e8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ed	90		 npad	 1
$LN5@rulePostPr:

; 730  : 		}
; 731  : 	}
; 732  : 
; 733  : 	return root;

  000ee	8b 45 0c	 mov	 eax, DWORD PTR _root$[ebp]

; 734  : }

  000f1	5e		 pop	 esi
  000f2	83 c4 04	 add	 esp, 4
  000f5	3b ec		 cmp	 ebp, esp
  000f7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000fc	8b e5		 mov	 esp, ebp
  000fe	5d		 pop	 ebp
  000ff	c3		 ret	 0
_rulePostProcessing ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3basetreeadaptor.c
;	COMDAT _dbgBecomeRoot
_TEXT	SEGMENT
_t$ = -4						; size = 4
_adaptor$ = 8						; size = 4
_newRootTree$ = 12					; size = 4
_oldRootTree$ = 16					; size = 4
_dbgBecomeRoot PROC					; COMDAT

; 692  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 693  : 	pANTLR3_BASE_TREE t;
; 694  : 	
; 695  : 	t = becomeRoot(adaptor, newRootTree, oldRootTree);

  0000c	8b 45 10	 mov	 eax, DWORD PTR _oldRootTree$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR _newRootTree$[ebp]
  00013	51		 push	 ecx
  00014	8b 55 08	 mov	 edx, DWORD PTR _adaptor$[ebp]
  00017	52		 push	 edx
  00018	e8 00 00 00 00	 call	 _becomeRoot
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00020	89 45 fc	 mov	 DWORD PTR _t$[ebp], eax

; 696  : 
; 697  : 	adaptor->debugger->becomeRoot(adaptor->debugger, newRootTree, oldRootTree);

  00023	8b f4		 mov	 esi, esp
  00025	8b 45 10	 mov	 eax, DWORD PTR _oldRootTree$[ebp]
  00028	50		 push	 eax
  00029	8b 4d 0c	 mov	 ecx, DWORD PTR _newRootTree$[ebp]
  0002c	51		 push	 ecx
  0002d	8b 55 08	 mov	 edx, DWORD PTR _adaptor$[ebp]
  00030	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00033	50		 push	 eax
  00034	8b 4d 08	 mov	 ecx, DWORD PTR _adaptor$[ebp]
  00037	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0003a	8b 82 94 00 00
	00		 mov	 eax, DWORD PTR [edx+148]
  00040	ff d0		 call	 eax
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH
  00045	3b f4		 cmp	 esi, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 698  : 
; 699  : 	return t;

  0004c	8b 45 fc	 mov	 eax, DWORD PTR _t$[ebp]

; 700  : }

  0004f	5e		 pop	 esi
  00050	83 c4 04	 add	 esp, 4
  00053	3b ec		 cmp	 ebp, esp
  00055	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
_dbgBecomeRoot ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3basetreeadaptor.c
;	COMDAT _becomeRoot
_TEXT	SEGMENT
_saveRoot$ = -4						; size = 4
_adaptor$ = 8						; size = 4
_newRootTree$ = 12					; size = 4
_oldRootTree$ = 16					; size = 4
_becomeRoot PROC					; COMDAT

; 621  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 622  :     pANTLR3_BASE_TREE saveRoot;
; 623  : 
; 624  : 	/* Protect against tree rewrites if we are in some sort of error
; 625  : 	 * state, but have tried to recover. In C we can end up with a null pointer
; 626  : 	 * for a tree that was not produced.
; 627  : 	 */
; 628  : 	if	(newRootTree == NULL)

  0000c	83 7d 0c 00	 cmp	 DWORD PTR _newRootTree$[ebp], 0
  00010	75 08		 jne	 SHORT $LN2@becomeRoot

; 629  : 	{
; 630  : 		return	oldRootTree;

  00012	8b 45 10	 mov	 eax, DWORD PTR _oldRootTree$[ebp]
  00015	e9 0b 01 00 00	 jmp	 $LN1@becomeRoot
$LN2@becomeRoot:

; 631  : 	}
; 632  : 
; 633  : 	/* root is just the new tree as is if there is no
; 634  : 	 * current root tree.
; 635  : 	 */
; 636  : 	if	(oldRootTree == NULL)

  0001a	83 7d 10 00	 cmp	 DWORD PTR _oldRootTree$[ebp], 0
  0001e	75 08		 jne	 SHORT $LN3@becomeRoot

; 637  : 	{
; 638  : 		return	newRootTree;

  00020	8b 45 0c	 mov	 eax, DWORD PTR _newRootTree$[ebp]
  00023	e9 fd 00 00 00	 jmp	 $LN1@becomeRoot
$LN3@becomeRoot:

; 639  : 	}
; 640  : 
; 641  : 	/* Produce ^(nil real-node)
; 642  : 	 */
; 643  : 	if	(newRootTree->isNilNode(newRootTree))

  00028	8b f4		 mov	 esi, esp
  0002a	8b 45 0c	 mov	 eax, DWORD PTR _newRootTree$[ebp]
  0002d	50		 push	 eax
  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR _newRootTree$[ebp]
  00031	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  00034	ff d2		 call	 edx
  00036	83 c4 04	 add	 esp, 4
  00039	3b f4		 cmp	 esi, esp
  0003b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00040	0f b6 c0	 movzx	 eax, al
  00043	85 c0		 test	 eax, eax
  00045	0f 84 83 00 00
	00		 je	 $LN4@becomeRoot

; 644  : 	{
; 645  : 		if	(newRootTree->getChildCount(newRootTree) > 1)

  0004b	8b f4		 mov	 esi, esp
  0004d	8b 4d 0c	 mov	 ecx, DWORD PTR _newRootTree$[ebp]
  00050	51		 push	 ecx
  00051	8b 55 0c	 mov	 edx, DWORD PTR _newRootTree$[ebp]
  00054	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  00057	ff d0		 call	 eax
  00059	83 c4 04	 add	 esp, 4
  0005c	3b f4		 cmp	 esi, esp
  0005e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00063	83 f8 01	 cmp	 eax, 1
  00066	76 2a		 jbe	 SHORT $LN5@becomeRoot

; 646  : 		{
; 647  : 			/* TODO: Handle tree exceptions 
; 648  : 			 */
; 649  : 			ANTLR3_FPRINTF(stderr, "More than one node as root! TODO: Create tree exception handling\n");

  00068	68 00 00 00 00	 push	 OFFSET ??_C@_0EC@GKDPFFCG@More?5than?5one?5node?5as?5root?$CB?5TOD@
  0006d	8b f4		 mov	 esi, esp
  0006f	6a 02		 push	 2
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  00077	83 c4 04	 add	 esp, 4
  0007a	3b f4		 cmp	 esi, esp
  0007c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00081	50		 push	 eax
  00082	e8 00 00 00 00	 call	 _fprintf
  00087	83 c4 08	 add	 esp, 8

; 650  : 			return newRootTree;

  0008a	8b 45 0c	 mov	 eax, DWORD PTR _newRootTree$[ebp]
  0008d	e9 93 00 00 00	 jmp	 $LN1@becomeRoot
$LN5@becomeRoot:

; 651  : 		}
; 652  : 
; 653  : 		/* The new root is the first child, keep track of the original newRoot
; 654  :          * because if it was a Nil Node, then we can reuse it now.
; 655  : 		 */
; 656  :         saveRoot    = newRootTree;

  00092	8b 4d 0c	 mov	 ecx, DWORD PTR _newRootTree$[ebp]
  00095	89 4d fc	 mov	 DWORD PTR _saveRoot$[ebp], ecx

; 657  : 		newRootTree = (pANTLR3_BASE_TREE)newRootTree->getChild(newRootTree, 0);

  00098	8b f4		 mov	 esi, esp
  0009a	6a 00		 push	 0
  0009c	8b 55 0c	 mov	 edx, DWORD PTR _newRootTree$[ebp]
  0009f	52		 push	 edx
  000a0	8b 45 0c	 mov	 eax, DWORD PTR _newRootTree$[ebp]
  000a3	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  000a6	ff d1		 call	 ecx
  000a8	83 c4 08	 add	 esp, 8
  000ab	3b f4		 cmp	 esi, esp
  000ad	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b2	89 45 0c	 mov	 DWORD PTR _newRootTree$[ebp], eax

; 658  : 
; 659  :         // Reclaim the old nilNode()
; 660  :         //
; 661  :         saveRoot->reuse(saveRoot);

  000b5	8b f4		 mov	 esi, esp
  000b7	8b 55 fc	 mov	 edx, DWORD PTR _saveRoot$[ebp]
  000ba	52		 push	 edx
  000bb	8b 45 fc	 mov	 eax, DWORD PTR _saveRoot$[ebp]
  000be	8b 48 78	 mov	 ecx, DWORD PTR [eax+120]
  000c1	ff d1		 call	 ecx
  000c3	83 c4 04	 add	 esp, 4
  000c6	3b f4		 cmp	 esi, esp
  000c8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000cd	90		 npad	 1
$LN4@becomeRoot:

; 662  : 	}
; 663  : 
; 664  : 	/* Add old root into new root. addChild takes care of the case where oldRoot
; 665  : 	 * is a flat list (nill rooted tree). All children of oldroot are added to
; 666  : 	 * new root.
; 667  : 	 */
; 668  : 	newRootTree->addChild(newRootTree, oldRootTree);

  000ce	8b f4		 mov	 esi, esp
  000d0	8b 55 10	 mov	 edx, DWORD PTR _oldRootTree$[ebp]
  000d3	52		 push	 edx
  000d4	8b 45 0c	 mov	 eax, DWORD PTR _newRootTree$[ebp]
  000d7	50		 push	 eax
  000d8	8b 4d 0c	 mov	 ecx, DWORD PTR _newRootTree$[ebp]
  000db	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  000de	ff d2		 call	 edx
  000e0	83 c4 08	 add	 esp, 8
  000e3	3b f4		 cmp	 esi, esp
  000e5	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 669  : 
; 670  :     // If the oldroot tree was a nil node, then we know at this point
; 671  :     // it has become orphaned by the rewrite logic, so we tell it to do
; 672  :     // whatever it needs to do to be reused.
; 673  :     //
; 674  :     if  (oldRootTree->isNilNode(oldRootTree))

  000ea	8b f4		 mov	 esi, esp
  000ec	8b 45 10	 mov	 eax, DWORD PTR _oldRootTree$[ebp]
  000ef	50		 push	 eax
  000f0	8b 4d 10	 mov	 ecx, DWORD PTR _oldRootTree$[ebp]
  000f3	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  000f6	ff d2		 call	 edx
  000f8	83 c4 04	 add	 esp, 4
  000fb	3b f4		 cmp	 esi, esp
  000fd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00102	0f b6 c0	 movzx	 eax, al
  00105	85 c0		 test	 eax, eax
  00107	74 19		 je	 SHORT $LN6@becomeRoot

; 675  :     {
; 676  :         // We have taken an old Root Tree and appended all its children to the new
; 677  :         // root. In addition though it was a nil node, which means the generated code
; 678  :         // will not reuse it again, so we will reclaim it here. First we want to zero out
; 679  :         // any pointers it was carrying around. We are just the baseTree handler so we
; 680  :         // don't know necessarilly know how to do this for the real node, we just ask the tree itself
; 681  :         // to do it.
; 682  :         //
; 683  :         oldRootTree->reuse(oldRootTree);

  00109	8b f4		 mov	 esi, esp
  0010b	8b 4d 10	 mov	 ecx, DWORD PTR _oldRootTree$[ebp]
  0010e	51		 push	 ecx
  0010f	8b 55 10	 mov	 edx, DWORD PTR _oldRootTree$[ebp]
  00112	8b 42 78	 mov	 eax, DWORD PTR [edx+120]
  00115	ff d0		 call	 eax
  00117	83 c4 04	 add	 esp, 4
  0011a	3b f4		 cmp	 esi, esp
  0011c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00121	90		 npad	 1
$LN6@becomeRoot:

; 684  :     }
; 685  : 	/* Always returns new root structure
; 686  : 	 */
; 687  : 	return	newRootTree;

  00122	8b 45 0c	 mov	 eax, DWORD PTR _newRootTree$[ebp]
$LN1@becomeRoot:

; 688  : 
; 689  : }

  00125	5e		 pop	 esi
  00126	83 c4 04	 add	 esp, 4
  00129	3b ec		 cmp	 ebp, esp
  0012b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00130	8b e5		 mov	 esp, ebp
  00132	5d		 pop	 ebp
  00133	c3		 ret	 0
_becomeRoot ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3basetreeadaptor.c
;	COMDAT _dbgAddChild
_TEXT	SEGMENT
_adaptor$ = 8						; size = 4
_t$ = 12						; size = 4
_child$ = 16						; size = 4
_dbgAddChild PROC					; COMDAT

; 557  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 558  : 	if	(t != NULL && child != NULL)

  00004	83 7d 0c 00	 cmp	 DWORD PTR _t$[ebp], 0
  00008	74 4c		 je	 SHORT $LN2@dbgAddChil
  0000a	83 7d 10 00	 cmp	 DWORD PTR _child$[ebp], 0
  0000e	74 46		 je	 SHORT $LN2@dbgAddChil

; 559  : 	{
; 560  : 		t->addChild(t, child);

  00010	8b f4		 mov	 esi, esp
  00012	8b 45 10	 mov	 eax, DWORD PTR _child$[ebp]
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR _t$[ebp]
  00019	51		 push	 ecx
  0001a	8b 55 0c	 mov	 edx, DWORD PTR _t$[ebp]
  0001d	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00020	ff d0		 call	 eax
  00022	83 c4 08	 add	 esp, 8
  00025	3b f4		 cmp	 esi, esp
  00027	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 561  : 		adaptor->debugger->addChild(adaptor->debugger, t, child);

  0002c	8b f4		 mov	 esi, esp
  0002e	8b 4d 10	 mov	 ecx, DWORD PTR _child$[ebp]
  00031	51		 push	 ecx
  00032	8b 55 0c	 mov	 edx, DWORD PTR _t$[ebp]
  00035	52		 push	 edx
  00036	8b 45 08	 mov	 eax, DWORD PTR _adaptor$[ebp]
  00039	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0003c	51		 push	 ecx
  0003d	8b 55 08	 mov	 edx, DWORD PTR _adaptor$[ebp]
  00040	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00043	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [eax+152]
  00049	ff d1		 call	 ecx
  0004b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004e	3b f4		 cmp	 esi, esp
  00050	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00055	90		 npad	 1
$LN2@dbgAddChil:

; 562  : 	}
; 563  : }

  00056	5e		 pop	 esi
  00057	3b ec		 cmp	 ebp, esp
  00059	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
_dbgAddChild ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3basetreeadaptor.c
;	COMDAT _addChild
_TEXT	SEGMENT
_adaptor$ = 8						; size = 4
_t$ = 12						; size = 4
_child$ = 16						; size = 4
_addChild PROC						; COMDAT

; 549  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 550  : 	if	(t != NULL && child != NULL)

  00004	83 7d 0c 00	 cmp	 DWORD PTR _t$[ebp], 0
  00008	74 23		 je	 SHORT $LN2@addChild
  0000a	83 7d 10 00	 cmp	 DWORD PTR _child$[ebp], 0
  0000e	74 1d		 je	 SHORT $LN2@addChild

; 551  : 	{
; 552  : 		t->addChild(t, child);

  00010	8b f4		 mov	 esi, esp
  00012	8b 45 10	 mov	 eax, DWORD PTR _child$[ebp]
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR _t$[ebp]
  00019	51		 push	 ecx
  0001a	8b 55 0c	 mov	 edx, DWORD PTR _t$[ebp]
  0001d	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00020	ff d0		 call	 eax
  00022	83 c4 08	 add	 esp, 8
  00025	3b f4		 cmp	 esi, esp
  00027	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002c	90		 npad	 1
$LN2@addChild:

; 553  : 	}
; 554  : }

  0002d	5e		 pop	 esi
  0002e	3b ec		 cmp	 ebp, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
_addChild ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3basetreeadaptor.c
;	COMDAT _dupTreeTT
_TEXT	SEGMENT
_i$ = -20						; size = 4
_n$ = -16						; size = 4
_newSubTree$ = -12					; size = 4
_child$ = -8						; size = 4
_newTree$ = -4						; size = 4
_adaptor$ = 8						; size = 4
_t$ = 12						; size = 4
_parent$ = 16						; size = 4
_dupTreeTT PROC						; COMDAT

; 468  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0000f	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00012	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00015	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00018	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 469  : 	pANTLR3_BASE_TREE	newTree;
; 470  : 	pANTLR3_BASE_TREE	child;
; 471  : 	pANTLR3_BASE_TREE	newSubTree;
; 472  : 	ANTLR3_UINT32		n;
; 473  : 	ANTLR3_UINT32		i;
; 474  : 
; 475  : 	if	(t == NULL)

  0001b	83 7d 0c 00	 cmp	 DWORD PTR _t$[ebp], 0
  0001f	75 07		 jne	 SHORT $LN5@dupTreeTT

; 476  : 	{
; 477  : 		return NULL;

  00021	33 c0		 xor	 eax, eax
  00023	e9 15 01 00 00	 jmp	 $LN1@dupTreeTT
$LN5@dupTreeTT:

; 478  : 	}
; 479  : 	newTree = (pANTLR3_BASE_TREE)t->dupNode(t);

  00028	8b f4		 mov	 esi, esp
  0002a	8b 45 0c	 mov	 eax, DWORD PTR _t$[ebp]
  0002d	50		 push	 eax
  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR _t$[ebp]
  00031	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00034	ff d2		 call	 edx
  00036	83 c4 04	 add	 esp, 4
  00039	3b f4		 cmp	 esi, esp
  0003b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00040	89 45 fc	 mov	 DWORD PTR _newTree$[ebp], eax

; 480  : 
; 481  : 	// Ensure new subtree root has parent/child index set
; 482  : 	//
; 483  : 	adaptor->setChildIndex		(adaptor, newTree, t->getChildIndex(t));

  00043	8b f4		 mov	 esi, esp
  00045	8b 45 0c	 mov	 eax, DWORD PTR _t$[ebp]
  00048	50		 push	 eax
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR _t$[ebp]
  0004c	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  0004f	ff d2		 call	 edx
  00051	83 c4 04	 add	 esp, 4
  00054	3b f4		 cmp	 esi, esp
  00056	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005b	8b f4		 mov	 esi, esp
  0005d	50		 push	 eax
  0005e	8b 45 fc	 mov	 eax, DWORD PTR _newTree$[ebp]
  00061	50		 push	 eax
  00062	8b 4d 08	 mov	 ecx, DWORD PTR _adaptor$[ebp]
  00065	51		 push	 ecx
  00066	8b 55 08	 mov	 edx, DWORD PTR _adaptor$[ebp]
  00069	8b 42 74	 mov	 eax, DWORD PTR [edx+116]
  0006c	ff d0		 call	 eax
  0006e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00071	3b f4		 cmp	 esi, esp
  00073	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 484  : 	adaptor->setParent			(adaptor, newTree, parent);

  00078	8b f4		 mov	 esi, esp
  0007a	8b 4d 10	 mov	 ecx, DWORD PTR _parent$[ebp]
  0007d	51		 push	 ecx
  0007e	8b 55 fc	 mov	 edx, DWORD PTR _newTree$[ebp]
  00081	52		 push	 edx
  00082	8b 45 08	 mov	 eax, DWORD PTR _adaptor$[ebp]
  00085	50		 push	 eax
  00086	8b 4d 08	 mov	 ecx, DWORD PTR _adaptor$[ebp]
  00089	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  0008c	ff d2		 call	 edx
  0008e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00091	3b f4		 cmp	 esi, esp
  00093	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 485  : 	n = adaptor->getChildCount	(adaptor, t);

  00098	8b f4		 mov	 esi, esp
  0009a	8b 45 0c	 mov	 eax, DWORD PTR _t$[ebp]
  0009d	50		 push	 eax
  0009e	8b 4d 08	 mov	 ecx, DWORD PTR _adaptor$[ebp]
  000a1	51		 push	 ecx
  000a2	8b 55 08	 mov	 edx, DWORD PTR _adaptor$[ebp]
  000a5	8b 42 7c	 mov	 eax, DWORD PTR [edx+124]
  000a8	ff d0		 call	 eax
  000aa	83 c4 08	 add	 esp, 8
  000ad	3b f4		 cmp	 esi, esp
  000af	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b4	89 45 f0	 mov	 DWORD PTR _n$[ebp], eax

; 486  : 
; 487  : 	for	(i=0; i < n; i++)

  000b7	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000be	eb 09		 jmp	 SHORT $LN4@dupTreeTT
$LN2@dupTreeTT:
  000c0	8b 4d ec	 mov	 ecx, DWORD PTR _i$[ebp]
  000c3	83 c1 01	 add	 ecx, 1
  000c6	89 4d ec	 mov	 DWORD PTR _i$[ebp], ecx
$LN4@dupTreeTT:
  000c9	8b 55 ec	 mov	 edx, DWORD PTR _i$[ebp]
  000cc	3b 55 f0	 cmp	 edx, DWORD PTR _n$[ebp]
  000cf	73 69		 jae	 SHORT $LN3@dupTreeTT

; 488  : 	{
; 489  : 		child = (pANTLR3_BASE_TREE)adaptor->getChild		(adaptor, t, i);

  000d1	8b f4		 mov	 esi, esp
  000d3	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  000d6	50		 push	 eax
  000d7	8b 4d 0c	 mov	 ecx, DWORD PTR _t$[ebp]
  000da	51		 push	 ecx
  000db	8b 55 08	 mov	 edx, DWORD PTR _adaptor$[ebp]
  000de	52		 push	 edx
  000df	8b 45 08	 mov	 eax, DWORD PTR _adaptor$[ebp]
  000e2	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  000e5	ff d1		 call	 ecx
  000e7	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ea	3b f4		 cmp	 esi, esp
  000ec	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f1	89 45 f8	 mov	 DWORD PTR _child$[ebp], eax

; 490  : 		newSubTree = (pANTLR3_BASE_TREE)adaptor->dupTreeTT	(adaptor, child, t);

  000f4	8b f4		 mov	 esi, esp
  000f6	8b 55 0c	 mov	 edx, DWORD PTR _t$[ebp]
  000f9	52		 push	 edx
  000fa	8b 45 f8	 mov	 eax, DWORD PTR _child$[ebp]
  000fd	50		 push	 eax
  000fe	8b 4d 08	 mov	 ecx, DWORD PTR _adaptor$[ebp]
  00101	51		 push	 ecx
  00102	8b 55 08	 mov	 edx, DWORD PTR _adaptor$[ebp]
  00105	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00108	ff d0		 call	 eax
  0010a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0010d	3b f4		 cmp	 esi, esp
  0010f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00114	89 45 f4	 mov	 DWORD PTR _newSubTree$[ebp], eax

; 491  : 		adaptor->addChild				(adaptor, newTree, newSubTree);

  00117	8b f4		 mov	 esi, esp
  00119	8b 4d f4	 mov	 ecx, DWORD PTR _newSubTree$[ebp]
  0011c	51		 push	 ecx
  0011d	8b 55 fc	 mov	 edx, DWORD PTR _newTree$[ebp]
  00120	52		 push	 edx
  00121	8b 45 08	 mov	 eax, DWORD PTR _adaptor$[ebp]
  00124	50		 push	 eax
  00125	8b 4d 08	 mov	 ecx, DWORD PTR _adaptor$[ebp]
  00128	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0012b	ff d2		 call	 edx
  0012d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00130	3b f4		 cmp	 esi, esp
  00132	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00137	90		 npad	 1

; 492  : 	}

  00138	eb 86		 jmp	 SHORT $LN2@dupTreeTT
$LN3@dupTreeTT:

; 493  : 	return	newTree;

  0013a	8b 45 fc	 mov	 eax, DWORD PTR _newTree$[ebp]
$LN1@dupTreeTT:

; 494  : }

  0013d	5e		 pop	 esi
  0013e	83 c4 14	 add	 esp, 20			; 00000014H
  00141	3b ec		 cmp	 ebp, esp
  00143	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00148	8b e5		 mov	 esp, ebp
  0014a	5d		 pop	 ebp
  0014b	c3		 ret	 0
_dupTreeTT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3basetreeadaptor.c
;	COMDAT _dbgDupTree
_TEXT	SEGMENT
_t$ = -4						; size = 4
_adaptor$ = 8						; size = 4
_tree$ = 12						; size = 4
_dbgDupTree PROC					; COMDAT

; 521  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 522  : 	pANTLR3_BASE_TREE t;
; 523  : 
; 524  : 	// Call the normal dup tree mechanism first
; 525  : 	//
; 526  : 	t = (pANTLR3_BASE_TREE)adaptor->dupTreeTT(adaptor, tree, NULL);

  0000c	8b f4		 mov	 esi, esp
  0000e	6a 00		 push	 0
  00010	8b 45 0c	 mov	 eax, DWORD PTR _tree$[ebp]
  00013	50		 push	 eax
  00014	8b 4d 08	 mov	 ecx, DWORD PTR _adaptor$[ebp]
  00017	51		 push	 ecx
  00018	8b 55 08	 mov	 edx, DWORD PTR _adaptor$[ebp]
  0001b	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0001e	ff d0		 call	 eax
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	3b f4		 cmp	 esi, esp
  00025	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002a	89 45 fc	 mov	 DWORD PTR _t$[ebp], eax

; 527  : 
; 528  : 	// In order to tell the debugger what we have just done, we now
; 529  : 	// simulate the tree building mechanism. THis will fire
; 530  : 	// lots of debugging events to the client and look like we
; 531  : 	// duped the tree..
; 532  : 	//
; 533  : 	simulateTreeConstruction(adaptor, t);

  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _t$[ebp]
  00030	51		 push	 ecx
  00031	8b 55 08	 mov	 edx, DWORD PTR _adaptor$[ebp]
  00034	52		 push	 edx
  00035	e8 00 00 00 00	 call	 _simulateTreeConstruction
  0003a	83 c4 08	 add	 esp, 8

; 534  : 
; 535  : 	return t;

  0003d	8b 45 fc	 mov	 eax, DWORD PTR _t$[ebp]

; 536  : }

  00040	5e		 pop	 esi
  00041	83 c4 04	 add	 esp, 4
  00044	3b ec		 cmp	 ebp, esp
  00046	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
_dbgDupTree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3basetreeadaptor.c
;	COMDAT _dupTree
_TEXT	SEGMENT
_adaptor$ = 8						; size = 4
_t$ = 12						; size = 4
_dupTree PROC						; COMDAT

; 462  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 463  : 	return	(pANTLR3_BASE_TREE)adaptor->dupTreeTT(adaptor, t, NULL);

  00004	8b f4		 mov	 esi, esp
  00006	6a 00		 push	 0
  00008	8b 45 0c	 mov	 eax, DWORD PTR _t$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _adaptor$[ebp]
  0000f	51		 push	 ecx
  00010	8b 55 08	 mov	 edx, DWORD PTR _adaptor$[ebp]
  00013	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00016	ff d0		 call	 eax
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001b	3b f4		 cmp	 esi, esp
  0001d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 464  : }

  00022	5e		 pop	 esi
  00023	3b ec		 cmp	 ebp, esp
  00025	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
_dupTree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3basetreeadaptor.c
;	COMDAT _dbgNil
_TEXT	SEGMENT
_t$ = -4						; size = 4
_adaptor$ = 8						; size = 4
_dbgNil	PROC						; COMDAT

; 448  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 449  : 	pANTLR3_BASE_TREE t;
; 450  : 
; 451  : 	t = (pANTLR3_BASE_TREE)adaptor->create				(adaptor, NULL);

  0000c	8b f4		 mov	 esi, esp
  0000e	6a 00		 push	 0
  00010	8b 45 08	 mov	 eax, DWORD PTR _adaptor$[ebp]
  00013	50		 push	 eax
  00014	8b 4d 08	 mov	 ecx, DWORD PTR _adaptor$[ebp]
  00017	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  0001a	ff d2		 call	 edx
  0001c	83 c4 08	 add	 esp, 8
  0001f	3b f4		 cmp	 esi, esp
  00021	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00026	89 45 fc	 mov	 DWORD PTR _t$[ebp], eax

; 452  : 	adaptor->debugger->createNode	(adaptor->debugger, t);

  00029	8b f4		 mov	 esi, esp
  0002b	8b 45 fc	 mov	 eax, DWORD PTR _t$[ebp]
  0002e	50		 push	 eax
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR _adaptor$[ebp]
  00032	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00035	52		 push	 edx
  00036	8b 45 08	 mov	 eax, DWORD PTR _adaptor$[ebp]
  00039	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0003c	8b 91 8c 00 00
	00		 mov	 edx, DWORD PTR [ecx+140]
  00042	ff d2		 call	 edx
  00044	83 c4 08	 add	 esp, 8
  00047	3b f4		 cmp	 esi, esp
  00049	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 453  : 
; 454  : 	return	t;

  0004e	8b 45 fc	 mov	 eax, DWORD PTR _t$[ebp]

; 455  : }

  00051	5e		 pop	 esi
  00052	83 c4 04	 add	 esp, 4
  00055	3b ec		 cmp	 ebp, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
_dbgNil	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3basetreeadaptor.c
;	COMDAT _nilNode
_TEXT	SEGMENT
_adaptor$ = 8						; size = 4
_nilNode PROC						; COMDAT

; 442  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 443  : 	return	(pANTLR3_BASE_TREE)adaptor->create(adaptor, NULL);

  00004	8b f4		 mov	 esi, esp
  00006	6a 00		 push	 0
  00008	8b 45 08	 mov	 eax, DWORD PTR _adaptor$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _adaptor$[ebp]
  0000f	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  00012	ff d2		 call	 edx
  00014	83 c4 08	 add	 esp, 8
  00017	3b f4		 cmp	 esi, esp
  00019	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 444  : }

  0001e	5e		 pop	 esi
  0001f	3b ec		 cmp	 ebp, esp
  00021	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
_nilNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3basetreeadaptor.c
;	COMDAT _antlr3BaseTreeAdaptorInit
_TEXT	SEGMENT
_adaptor$ = 8						; size = 4
_debugger$ = 12						; size = 4
_antlr3BaseTreeAdaptorInit PROC				; COMDAT

; 81   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 82   : 	// Initialize the interface
; 83   : 	//
; 84   : 	if	(debugger == NULL)

  00003	83 7d 0c 00	 cmp	 DWORD PTR _debugger$[ebp], 0
  00007	75 5c		 jne	 SHORT $LN2@antlr3Base

; 85   : 	{
; 86   : 		adaptor->nilNode				= (void * (*)(pANTLR3_BASE_TREE_ADAPTOR)) 								

  00009	8b 45 08	 mov	 eax, DWORD PTR _adaptor$[ebp]
  0000c	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], OFFSET _nilNode

; 87   : 																				nilNode;
; 88   : 		adaptor->addChild				= (void   (*)(pANTLR3_BASE_TREE_ADAPTOR, void *, void *))								

  00013	8b 4d 08	 mov	 ecx, DWORD PTR _adaptor$[ebp]
  00016	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], OFFSET _addChild

; 89   : 																				addChild;
; 90   : 		adaptor->becomeRoot				= (void * (*)(pANTLR3_BASE_TREE_ADAPTOR, void *, void *))				

  0001d	8b 55 08	 mov	 edx, DWORD PTR _adaptor$[ebp]
  00020	c7 42 34 00 00
	00 00		 mov	 DWORD PTR [edx+52], OFFSET _becomeRoot

; 91   : 																				becomeRoot;
; 92   : 		adaptor->addChildToken			= (void   (*)(pANTLR3_BASE_TREE_ADAPTOR, void *, pANTLR3_COMMON_TOKEN))	

  00027	8b 45 08	 mov	 eax, DWORD PTR _adaptor$[ebp]
  0002a	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], OFFSET _addChildToken

; 93   : 																				addChildToken;
; 94   : 		adaptor->becomeRootToken		= (void * (*)(pANTLR3_BASE_TREE_ADAPTOR, void *, void *))

  00031	8b 4d 08	 mov	 ecx, DWORD PTR _adaptor$[ebp]
  00034	c7 41 3c 00 00
	00 00		 mov	 DWORD PTR [ecx+60], OFFSET _becomeRootToken

; 95   : 																				becomeRootToken;
; 96   : 		adaptor->createTypeToken		= (void * (*)(pANTLR3_BASE_TREE_ADAPTOR, ANTLR3_UINT32, pANTLR3_COMMON_TOKEN))

  0003b	8b 55 08	 mov	 edx, DWORD PTR _adaptor$[ebp]
  0003e	c7 42 44 00 00
	00 00		 mov	 DWORD PTR [edx+68], OFFSET _createTypeToken

; 97   : 																				createTypeToken;
; 98   : 		adaptor->createTypeTokenText	= (void * (*)(pANTLR3_BASE_TREE_ADAPTOR, ANTLR3_UINT32, pANTLR3_COMMON_TOKEN, pANTLR3_UINT8))

  00045	8b 45 08	 mov	 eax, DWORD PTR _adaptor$[ebp]
  00048	c7 40 48 00 00
	00 00		 mov	 DWORD PTR [eax+72], OFFSET _createTypeTokenText

; 99   : 																				createTypeTokenText;
; 100  : 		adaptor->createTypeText			= (void * (*)(pANTLR3_BASE_TREE_ADAPTOR, ANTLR3_UINT32, pANTLR3_UINT8))

  0004f	8b 4d 08	 mov	 ecx, DWORD PTR _adaptor$[ebp]
  00052	c7 41 4c 00 00
	00 00		 mov	 DWORD PTR [ecx+76], OFFSET _createTypeText

; 101  : 																				createTypeText;
; 102  : 		adaptor->dupTree				= (void * (*)(pANTLR3_BASE_TREE_ADAPTOR, void *))		 				

  00059	8b 55 08	 mov	 edx, DWORD PTR _adaptor$[ebp]
  0005c	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], OFFSET _dupTree

; 103  : 																				dupTree;
; 104  : 	}

  00063	eb 63		 jmp	 SHORT $LN3@antlr3Base
$LN2@antlr3Base:

; 105  : 	else
; 106  : 	{
; 107  : 		adaptor->nilNode				= (void * (*)(pANTLR3_BASE_TREE_ADAPTOR))

  00065	8b 45 08	 mov	 eax, DWORD PTR _adaptor$[ebp]
  00068	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], OFFSET _dbgNil

; 108  :                                                                                 dbgNil;
; 109  : 		adaptor->addChild				= (void   (*)(pANTLR3_BASE_TREE_ADAPTOR, void *, void *))

  0006f	8b 4d 08	 mov	 ecx, DWORD PTR _adaptor$[ebp]
  00072	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], OFFSET _dbgAddChild

; 110  :                                                                                 dbgAddChild;
; 111  : 		adaptor->becomeRoot				= (void * (*)(pANTLR3_BASE_TREE_ADAPTOR, void *, void *))

  00079	8b 55 08	 mov	 edx, DWORD PTR _adaptor$[ebp]
  0007c	c7 42 34 00 00
	00 00		 mov	 DWORD PTR [edx+52], OFFSET _dbgBecomeRoot

; 112  : 																				dbgBecomeRoot;
; 113  : 		adaptor->addChildToken			= (void   (*)(pANTLR3_BASE_TREE_ADAPTOR, void *, pANTLR3_COMMON_TOKEN))

  00083	8b 45 08	 mov	 eax, DWORD PTR _adaptor$[ebp]
  00086	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], OFFSET _dbgAddChildToken

; 114  :                                                                                 dbgAddChildToken;
; 115  : 		adaptor->becomeRootToken		= (void * (*)(pANTLR3_BASE_TREE_ADAPTOR, void *, void *))

  0008d	8b 4d 08	 mov	 ecx, DWORD PTR _adaptor$[ebp]
  00090	c7 41 3c 00 00
	00 00		 mov	 DWORD PTR [ecx+60], OFFSET _dbgBecomeRootToken

; 116  :                                                                                 dbgBecomeRootToken;
; 117  : 		adaptor->createTypeToken		= (void * (*)(pANTLR3_BASE_TREE_ADAPTOR, ANTLR3_UINT32, pANTLR3_COMMON_TOKEN))

  00097	8b 55 08	 mov	 edx, DWORD PTR _adaptor$[ebp]
  0009a	c7 42 44 00 00
	00 00		 mov	 DWORD PTR [edx+68], OFFSET _dbgCreateTypeToken

; 118  :                                                                                 dbgCreateTypeToken;
; 119  : 		adaptor->createTypeTokenText	= (void * (*)(pANTLR3_BASE_TREE_ADAPTOR, ANTLR3_UINT32, pANTLR3_COMMON_TOKEN, pANTLR3_UINT8))

  000a1	8b 45 08	 mov	 eax, DWORD PTR _adaptor$[ebp]
  000a4	c7 40 48 00 00
	00 00		 mov	 DWORD PTR [eax+72], OFFSET _dbgCreateTypeTokenText

; 120  :                                                                                 dbgCreateTypeTokenText;
; 121  : 		adaptor->createTypeText			= (void * (*)(pANTLR3_BASE_TREE_ADAPTOR, ANTLR3_UINT32, pANTLR3_UINT8))

  000ab	8b 4d 08	 mov	 ecx, DWORD PTR _adaptor$[ebp]
  000ae	c7 41 4c 00 00
	00 00		 mov	 DWORD PTR [ecx+76], OFFSET _dbgCreateTypeText

; 122  :                                                                                 dbgCreateTypeText;
; 123  : 		adaptor->dupTree				= (void * (*)(pANTLR3_BASE_TREE_ADAPTOR, void *))

  000b5	8b 55 08	 mov	 edx, DWORD PTR _adaptor$[ebp]
  000b8	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], OFFSET _dbgDupTree

; 124  :                                                                                 dbgDupTree;
; 125  : 		debugger->adaptor				= adaptor;

  000bf	8b 45 0c	 mov	 eax, DWORD PTR _debugger$[ebp]
  000c2	8b 4d 08	 mov	 ecx, DWORD PTR _adaptor$[ebp]
  000c5	89 48 18	 mov	 DWORD PTR [eax+24], ecx
$LN3@antlr3Base:

; 126  : 	}
; 127  : 
; 128  : 	adaptor->dupTreeTT				=  (void * (*)(pANTLR3_BASE_TREE_ADAPTOR, void *, void *))

  000c8	8b 55 08	 mov	 edx, DWORD PTR _adaptor$[ebp]
  000cb	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET _dupTreeTT

; 129  :                                                                                 dupTreeTT;
; 130  : 	adaptor->rulePostProcessing		=  (void * (*)(pANTLR3_BASE_TREE_ADAPTOR, void *))

  000d2	8b 45 08	 mov	 eax, DWORD PTR _adaptor$[ebp]
  000d5	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [eax+56], OFFSET _rulePostProcessing

; 131  :                                                                                 rulePostProcessing;
; 132  : 	adaptor->getType				=  (ANTLR3_UINT32 (*)(pANTLR3_BASE_TREE_ADAPTOR, void *))

  000dc	8b 4d 08	 mov	 ecx, DWORD PTR _adaptor$[ebp]
  000df	c7 41 54 00 00
	00 00		 mov	 DWORD PTR [ecx+84], OFFSET _getType

; 133  :                                                                                 getType;
; 134  : 	adaptor->setType				=  (void   (*)(pANTLR3_BASE_TREE_ADAPTOR, void *, ANTLR3_UINT32))

  000e6	8b 55 08	 mov	 edx, DWORD PTR _adaptor$[ebp]
  000e9	c7 42 58 00 00
	00 00		 mov	 DWORD PTR [edx+88], OFFSET _setType

; 135  : 																				setType;
; 136  : 	adaptor->getText				=  (pANTLR3_STRING (*) (pANTLR3_BASE_TREE_ADAPTOR, void *))

  000f0	8b 45 08	 mov	 eax, DWORD PTR _adaptor$[ebp]
  000f3	c7 40 5c 00 00
	00 00		 mov	 DWORD PTR [eax+92], OFFSET _getText

; 137  :                                                                                 getText;
; 138  : 	adaptor->setText8				=  (void   (*)(pANTLR3_BASE_TREE_ADAPTOR, pANTLR3_UINT8))

  000fa	8b 4d 08	 mov	 ecx, DWORD PTR _adaptor$[ebp]
  000fd	c7 41 64 00 00
	00 00		 mov	 DWORD PTR [ecx+100], OFFSET _setText8

; 139  : 																				setText8;
; 140  : 	adaptor->setText				=  (void   (*)(pANTLR3_BASE_TREE_ADAPTOR, pANTLR3_STRING))

  00104	8b 55 08	 mov	 edx, DWORD PTR _adaptor$[ebp]
  00107	c7 42 60 00 00
	00 00		 mov	 DWORD PTR [edx+96], OFFSET _setText

; 141  :                                                                                 setText;
; 142  : 	adaptor->getChild				=  (void * (*)(pANTLR3_BASE_TREE_ADAPTOR, void *, ANTLR3_UINT32))

  0010e	8b 45 08	 mov	 eax, DWORD PTR _adaptor$[ebp]
  00111	c7 40 68 00 00
	00 00		 mov	 DWORD PTR [eax+104], OFFSET _getChild

; 143  :                                                                                 getChild;
; 144  : 	adaptor->getChildCount			=  (ANTLR3_UINT32 (*)(pANTLR3_BASE_TREE_ADAPTOR, void *))

  00118	8b 4d 08	 mov	 ecx, DWORD PTR _adaptor$[ebp]
  0011b	c7 41 7c 00 00
	00 00		 mov	 DWORD PTR [ecx+124], OFFSET _getChildCount

; 145  :                                                                                 getChildCount;
; 146  : 	adaptor->getUniqueID			=  (ANTLR3_UINT32 (*)(pANTLR3_BASE_TREE_ADAPTOR, void *))

  00122	8b 55 08	 mov	 edx, DWORD PTR _adaptor$[ebp]
  00125	c7 82 80 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+128], OFFSET _getUniqueID

; 147  :                                                                                 getUniqueID;
; 148  : 	adaptor->isNilNode				=  (ANTLR3_BOOLEAN (*)(pANTLR3_BASE_TREE_ADAPTOR, void *))

  0012f	8b 45 08	 mov	 eax, DWORD PTR _adaptor$[ebp]
  00132	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], OFFSET _isNilNode

; 149  :                                                                                 isNilNode;
; 150  : 
; 151  : 	adaptor->makeDot				=  (pANTLR3_STRING  (*)(pANTLR3_BASE_TREE_ADAPTOR, void *))

  00139	8b 4d 08	 mov	 ecx, DWORD PTR _adaptor$[ebp]
  0013c	c7 81 a0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+160], OFFSET _makeDot

; 152  : 																				makeDot;
; 153  : 	
; 154  : 	/* Remaining functions filled in by the caller.
; 155  : 	 */
; 156  : 	return;
; 157  : }

  00146	5d		 pop	 ebp
  00147	c3		 ret	 0
_antlr3BaseTreeAdaptorInit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1771 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 1772 :         int _Result;
; 1773 :         va_list _ArgList;
; 1774 :         __crt_va_start(_ArgList, _Format);

  00014	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00017	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1775 : 
; 1776 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  0001a	8b 4d f8	 mov	 ecx, DWORD PTR __ArgList$[ebp]
  0001d	51		 push	 ecx
  0001e	6a 00		 push	 0
  00020	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00023	52		 push	 edx
  00024	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 __vsprintf_l
  0002d	83 c4 10	 add	 esp, 16			; 00000010H
  00030	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1777 : 
; 1778 :         __crt_va_end(_ArgList);

  00033	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 1779 :         return _Result;

  0003a	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 1780 :     }

  0003d	83 c4 08	 add	 esp, 8
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1458 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1459 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00003	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  0000e	52		 push	 edx
  0000f	6a ff		 push	 -1
  00011	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 __vsnprintf_l
  0001a	83 c4 14	 add	 esp, 20			; 00000014H

; 1460 :     }

  0001d	3b ec		 cmp	 ebp, esp
  0001f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1391 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 1392 :         int const _Result = __stdio_common_vsprintf(

  00015	8b f4		 mov	 esi, esp
  00017	8b 45 18	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0001a	50		 push	 eax
  0001b	8b 4d 14	 mov	 ecx, DWORD PTR __Locale$[ebp]
  0001e	51		 push	 ecx
  0001f	8b 55 10	 mov	 edx, DWORD PTR __Format$[ebp]
  00022	52		 push	 edx
  00023	8b 45 0c	 mov	 eax, DWORD PTR __BufferCount$[ebp]
  00026	50		 push	 eax
  00027	8b 4d 08	 mov	 ecx, DWORD PTR __Buffer$[ebp]
  0002a	51		 push	 ecx
  0002b	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00030	8b 10		 mov	 edx, DWORD PTR [eax]
  00032	83 ca 01	 or	 edx, 1
  00035	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00038	50		 push	 eax
  00039	52		 push	 edx
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsprintf
  00040	83 c4 1c	 add	 esp, 28			; 0000001cH
  00043	3b f4		 cmp	 esi, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

  0004d	83 7d fc 00	 cmp	 DWORD PTR __Result$[ebp], 0
  00051	7d 09		 jge	 SHORT $LN3@vsnprintf_
  00053	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR tv74[ebp], -1
  0005a	eb 06		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  0005c	8b 4d fc	 mov	 ecx, DWORD PTR __Result$[ebp]
  0005f	89 4d f8	 mov	 DWORD PTR tv74[ebp], ecx
$LN4@vsnprintf_:
  00062	8b 45 f8	 mov	 eax, DWORD PTR tv74[ebp]

; 1397 :     }

  00065	5e		 pop	 esi
  00066	83 c4 08	 add	 esp, 8
  00069	3b ec		 cmp	 ebp, esp
  0006b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 837  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 838  :         int _Result;
; 839  :         va_list _ArgList;
; 840  :         __crt_va_start(_ArgList, _Format);

  00014	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00017	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 841  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

  0001a	8b 4d f8	 mov	 ecx, DWORD PTR __ArgList$[ebp]
  0001d	51		 push	 ecx
  0001e	6a 00		 push	 0
  00020	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00023	52		 push	 edx
  00024	8b 45 08	 mov	 eax, DWORD PTR __Stream$[ebp]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 __vfprintf_l
  0002d	83 c4 10	 add	 esp, 16			; 00000010H
  00030	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 842  :         __crt_va_end(_ArgList);

  00033	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 843  :         return _Result;

  0003a	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 844  :     }

  0003d	83 c4 08	 add	 esp, 8
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 644  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00004	8b f4		 mov	 esi, esp
  00006	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  0000d	51		 push	 ecx
  0000e	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00011	52		 push	 edx
  00012	8b 45 08	 mov	 eax, DWORD PTR __Stream$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  0001b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001e	51		 push	 ecx
  0001f	8b 10		 mov	 edx, DWORD PTR [eax]
  00021	52		 push	 edx
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vfprintf
  00028	83 c4 18	 add	 esp, 24			; 00000018H
  0002b	3b f4		 cmp	 esi, esp
  0002d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 646  :     }

  00032	5e		 pop	 esi
  00033	3b ec		 cmp	 ebp, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 90   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00003	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
