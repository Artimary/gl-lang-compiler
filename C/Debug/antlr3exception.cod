; Listing generated by Microsoft (R) Optimizing Compiler Version 19.42.34436.0 

	TITLE	C:\SPO_labs\C\Debug\antlr3exception.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	___local_stdio_printf_options
PUBLIC	__vfprintf_l
PUBLIC	_fprintf
PUBLIC	_antlr3ExceptionNew
PUBLIC	??_C@_0CE@KAPLBCLA@ANTLR3_EXCEPTION?5number?5?$CFd?5?$CI?$CF08@ ; `string'
PUBLIC	??_C@_0BG@GCGJJLGN@ANTLR3_EXCEPTION?3?5?$CFs?6@	; `string'
EXTRN	__imp__calloc:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0BG@GCGJJLGN@ANTLR3_EXCEPTION?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BG@GCGJJLGN@ANTLR3_EXCEPTION?3?5?$CFs?6@ DB 'ANTLR3_EXCEPTION: %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@KAPLBCLA@ANTLR3_EXCEPTION?5number?5?$CFd?5?$CI?$CF08@
CONST	SEGMENT
??_C@_0CE@KAPLBCLA@ANTLR3_EXCEPTION?5number?5?$CFd?5?$CI?$CF08@ DB 'ANTLR'
	DB	'3_EXCEPTION number %d (%08X).', 0aH, 00H	; `string'
CONST	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3exception.c
;	COMDAT _antlr3ExceptionFree
_TEXT	SEGMENT
_next$ = -4						; size = 4
_ex$ = 8						; size = 4
_antlr3ExceptionFree PROC				; COMDAT

; 155  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
$LN2@antlr3Exce:

; 156  :     pANTLR3_EXCEPTION next;
; 157  : 
; 158  :     /* Ensure valid pointer
; 159  :      */
; 160  :     while   (ex != NULL)

  0000c	83 7d 08 00	 cmp	 DWORD PTR _ex$[ebp], 0
  00010	74 72		 je	 SHORT $LN3@antlr3Exce

; 161  :     {
; 162  : 	/* Pick up anythign following now, before we free the
; 163  : 	 * current memory block.
; 164  : 	 */
; 165  : 	next	= ex->nextException;

  00012	8b 45 08	 mov	 eax, DWORD PTR _ex$[ebp]
  00015	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  00018	89 4d fc	 mov	 DWORD PTR _next$[ebp], ecx

; 166  : 
; 167  : 	/* Free the message pointer if advised to
; 168  : 	 */
; 169  : 	if  (ex->freeMessage == ANTLR3_TRUE)

  0001b	8b 55 08	 mov	 edx, DWORD PTR _ex$[ebp]
  0001e	0f b6 42 10	 movzx	 eax, BYTE PTR [edx+16]
  00022	83 f8 01	 cmp	 eax, 1
  00025	75 1a		 jne	 SHORT $LN4@antlr3Exce

; 170  : 	{
; 171  : 	    ANTLR3_FREE(ex->message);

  00027	8b f4		 mov	 esi, esp
  00029	8b 4d 08	 mov	 ecx, DWORD PTR _ex$[ebp]
  0002c	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0002f	52		 push	 edx
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00036	83 c4 04	 add	 esp, 4
  00039	3b f4		 cmp	 esi, esp
  0003b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00040	90		 npad	 1
$LN4@antlr3Exce:

; 172  : 	}
; 173  : 
; 174  : 	/* Call the programmer's custom free routine if advised to
; 175  : 	 */
; 176  : 	if  (ex->freeCustom != NULL)

  00041	8b 45 08	 mov	 eax, DWORD PTR _ex$[ebp]
  00044	83 78 4c 00	 cmp	 DWORD PTR [eax+76], 0
  00048	74 1c		 je	 SHORT $LN5@antlr3Exce

; 177  : 	{
; 178  : 	    ex->freeCustom(ex->custom);

  0004a	8b f4		 mov	 esi, esp
  0004c	8b 4d 08	 mov	 ecx, DWORD PTR _ex$[ebp]
  0004f	8b 51 48	 mov	 edx, DWORD PTR [ecx+72]
  00052	52		 push	 edx
  00053	8b 45 08	 mov	 eax, DWORD PTR _ex$[ebp]
  00056	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  00059	ff d1		 call	 ecx
  0005b	83 c4 04	 add	 esp, 4
  0005e	3b f4		 cmp	 esi, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	90		 npad	 1
$LN5@antlr3Exce:

; 179  : 	}
; 180  : 
; 181  : 	/* Free the actual structure itself
; 182  : 	 */
; 183  : 	ANTLR3_FREE(ex);

  00066	8b f4		 mov	 esi, esp
  00068	8b 55 08	 mov	 edx, DWORD PTR _ex$[ebp]
  0006b	52		 push	 edx
  0006c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00072	83 c4 04	 add	 esp, 4
  00075	3b f4		 cmp	 esi, esp
  00077	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 184  : 
; 185  : 	ex = next;

  0007c	8b 45 fc	 mov	 eax, DWORD PTR _next$[ebp]
  0007f	89 45 08	 mov	 DWORD PTR _ex$[ebp], eax

; 186  :     }

  00082	eb 88		 jmp	 SHORT $LN2@antlr3Exce
$LN3@antlr3Exce:

; 187  : 
; 188  :     return;
; 189  : }

  00084	5e		 pop	 esi
  00085	83 c4 04	 add	 esp, 4
  00088	3b ec		 cmp	 ebp, esp
  0008a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c3		 ret	 0
_antlr3ExceptionFree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3exception.c
;	COMDAT _antlr3ExceptionPrint
_TEXT	SEGMENT
_ex$ = 8						; size = 4
_antlr3ExceptionPrint PROC				; COMDAT

; 119  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
$LN2@antlr3Exce:

; 120  :     /* Ensure valid pointer
; 121  :      */
; 122  :     while   (ex != NULL)

  00004	83 7d 08 00	 cmp	 DWORD PTR _ex$[ebp], 0
  00008	74 6d		 je	 SHORT $LN3@antlr3Exce

; 123  :     {
; 124  : 	/* Number if no message, else the message
; 125  : 	 */
; 126  : 	if  (ex->message == NULL)

  0000a	8b 45 08	 mov	 eax, DWORD PTR _ex$[ebp]
  0000d	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00011	75 30		 jne	 SHORT $LN4@antlr3Exce

; 127  : 	{
; 128  : 	    ANTLR3_FPRINTF(stderr, "ANTLR3_EXCEPTION number %d (%08X).\n", ex->type, ex->type);

  00013	8b 4d 08	 mov	 ecx, DWORD PTR _ex$[ebp]
  00016	8b 11		 mov	 edx, DWORD PTR [ecx]
  00018	52		 push	 edx
  00019	8b 45 08	 mov	 eax, DWORD PTR _ex$[ebp]
  0001c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001e	51		 push	 ecx
  0001f	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@KAPLBCLA@ANTLR3_EXCEPTION?5number?5?$CFd?5?$CI?$CF08@
  00024	8b f4		 mov	 esi, esp
  00026	6a 02		 push	 2
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  0002e	83 c4 04	 add	 esp, 4
  00031	3b f4		 cmp	 esi, esp
  00033	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 _fprintf
  0003e	83 c4 10	 add	 esp, 16			; 00000010H

; 129  : 	}

  00041	eb 29		 jmp	 SHORT $LN5@antlr3Exce
$LN4@antlr3Exce:

; 130  : 	else
; 131  : 	{
; 132  : 	    ANTLR3_FPRINTF(stderr, "ANTLR3_EXCEPTION: %s\n", (char *)(ex->message));

  00043	8b 55 08	 mov	 edx, DWORD PTR _ex$[ebp]
  00046	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00049	50		 push	 eax
  0004a	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@GCGJJLGN@ANTLR3_EXCEPTION?3?5?$CFs?6@
  0004f	8b f4		 mov	 esi, esp
  00051	6a 02		 push	 2
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  00059	83 c4 04	 add	 esp, 4
  0005c	3b f4		 cmp	 esi, esp
  0005e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00063	50		 push	 eax
  00064	e8 00 00 00 00	 call	 _fprintf
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@antlr3Exce:

; 133  : 	}
; 134  : 
; 135  : 	/* Move to next in the chain (if any)
; 136  : 	 */
; 137  : 	ex = ex->nextException;

  0006c	8b 4d 08	 mov	 ecx, DWORD PTR _ex$[ebp]
  0006f	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  00072	89 55 08	 mov	 DWORD PTR _ex$[ebp], edx

; 138  :     }

  00075	eb 8d		 jmp	 SHORT $LN2@antlr3Exce
$LN3@antlr3Exce:

; 139  : 
; 140  :     return;
; 141  : }

  00077	5e		 pop	 esi
  00078	3b ec		 cmp	 ebp, esp
  0007a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007f	5d		 pop	 ebp
  00080	c3		 ret	 0
_antlr3ExceptionPrint ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3exception.c
;	COMDAT _antlr3ExceptionNew
_TEXT	SEGMENT
_ex$ = -4						; size = 4
_exception$ = 8						; size = 4
_name$ = 12						; size = 4
_message$ = 16						; size = 4
_freeMessage$ = 20					; size = 1
_antlr3ExceptionNew PROC				; COMDAT

; 73   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 74   : 	pANTLR3_EXCEPTION	ex;
; 75   : 
; 76   : 	/* Allocate memory for the structure
; 77   : 	*/
; 78   : 	ex	= (pANTLR3_EXCEPTION) ANTLR3_CALLOC(1, sizeof(ANTLR3_EXCEPTION));

  0000c	8b f4		 mov	 esi, esp
  0000e	6a 58		 push	 88			; 00000058H
  00010	6a 01		 push	 1
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__calloc
  00018	83 c4 08	 add	 esp, 8
  0001b	3b f4		 cmp	 esi, esp
  0001d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00022	89 45 fc	 mov	 DWORD PTR _ex$[ebp], eax

; 79   : 
; 80   : 	/* Check for memory allocation
; 81   : 	*/
; 82   : 	if	(ex == NULL)

  00025	83 7d fc 00	 cmp	 DWORD PTR _ex$[ebp], 0
  00029	75 04		 jne	 SHORT $LN2@antlr3Exce

; 83   : 	{
; 84   : 		return	NULL;

  0002b	33 c0		 xor	 eax, eax
  0002d	eb 3a		 jmp	 SHORT $LN1@antlr3Exce
$LN2@antlr3Exce:

; 85   : 	}
; 86   : 
; 87   : 	ex->name		= name;		/* Install exception name	*/

  0002f	8b 45 fc	 mov	 eax, DWORD PTR _ex$[ebp]
  00032	8b 4d 0c	 mov	 ecx, DWORD PTR _name$[ebp]
  00035	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 88   : 	ex->type		= exception;	/* Install the exception number	*/

  00038	8b 55 fc	 mov	 edx, DWORD PTR _ex$[ebp]
  0003b	8b 45 08	 mov	 eax, DWORD PTR _exception$[ebp]
  0003e	89 02		 mov	 DWORD PTR [edx], eax

; 89   : 	ex->message		= message;	/* Install message string	*/

  00040	8b 4d fc	 mov	 ecx, DWORD PTR _ex$[ebp]
  00043	8b 55 10	 mov	 edx, DWORD PTR _message$[ebp]
  00046	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 90   : 
; 91   : 	/* Indicate whether the string should be freed if exception is destroyed    
; 92   : 	*/
; 93   : 	ex->freeMessage	= freeMessage;

  00049	8b 45 fc	 mov	 eax, DWORD PTR _ex$[ebp]
  0004c	8a 4d 14	 mov	 cl, BYTE PTR _freeMessage$[ebp]
  0004f	88 48 10	 mov	 BYTE PTR [eax+16], cl

; 94   : 
; 95   : 	/* Install the API
; 96   : 	*/
; 97   : 	ex->print	    =  antlr3ExceptionPrint;

  00052	8b 55 fc	 mov	 edx, DWORD PTR _ex$[ebp]
  00055	c7 42 50 00 00
	00 00		 mov	 DWORD PTR [edx+80], OFFSET _antlr3ExceptionPrint

; 98   : 	ex->freeEx	    =  antlr3ExceptionFree;

  0005c	8b 45 fc	 mov	 eax, DWORD PTR _ex$[ebp]
  0005f	c7 40 54 00 00
	00 00		 mov	 DWORD PTR [eax+84], OFFSET _antlr3ExceptionFree

; 99   : 
; 100  : 	return ex;

  00066	8b 45 fc	 mov	 eax, DWORD PTR _ex$[ebp]
$LN1@antlr3Exce:

; 101  : }

  00069	5e		 pop	 esi
  0006a	83 c4 04	 add	 esp, 4
  0006d	3b ec		 cmp	 ebp, esp
  0006f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c3		 ret	 0
_antlr3ExceptionNew ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 837  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 838  :         int _Result;
; 839  :         va_list _ArgList;
; 840  :         __crt_va_start(_ArgList, _Format);

  00014	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00017	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 841  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

  0001a	8b 4d f8	 mov	 ecx, DWORD PTR __ArgList$[ebp]
  0001d	51		 push	 ecx
  0001e	6a 00		 push	 0
  00020	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00023	52		 push	 edx
  00024	8b 45 08	 mov	 eax, DWORD PTR __Stream$[ebp]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 __vfprintf_l
  0002d	83 c4 10	 add	 esp, 16			; 00000010H
  00030	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 842  :         __crt_va_end(_ArgList);

  00033	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 843  :         return _Result;

  0003a	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 844  :     }

  0003d	83 c4 08	 add	 esp, 8
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 644  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00004	8b f4		 mov	 esi, esp
  00006	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  0000d	51		 push	 ecx
  0000e	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00011	52		 push	 edx
  00012	8b 45 08	 mov	 eax, DWORD PTR __Stream$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  0001b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001e	51		 push	 ecx
  0001f	8b 10		 mov	 edx, DWORD PTR [eax]
  00021	52		 push	 edx
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vfprintf
  00028	83 c4 18	 add	 esp, 24			; 00000018H
  0002b	3b f4		 cmp	 esi, esp
  0002d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 646  :     }

  00032	5e		 pop	 esi
  00033	3b ec		 cmp	 ebp, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 90   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00003	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
