; Listing generated by Microsoft (R) Optimizing Compiler Version 19.42.34436.0 

	TITLE	C:\SPO_labs\C\Debug\antlr3filestream.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_antlr3FileStreamNew
PUBLIC	_antlr3StringStreamNew
PUBLIC	_antlr3Fopen
PUBLIC	_antlr3Fclose
PUBLIC	_antlr3Fsize
PUBLIC	_antlr3read8Bit
PUBLIC	_antlr3Fread
PUBLIC	??_C@_02JDPG@rb@				; `string'
EXTRN	__imp__calloc:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp__fclose:PROC
EXTRN	__imp__fopen:PROC
EXTRN	__imp__fread:PROC
EXTRN	__imp___stat64i32:PROC
EXTRN	_antlr38BitSetupStream:PROC
EXTRN	_antlr3UTF16SetupStream:PROC
EXTRN	_antlr3UTF32SetupStream:PROC
EXTRN	_antlr3UTF8SetupStream:PROC
EXTRN	_antlr3EBCDICSetupStream:PROC
EXTRN	_antlr3GenericSetupStream:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_02JDPG@rb@
CONST	SEGMENT
??_C@_02JDPG@rb@ DB 'rb', 00H				; `string'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	01eH
	DB	051H
voltbl	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3filestream.c
;	COMDAT _antlr3CreateStringStream
_TEXT	SEGMENT
_input$ = -4						; size = 4
_data$ = 8						; size = 4
_antlr3CreateStringStream PROC				; COMDAT

; 443  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 444  : 	// Pointer to the input stream we are going to create
; 445  : 	//
; 446  : 	pANTLR3_INPUT_STREAM    input;
; 447  : 
; 448  : 	if	(data == NULL)

  0000c	83 7d 08 00	 cmp	 DWORD PTR _data$[ebp], 0
  00010	75 04		 jne	 SHORT $LN2@antlr3Crea

; 449  : 	{
; 450  : 		return NULL;

  00012	33 c0		 xor	 eax, eax
  00014	eb 45		 jmp	 SHORT $LN1@antlr3Crea
$LN2@antlr3Crea:

; 451  : 	}
; 452  : 
; 453  : 	// Allocate memory for the input stream structure
; 454  : 	//
; 455  : 	input   = (pANTLR3_INPUT_STREAM)

  00016	8b f4		 mov	 esi, esp
  00018	6a 7c		 push	 124			; 0000007cH
  0001a	6a 01		 push	 1
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__calloc
  00022	83 c4 08	 add	 esp, 8
  00025	3b f4		 cmp	 esi, esp
  00027	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002c	89 45 fc	 mov	 DWORD PTR _input$[ebp], eax

; 456  : 		ANTLR3_CALLOC(1, sizeof(ANTLR3_INPUT_STREAM));
; 457  : 
; 458  : 	if	(input == NULL)

  0002f	83 7d fc 00	 cmp	 DWORD PTR _input$[ebp], 0
  00033	75 04		 jne	 SHORT $LN3@antlr3Crea

; 459  : 	{
; 460  : 		return	NULL;

  00035	33 c0		 xor	 eax, eax
  00037	eb 22		 jmp	 SHORT $LN1@antlr3Crea
$LN3@antlr3Crea:

; 461  : 	}
; 462  : 
; 463  : 	// Structure was allocated correctly, now we can install the pointer
; 464  : 	//
; 465  :         input->data             = data;

  00039	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  0003c	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  0003f	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 466  :         input->isAllocated	= ANTLR3_FALSE;

  00042	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  00045	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0

; 467  : 
; 468  : 	// Call the common 8 bit input stream handler
; 469  : 	// initialization.
; 470  : 	//
; 471  : 	antlr3GenericSetupStream(input);

  0004c	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 _antlr3GenericSetupStream
  00055	83 c4 04	 add	 esp, 4

; 472  : 
; 473  :         return  input;

  00058	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
$LN1@antlr3Crea:

; 474  : }

  0005b	5e		 pop	 esi
  0005c	83 c4 04	 add	 esp, 4
  0005f	3b ec		 cmp	 ebp, esp
  00061	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
_antlr3CreateStringStream ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3filestream.c
;	COMDAT _antlr3CreateFileStream
_TEXT	SEGMENT
_status$ = -8						; size = 4
_input$ = -4						; size = 4
_fileName$ = 8						; size = 4
_antlr3CreateFileStream PROC				; COMDAT

; 309  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 310  : 	// Pointer to the input stream we are going to create
; 311  : 	//
; 312  : 	pANTLR3_INPUT_STREAM    input;
; 313  : 	ANTLR3_UINT32	    status;
; 314  : 
; 315  : 	if	(fileName == NULL)

  00015	83 7d 08 00	 cmp	 DWORD PTR _fileName$[ebp], 0
  00019	75 04		 jne	 SHORT $LN2@antlr3Crea

; 316  : 	{
; 317  : 		return NULL;

  0001b	33 c0		 xor	 eax, eax
  0001d	eb 67		 jmp	 SHORT $LN1@antlr3Crea
$LN2@antlr3Crea:

; 318  : 	}
; 319  : 
; 320  : 	// Allocate memory for the input stream structure
; 321  : 	//
; 322  : 	input   = (pANTLR3_INPUT_STREAM)

  0001f	8b f4		 mov	 esi, esp
  00021	6a 7c		 push	 124			; 0000007cH
  00023	6a 01		 push	 1
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__calloc
  0002b	83 c4 08	 add	 esp, 8
  0002e	3b f4		 cmp	 esi, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	89 45 fc	 mov	 DWORD PTR _input$[ebp], eax

; 323  : 		ANTLR3_CALLOC(1, sizeof(ANTLR3_INPUT_STREAM));
; 324  : 
; 325  : 	if	(input == NULL)

  00038	83 7d fc 00	 cmp	 DWORD PTR _input$[ebp], 0
  0003c	75 04		 jne	 SHORT $LN3@antlr3Crea

; 326  : 	{
; 327  : 		return	NULL;

  0003e	33 c0		 xor	 eax, eax
  00040	eb 44		 jmp	 SHORT $LN1@antlr3Crea
$LN3@antlr3Crea:

; 328  : 	}
; 329  : 
; 330  : 	// Structure was allocated correctly, now we can read the file.
; 331  : 	//
; 332  : 	status  = antlr3read8Bit(input, fileName);

  00042	8b 45 08	 mov	 eax, DWORD PTR _fileName$[ebp]
  00045	50		 push	 eax
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  00049	51		 push	 ecx
  0004a	e8 00 00 00 00	 call	 _antlr3read8Bit
  0004f	83 c4 08	 add	 esp, 8
  00052	89 45 f8	 mov	 DWORD PTR _status$[ebp], eax

; 333  : 
; 334  : 	// Call the common 8 bit input stream handler
; 335  : 	// initialization.
; 336  : 	//
; 337  : 	antlr3GenericSetupStream(input);

  00055	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  00058	52		 push	 edx
  00059	e8 00 00 00 00	 call	 _antlr3GenericSetupStream
  0005e	83 c4 04	 add	 esp, 4

; 338  : 
; 339  :         // However if the file was not there or something then we
; 340  :         // need to close. Have to wait until here as we cannot call
; 341  :         // close until the API is installed of course.
; 342  :         // 
; 343  : 	if	(status != ANTLR3_SUCCESS)

  00061	83 7d f8 00	 cmp	 DWORD PTR _status$[ebp], 0
  00065	74 1c		 je	 SHORT $LN4@antlr3Crea

; 344  : 	{
; 345  : 		input->close(input);

  00067	8b f4		 mov	 esi, esp
  00069	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  0006c	50		 push	 eax
  0006d	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  00070	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  00073	ff d2		 call	 edx
  00075	83 c4 04	 add	 esp, 4
  00078	3b f4		 cmp	 esi, esp
  0007a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 346  : 		return	NULL;

  0007f	33 c0		 xor	 eax, eax
  00081	eb 03		 jmp	 SHORT $LN1@antlr3Crea
$LN4@antlr3Crea:

; 347  : 	}
; 348  : 
; 349  : 	return  input;

  00083	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
$LN1@antlr3Crea:

; 350  : }

  00086	5e		 pop	 esi
  00087	83 c4 08	 add	 esp, 8
  0008a	3b ec		 cmp	 ebp, esp
  0008c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c3		 ret	 0
_antlr3CreateFileStream ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3filestream.c
;	COMDAT _setupInputStream
_TEXT	SEGMENT
tv67 = -12						; size = 4
_bomTest$ = -8						; size = 2
_isBigEndian$ = -1					; size = 1
_input$ = 8						; size = 4
_setupInputStream PROC					; COMDAT

; 131  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 132  :     ANTLR3_BOOLEAN  isBigEndian;
; 133  : 
; 134  :     // Used to determine the endianness of the machine we are currently
; 135  :     // running on.
; 136  :     //
; 137  :     ANTLR3_UINT16 bomTest = 0xFEFF;

  0001b	b8 ff fe 00 00	 mov	 eax, 65279		; 0000feffH
  00020	66 89 45 f8	 mov	 WORD PTR _bomTest$[ebp], ax

; 138  :     
; 139  :     // What endianess is the machine we are running on? If the incoming
; 140  :     // encoding endianess is the same as this machine's natural byte order
; 141  :     // then we can use more efficient API calls.
; 142  :     //
; 143  :     if  (*((pANTLR3_UINT8)(&bomTest)) == 0xFE)

  00024	0f b6 4d f8	 movzx	 ecx, BYTE PTR _bomTest$[ebp]
  00028	81 f9 fe 00 00
	00		 cmp	 ecx, 254		; 000000feH
  0002e	75 06		 jne	 SHORT $LN4@setupInput

; 144  :     {
; 145  :         isBigEndian = ANTLR3_TRUE;

  00030	c6 45 ff 01	 mov	 BYTE PTR _isBigEndian$[ebp], 1

; 146  :     }

  00034	eb 04		 jmp	 SHORT $LN5@setupInput
$LN4@setupInput:

; 147  :     else
; 148  :     {
; 149  :         isBigEndian = ANTLR3_FALSE;

  00036	c6 45 ff 00	 mov	 BYTE PTR _isBigEndian$[ebp], 0
$LN5@setupInput:

; 150  :     }
; 151  : 
; 152  :     // What encoding did the user tell us {s}he thought it was? I am going
; 153  :     // to get sick of the questions on antlr-interest, I know I am.
; 154  :     //
; 155  :     switch  (input->encoding)

  0003a	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  0003d	8b 42 78	 mov	 eax, DWORD PTR [edx+120]
  00040	89 45 f4	 mov	 DWORD PTR tv67[ebp], eax
  00043	8b 4d f4	 mov	 ecx, DWORD PTR tv67[ebp]
  00046	83 e9 04	 sub	 ecx, 4
  00049	89 4d f4	 mov	 DWORD PTR tv67[ebp], ecx
  0004c	83 7d f4 3c	 cmp	 DWORD PTR tv67[ebp], 60	; 0000003cH
  00050	0f 87 4a 02 00
	00		 ja	 $LN23@setupInput
  00056	8b 55 f4	 mov	 edx, DWORD PTR tv67[ebp]
  00059	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN26@setupInput[edx]
  00060	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN27@setupInput[eax*4]
$LN6@setupInput:

; 156  :     {
; 157  :         case    ANTLR3_ENC_UTF8:
; 158  : 
; 159  :             // See if there is a BOM at the start of this UTF-8 sequence
; 160  :             // and just eat it if there is. Windows .TXT files have this for instance
; 161  :             // as it identifies UTF-8 even though it is of no consequence for byte order
; 162  :             // as UTF-8 does not have a byte order.
; 163  :             //
; 164  :             if  (       (ANTLR3_UINT8)(*((pANTLR3_UINT8)input->nextChar))      == 0xEF
; 165  :                     &&  (ANTLR3_UINT8)(*((pANTLR3_UINT8)input->nextChar+1))    == 0xBB
; 166  :                     &&  (ANTLR3_UINT8)(*((pANTLR3_UINT8)input->nextChar+2))    == 0xBF

  00067	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  0006a	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0006d	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00070	3d ef 00 00 00	 cmp	 eax, 239		; 000000efH
  00075	75 31		 jne	 SHORT $LN7@setupInput
  00077	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  0007a	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0007d	0f b6 42 01	 movzx	 eax, BYTE PTR [edx+1]
  00081	3d bb 00 00 00	 cmp	 eax, 187		; 000000bbH
  00086	75 20		 jne	 SHORT $LN7@setupInput
  00088	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  0008b	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0008e	0f b6 42 02	 movzx	 eax, BYTE PTR [edx+2]
  00092	3d bf 00 00 00	 cmp	 eax, 191		; 000000bfH
  00097	75 0f		 jne	 SHORT $LN7@setupInput

; 167  :                 )
; 168  :             {
; 169  :                 // The UTF8 BOM is present so skip it
; 170  :                 //
; 171  :                 input->nextChar = (void *)((pANTLR3_UINT8)input->nextChar + 3);

  00099	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  0009c	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0009f	83 c2 03	 add	 edx, 3
  000a2	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  000a5	89 50 14	 mov	 DWORD PTR [eax+20], edx
$LN7@setupInput:

; 172  :             }
; 173  : 
; 174  :             // Install the UTF8 input routines
; 175  :             //
; 176  :             antlr3UTF8SetupStream(input);

  000a8	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  000ab	51		 push	 ecx
  000ac	e8 00 00 00 00	 call	 _antlr3UTF8SetupStream
  000b1	83 c4 04	 add	 esp, 4

; 177  :             break;

  000b4	e9 f3 01 00 00	 jmp	 $LN2@setupInput
$LN8@setupInput:

; 178  : 
; 179  :         case    ANTLR3_ENC_UTF16:
; 180  : 
; 181  :             // See if there is a BOM at the start of the input. If not then
; 182  :             // we assume that the byte order is the natural order of this
; 183  :             // machine (or it is really UCS2). If there is a BOM we determine if the encoding
; 184  :             // is the same as the natural order of this machine.
; 185  :             //
; 186  :             if  (       (ANTLR3_UINT8)(*((pANTLR3_UINT8)input->nextChar))      == 0xFE
; 187  :                     &&  (ANTLR3_UINT8)(*((pANTLR3_UINT8)input->nextChar+1))    == 0xFF

  000b9	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  000bc	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  000bf	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000c2	81 f9 fe 00 00
	00		 cmp	 ecx, 254		; 000000feH
  000c8	75 36		 jne	 SHORT $LN9@setupInput
  000ca	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  000cd	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  000d0	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  000d4	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  000da	75 24		 jne	 SHORT $LN9@setupInput

; 188  :                 )
; 189  :             {
; 190  :                 // BOM Present, indicates Big Endian
; 191  :                 //
; 192  :                 input->nextChar = (void *)((pANTLR3_UINT8)input->nextChar + 2);

  000dc	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  000df	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  000e2	83 c0 02	 add	 eax, 2
  000e5	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  000e8	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 193  : 
; 194  :                 antlr3UTF16SetupStream(input, isBigEndian, ANTLR3_TRUE);

  000eb	6a 01		 push	 1
  000ed	0f b6 55 ff	 movzx	 edx, BYTE PTR _isBigEndian$[ebp]
  000f1	52		 push	 edx
  000f2	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  000f5	50		 push	 eax
  000f6	e8 00 00 00 00	 call	 _antlr3UTF16SetupStream
  000fb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 195  :             }

  000fe	eb 5b		 jmp	 SHORT $LN12@setupInput
$LN9@setupInput:

; 196  :             else if  (      (ANTLR3_UINT8)(*((pANTLR3_UINT8)input->nextChar))      == 0xFF
; 197  :                         &&  (ANTLR3_UINT8)(*((pANTLR3_UINT8)input->nextChar+1))    == 0xFE

  00100	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  00103	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00106	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00109	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0010e	75 35		 jne	 SHORT $LN11@setupInput
  00110	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  00113	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00116	0f b6 42 01	 movzx	 eax, BYTE PTR [edx+1]
  0011a	3d fe 00 00 00	 cmp	 eax, 254		; 000000feH
  0011f	75 24		 jne	 SHORT $LN11@setupInput

; 198  :                 )
; 199  :             {
; 200  :                 // BOM present, indicates Little Endian
; 201  :                 //
; 202  :                 input->nextChar = (void *)((pANTLR3_UINT8)input->nextChar + 2);

  00121	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  00124	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00127	83 c2 02	 add	 edx, 2
  0012a	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  0012d	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 203  : 
; 204  :                 antlr3UTF16SetupStream(input, isBigEndian, ANTLR3_FALSE);

  00130	6a 00		 push	 0
  00132	0f b6 4d ff	 movzx	 ecx, BYTE PTR _isBigEndian$[ebp]
  00136	51		 push	 ecx
  00137	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  0013a	52		 push	 edx
  0013b	e8 00 00 00 00	 call	 _antlr3UTF16SetupStream
  00140	83 c4 0c	 add	 esp, 12			; 0000000cH

; 205  :             }

  00143	eb 16		 jmp	 SHORT $LN12@setupInput
$LN11@setupInput:

; 206  :             else
; 207  :             {
; 208  :                 // No BOM present, assume local computer byte order
; 209  :                 //
; 210  :                 antlr3UTF16SetupStream(input, isBigEndian, isBigEndian);

  00145	0f b6 45 ff	 movzx	 eax, BYTE PTR _isBigEndian$[ebp]
  00149	50		 push	 eax
  0014a	0f b6 4d ff	 movzx	 ecx, BYTE PTR _isBigEndian$[ebp]
  0014e	51		 push	 ecx
  0014f	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  00152	52		 push	 edx
  00153	e8 00 00 00 00	 call	 _antlr3UTF16SetupStream
  00158	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN12@setupInput:

; 211  :             }
; 212  :             break;

  0015b	e9 4c 01 00 00	 jmp	 $LN2@setupInput
$LN13@setupInput:

; 213  : 
; 214  :         case    ANTLR3_ENC_UTF32:
; 215  : 
; 216  :             // See if there is a BOM at the start of the input. If not then
; 217  :             // we assume that the byte order is the natural order of this
; 218  :             // machine. If there is we determine if the encoding
; 219  :             // is the same as the natural order of this machine.
; 220  :             //
; 221  :             if  (       (ANTLR3_UINT8)(*((pANTLR3_UINT8)input->nextChar))      == 0x00
; 222  :                     &&  (ANTLR3_UINT8)(*((pANTLR3_UINT8)input->nextChar+1))    == 0x00
; 223  :                     &&  (ANTLR3_UINT8)(*((pANTLR3_UINT8)input->nextChar+2))    == 0xFE
; 224  :                     &&  (ANTLR3_UINT8)(*((pANTLR3_UINT8)input->nextChar+3))    == 0xFF

  00160	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  00163	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00166	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00169	85 d2		 test	 edx, edx
  0016b	75 56		 jne	 SHORT $LN14@setupInput
  0016d	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  00170	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00173	0f b6 51 01	 movzx	 edx, BYTE PTR [ecx+1]
  00177	85 d2		 test	 edx, edx
  00179	75 48		 jne	 SHORT $LN14@setupInput
  0017b	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  0017e	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00181	0f b6 51 02	 movzx	 edx, BYTE PTR [ecx+2]
  00185	81 fa fe 00 00
	00		 cmp	 edx, 254		; 000000feH
  0018b	75 36		 jne	 SHORT $LN14@setupInput
  0018d	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  00190	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00193	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  00197	81 fa ff 00 00
	00		 cmp	 edx, 255		; 000000ffH
  0019d	75 24		 jne	 SHORT $LN14@setupInput

; 225  :                 )
; 226  :             {
; 227  :                 // BOM Present, indicates Big Endian
; 228  :                 //
; 229  :                 input->nextChar = (void *)((pANTLR3_UINT8)input->nextChar + 4);

  0019f	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  001a2	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  001a5	83 c1 04	 add	 ecx, 4
  001a8	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  001ab	89 4a 14	 mov	 DWORD PTR [edx+20], ecx

; 230  : 
; 231  :                 antlr3UTF32SetupStream(input, isBigEndian, ANTLR3_TRUE);

  001ae	6a 01		 push	 1
  001b0	0f b6 45 ff	 movzx	 eax, BYTE PTR _isBigEndian$[ebp]
  001b4	50		 push	 eax
  001b5	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  001b8	51		 push	 ecx
  001b9	e8 00 00 00 00	 call	 _antlr3UTF32SetupStream
  001be	83 c4 0c	 add	 esp, 12			; 0000000cH

; 232  :             }

  001c1	eb 79		 jmp	 SHORT $LN17@setupInput
$LN14@setupInput:

; 233  :             else if  (      (ANTLR3_UINT8)(*((pANTLR3_UINT8)input->nextChar))      == 0xFF
; 234  :                         &&  (ANTLR3_UINT8)(*((pANTLR3_UINT8)input->nextChar+1))    == 0xFE
; 235  :                         &&  (ANTLR3_UINT8)(*((pANTLR3_UINT8)input->nextChar+1))    == 0x00
; 236  :                         &&  (ANTLR3_UINT8)(*((pANTLR3_UINT8)input->nextChar+1))    == 0x00

  001c3	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  001c6	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  001c9	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  001cc	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  001d2	75 52		 jne	 SHORT $LN16@setupInput
  001d4	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  001d7	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  001da	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  001de	81 f9 fe 00 00
	00		 cmp	 ecx, 254		; 000000feH
  001e4	75 40		 jne	 SHORT $LN16@setupInput
  001e6	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  001e9	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  001ec	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  001f0	85 c9		 test	 ecx, ecx
  001f2	75 32		 jne	 SHORT $LN16@setupInput
  001f4	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  001f7	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  001fa	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  001fe	85 c9		 test	 ecx, ecx
  00200	75 24		 jne	 SHORT $LN16@setupInput

; 237  :                 )
; 238  :             {
; 239  :                 // BOM present, indicates Little Endian
; 240  :                 //
; 241  :                 input->nextChar = (void *)((pANTLR3_UINT8)input->nextChar + 4);

  00202	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  00205	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00208	83 c0 04	 add	 eax, 4
  0020b	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  0020e	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 242  : 
; 243  :                 antlr3UTF32SetupStream(input, isBigEndian, ANTLR3_FALSE);

  00211	6a 00		 push	 0
  00213	0f b6 55 ff	 movzx	 edx, BYTE PTR _isBigEndian$[ebp]
  00217	52		 push	 edx
  00218	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  0021b	50		 push	 eax
  0021c	e8 00 00 00 00	 call	 _antlr3UTF32SetupStream
  00221	83 c4 0c	 add	 esp, 12			; 0000000cH

; 244  :             }

  00224	eb 16		 jmp	 SHORT $LN17@setupInput
$LN16@setupInput:

; 245  :             else
; 246  :             {
; 247  :                 // No BOM present, assume local computer byte order
; 248  :                 //
; 249  :                 antlr3UTF32SetupStream(input, isBigEndian, isBigEndian);

  00226	0f b6 4d ff	 movzx	 ecx, BYTE PTR _isBigEndian$[ebp]
  0022a	51		 push	 ecx
  0022b	0f b6 55 ff	 movzx	 edx, BYTE PTR _isBigEndian$[ebp]
  0022f	52		 push	 edx
  00230	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  00233	50		 push	 eax
  00234	e8 00 00 00 00	 call	 _antlr3UTF32SetupStream
  00239	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN17@setupInput:

; 250  :             }
; 251  :             break;

  0023c	eb 6e		 jmp	 SHORT $LN2@setupInput
$LN18@setupInput:

; 252  : 
; 253  :         case    ANTLR3_ENC_UTF16BE:
; 254  : 
; 255  :             // Encoding is definately Big Endian with no BOM
; 256  :             //
; 257  :             antlr3UTF16SetupStream(input, isBigEndian, ANTLR3_TRUE);

  0023e	6a 01		 push	 1
  00240	0f b6 4d ff	 movzx	 ecx, BYTE PTR _isBigEndian$[ebp]
  00244	51		 push	 ecx
  00245	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  00248	52		 push	 edx
  00249	e8 00 00 00 00	 call	 _antlr3UTF16SetupStream
  0024e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 258  :             break;

  00251	eb 59		 jmp	 SHORT $LN2@setupInput
$LN19@setupInput:

; 259  : 
; 260  :         case    ANTLR3_ENC_UTF16LE:
; 261  : 
; 262  :             // Encoding is definately Little Endian with no BOM
; 263  :             //
; 264  :             antlr3UTF16SetupStream(input, isBigEndian, ANTLR3_FALSE);

  00253	6a 00		 push	 0
  00255	0f b6 45 ff	 movzx	 eax, BYTE PTR _isBigEndian$[ebp]
  00259	50		 push	 eax
  0025a	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  0025d	51		 push	 ecx
  0025e	e8 00 00 00 00	 call	 _antlr3UTF16SetupStream
  00263	83 c4 0c	 add	 esp, 12			; 0000000cH

; 265  :             break;

  00266	eb 44		 jmp	 SHORT $LN2@setupInput
$LN20@setupInput:

; 266  : 
; 267  :         case    ANTLR3_ENC_UTF32BE:
; 268  : 
; 269  :             // Encoding is definately Big Endian with no BOM
; 270  :             //
; 271  :             antlr3UTF32SetupStream(input, isBigEndian, ANTLR3_TRUE);

  00268	6a 01		 push	 1
  0026a	0f b6 55 ff	 movzx	 edx, BYTE PTR _isBigEndian$[ebp]
  0026e	52		 push	 edx
  0026f	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  00272	50		 push	 eax
  00273	e8 00 00 00 00	 call	 _antlr3UTF32SetupStream
  00278	83 c4 0c	 add	 esp, 12			; 0000000cH

; 272  :             break;

  0027b	eb 2f		 jmp	 SHORT $LN2@setupInput
$LN21@setupInput:

; 273  : 
; 274  :         case    ANTLR3_ENC_UTF32LE:
; 275  : 
; 276  :             // Encoding is definately Little Endian with no BOM
; 277  :             //
; 278  :             antlr3UTF32SetupStream(input, isBigEndian, ANTLR3_FALSE);

  0027d	6a 00		 push	 0
  0027f	0f b6 4d ff	 movzx	 ecx, BYTE PTR _isBigEndian$[ebp]
  00283	51		 push	 ecx
  00284	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  00287	52		 push	 edx
  00288	e8 00 00 00 00	 call	 _antlr3UTF32SetupStream
  0028d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 279  :             break;

  00290	eb 1a		 jmp	 SHORT $LN2@setupInput
$LN22@setupInput:

; 280  : 
; 281  :         case    ANTLR3_ENC_EBCDIC:
; 282  : 
; 283  :             // EBCDIC is basically the same as ASCII but with an on the
; 284  :             // fly translation to ASCII
; 285  :             //
; 286  :             antlr3EBCDICSetupStream(input);

  00292	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  00295	50		 push	 eax
  00296	e8 00 00 00 00	 call	 _antlr3EBCDICSetupStream
  0029b	83 c4 04	 add	 esp, 4

; 287  :             break;

  0029e	eb 0c		 jmp	 SHORT $LN2@setupInput
$LN23@setupInput:

; 288  : 
; 289  :         case    ANTLR3_ENC_8BIT:
; 290  :         default:
; 291  : 
; 292  :             // Standard 8bit/ASCII
; 293  :             //
; 294  :             antlr38BitSetupStream(input);

  002a0	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  002a3	51		 push	 ecx
  002a4	e8 00 00 00 00	 call	 _antlr38BitSetupStream
  002a9	83 c4 04	 add	 esp, 4
$LN2@setupInput:

; 295  :             break;
; 296  :     }    
; 297  : }

  002ac	83 c4 0c	 add	 esp, 12			; 0000000cH
  002af	3b ec		 cmp	 ebp, esp
  002b1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002b6	8b e5		 mov	 esp, ebp
  002b8	5d		 pop	 ebp
  002b9	c3		 ret	 0
  002ba	66 90		 npad	 2
$LN27@setupInput:
  002bc	00 00 00 00	 DD	 $LN23@setupInput
  002c0	00 00 00 00	 DD	 $LN6@setupInput
  002c4	00 00 00 00	 DD	 $LN8@setupInput
  002c8	00 00 00 00	 DD	 $LN18@setupInput
  002cc	00 00 00 00	 DD	 $LN19@setupInput
  002d0	00 00 00 00	 DD	 $LN13@setupInput
  002d4	00 00 00 00	 DD	 $LN20@setupInput
  002d8	00 00 00 00	 DD	 $LN21@setupInput
  002dc	00 00 00 00	 DD	 $LN22@setupInput
  002e0	00 00 00 00	 DD	 $LN23@setupInput
$LN26@setupInput:
  002e4	00		 DB	 0
  002e5	09		 DB	 9
  002e6	09		 DB	 9
  002e7	09		 DB	 9
  002e8	01		 DB	 1
  002e9	09		 DB	 9
  002ea	09		 DB	 9
  002eb	09		 DB	 9
  002ec	09		 DB	 9
  002ed	09		 DB	 9
  002ee	09		 DB	 9
  002ef	09		 DB	 9
  002f0	02		 DB	 2
  002f1	03		 DB	 3
  002f2	04		 DB	 4
  002f3	09		 DB	 9
  002f4	09		 DB	 9
  002f5	09		 DB	 9
  002f6	09		 DB	 9
  002f7	09		 DB	 9
  002f8	09		 DB	 9
  002f9	09		 DB	 9
  002fa	09		 DB	 9
  002fb	09		 DB	 9
  002fc	09		 DB	 9
  002fd	09		 DB	 9
  002fe	09		 DB	 9
  002ff	09		 DB	 9
  00300	05		 DB	 5
  00301	06		 DB	 6
  00302	07		 DB	 7
  00303	09		 DB	 9
  00304	09		 DB	 9
  00305	09		 DB	 9
  00306	09		 DB	 9
  00307	09		 DB	 9
  00308	09		 DB	 9
  00309	09		 DB	 9
  0030a	09		 DB	 9
  0030b	09		 DB	 9
  0030c	09		 DB	 9
  0030d	09		 DB	 9
  0030e	09		 DB	 9
  0030f	09		 DB	 9
  00310	09		 DB	 9
  00311	09		 DB	 9
  00312	09		 DB	 9
  00313	09		 DB	 9
  00314	09		 DB	 9
  00315	09		 DB	 9
  00316	09		 DB	 9
  00317	09		 DB	 9
  00318	09		 DB	 9
  00319	09		 DB	 9
  0031a	09		 DB	 9
  0031b	09		 DB	 9
  0031c	09		 DB	 9
  0031d	09		 DB	 9
  0031e	09		 DB	 9
  0031f	09		 DB	 9
  00320	08		 DB	 8
_setupInputStream ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3filestream.c
;	COMDAT _antlr3Fread
_TEXT	SEGMENT
_fdsc$ = 8						; size = 4
_count$ = 12						; size = 4
_data$ = 16						; size = 4
_antlr3Fread PROC					; COMDAT

; 429  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 430  :     return  (ANTLR3_UINT32)fread(data, (size_t)count, 1, fdsc);

  00004	8b f4		 mov	 esi, esp
  00006	8b 45 08	 mov	 eax, DWORD PTR _fdsc$[ebp]
  00009	50		 push	 eax
  0000a	6a 01		 push	 1
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR _count$[ebp]
  0000f	51		 push	 ecx
  00010	8b 55 10	 mov	 edx, DWORD PTR _data$[ebp]
  00013	52		 push	 edx
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  0001a	83 c4 10	 add	 esp, 16			; 00000010H
  0001d	3b f4		 cmp	 esi, esp
  0001f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 431  : }

  00024	5e		 pop	 esi
  00025	3b ec		 cmp	 ebp, esp
  00027	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
_antlr3Fread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3filestream.c
;	COMDAT _antlr3read8Bit
_TEXT	SEGMENT
_fSize$ = -8						; size = 4
_infile$ = -4						; size = 4
_input$ = 8						; size = 4
_fileName$ = 12						; size = 4
_antlr3read8Bit PROC					; COMDAT

; 354  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 355  : 	ANTLR3_FDSC	    infile;
; 356  : 	ANTLR3_UINT32	    fSize;
; 357  : 
; 358  : 	/* Open the OS file in read binary mode
; 359  : 	*/
; 360  : 	infile  = antlr3Fopen(fileName, "rb");

  00015	68 00 00 00 00	 push	 OFFSET ??_C@_02JDPG@rb@
  0001a	8b 45 0c	 mov	 eax, DWORD PTR _fileName$[ebp]
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 _antlr3Fopen
  00023	83 c4 08	 add	 esp, 8
  00026	89 45 fc	 mov	 DWORD PTR _infile$[ebp], eax

; 361  : 
; 362  : 	/* Check that it was there
; 363  : 	*/
; 364  : 	if	(infile == NULL)

  00029	83 7d fc 00	 cmp	 DWORD PTR _infile$[ebp], 0
  0002d	75 07		 jne	 SHORT $LN2@antlr3read

; 365  : 	{
; 366  : 		return	(ANTLR3_UINT32)ANTLR3_ERR_NOFILE;

  0002f	b8 02 00 00 00	 mov	 eax, 2
  00034	eb 73		 jmp	 SHORT $LN1@antlr3read
$LN2@antlr3read:

; 367  : 	}
; 368  : 
; 369  : 	/* It was there, so we can read the bytes now
; 370  : 	*/
; 371  : 	fSize   = antlr3Fsize(fileName);	/* Size of input file	*/

  00036	8b 4d 0c	 mov	 ecx, DWORD PTR _fileName$[ebp]
  00039	51		 push	 ecx
  0003a	e8 00 00 00 00	 call	 _antlr3Fsize
  0003f	83 c4 04	 add	 esp, 4
  00042	89 45 f8	 mov	 DWORD PTR _fSize$[ebp], eax

; 372  : 
; 373  : 	/* Allocate buffer for this input set   
; 374  : 	*/
; 375  : 	input->data	    = ANTLR3_MALLOC((size_t)fSize);

  00045	8b f4		 mov	 esi, esp
  00047	8b 55 f8	 mov	 edx, DWORD PTR _fSize$[ebp]
  0004a	52		 push	 edx
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00051	83 c4 04	 add	 esp, 4
  00054	3b f4		 cmp	 esi, esp
  00056	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005b	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  0005e	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 376  : 	input->sizeBuf  = fSize;

  00061	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  00064	8b 45 f8	 mov	 eax, DWORD PTR _fSize$[ebp]
  00067	89 42 18	 mov	 DWORD PTR [edx+24], eax

; 377  : 
; 378  : 	if	(input->data == NULL)

  0006a	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  0006d	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  00071	75 07		 jne	 SHORT $LN3@antlr3read

; 379  : 	{
; 380  : 		return	(ANTLR3_UINT32)ANTLR3_ERR_NOMEM;

  00073	b8 01 00 00 00	 mov	 eax, 1
  00078	eb 2f		 jmp	 SHORT $LN1@antlr3read
$LN3@antlr3read:

; 381  : 	}
; 382  : 
; 383  : 	input->isAllocated	= ANTLR3_TRUE;

  0007a	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  0007d	c7 42 0c 01 00
	00 00		 mov	 DWORD PTR [edx+12], 1

; 384  : 
; 385  : 	/* Now we read the file. Characters are not converted to
; 386  : 	* the internal ANTLR encoding until they are read from the buffer
; 387  : 	*/
; 388  : 	antlr3Fread(infile, fSize, input->data);

  00084	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  00087	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0008a	51		 push	 ecx
  0008b	8b 55 f8	 mov	 edx, DWORD PTR _fSize$[ebp]
  0008e	52		 push	 edx
  0008f	8b 45 fc	 mov	 eax, DWORD PTR _infile$[ebp]
  00092	50		 push	 eax
  00093	e8 00 00 00 00	 call	 _antlr3Fread
  00098	83 c4 0c	 add	 esp, 12			; 0000000cH

; 389  : 
; 390  : 	/* And close the file handle
; 391  : 	*/
; 392  : 	antlr3Fclose(infile);

  0009b	8b 4d fc	 mov	 ecx, DWORD PTR _infile$[ebp]
  0009e	51		 push	 ecx
  0009f	e8 00 00 00 00	 call	 _antlr3Fclose
  000a4	83 c4 04	 add	 esp, 4

; 393  : 
; 394  : 	return  ANTLR3_SUCCESS;

  000a7	33 c0		 xor	 eax, eax
$LN1@antlr3read:

; 395  : }

  000a9	5e		 pop	 esi
  000aa	83 c4 08	 add	 esp, 8
  000ad	3b ec		 cmp	 ebp, esp
  000af	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b4	8b e5		 mov	 esp, ebp
  000b6	5d		 pop	 ebp
  000b7	c3		 ret	 0
_antlr3read8Bit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3filestream.c
;	COMDAT _antlr3Fsize
_TEXT	SEGMENT
_statbuf$ = -56						; size = 48
__$ArrayPad$ = -4					; size = 4
_fileName$ = 8						; size = 4
_antlr3Fsize PROC					; COMDAT

; 419  : {   

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8d 7d c4	 lea	 edi, DWORD PTR [ebp-60]
  0000b	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 420  :     struct _stat	statbuf;
; 421  : 
; 422  :     _stat((const char *)fileName, &statbuf);

  00021	8b f4		 mov	 esi, esp
  00023	8d 45 c8	 lea	 eax, DWORD PTR _statbuf$[ebp]
  00026	50		 push	 eax
  00027	8b 4d 08	 mov	 ecx, DWORD PTR _fileName$[ebp]
  0002a	51		 push	 ecx
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___stat64i32
  00031	83 c4 08	 add	 esp, 8
  00034	3b f4		 cmp	 esi, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 423  : 
; 424  :     return (ANTLR3_UINT32)statbuf.st_size;

  0003b	8b 45 dc	 mov	 eax, DWORD PTR _statbuf$[ebp+20]

; 425  : }

  0003e	52		 push	 edx
  0003f	8b cd		 mov	 ecx, ebp
  00041	50		 push	 eax
  00042	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@antlr3Fsiz
  00048	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0004d	58		 pop	 eax
  0004e	5a		 pop	 edx
  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00054	33 cd		 xor	 ecx, ebp
  00056	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005b	83 c4 3c	 add	 esp, 60			; 0000003cH
  0005e	3b ec		 cmp	 ebp, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
  00069	0f 1f 00	 npad	 3
$LN5@antlr3Fsiz:
  0006c	01 00 00 00	 DD	 1
  00070	00 00 00 00	 DD	 $LN4@antlr3Fsiz
$LN4@antlr3Fsiz:
  00074	c8 ff ff ff	 DD	 -56			; ffffffc8H
  00078	30 00 00 00	 DD	 48			; 00000030H
  0007c	00 00 00 00	 DD	 $LN3@antlr3Fsiz
$LN3@antlr3Fsiz:
  00080	73		 DB	 115			; 00000073H
  00081	74		 DB	 116			; 00000074H
  00082	61		 DB	 97			; 00000061H
  00083	74		 DB	 116			; 00000074H
  00084	62		 DB	 98			; 00000062H
  00085	75		 DB	 117			; 00000075H
  00086	66		 DB	 102			; 00000066H
  00087	00		 DB	 0
_antlr3Fsize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3filestream.c
;	COMDAT _antlr3Fclose
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_antlr3Fclose PROC					; COMDAT

; 414  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 415  :     fclose(fd);

  00004	8b f4		 mov	 esi, esp
  00006	8b 45 08	 mov	 eax, DWORD PTR _fd$[ebp]
  00009	50		 push	 eax
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00010	83 c4 04	 add	 esp, 4
  00013	3b f4		 cmp	 esi, esp
  00015	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001a	90		 npad	 1

; 416  : }

  0001b	5e		 pop	 esi
  0001c	3b ec		 cmp	 ebp, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
_antlr3Fclose ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3filestream.c
;	COMDAT _antlr3Fopen
_TEXT	SEGMENT
_filename$ = 8						; size = 4
_mode$ = 12						; size = 4
_antlr3Fopen PROC					; COMDAT

; 405  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 406  :     return  (ANTLR3_FDSC)fopen((const char *)filename, mode);

  00004	8b f4		 mov	 esi, esp
  00006	8b 45 0c	 mov	 eax, DWORD PTR _mode$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _filename$[ebp]
  0000d	51		 push	 ecx
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  00014	83 c4 08	 add	 esp, 8
  00017	3b f4		 cmp	 esi, esp
  00019	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 407  : }

  0001e	5e		 pop	 esi
  0001f	3b ec		 cmp	 ebp, esp
  00021	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
_antlr3Fopen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3filestream.c
;	COMDAT _antlr3StringStreamNew
_TEXT	SEGMENT
_input$ = -4						; size = 4
_data$ = 8						; size = 4
_encoding$ = 12						; size = 4
_size$ = 16						; size = 4
_name$ = 20						; size = 4
_antlr3StringStreamNew PROC				; COMDAT

; 90   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 91   :     pANTLR3_INPUT_STREAM    input;
; 92   : 
; 93   :     // First order of business is to set up the stream and install the data pointer.
; 94   :     // Then we will work out the encoding and byte order and adjust the API functions that are installed for the
; 95   :     // default 8Bit stream accordingly.
; 96   :     //
; 97   :     input   = antlr3CreateStringStream(data);

  0000c	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 _antlr3CreateStringStream
  00015	83 c4 04	 add	 esp, 4
  00018	89 45 fc	 mov	 DWORD PTR _input$[ebp], eax

; 98   :     if  (input == NULL)

  0001b	83 7d fc 00	 cmp	 DWORD PTR _input$[ebp], 0
  0001f	75 04		 jne	 SHORT $LN2@antlr3Stri

; 99   :     {
; 100  :         return NULL;

  00021	33 c0		 xor	 eax, eax
  00023	eb 59		 jmp	 SHORT $LN1@antlr3Stri
$LN2@antlr3Stri:

; 101  :     }
; 102  :     
; 103  :     // Size (in bytes) of the given 'string'
; 104  :     //
; 105  :     input->sizeBuf		= size;

  00025	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  00028	8b 55 10	 mov	 edx, DWORD PTR _size$[ebp]
  0002b	89 51 18	 mov	 DWORD PTR [ecx+24], edx

; 106  : 
; 107  :     // We have the data in memory now so we can deal with it according to 
; 108  :     // the encoding scheme we were given by the user.
; 109  :     //
; 110  :     input->encoding = encoding;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  00031	8b 4d 0c	 mov	 ecx, DWORD PTR _encoding$[ebp]
  00034	89 48 78	 mov	 DWORD PTR [eax+120], ecx

; 111  : 
; 112  :     // Now we need to work out the endian type and install any 
; 113  :     // API functions that differ from 8Bit
; 114  :     //
; 115  :     setupInputStream(input);

  00037	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  0003a	52		 push	 edx
  0003b	e8 00 00 00 00	 call	 _setupInputStream
  00040	83 c4 04	 add	 esp, 4

; 116  : 
; 117  :     // Now we can set up the file name
; 118  :     //	
; 119  :     input->istream->streamName	= input->strFactory->newStr8(input->strFactory, name);

  00043	8b f4		 mov	 esi, esp
  00045	8b 45 14	 mov	 eax, DWORD PTR _name$[ebp]
  00048	50		 push	 eax
  00049	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  0004c	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0004f	52		 push	 edx
  00050	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  00053	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00056	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00059	ff d2		 call	 edx
  0005b	83 c4 08	 add	 esp, 8
  0005e	3b f4		 cmp	 esi, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  00068	8b 11		 mov	 edx, DWORD PTR [ecx]
  0006a	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 120  :     input->fileName		= input->istream->streamName;

  0006d	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  00070	8b 08		 mov	 ecx, DWORD PTR [eax]
  00072	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  00075	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00078	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 121  : 
; 122  :     return input;

  0007b	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
$LN1@antlr3Stri:

; 123  : }

  0007e	5e		 pop	 esi
  0007f	83 c4 04	 add	 esp, 4
  00082	3b ec		 cmp	 ebp, esp
  00084	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c3		 ret	 0
_antlr3StringStreamNew ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3filestream.c
;	COMDAT _antlr3FileStreamNew
_TEXT	SEGMENT
_input$ = -4						; size = 4
_fileName$ = 8						; size = 4
_encoding$ = 12						; size = 4
_antlr3FileStreamNew PROC				; COMDAT

; 55   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 56   :     pANTLR3_INPUT_STREAM input;
; 57   : 
; 58   :     // First order of business is to read the file into some buffer space
; 59   :     // as just straight 8 bit bytes. Then we will work out the encoding and
; 60   :     // byte order and adjust the API functions that are installed for the
; 61   :     // default 8Bit stream accordingly.
; 62   :     //
; 63   :     input   = antlr3CreateFileStream(fileName);

  0000c	8b 45 08	 mov	 eax, DWORD PTR _fileName$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 _antlr3CreateFileStream
  00015	83 c4 04	 add	 esp, 4
  00018	89 45 fc	 mov	 DWORD PTR _input$[ebp], eax

; 64   :     if  (input == NULL)

  0001b	83 7d fc 00	 cmp	 DWORD PTR _input$[ebp], 0
  0001f	75 04		 jne	 SHORT $LN2@antlr3File

; 65   :     {
; 66   :         return NULL;

  00021	33 c0		 xor	 eax, eax
  00023	eb 50		 jmp	 SHORT $LN1@antlr3File
$LN2@antlr3File:

; 67   :     }
; 68   : 
; 69   :     // We have the data in memory now so we can deal with it according to 
; 70   :     // the encoding scheme we were given by the user.
; 71   :     //
; 72   :     input->encoding = encoding;

  00025	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  00028	8b 55 0c	 mov	 edx, DWORD PTR _encoding$[ebp]
  0002b	89 51 78	 mov	 DWORD PTR [ecx+120], edx

; 73   : 
; 74   :     // Now we need to work out the endian type and install any 
; 75   :     // API functions that differ from 8Bit
; 76   :     //
; 77   :     setupInputStream(input);

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 _setupInputStream
  00037	83 c4 04	 add	 esp, 4

; 78   : 
; 79   :     // Now we can set up the file name
; 80   :     //	
; 81   :     input->istream->streamName	= input->strFactory->newStr8(input->strFactory, fileName);

  0003a	8b f4		 mov	 esi, esp
  0003c	8b 4d 08	 mov	 ecx, DWORD PTR _fileName$[ebp]
  0003f	51		 push	 ecx
  00040	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  00043	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00046	50		 push	 eax
  00047	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  0004a	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0004d	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00050	ff d0		 call	 eax
  00052	83 c4 08	 add	 esp, 8
  00055	3b f4		 cmp	 esi, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005c	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  0005f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00061	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 82   :     input->fileName		= input->istream->streamName;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  00067	8b 08		 mov	 ecx, DWORD PTR [eax]
  00069	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  0006c	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0006f	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 83   : 
; 84   :     return input;

  00072	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
$LN1@antlr3File:

; 85   : }

  00075	5e		 pop	 esi
  00076	83 c4 04	 add	 esp, 4
  00079	3b ec		 cmp	 ebp, esp
  0007b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c3		 ret	 0
_antlr3FileStreamNew ENDP
_TEXT	ENDS
END
