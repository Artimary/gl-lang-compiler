; Listing generated by Microsoft (R) Optimizing Compiler Version 19.42.34436.0 

	TITLE	C:\SPO_labs\C\Debug\antlr3commontreeadaptor.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_ANTLR3_TREE_ADAPTORNew
PUBLIC	_ANTLR3_TREE_ADAPTORDebugNew
PUBLIC	??_C@_0BA@IPNBIIJO@Tree?5Error?5Node@		; `string'
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	_antlr3TokenFactoryNew:PROC
EXTRN	_antlr3ArboretumNew:PROC
EXTRN	_antlr3BaseTreeAdaptorInit:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0BA@IPNBIIJO@Tree?5Error?5Node@
CONST	SEGMENT
??_C@_0BA@IPNBIIJO@Tree?5Error?5Node@ DB 'Tree Error Node', 00H ; `string'
CONST	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontreeadaptor.c
;	COMDAT _ctaFree
_TEXT	SEGMENT
_cta$ = -4						; size = 4
_adaptor$ = 8						; size = 4
_ctaFree PROC						; COMDAT

; 217  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 218  :     pANTLR3_COMMON_TREE_ADAPTOR cta;
; 219  : 
; 220  :     cta	= (pANTLR3_COMMON_TREE_ADAPTOR)(adaptor->super);

  0000c	8b 45 08	 mov	 eax, DWORD PTR _adaptor$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	89 4d fc	 mov	 DWORD PTR _cta$[ebp], ecx

; 221  : 
; 222  :     /* Free the tree factory we created
; 223  :      */
; 224  :     cta->arboretum->close(((pANTLR3_COMMON_TREE_ADAPTOR)(adaptor->super))->arboretum);

  00014	8b 55 08	 mov	 edx, DWORD PTR _adaptor$[ebp]
  00017	8b 02		 mov	 eax, DWORD PTR [edx]
  00019	8b f4		 mov	 esi, esp
  0001b	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  00021	51		 push	 ecx
  00022	8b 55 fc	 mov	 edx, DWORD PTR _cta$[ebp]
  00025	8b 82 b0 00 00
	00		 mov	 eax, DWORD PTR [edx+176]
  0002b	8b 88 bc 00 00
	00		 mov	 ecx, DWORD PTR [eax+188]
  00031	ff d1		 call	 ecx
  00033	83 c4 04	 add	 esp, 4
  00036	3b f4		 cmp	 esi, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 225  : 
; 226  :     /* Free the token factory we created
; 227  :      */
; 228  :     adaptor->tokenFactory->close(adaptor->tokenFactory);

  0003d	8b f4		 mov	 esi, esp
  0003f	8b 55 08	 mov	 edx, DWORD PTR _adaptor$[ebp]
  00042	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00045	50		 push	 eax
  00046	8b 4d 08	 mov	 ecx, DWORD PTR _adaptor$[ebp]
  00049	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0004c	8b 82 b0 00 00
	00		 mov	 eax, DWORD PTR [edx+176]
  00052	ff d0		 call	 eax
  00054	83 c4 04	 add	 esp, 4
  00057	3b f4		 cmp	 esi, esp
  00059	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 229  : 
; 230  :     /* Free the super pointer, as it is this that was allocated
; 231  :      * and is the common tree structure.
; 232  :      */
; 233  :     ANTLR3_FREE(adaptor->super);

  0005e	8b f4		 mov	 esi, esp
  00060	8b 4d 08	 mov	 ecx, DWORD PTR _adaptor$[ebp]
  00063	8b 11		 mov	 edx, DWORD PTR [ecx]
  00065	52		 push	 edx
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0006c	83 c4 04	 add	 esp, 4
  0006f	3b f4		 cmp	 esi, esp
  00071	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00076	90		 npad	 1

; 234  : }

  00077	5e		 pop	 esi
  00078	83 c4 04	 add	 esp, 4
  0007b	3b ec		 cmp	 ebp, esp
  0007d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
_ctaFree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontreeadaptor.c
;	COMDAT _getTokenStopIndex
_TEXT	SEGMENT
_adaptor$ = 8						; size = 4
_t$ = 12						; size = 4
_getTokenStopIndex PROC					; COMDAT

; 427  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 428  :     return  ((pANTLR3_COMMON_TREE)(t->super))->stopIndex;

  00003	8b 45 0c	 mov	 eax, DWORD PTR _t$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 429  : }

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
_getTokenStopIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontreeadaptor.c
;	COMDAT _getTokenStartIndex
_TEXT	SEGMENT
_adaptor$ = 8						; size = 4
_t$ = 12						; size = 4
_getTokenStartIndex PROC				; COMDAT

; 421  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 422  :     return  ((pANTLR3_COMMON_TREE)(t->super))->startIndex;

  00003	8b 45 0c	 mov	 eax, DWORD PTR _t$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 423  : }

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
_getTokenStartIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontreeadaptor.c
;	COMDAT _dbgSetTokenBoundaries
_TEXT	SEGMENT
_adaptor$ = 8						; size = 4
_t$ = 12						; size = 4
_startToken$ = 16					; size = 4
_stopToken$ = 20					; size = 4
_dbgSetTokenBoundaries PROC				; COMDAT

; 410  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 411  : 	setTokenBoundaries(adaptor, t, startToken, stopToken);

  00005	8b 45 14	 mov	 eax, DWORD PTR _stopToken$[ebp]
  00008	50		 push	 eax
  00009	8b 4d 10	 mov	 ecx, DWORD PTR _startToken$[ebp]
  0000c	51		 push	 ecx
  0000d	8b 55 0c	 mov	 edx, DWORD PTR _t$[ebp]
  00010	52		 push	 edx
  00011	8b 45 08	 mov	 eax, DWORD PTR _adaptor$[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 _setTokenBoundaries
  0001a	83 c4 10	 add	 esp, 16			; 00000010H

; 412  : 
; 413  : 	if	(t != NULL && startToken != NULL && stopToken != NULL)

  0001d	83 7d 0c 00	 cmp	 DWORD PTR _t$[ebp], 0
  00021	74 64		 je	 SHORT $LN2@dbgSetToke
  00023	83 7d 10 00	 cmp	 DWORD PTR _startToken$[ebp], 0
  00027	74 5e		 je	 SHORT $LN2@dbgSetToke
  00029	83 7d 14 00	 cmp	 DWORD PTR _stopToken$[ebp], 0
  0002d	74 58		 je	 SHORT $LN2@dbgSetToke

; 414  : 	{
; 415  : 		adaptor->debugger->setTokenBoundaries(adaptor->debugger, t, startToken->getTokenIndex(startToken), stopToken->getTokenIndex(stopToken));

  0002f	8b f4		 mov	 esi, esp
  00031	8b 4d 14	 mov	 ecx, DWORD PTR _stopToken$[ebp]
  00034	51		 push	 ecx
  00035	8b 55 14	 mov	 edx, DWORD PTR _stopToken$[ebp]
  00038	8b 42 74	 mov	 eax, DWORD PTR [edx+116]
  0003b	ff d0		 call	 eax
  0003d	83 c4 04	 add	 esp, 4
  00040	3b f4		 cmp	 esi, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b f4		 mov	 esi, esp
  00049	50		 push	 eax
  0004a	8b fc		 mov	 edi, esp
  0004c	8b 4d 10	 mov	 ecx, DWORD PTR _startToken$[ebp]
  0004f	51		 push	 ecx
  00050	8b 55 10	 mov	 edx, DWORD PTR _startToken$[ebp]
  00053	8b 42 74	 mov	 eax, DWORD PTR [edx+116]
  00056	ff d0		 call	 eax
  00058	83 c4 04	 add	 esp, 4
  0005b	3b fc		 cmp	 edi, esp
  0005d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00062	50		 push	 eax
  00063	8b 4d 0c	 mov	 ecx, DWORD PTR _t$[ebp]
  00066	51		 push	 ecx
  00067	8b 55 08	 mov	 edx, DWORD PTR _adaptor$[ebp]
  0006a	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0006d	50		 push	 eax
  0006e	8b 4d 08	 mov	 ecx, DWORD PTR _adaptor$[ebp]
  00071	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00074	8b 82 9c 00 00
	00		 mov	 eax, DWORD PTR [edx+156]
  0007a	ff d0		 call	 eax
  0007c	83 c4 10	 add	 esp, 16			; 00000010H
  0007f	3b f4		 cmp	 esi, esp
  00081	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00086	90		 npad	 1
$LN2@dbgSetToke:

; 416  : 	}
; 417  : }

  00087	5f		 pop	 edi
  00088	5e		 pop	 esi
  00089	3b ec		 cmp	 ebp, esp
  0008b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00090	5d		 pop	 ebp
  00091	c3		 ret	 0
_dbgSetTokenBoundaries ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontreeadaptor.c
;	COMDAT _setTokenBoundaries
_TEXT	SEGMENT
_ct$ = -12						; size = 4
_stop$ = -8						; size = 4
_start$ = -4						; size = 4
_adaptor$ = 8						; size = 4
_t$ = 12						; size = 4
_startToken$ = 16					; size = 4
_stopToken$ = 20					; size = 4
_setTokenBoundaries PROC				; COMDAT

; 373  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000e	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00015	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 374  : 	ANTLR3_MARKER   start;
; 375  : 	ANTLR3_MARKER   stop;
; 376  : 
; 377  : 	pANTLR3_COMMON_TREE	    ct;
; 378  : 
; 379  : 	if	(t == NULL)

  0001c	83 7d 0c 00	 cmp	 DWORD PTR _t$[ebp], 0
  00020	75 02		 jne	 SHORT $LN2@setTokenBo

; 380  : 	{
; 381  : 		return;

  00022	eb 6e		 jmp	 SHORT $LN1@setTokenBo
$LN2@setTokenBo:

; 382  : 	}
; 383  : 
; 384  : 	if	( startToken != NULL)

  00024	83 7d 10 00	 cmp	 DWORD PTR _startToken$[ebp], 0
  00028	74 1d		 je	 SHORT $LN3@setTokenBo

; 385  : 	{
; 386  : 		start = startToken->getTokenIndex(startToken);

  0002a	8b f4		 mov	 esi, esp
  0002c	8b 45 10	 mov	 eax, DWORD PTR _startToken$[ebp]
  0002f	50		 push	 eax
  00030	8b 4d 10	 mov	 ecx, DWORD PTR _startToken$[ebp]
  00033	8b 51 74	 mov	 edx, DWORD PTR [ecx+116]
  00036	ff d2		 call	 edx
  00038	83 c4 04	 add	 esp, 4
  0003b	3b f4		 cmp	 esi, esp
  0003d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00042	89 45 fc	 mov	 DWORD PTR _start$[ebp], eax

; 387  : 	}

  00045	eb 07		 jmp	 SHORT $LN4@setTokenBo
$LN3@setTokenBo:

; 388  : 	else
; 389  : 	{
; 390  : 		start = 0;

  00047	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _start$[ebp], 0
$LN4@setTokenBo:

; 391  : 	}
; 392  : 
; 393  : 	if	( stopToken != NULL)

  0004e	83 7d 14 00	 cmp	 DWORD PTR _stopToken$[ebp], 0
  00052	74 1d		 je	 SHORT $LN5@setTokenBo

; 394  : 	{
; 395  : 		stop = stopToken->getTokenIndex(stopToken);

  00054	8b f4		 mov	 esi, esp
  00056	8b 45 14	 mov	 eax, DWORD PTR _stopToken$[ebp]
  00059	50		 push	 eax
  0005a	8b 4d 14	 mov	 ecx, DWORD PTR _stopToken$[ebp]
  0005d	8b 51 74	 mov	 edx, DWORD PTR [ecx+116]
  00060	ff d2		 call	 edx
  00062	83 c4 04	 add	 esp, 4
  00065	3b f4		 cmp	 esi, esp
  00067	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006c	89 45 f8	 mov	 DWORD PTR _stop$[ebp], eax

; 396  : 	}

  0006f	eb 07		 jmp	 SHORT $LN6@setTokenBo
$LN5@setTokenBo:

; 397  : 	else
; 398  : 	{
; 399  : 		stop = 0;

  00071	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _stop$[ebp], 0
$LN6@setTokenBo:

; 400  : 	}
; 401  : 
; 402  : 	ct	= (pANTLR3_COMMON_TREE)(t->super);

  00078	8b 45 0c	 mov	 eax, DWORD PTR _t$[ebp]
  0007b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007d	89 4d f4	 mov	 DWORD PTR _ct$[ebp], ecx

; 403  : 
; 404  : 	ct->startIndex  = start;

  00080	8b 55 f4	 mov	 edx, DWORD PTR _ct$[ebp]
  00083	8b 45 fc	 mov	 eax, DWORD PTR _start$[ebp]
  00086	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 405  : 	ct->stopIndex   = stop;

  00089	8b 4d f4	 mov	 ecx, DWORD PTR _ct$[ebp]
  0008c	8b 55 f8	 mov	 edx, DWORD PTR _stop$[ebp]
  0008f	89 51 08	 mov	 DWORD PTR [ecx+8], edx
$LN1@setTokenBo:

; 406  : 
; 407  : }

  00092	5e		 pop	 esi
  00093	83 c4 0c	 add	 esp, 12			; 0000000cH
  00096	3b ec		 cmp	 ebp, esp
  00098	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	c3		 ret	 0
_setTokenBoundaries ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontreeadaptor.c
;	COMDAT _errorNode
_TEXT	SEGMENT
_adaptor$ = 8						; size = 4
_ctnstream$ = 12					; size = 4
_startToken$ = 16					; size = 4
_stopToken$ = 20					; size = 4
_e$ = 24						; size = 4
_errorNode PROC						; COMDAT

; 240  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 241  : 	// Use the supplied common tree node stream to get another tree from the factory
; 242  : 	// TODO: Look at creating the erronode as in Java, but this is complicated by the
; 243  : 	// need to track and free the memory allocated to it, so for now, we just
; 244  : 	// want something in the tree that isn't a NULL pointer.
; 245  : 	//
; 246  : 	return (pANTLR3_BASE_TREE)adaptor->createTypeText(adaptor, ANTLR3_TOKEN_INVALID, (pANTLR3_UINT8)"Tree Error Node");

  00004	8b f4		 mov	 esi, esp
  00006	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@IPNBIIJO@Tree?5Error?5Node@
  0000b	6a 00		 push	 0
  0000d	8b 45 08	 mov	 eax, DWORD PTR _adaptor$[ebp]
  00010	50		 push	 eax
  00011	8b 4d 08	 mov	 ecx, DWORD PTR _adaptor$[ebp]
  00014	8b 51 4c	 mov	 edx, DWORD PTR [ecx+76]
  00017	ff d2		 call	 edx
  00019	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001c	3b f4		 cmp	 esi, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 247  : 
; 248  : }

  00023	5e		 pop	 esi
  00024	3b ec		 cmp	 ebp, esp
  00026	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
_errorNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontreeadaptor.c
;	COMDAT _deleteChild
_TEXT	SEGMENT
_adaptor$ = 8						; size = 4
_t$ = 12						; size = 4
_i$ = 16						; size = 4
_deleteChild PROC					; COMDAT

; 466  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 467  : 	t->deleteChild(t, i);

  00004	8b f4		 mov	 esi, esp
  00006	8b 45 10	 mov	 eax, DWORD PTR _i$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _t$[ebp]
  0000d	51		 push	 ecx
  0000e	8b 55 0c	 mov	 edx, DWORD PTR _t$[ebp]
  00011	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00014	ff d0		 call	 eax
  00016	83 c4 08	 add	 esp, 8
  00019	3b f4		 cmp	 esi, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	90		 npad	 1

; 468  : }

  00021	5e		 pop	 esi
  00022	3b ec		 cmp	 ebp, esp
  00024	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
_deleteChild ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontreeadaptor.c
;	COMDAT _setChild
_TEXT	SEGMENT
_adaptor$ = 8						; size = 4
_t$ = 12						; size = 4
_i$ = 16						; size = 4
_child$ = 20						; size = 4
_setChild PROC						; COMDAT

; 460  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 461  : 	t->setChild(t, i, child);

  00004	8b f4		 mov	 esi, esp
  00006	8b 45 14	 mov	 eax, DWORD PTR _child$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR _i$[ebp]
  0000d	51		 push	 ecx
  0000e	8b 55 0c	 mov	 edx, DWORD PTR _t$[ebp]
  00011	52		 push	 edx
  00012	8b 45 0c	 mov	 eax, DWORD PTR _t$[ebp]
  00015	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  00018	ff d1		 call	 ecx
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001d	3b f4		 cmp	 esi, esp
  0001f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00024	90		 npad	 1

; 462  : }

  00025	5e		 pop	 esi
  00026	3b ec		 cmp	 ebp, esp
  00028	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
_setChild ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontreeadaptor.c
;	COMDAT _getParent
_TEXT	SEGMENT
_adaptor$ = 8						; size = 4
_child$ = 12						; size = 4
_getParent PROC						; COMDAT

; 494  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 495  : 	return child->getParent(child);

  00004	8b f4		 mov	 esi, esp
  00006	8b 45 0c	 mov	 eax, DWORD PTR _child$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _child$[ebp]
  0000d	8b 51 48	 mov	 edx, DWORD PTR [ecx+72]
  00010	ff d2		 call	 edx
  00012	83 c4 04	 add	 esp, 4
  00015	3b f4		 cmp	 esi, esp
  00017	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 496  : }

  0001c	5e		 pop	 esi
  0001d	3b ec		 cmp	 ebp, esp
  0001f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
_getParent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontreeadaptor.c
;	COMDAT _setParent
_TEXT	SEGMENT
_adaptor$ = 8						; size = 4
_child$ = 12						; size = 4
_parent$ = 16						; size = 4
_setParent PROC						; COMDAT

; 489  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 490  : 	child->setParent(child, parent);

  00004	8b f4		 mov	 esi, esp
  00006	8b 45 10	 mov	 eax, DWORD PTR _parent$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _child$[ebp]
  0000d	51		 push	 ecx
  0000e	8b 55 0c	 mov	 edx, DWORD PTR _child$[ebp]
  00011	8b 42 4c	 mov	 eax, DWORD PTR [edx+76]
  00014	ff d0		 call	 eax
  00016	83 c4 08	 add	 esp, 8
  00019	3b f4		 cmp	 esi, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	90		 npad	 1

; 491  : }

  00021	5e		 pop	 esi
  00022	3b ec		 cmp	 ebp, esp
  00024	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
_setParent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontreeadaptor.c
;	COMDAT _getChildIndex
_TEXT	SEGMENT
_adaptor$ = 8						; size = 4
_t$ = 12						; size = 4
_getChildIndex PROC					; COMDAT

; 484  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 485  : 	return t->getChildIndex(t);

  00004	8b f4		 mov	 esi, esp
  00006	8b 45 0c	 mov	 eax, DWORD PTR _t$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _t$[ebp]
  0000d	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  00010	ff d2		 call	 edx
  00012	83 c4 04	 add	 esp, 4
  00015	3b f4		 cmp	 esi, esp
  00017	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 486  : }

  0001c	5e		 pop	 esi
  0001d	3b ec		 cmp	 ebp, esp
  0001f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
_getChildIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontreeadaptor.c
;	COMDAT _setChildIndex
_TEXT	SEGMENT
_adaptor$ = 8						; size = 4
_t$ = 12						; size = 4
_i$ = 16						; size = 4
_setChildIndex PROC					; COMDAT

; 478  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 479  : 	t->setChildIndex(t, i);

  00004	8b f4		 mov	 esi, esp
  00006	8b 45 10	 mov	 eax, DWORD PTR _i$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _t$[ebp]
  0000d	51		 push	 ecx
  0000e	8b 55 0c	 mov	 edx, DWORD PTR _t$[ebp]
  00011	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  00014	ff d0		 call	 eax
  00016	83 c4 08	 add	 esp, 8
  00019	3b f4		 cmp	 esi, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	90		 npad	 1

; 480  : }

  00021	5e		 pop	 esi
  00022	3b ec		 cmp	 ebp, esp
  00024	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
_setChildIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontreeadaptor.c
;	COMDAT _setDebugEventListener
_TEXT	SEGMENT
_adaptor$ = 8						; size = 4
_debugger$ = 12						; size = 4
_setDebugEventListener PROC				; COMDAT

; 203  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 204  : 	// Reinitialize as a debug version
; 205  : 	//
; 206  : 	antlr3BaseTreeAdaptorInit(adaptor, debugger);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _debugger$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _adaptor$[ebp]
  0000a	51		 push	 ecx
  0000b	e8 00 00 00 00	 call	 _antlr3BaseTreeAdaptorInit
  00010	83 c4 08	 add	 esp, 8

; 207  : 
; 208  : 	adaptor->create				= (void * (*) (pANTLR3_BASE_TREE_ADAPTOR, pANTLR3_COMMON_TOKEN))

  00013	8b 55 08	 mov	 edx, DWORD PTR _adaptor$[ebp]
  00016	c7 42 40 00 00
	00 00		 mov	 DWORD PTR [edx+64], OFFSET _dbgCreate

; 209  :                                     dbgCreate;
; 210  : 	adaptor->setTokenBoundaries	= (void   (*) (pANTLR3_BASE_TREE_ADAPTOR, void *, pANTLR3_COMMON_TOKEN, pANTLR3_COMMON_TOKEN))

  0001d	8b 45 08	 mov	 eax, DWORD PTR _adaptor$[ebp]
  00020	c7 80 90 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+144], OFFSET _dbgSetTokenBoundaries

; 211  :                                     dbgSetTokenBoundaries;
; 212  : 
; 213  : }

  0002a	3b ec		 cmp	 ebp, esp
  0002c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
_setDebugEventListener ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontreeadaptor.c
;	COMDAT _replaceChildren
_TEXT	SEGMENT
_adaptor$ = 8						; size = 4
_parent$ = 12						; size = 4
_startChildIndex$ = 16					; size = 4
_stopChildIndex$ = 20					; size = 4
_t$ = 24						; size = 4
_replaceChildren PROC					; COMDAT

; 446  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 447  : 	if	(parent != NULL)

  00004	83 7d 0c 00	 cmp	 DWORD PTR _parent$[ebp], 0
  00008	74 25		 je	 SHORT $LN2@replaceChi

; 448  : 	{
; 449  : 		parent->replaceChildren(parent, startChildIndex, stopChildIndex, t);

  0000a	8b f4		 mov	 esi, esp
  0000c	8b 45 18	 mov	 eax, DWORD PTR _t$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 14	 mov	 ecx, DWORD PTR _stopChildIndex$[ebp]
  00013	51		 push	 ecx
  00014	8b 55 10	 mov	 edx, DWORD PTR _startChildIndex$[ebp]
  00017	52		 push	 edx
  00018	8b 45 0c	 mov	 eax, DWORD PTR _parent$[ebp]
  0001b	50		 push	 eax
  0001c	8b 4d 0c	 mov	 ecx, DWORD PTR _parent$[ebp]
  0001f	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00022	ff d2		 call	 edx
  00024	83 c4 10	 add	 esp, 16			; 00000010H
  00027	3b f4		 cmp	 esi, esp
  00029	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002e	90		 npad	 1
$LN2@replaceChi:

; 450  : 	}
; 451  : }

  0002f	5e		 pop	 esi
  00030	3b ec		 cmp	 ebp, esp
  00032	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
_replaceChildren ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontreeadaptor.c
;	COMDAT _getChildCount
_TEXT	SEGMENT
_adaptor$ = 8						; size = 4
_t$ = 12						; size = 4
_getChildCount PROC					; COMDAT

; 472  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 473  : 	return t->getChildCount(t);

  00004	8b f4		 mov	 esi, esp
  00006	8b 45 0c	 mov	 eax, DWORD PTR _t$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _t$[ebp]
  0000d	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  00010	ff d2		 call	 edx
  00012	83 c4 04	 add	 esp, 4
  00015	3b f4		 cmp	 esi, esp
  00017	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 474  : }

  0001c	5e		 pop	 esi
  0001d	3b ec		 cmp	 ebp, esp
  0001f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
_getChildCount ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontreeadaptor.c
;	COMDAT _getChild
_TEXT	SEGMENT
_adaptor$ = 8						; size = 4
_t$ = 12						; size = 4
_i$ = 16						; size = 4
_getChild PROC						; COMDAT

; 455  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 456  : 	return (pANTLR3_BASE_TREE)t->getChild(t, i);

  00004	8b f4		 mov	 esi, esp
  00006	8b 45 10	 mov	 eax, DWORD PTR _i$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _t$[ebp]
  0000d	51		 push	 ecx
  0000e	8b 55 0c	 mov	 edx, DWORD PTR _t$[ebp]
  00011	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  00014	ff d0		 call	 eax
  00016	83 c4 08	 add	 esp, 8
  00019	3b f4		 cmp	 esi, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 457  : }

  00020	5e		 pop	 esi
  00021	3b ec		 cmp	 ebp, esp
  00023	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
_getChild ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontreeadaptor.c
;	COMDAT _getType
_TEXT	SEGMENT
_adaptor$ = 8						; size = 4
_t$ = 12						; size = 4
_getType PROC						; COMDAT

; 439  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 440  :     return  t->getType(t);

  00004	8b f4		 mov	 esi, esp
  00006	8b 45 0c	 mov	 eax, DWORD PTR _t$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _t$[ebp]
  0000d	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  00010	ff d2		 call	 edx
  00012	83 c4 04	 add	 esp, 4
  00015	3b f4		 cmp	 esi, esp
  00017	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 441  : }

  0001c	5e		 pop	 esi
  0001d	3b ec		 cmp	 ebp, esp
  0001f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
_getType ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontreeadaptor.c
;	COMDAT _getText
_TEXT	SEGMENT
_adaptor$ = 8						; size = 4
_t$ = 12						; size = 4
_getText PROC						; COMDAT

; 433  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 434  :     return  t->getText(t);

  00004	8b f4		 mov	 esi, esp
  00006	8b 45 0c	 mov	 eax, DWORD PTR _t$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _t$[ebp]
  0000d	8b 51 5c	 mov	 edx, DWORD PTR [ecx+92]
  00010	ff d2		 call	 edx
  00012	83 c4 04	 add	 esp, 4
  00015	3b f4		 cmp	 esi, esp
  00017	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 435  : }

  0001c	5e		 pop	 esi
  0001d	3b ec		 cmp	 ebp, esp
  0001f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
_getText ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontreeadaptor.c
;	COMDAT _createTokenFromToken
_TEXT	SEGMENT
_text$1 = -8						; size = 4
_newToken$ = -4						; size = 4
_adaptor$ = 8						; size = 4
_fromToken$ = 12					; size = 4
_createTokenFromToken PROC				; COMDAT

; 328  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 329  :     pANTLR3_COMMON_TOKEN    newToken;
; 330  : 
; 331  :     newToken	= adaptor->tokenFactory->newToken(adaptor->tokenFactory);

  00015	8b f4		 mov	 esi, esp
  00017	8b 45 08	 mov	 eax, DWORD PTR _adaptor$[ebp]
  0001a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0001d	51		 push	 ecx
  0001e	8b 55 08	 mov	 edx, DWORD PTR _adaptor$[ebp]
  00021	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00024	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  0002a	ff d1		 call	 ecx
  0002c	83 c4 04	 add	 esp, 4
  0002f	3b f4		 cmp	 esi, esp
  00031	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00036	89 45 fc	 mov	 DWORD PTR _newToken$[ebp], eax

; 332  :     
; 333  :     if	(newToken != NULL)

  00039	83 7d fc 00	 cmp	 DWORD PTR _newToken$[ebp], 0
  0003d	0f 84 80 01 00
	00		 je	 $LN2@createToke

; 334  :     {
; 335  : 		// Create the text using our own string factory to avoid complicating
; 336  : 		// commontoken.
; 337  : 		//
; 338  : 		pANTLR3_STRING	text;
; 339  : 
; 340  : 		newToken->toString  = fromToken->toString;

  00043	8b 55 fc	 mov	 edx, DWORD PTR _newToken$[ebp]
  00046	8b 45 0c	 mov	 eax, DWORD PTR _fromToken$[ebp]
  00049	8b 88 8c 00 00
	00		 mov	 ecx, DWORD PTR [eax+140]
  0004f	89 8a 8c 00 00
	00		 mov	 DWORD PTR [edx+140], ecx

; 341  : 
; 342  : 		if	(fromToken->textState == ANTLR3_TEXT_CHARP)

  00055	8b 55 0c	 mov	 edx, DWORD PTR _fromToken$[ebp]
  00058	83 7a 2c 01	 cmp	 DWORD PTR [edx+44], 1
  0005c	75 18		 jne	 SHORT $LN3@createToke

; 343  : 		{
; 344  : 			newToken->textState		= ANTLR3_TEXT_CHARP;

  0005e	8b 45 fc	 mov	 eax, DWORD PTR _newToken$[ebp]
  00061	c7 40 2c 01 00
	00 00		 mov	 DWORD PTR [eax+44], 1

; 345  : 			newToken->tokText.chars	= fromToken->tokText.chars;

  00068	8b 4d fc	 mov	 ecx, DWORD PTR _newToken$[ebp]
  0006b	8b 55 0c	 mov	 edx, DWORD PTR _fromToken$[ebp]
  0006e	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  00071	89 41 30	 mov	 DWORD PTR [ecx+48], eax

; 346  : 		}

  00074	eb 57		 jmp	 SHORT $LN4@createToke
$LN3@createToke:

; 347  : 		else
; 348  : 		{
; 349  : 			text						= fromToken->getText(fromToken);

  00076	8b f4		 mov	 esi, esp
  00078	8b 4d 0c	 mov	 ecx, DWORD PTR _fromToken$[ebp]
  0007b	51		 push	 ecx
  0007c	8b 55 0c	 mov	 edx, DWORD PTR _fromToken$[ebp]
  0007f	8b 42 48	 mov	 eax, DWORD PTR [edx+72]
  00082	ff d0		 call	 eax
  00084	83 c4 04	 add	 esp, 4
  00087	3b f4		 cmp	 esi, esp
  00089	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008e	89 45 f8	 mov	 DWORD PTR _text$1[ebp], eax

; 350  : 			newToken->textState			= ANTLR3_TEXT_STRING;

  00091	8b 4d fc	 mov	 ecx, DWORD PTR _newToken$[ebp]
  00094	c7 41 2c 02 00
	00 00		 mov	 DWORD PTR [ecx+44], 2

; 351  : 			newToken->tokText.text	    = adaptor->strFactory->newPtr(adaptor->strFactory, text->chars, text->len);

  0009b	8b f4		 mov	 esi, esp
  0009d	8b 55 f8	 mov	 edx, DWORD PTR _text$1[ebp]
  000a0	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000a3	50		 push	 eax
  000a4	8b 4d f8	 mov	 ecx, DWORD PTR _text$1[ebp]
  000a7	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000aa	52		 push	 edx
  000ab	8b 45 08	 mov	 eax, DWORD PTR _adaptor$[ebp]
  000ae	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000b1	51		 push	 ecx
  000b2	8b 55 08	 mov	 edx, DWORD PTR _adaptor$[ebp]
  000b5	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000b8	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  000bb	ff d1		 call	 ecx
  000bd	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c0	3b f4		 cmp	 esi, esp
  000c2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c7	8b 55 fc	 mov	 edx, DWORD PTR _newToken$[ebp]
  000ca	89 42 30	 mov	 DWORD PTR [edx+48], eax
$LN4@createToke:

; 352  : 		}
; 353  : 
; 354  : 		newToken->setLine				(newToken, fromToken->getLine(fromToken));

  000cd	8b f4		 mov	 esi, esp
  000cf	8b 45 0c	 mov	 eax, DWORD PTR _fromToken$[ebp]
  000d2	50		 push	 eax
  000d3	8b 4d 0c	 mov	 ecx, DWORD PTR _fromToken$[ebp]
  000d6	8b 51 5c	 mov	 edx, DWORD PTR [ecx+92]
  000d9	ff d2		 call	 edx
  000db	83 c4 04	 add	 esp, 4
  000de	3b f4		 cmp	 esi, esp
  000e0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e5	8b f4		 mov	 esi, esp
  000e7	50		 push	 eax
  000e8	8b 45 fc	 mov	 eax, DWORD PTR _newToken$[ebp]
  000eb	50		 push	 eax
  000ec	8b 4d fc	 mov	 ecx, DWORD PTR _newToken$[ebp]
  000ef	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  000f2	ff d2		 call	 edx
  000f4	83 c4 08	 add	 esp, 8
  000f7	3b f4		 cmp	 esi, esp
  000f9	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 355  : 		newToken->setTokenIndex			(newToken, fromToken->getTokenIndex(fromToken));

  000fe	8b f4		 mov	 esi, esp
  00100	8b 45 0c	 mov	 eax, DWORD PTR _fromToken$[ebp]
  00103	50		 push	 eax
  00104	8b 4d 0c	 mov	 ecx, DWORD PTR _fromToken$[ebp]
  00107	8b 51 74	 mov	 edx, DWORD PTR [ecx+116]
  0010a	ff d2		 call	 edx
  0010c	83 c4 04	 add	 esp, 4
  0010f	3b f4		 cmp	 esi, esp
  00111	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00116	8b f4		 mov	 esi, esp
  00118	50		 push	 eax
  00119	8b 45 fc	 mov	 eax, DWORD PTR _newToken$[ebp]
  0011c	50		 push	 eax
  0011d	8b 4d fc	 mov	 ecx, DWORD PTR _newToken$[ebp]
  00120	8b 51 78	 mov	 edx, DWORD PTR [ecx+120]
  00123	ff d2		 call	 edx
  00125	83 c4 08	 add	 esp, 8
  00128	3b f4		 cmp	 esi, esp
  0012a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 356  : 		newToken->setCharPositionInLine	(newToken, fromToken->getCharPositionInLine(fromToken));

  0012f	8b f4		 mov	 esi, esp
  00131	8b 45 0c	 mov	 eax, DWORD PTR _fromToken$[ebp]
  00134	50		 push	 eax
  00135	8b 4d 0c	 mov	 ecx, DWORD PTR _fromToken$[ebp]
  00138	8b 51 64	 mov	 edx, DWORD PTR [ecx+100]
  0013b	ff d2		 call	 edx
  0013d	83 c4 04	 add	 esp, 4
  00140	3b f4		 cmp	 esi, esp
  00142	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00147	8b f4		 mov	 esi, esp
  00149	50		 push	 eax
  0014a	8b 45 fc	 mov	 eax, DWORD PTR _newToken$[ebp]
  0014d	50		 push	 eax
  0014e	8b 4d fc	 mov	 ecx, DWORD PTR _newToken$[ebp]
  00151	8b 51 68	 mov	 edx, DWORD PTR [ecx+104]
  00154	ff d2		 call	 edx
  00156	83 c4 08	 add	 esp, 8
  00159	3b f4		 cmp	 esi, esp
  0015b	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 357  : 		newToken->setChannel			(newToken, fromToken->getChannel(fromToken));

  00160	8b f4		 mov	 esi, esp
  00162	8b 45 0c	 mov	 eax, DWORD PTR _fromToken$[ebp]
  00165	50		 push	 eax
  00166	8b 4d 0c	 mov	 ecx, DWORD PTR _fromToken$[ebp]
  00169	8b 51 6c	 mov	 edx, DWORD PTR [ecx+108]
  0016c	ff d2		 call	 edx
  0016e	83 c4 04	 add	 esp, 4
  00171	3b f4		 cmp	 esi, esp
  00173	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00178	8b f4		 mov	 esi, esp
  0017a	50		 push	 eax
  0017b	8b 45 fc	 mov	 eax, DWORD PTR _newToken$[ebp]
  0017e	50		 push	 eax
  0017f	8b 4d fc	 mov	 ecx, DWORD PTR _newToken$[ebp]
  00182	8b 51 70	 mov	 edx, DWORD PTR [ecx+112]
  00185	ff d2		 call	 edx
  00187	83 c4 08	 add	 esp, 8
  0018a	3b f4		 cmp	 esi, esp
  0018c	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 358  : 		newToken->setType				(newToken, fromToken->getType(fromToken));

  00191	8b f4		 mov	 esi, esp
  00193	8b 45 0c	 mov	 eax, DWORD PTR _fromToken$[ebp]
  00196	50		 push	 eax
  00197	8b 4d 0c	 mov	 ecx, DWORD PTR _fromToken$[ebp]
  0019a	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  0019d	ff d2		 call	 edx
  0019f	83 c4 04	 add	 esp, 4
  001a2	3b f4		 cmp	 esi, esp
  001a4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001a9	8b f4		 mov	 esi, esp
  001ab	50		 push	 eax
  001ac	8b 45 fc	 mov	 eax, DWORD PTR _newToken$[ebp]
  001af	50		 push	 eax
  001b0	8b 4d fc	 mov	 ecx, DWORD PTR _newToken$[ebp]
  001b3	8b 51 58	 mov	 edx, DWORD PTR [ecx+88]
  001b6	ff d2		 call	 edx
  001b8	83 c4 08	 add	 esp, 8
  001bb	3b f4		 cmp	 esi, esp
  001bd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001c2	90		 npad	 1
$LN2@createToke:

; 359  :     }
; 360  : 
; 361  :     return  newToken;

  001c3	8b 45 fc	 mov	 eax, DWORD PTR _newToken$[ebp]

; 362  : }

  001c6	5e		 pop	 esi
  001c7	83 c4 08	 add	 esp, 8
  001ca	3b ec		 cmp	 ebp, esp
  001cc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001d1	8b e5		 mov	 esp, ebp
  001d3	5d		 pop	 ebp
  001d4	c3		 ret	 0
_createTokenFromToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontreeadaptor.c
;	COMDAT _createToken
_TEXT	SEGMENT
_newToken$ = -4						; size = 4
_adaptor$ = 8						; size = 4
_tokenType$ = 12					; size = 4
_text$ = 16						; size = 4
_createToken PROC					; COMDAT

; 292  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 293  :     pANTLR3_COMMON_TOKEN    newToken;
; 294  : 
; 295  :     newToken	= adaptor->tokenFactory->newToken(adaptor->tokenFactory);

  0000c	8b f4		 mov	 esi, esp
  0000e	8b 45 08	 mov	 eax, DWORD PTR _adaptor$[ebp]
  00011	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00014	51		 push	 ecx
  00015	8b 55 08	 mov	 edx, DWORD PTR _adaptor$[ebp]
  00018	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0001b	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00021	ff d1		 call	 ecx
  00023	83 c4 04	 add	 esp, 4
  00026	3b f4		 cmp	 esi, esp
  00028	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002d	89 45 fc	 mov	 DWORD PTR _newToken$[ebp], eax

; 296  : 
; 297  :     if	(newToken != NULL)

  00030	83 7d fc 00	 cmp	 DWORD PTR _newToken$[ebp], 0
  00034	74 4d		 je	 SHORT $LN2@createToke

; 298  :     {	
; 299  : 		newToken->textState		= ANTLR3_TEXT_CHARP;

  00036	8b 55 fc	 mov	 edx, DWORD PTR _newToken$[ebp]
  00039	c7 42 2c 01 00
	00 00		 mov	 DWORD PTR [edx+44], 1

; 300  : 		newToken->tokText.chars = (pANTLR3_UCHAR)text;

  00040	8b 45 fc	 mov	 eax, DWORD PTR _newToken$[ebp]
  00043	8b 4d 10	 mov	 ecx, DWORD PTR _text$[ebp]
  00046	89 48 30	 mov	 DWORD PTR [eax+48], ecx

; 301  : 		newToken->setType(newToken, tokenType);

  00049	8b f4		 mov	 esi, esp
  0004b	8b 55 0c	 mov	 edx, DWORD PTR _tokenType$[ebp]
  0004e	52		 push	 edx
  0004f	8b 45 fc	 mov	 eax, DWORD PTR _newToken$[ebp]
  00052	50		 push	 eax
  00053	8b 4d fc	 mov	 ecx, DWORD PTR _newToken$[ebp]
  00056	8b 51 58	 mov	 edx, DWORD PTR [ecx+88]
  00059	ff d2		 call	 edx
  0005b	83 c4 08	 add	 esp, 8
  0005e	3b f4		 cmp	 esi, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 302  : 		newToken->input				= adaptor->tokenFactory->input;

  00065	8b 45 08	 mov	 eax, DWORD PTR _adaptor$[ebp]
  00068	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0006b	8b 55 fc	 mov	 edx, DWORD PTR _newToken$[ebp]
  0006e	8b 81 a0 00 00
	00		 mov	 eax, DWORD PTR [ecx+160]
  00074	89 42 1c	 mov	 DWORD PTR [edx+28], eax

; 303  :         newToken->strFactory        = adaptor->strFactory;

  00077	8b 4d fc	 mov	 ecx, DWORD PTR _newToken$[ebp]
  0007a	8b 55 08	 mov	 edx, DWORD PTR _adaptor$[ebp]
  0007d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00080	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN2@createToke:

; 304  :     }
; 305  :     return  newToken;

  00083	8b 45 fc	 mov	 eax, DWORD PTR _newToken$[ebp]

; 306  : }

  00086	5e		 pop	 esi
  00087	83 c4 04	 add	 esp, 4
  0008a	3b ec		 cmp	 ebp, esp
  0008c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c3		 ret	 0
_createToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontreeadaptor.c
;	COMDAT _dbgCreate
_TEXT	SEGMENT
_ct$ = -4						; size = 4
_adaptor$ = 8						; size = 4
_payload$ = 12						; size = 4
_dbgCreate PROC						; COMDAT

; 273  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 274  : 	pANTLR3_BASE_TREE	ct;
; 275  : 
; 276  : 	ct = create(adaptor, payload);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR _payload$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _adaptor$[ebp]
  00013	51		 push	 ecx
  00014	e8 00 00 00 00	 call	 _create
  00019	83 c4 08	 add	 esp, 8
  0001c	89 45 fc	 mov	 DWORD PTR _ct$[ebp], eax

; 277  : 	adaptor->debugger->createNode(adaptor->debugger, ct);

  0001f	8b f4		 mov	 esi, esp
  00021	8b 55 fc	 mov	 edx, DWORD PTR _ct$[ebp]
  00024	52		 push	 edx
  00025	8b 45 08	 mov	 eax, DWORD PTR _adaptor$[ebp]
  00028	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0002b	51		 push	 ecx
  0002c	8b 55 08	 mov	 edx, DWORD PTR _adaptor$[ebp]
  0002f	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00032	8b 88 8c 00 00
	00		 mov	 ecx, DWORD PTR [eax+140]
  00038	ff d1		 call	 ecx
  0003a	83 c4 08	 add	 esp, 8
  0003d	3b f4		 cmp	 esi, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 278  : 
; 279  : 	return ct;

  00044	8b 45 fc	 mov	 eax, DWORD PTR _ct$[ebp]

; 280  : }

  00047	5e		 pop	 esi
  00048	83 c4 04	 add	 esp, 4
  0004b	3b ec		 cmp	 ebp, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
_dbgCreate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontreeadaptor.c
;	COMDAT _create
_TEXT	SEGMENT
_ct$ = -4						; size = 4
_adaptor$ = 8						; size = 4
_payload$ = 12						; size = 4
_create	PROC						; COMDAT

; 260  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 261  :     pANTLR3_BASE_TREE	ct;
; 262  :     
; 263  :     /* Create a new common tree as this is what this adaptor deals with
; 264  :      */
; 265  :     ct = ((pANTLR3_COMMON_TREE_ADAPTOR)(adaptor->super))->arboretum->newFromToken(((pANTLR3_COMMON_TREE_ADAPTOR)(adaptor->super))->arboretum, payload);

  0000c	8b f4		 mov	 esi, esp
  0000e	8b 45 0c	 mov	 eax, DWORD PTR _payload$[ebp]
  00011	50		 push	 eax
  00012	8b 4d 08	 mov	 ecx, DWORD PTR _adaptor$[ebp]
  00015	8b 11		 mov	 edx, DWORD PTR [ecx]
  00017	8b 82 b0 00 00
	00		 mov	 eax, DWORD PTR [edx+176]
  0001d	50		 push	 eax
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR _adaptor$[ebp]
  00021	8b 11		 mov	 edx, DWORD PTR [ecx]
  00023	8b 82 b0 00 00
	00		 mov	 eax, DWORD PTR [edx+176]
  00029	8b 88 b8 00 00
	00		 mov	 ecx, DWORD PTR [eax+184]
  0002f	ff d1		 call	 ecx
  00031	83 c4 08	 add	 esp, 8
  00034	3b f4		 cmp	 esi, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	89 45 fc	 mov	 DWORD PTR _ct$[ebp], eax

; 266  : 
; 267  :     /* But all adaptors return the pointer to the base interface.
; 268  :      */
; 269  :     return  ct;

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _ct$[ebp]

; 270  : }

  00041	5e		 pop	 esi
  00042	83 c4 04	 add	 esp, 4
  00045	3b ec		 cmp	 ebp, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
_create	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontreeadaptor.c
;	COMDAT _dupNode
_TEXT	SEGMENT
tv68 = -4						; size = 4
_adaptor$ = 8						; size = 4
_treeNode$ = 12						; size = 4
_dupNode PROC						; COMDAT

; 254  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 255  : 	return  treeNode == NULL ? NULL : (pANTLR3_BASE_TREE)treeNode->dupNode(treeNode);

  0000c	83 7d 0c 00	 cmp	 DWORD PTR _treeNode$[ebp], 0
  00010	75 09		 jne	 SHORT $LN3@dupNode
  00012	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
  00019	eb 1b		 jmp	 SHORT $LN4@dupNode
$LN3@dupNode:
  0001b	8b f4		 mov	 esi, esp
  0001d	8b 45 0c	 mov	 eax, DWORD PTR _treeNode$[ebp]
  00020	50		 push	 eax
  00021	8b 4d 0c	 mov	 ecx, DWORD PTR _treeNode$[ebp]
  00024	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00027	ff d2		 call	 edx
  00029	83 c4 04	 add	 esp, 4
  0002c	3b f4		 cmp	 esi, esp
  0002e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00033	89 45 fc	 mov	 DWORD PTR tv68[ebp], eax
$LN4@dupNode:
  00036	8b 45 fc	 mov	 eax, DWORD PTR tv68[ebp]

; 256  : }

  00039	5e		 pop	 esi
  0003a	83 c4 04	 add	 esp, 4
  0003d	3b ec		 cmp	 ebp, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
_dupNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontreeadaptor.c
;	COMDAT _ANTLR3_TREE_ADAPTORDebugNew
_TEXT	SEGMENT
_ta$ = -4						; size = 4
_strFactory$ = 8					; size = 4
_debugger$ = 12						; size = 4
_ANTLR3_TREE_ADAPTORDebugNew PROC			; COMDAT

; 178  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 179  : 	pANTLR3_BASE_TREE_ADAPTOR	ta;
; 180  : 
; 181  : 	// Create a normal one first
; 182  : 	//
; 183  : 	ta	= ANTLR3_TREE_ADAPTORNew(strFactory);

  0000b	8b 45 08	 mov	 eax, DWORD PTR _strFactory$[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 _ANTLR3_TREE_ADAPTORNew
  00014	83 c4 04	 add	 esp, 4
  00017	89 45 fc	 mov	 DWORD PTR _ta$[ebp], eax

; 184  : 	
; 185  : 	if	(ta != NULL)

  0001a	83 7d fc 00	 cmp	 DWORD PTR _ta$[ebp], 0
  0001e	74 27		 je	 SHORT $LN2@ANTLR3_TRE

; 186  : 	{
; 187  : 		// Reinitialize as a debug version
; 188  : 		//
; 189  : 		antlr3BaseTreeAdaptorInit(ta, debugger);

  00020	8b 4d 0c	 mov	 ecx, DWORD PTR _debugger$[ebp]
  00023	51		 push	 ecx
  00024	8b 55 fc	 mov	 edx, DWORD PTR _ta$[ebp]
  00027	52		 push	 edx
  00028	e8 00 00 00 00	 call	 _antlr3BaseTreeAdaptorInit
  0002d	83 c4 08	 add	 esp, 8

; 190  : 		ta->create				= (void * (*) (pANTLR3_BASE_TREE_ADAPTOR, pANTLR3_COMMON_TOKEN))

  00030	8b 45 fc	 mov	 eax, DWORD PTR _ta$[ebp]
  00033	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [eax+64], OFFSET _dbgCreate

; 191  : 									dbgCreate;
; 192  : 		ta->setTokenBoundaries	= (void   (*) (pANTLR3_BASE_TREE_ADAPTOR, void *, pANTLR3_COMMON_TOKEN, pANTLR3_COMMON_TOKEN))

  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _ta$[ebp]
  0003d	c7 81 90 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+144], OFFSET _dbgSetTokenBoundaries
$LN2@ANTLR3_TRE:

; 193  : 									dbgSetTokenBoundaries;
; 194  : 	}
; 195  : 
; 196  : 	return	ta;

  00047	8b 45 fc	 mov	 eax, DWORD PTR _ta$[ebp]

; 197  : }

  0004a	83 c4 04	 add	 esp, 4
  0004d	3b ec		 cmp	 ebp, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
_ANTLR3_TREE_ADAPTORDebugNew ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontreeadaptor.c
;	COMDAT _ANTLR3_TREE_ADAPTORNew
_TEXT	SEGMENT
_cta$ = -4						; size = 4
_strFactory$ = 8					; size = 4
_ANTLR3_TREE_ADAPTORNew PROC				; COMDAT

; 85   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 86   : 	pANTLR3_COMMON_TREE_ADAPTOR	cta;
; 87   : 
; 88   : 	// First job is to create the memory we need for the tree adaptor interface.
; 89   : 	//
; 90   : 	cta	= (pANTLR3_COMMON_TREE_ADAPTOR) ANTLR3_MALLOC((size_t)(sizeof(ANTLR3_COMMON_TREE_ADAPTOR)));

  0000c	8b f4		 mov	 esi, esp
  0000e	68 b4 00 00 00	 push	 180			; 000000b4H
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00019	83 c4 04	 add	 esp, 4
  0001c	3b f4		 cmp	 esi, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	89 45 fc	 mov	 DWORD PTR _cta$[ebp], eax

; 91   : 
; 92   : 	if	(cta == NULL)

  00026	83 7d fc 00	 cmp	 DWORD PTR _cta$[ebp], 0
  0002a	75 07		 jne	 SHORT $LN2@ANTLR3_TRE

; 93   : 	{
; 94   : 		return	NULL;

  0002c	33 c0		 xor	 eax, eax
  0002e	e9 47 01 00 00	 jmp	 $LN1@ANTLR3_TRE
$LN2@ANTLR3_TRE:

; 95   : 	}
; 96   : 
; 97   : 	// Memory is initialized, so initialize the base tree adaptor
; 98   : 	//
; 99   : 	antlr3BaseTreeAdaptorInit(&(cta->baseAdaptor), NULL);

  00033	6a 00		 push	 0
  00035	8b 45 fc	 mov	 eax, DWORD PTR _cta$[ebp]
  00038	83 c0 04	 add	 eax, 4
  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 _antlr3BaseTreeAdaptorInit
  00041	83 c4 08	 add	 esp, 8

; 100  : 
; 101  : 	// Install our interface overrides. Strangeness is to allow generated code to treat them
; 102  :     // as returning void *
; 103  : 	//
; 104  : 	cta->baseAdaptor.dupNode				=  (void * (*) (pANTLR3_BASE_TREE_ADAPTOR, void *))

  00044	8b 4d fc	 mov	 ecx, DWORD PTR _cta$[ebp]
  00047	c7 41 54 00 00
	00 00		 mov	 DWORD PTR [ecx+84], OFFSET _dupNode

; 105  : 													dupNode;
; 106  : 	cta->baseAdaptor.create					=  (void * (*) (pANTLR3_BASE_TREE_ADAPTOR, pANTLR3_COMMON_TOKEN))

  0004e	8b 55 fc	 mov	 edx, DWORD PTR _cta$[ebp]
  00051	c7 42 44 00 00
	00 00		 mov	 DWORD PTR [edx+68], OFFSET _create

; 107  : 													create;
; 108  : 	cta->baseAdaptor.createToken			=  

  00058	8b 45 fc	 mov	 eax, DWORD PTR _cta$[ebp]
  0005b	c7 80 88 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+136], OFFSET _createToken

; 109  : 													createToken;
; 110  : 	cta->baseAdaptor.createTokenFromToken   =  

  00065	8b 4d fc	 mov	 ecx, DWORD PTR _cta$[ebp]
  00068	c7 81 8c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+140], OFFSET _createTokenFromToken

; 111  : 													createTokenFromToken;
; 112  : 	cta->baseAdaptor.setTokenBoundaries	    =  (void   (*) (pANTLR3_BASE_TREE_ADAPTOR, void *, pANTLR3_COMMON_TOKEN, pANTLR3_COMMON_TOKEN))

  00072	8b 55 fc	 mov	 edx, DWORD PTR _cta$[ebp]
  00075	c7 82 94 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+148], OFFSET _setTokenBoundaries

; 113  : 													setTokenBoundaries;
; 114  : 	cta->baseAdaptor.getTokenStartIndex	    =  (ANTLR3_MARKER  (*) (pANTLR3_BASE_TREE_ADAPTOR, void *))

  0007f	8b 45 fc	 mov	 eax, DWORD PTR _cta$[ebp]
  00082	c7 80 98 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+152], OFFSET _getTokenStartIndex

; 115  :                                                     getTokenStartIndex;
; 116  : 	cta->baseAdaptor.getTokenStopIndex	    =  (ANTLR3_MARKER  (*) (pANTLR3_BASE_TREE_ADAPTOR, void *))

  0008c	8b 4d fc	 mov	 ecx, DWORD PTR _cta$[ebp]
  0008f	c7 81 9c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+156], OFFSET _getTokenStopIndex

; 117  :                                                     getTokenStopIndex;
; 118  : 	cta->baseAdaptor.getText				=  (pANTLR3_STRING (*) (pANTLR3_BASE_TREE_ADAPTOR, void *))

  00099	8b 55 fc	 mov	 edx, DWORD PTR _cta$[ebp]
  0009c	c7 42 60 00 00
	00 00		 mov	 DWORD PTR [edx+96], OFFSET _getText

; 119  :                                                     getText;
; 120  : 	cta->baseAdaptor.getType				=  (ANTLR3_UINT32  (*) (pANTLR3_BASE_TREE_ADAPTOR, void *))

  000a3	8b 45 fc	 mov	 eax, DWORD PTR _cta$[ebp]
  000a6	c7 40 58 00 00
	00 00		 mov	 DWORD PTR [eax+88], OFFSET _getType

; 121  :                                                     getType;
; 122  : 	cta->baseAdaptor.getChild				=  (void * (*) (pANTLR3_BASE_TREE_ADAPTOR, void *, ANTLR3_UINT32))

  000ad	8b 4d fc	 mov	 ecx, DWORD PTR _cta$[ebp]
  000b0	c7 41 6c 00 00
	00 00		 mov	 DWORD PTR [ecx+108], OFFSET _getChild

; 123  :                                                     getChild;
; 124  : 	cta->baseAdaptor.setChild				=  (void   (*) (pANTLR3_BASE_TREE_ADAPTOR, void *, ANTLR3_UINT32, void *))

  000b7	8b 55 fc	 mov	 edx, DWORD PTR _cta$[ebp]
  000ba	c7 42 70 00 00
	00 00		 mov	 DWORD PTR [edx+112], OFFSET _setChild

; 125  :                                                     setChild;
; 126  : 	cta->baseAdaptor.setParent				=  (void   (*) (pANTLR3_BASE_TREE_ADAPTOR, void *, void *))

  000c1	8b 45 fc	 mov	 eax, DWORD PTR _cta$[ebp]
  000c4	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [eax+40], OFFSET _setParent

; 127  :                                                     setParent;
; 128  :     cta->baseAdaptor.getParent				=  (void * (*) (pANTLR3_BASE_TREE_ADAPTOR, void *))

  000cb	8b 4d fc	 mov	 ecx, DWORD PTR _cta$[ebp]
  000ce	c7 41 2c 00 00
	00 00		 mov	 DWORD PTR [ecx+44], OFFSET _getParent

; 129  :                                                     getParent;
; 130  : 	cta->baseAdaptor.setChildIndex			=  (void   (*) (pANTLR3_BASE_TREE_ADAPTOR, void *, ANTLR3_UINT32))

  000d5	8b 55 fc	 mov	 edx, DWORD PTR _cta$[ebp]
  000d8	c7 42 78 00 00
	00 00		 mov	 DWORD PTR [edx+120], OFFSET _setChildIndex

; 131  :                                                     setChildIndex;
; 132  : 	cta->baseAdaptor.deleteChild			=  (void   (*) (pANTLR3_BASE_TREE_ADAPTOR, void *, ANTLR3_UINT32))

  000df	8b 45 fc	 mov	 eax, DWORD PTR _cta$[ebp]
  000e2	c7 40 74 00 00
	00 00		 mov	 DWORD PTR [eax+116], OFFSET _deleteChild

; 133  :                                                     deleteChild;
; 134  : 	cta->baseAdaptor.getChildCount			=  (ANTLR3_UINT32  (*) (pANTLR3_BASE_TREE_ADAPTOR, void *))

  000e9	8b 4d fc	 mov	 ecx, DWORD PTR _cta$[ebp]
  000ec	c7 81 80 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+128], OFFSET _getChildCount

; 135  :                                                     getChildCount;
; 136  : 	cta->baseAdaptor.getChildIndex			=  (ANTLR3_INT32  (*) (pANTLR3_BASE_TREE_ADAPTOR, void *))

  000f6	8b 55 fc	 mov	 edx, DWORD PTR _cta$[ebp]
  000f9	c7 42 7c 00 00
	00 00		 mov	 DWORD PTR [edx+124], OFFSET _getChildIndex

; 137  :                                                     getChildIndex;
; 138  : 	cta->baseAdaptor.free					=  (void  (*) (pANTLR3_BASE_TREE_ADAPTOR))

  00100	8b 45 fc	 mov	 eax, DWORD PTR _cta$[ebp]
  00103	c7 80 ac 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+172], OFFSET _ctaFree

; 139  :                                                     ctaFree;
; 140  : 	cta->baseAdaptor.setDebugEventListener	=  

  0010d	8b 4d fc	 mov	 ecx, DWORD PTR _cta$[ebp]
  00110	c7 81 a0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+160], OFFSET _setDebugEventListener

; 141  : 													setDebugEventListener;
; 142  : 	cta->baseAdaptor.replaceChildren		=  (void   (*) (pANTLR3_BASE_TREE_ADAPTOR, void *, ANTLR3_INT32, ANTLR3_INT32, void *))

  0011a	8b 55 fc	 mov	 edx, DWORD PTR _cta$[ebp]
  0011d	c7 82 a8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+168], OFFSET _replaceChildren

; 143  :                                                     replaceChildren;
; 144  : 	cta->baseAdaptor.errorNode				=  (void * (*) (pANTLR3_BASE_TREE_ADAPTOR, pANTLR3_TOKEN_STREAM, pANTLR3_COMMON_TOKEN, pANTLR3_COMMON_TOKEN, pANTLR3_EXCEPTION))

  00127	8b 45 fc	 mov	 eax, DWORD PTR _cta$[ebp]
  0012a	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], OFFSET _errorNode

; 145  :                                                     errorNode;
; 146  : 
; 147  : 	// Install the super class pointer
; 148  : 	//
; 149  : 	cta->baseAdaptor.super	    = cta;

  00131	8b 4d fc	 mov	 ecx, DWORD PTR _cta$[ebp]
  00134	8b 55 fc	 mov	 edx, DWORD PTR _cta$[ebp]
  00137	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 150  : 
; 151  : 	// Install a tree factory for creating new tree nodes
; 152  : 	//
; 153  : 	cta->arboretum  = antlr3ArboretumNew(strFactory);

  0013a	8b 45 08	 mov	 eax, DWORD PTR _strFactory$[ebp]
  0013d	50		 push	 eax
  0013e	e8 00 00 00 00	 call	 _antlr3ArboretumNew
  00143	83 c4 04	 add	 esp, 4
  00146	8b 4d fc	 mov	 ecx, DWORD PTR _cta$[ebp]
  00149	89 81 b0 00 00
	00		 mov	 DWORD PTR [ecx+176], eax

; 154  : 
; 155  : 	// Install a token factory for imaginary tokens, these imaginary
; 156  : 	// tokens do not require access to the input stream so we can
; 157  : 	// dummy the creation of it, but they will need a string factory.
; 158  : 	//
; 159  : 	cta->baseAdaptor.tokenFactory						= antlr3TokenFactoryNew(NULL);

  0014f	6a 00		 push	 0
  00151	e8 00 00 00 00	 call	 _antlr3TokenFactoryNew
  00156	83 c4 04	 add	 esp, 4
  00159	8b 55 fc	 mov	 edx, DWORD PTR _cta$[ebp]
  0015c	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 160  : 	cta->baseAdaptor.tokenFactory->unTruc.strFactory	= strFactory;

  0015f	8b 45 fc	 mov	 eax, DWORD PTR _cta$[ebp]
  00162	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00165	8b 55 08	 mov	 edx, DWORD PTR _strFactory$[ebp]
  00168	89 51 18	 mov	 DWORD PTR [ecx+24], edx

; 161  : 
; 162  : 	// Allow the base tree adaptor to share the tree factory's string factory.
; 163  : 	//
; 164  : 	cta->baseAdaptor.strFactory	= strFactory;

  0016b	8b 45 fc	 mov	 eax, DWORD PTR _cta$[ebp]
  0016e	8b 4d 08	 mov	 ecx, DWORD PTR _strFactory$[ebp]
  00171	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 165  : 
; 166  : 	// Return the address of the base adaptor interface.
; 167  : 	//
; 168  : 	return  &(cta->baseAdaptor);

  00174	8b 45 fc	 mov	 eax, DWORD PTR _cta$[ebp]
  00177	83 c0 04	 add	 eax, 4
$LN1@ANTLR3_TRE:

; 169  : }

  0017a	5e		 pop	 esi
  0017b	83 c4 04	 add	 esp, 4
  0017e	3b ec		 cmp	 ebp, esp
  00180	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00185	8b e5		 mov	 esp, ebp
  00187	5d		 pop	 ebp
  00188	c3		 ret	 0
_ANTLR3_TREE_ADAPTORNew ENDP
_TEXT	ENDS
END
