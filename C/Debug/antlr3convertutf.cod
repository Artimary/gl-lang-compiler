; Listing generated by Microsoft (R) Optimizing Compiler Version 19.42.34436.0 

	TITLE	C:\SPO_labs\C\Debug\antlr3convertutf.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
_trailingBytesForUTF8 DB 00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
_offsetsFromUTF8 DD 00H
	DD	03080H
	DD	0e2080H
	DD	03c82080H
	DD	0fa082080H
	DD	082082080H
_firstByteMark DB 00H
	DB	00H
	DB	0c0H
	DB	0e0H
	DB	0f0H
	DB	0f8H
	DB	0fcH
CONST	ENDS
PUBLIC	_ConvertUTF8toUTF16
PUBLIC	_ConvertUTF16toUTF8
PUBLIC	_ConvertUTF8toUTF32
PUBLIC	_ConvertUTF32toUTF8
PUBLIC	_ConvertUTF16toUTF32
PUBLIC	_ConvertUTF32toUTF16
PUBLIC	_isLegalUTF8Sequence
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3convertutf.c
;	COMDAT _isLegalUTF8
_TEXT	SEGMENT
tv80 = -16						; size = 4
tv65 = -12						; size = 4
_srcptr$ = -8						; size = 4
_a$ = -1						; size = 1
_source$ = 8						; size = 4
_length$ = 12						; size = 4
_isLegalUTF8 PROC					; COMDAT

; 287  : isLegalUTF8(const UTF8 *source, int length) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 288  :     UTF8 a;
; 289  :     const UTF8 *srcptr = source+length;

  00006	8b 45 08	 mov	 eax, DWORD PTR _source$[ebp]
  00009	03 45 0c	 add	 eax, DWORD PTR _length$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR _srcptr$[ebp], eax

; 290  :     switch (length) {

  0000f	8b 4d 0c	 mov	 ecx, DWORD PTR _length$[ebp]
  00012	89 4d f4	 mov	 DWORD PTR tv65[ebp], ecx
  00015	8b 55 f4	 mov	 edx, DWORD PTR tv65[ebp]
  00018	83 ea 01	 sub	 edx, 1
  0001b	89 55 f4	 mov	 DWORD PTR tv65[ebp], edx
  0001e	83 7d f4 03	 cmp	 DWORD PTR tv65[ebp], 3
  00022	77 0a		 ja	 SHORT $LN6@isLegalUTF
  00024	8b 45 f4	 mov	 eax, DWORD PTR tv65[ebp]
  00027	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN29@isLegalUTF[eax*4]
$LN6@isLegalUTF:

; 291  :     default: return ANTLR3_FALSE;

  0002e	32 c0		 xor	 al, al
  00030	e9 38 01 00 00	 jmp	 $LN1@isLegalUTF
$LN7@isLegalUTF:

; 292  : 	/* Everything else falls through when "true"... */
; 293  :     case 4: if ((a = (*--srcptr)) < 0x80 || a > 0xBF) return ANTLR3_FALSE;

  00035	8b 4d f8	 mov	 ecx, DWORD PTR _srcptr$[ebp]
  00038	83 e9 01	 sub	 ecx, 1
  0003b	89 4d f8	 mov	 DWORD PTR _srcptr$[ebp], ecx
  0003e	8b 55 f8	 mov	 edx, DWORD PTR _srcptr$[ebp]
  00041	8a 02		 mov	 al, BYTE PTR [edx]
  00043	88 45 ff	 mov	 BYTE PTR _a$[ebp], al
  00046	0f b6 4d ff	 movzx	 ecx, BYTE PTR _a$[ebp]
  0004a	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  00050	7c 0c		 jl	 SHORT $LN9@isLegalUTF
  00052	0f b6 55 ff	 movzx	 edx, BYTE PTR _a$[ebp]
  00056	81 fa bf 00 00
	00		 cmp	 edx, 191		; 000000bfH
  0005c	7e 07		 jle	 SHORT $LN8@isLegalUTF
$LN9@isLegalUTF:
  0005e	32 c0		 xor	 al, al
  00060	e9 08 01 00 00	 jmp	 $LN1@isLegalUTF
$LN8@isLegalUTF:

; 294  :     case 3: if ((a = (*--srcptr)) < 0x80 || a > 0xBF) return ANTLR3_FALSE;

  00065	8b 45 f8	 mov	 eax, DWORD PTR _srcptr$[ebp]
  00068	83 e8 01	 sub	 eax, 1
  0006b	89 45 f8	 mov	 DWORD PTR _srcptr$[ebp], eax
  0006e	8b 4d f8	 mov	 ecx, DWORD PTR _srcptr$[ebp]
  00071	8a 11		 mov	 dl, BYTE PTR [ecx]
  00073	88 55 ff	 mov	 BYTE PTR _a$[ebp], dl
  00076	0f b6 45 ff	 movzx	 eax, BYTE PTR _a$[ebp]
  0007a	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  0007f	7c 0c		 jl	 SHORT $LN12@isLegalUTF
  00081	0f b6 4d ff	 movzx	 ecx, BYTE PTR _a$[ebp]
  00085	81 f9 bf 00 00
	00		 cmp	 ecx, 191		; 000000bfH
  0008b	7e 07		 jle	 SHORT $LN11@isLegalUTF
$LN12@isLegalUTF:
  0008d	32 c0		 xor	 al, al
  0008f	e9 d9 00 00 00	 jmp	 $LN1@isLegalUTF
$LN11@isLegalUTF:

; 295  :     case 2: if ((a = (*--srcptr)) > 0xBF) return ANTLR3_FALSE;

  00094	8b 55 f8	 mov	 edx, DWORD PTR _srcptr$[ebp]
  00097	83 ea 01	 sub	 edx, 1
  0009a	89 55 f8	 mov	 DWORD PTR _srcptr$[ebp], edx
  0009d	8b 45 f8	 mov	 eax, DWORD PTR _srcptr$[ebp]
  000a0	8a 08		 mov	 cl, BYTE PTR [eax]
  000a2	88 4d ff	 mov	 BYTE PTR _a$[ebp], cl
  000a5	0f b6 55 ff	 movzx	 edx, BYTE PTR _a$[ebp]
  000a9	81 fa bf 00 00
	00		 cmp	 edx, 191		; 000000bfH
  000af	7e 07		 jle	 SHORT $LN14@isLegalUTF
  000b1	32 c0		 xor	 al, al
  000b3	e9 b5 00 00 00	 jmp	 $LN1@isLegalUTF
$LN14@isLegalUTF:

; 296  : 
; 297  : 	switch (*source) {

  000b8	8b 45 08	 mov	 eax, DWORD PTR _source$[ebp]
  000bb	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000be	89 4d f0	 mov	 DWORD PTR tv80[ebp], ecx
  000c1	8b 55 f0	 mov	 edx, DWORD PTR tv80[ebp]
  000c4	81 ea e0 00 00
	00		 sub	 edx, 224		; 000000e0H
  000ca	89 55 f0	 mov	 DWORD PTR tv80[ebp], edx
  000cd	83 7d f0 14	 cmp	 DWORD PTR tv80[ebp], 20	; 00000014H
  000d1	77 58		 ja	 SHORT $LN23@isLegalUTF
  000d3	8b 45 f0	 mov	 eax, DWORD PTR tv80[ebp]
  000d6	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN30@isLegalUTF[eax]
  000dd	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN31@isLegalUTF[ecx*4]
$LN15@isLegalUTF:

; 298  : 	    /* no fall-through in this inner switch */
; 299  : 	    case 0xE0: if (a < 0xA0) return ANTLR3_FALSE; break;

  000e4	0f b6 55 ff	 movzx	 edx, BYTE PTR _a$[ebp]
  000e8	81 fa a0 00 00
	00		 cmp	 edx, 160		; 000000a0H
  000ee	7d 04		 jge	 SHORT $LN16@isLegalUTF
  000f0	32 c0		 xor	 al, al
  000f2	eb 79		 jmp	 SHORT $LN1@isLegalUTF
$LN16@isLegalUTF:
  000f4	eb 44		 jmp	 SHORT $LN4@isLegalUTF
$LN17@isLegalUTF:

; 300  : 	    case 0xED: if (a > 0x9F) return ANTLR3_FALSE; break;

  000f6	0f b6 45 ff	 movzx	 eax, BYTE PTR _a$[ebp]
  000fa	3d 9f 00 00 00	 cmp	 eax, 159		; 0000009fH
  000ff	7e 04		 jle	 SHORT $LN18@isLegalUTF
  00101	32 c0		 xor	 al, al
  00103	eb 68		 jmp	 SHORT $LN1@isLegalUTF
$LN18@isLegalUTF:
  00105	eb 33		 jmp	 SHORT $LN4@isLegalUTF
$LN19@isLegalUTF:

; 301  : 	    case 0xF0: if (a < 0x90) return ANTLR3_FALSE; break;

  00107	0f b6 4d ff	 movzx	 ecx, BYTE PTR _a$[ebp]
  0010b	81 f9 90 00 00
	00		 cmp	 ecx, 144		; 00000090H
  00111	7d 04		 jge	 SHORT $LN20@isLegalUTF
  00113	32 c0		 xor	 al, al
  00115	eb 56		 jmp	 SHORT $LN1@isLegalUTF
$LN20@isLegalUTF:
  00117	eb 21		 jmp	 SHORT $LN4@isLegalUTF
$LN21@isLegalUTF:

; 302  : 	    case 0xF4: if (a > 0x8F) return ANTLR3_FALSE; break;

  00119	0f b6 55 ff	 movzx	 edx, BYTE PTR _a$[ebp]
  0011d	81 fa 8f 00 00
	00		 cmp	 edx, 143		; 0000008fH
  00123	7e 04		 jle	 SHORT $LN22@isLegalUTF
  00125	32 c0		 xor	 al, al
  00127	eb 44		 jmp	 SHORT $LN1@isLegalUTF
$LN22@isLegalUTF:
  00129	eb 0f		 jmp	 SHORT $LN4@isLegalUTF
$LN23@isLegalUTF:

; 303  : 	    default:   if (a < 0x80) return ANTLR3_FALSE;

  0012b	0f b6 45 ff	 movzx	 eax, BYTE PTR _a$[ebp]
  0012f	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00134	7d 04		 jge	 SHORT $LN24@isLegalUTF
  00136	32 c0		 xor	 al, al
  00138	eb 33		 jmp	 SHORT $LN1@isLegalUTF
$LN24@isLegalUTF:
$LN4@isLegalUTF:

; 304  : 	}
; 305  : 
; 306  :     case 1: if (*source >= 0x80 && *source < 0xC2) return ANTLR3_FALSE;

  0013a	8b 4d 08	 mov	 ecx, DWORD PTR _source$[ebp]
  0013d	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00140	81 fa 80 00 00
	00		 cmp	 edx, 128		; 00000080H
  00146	7c 12		 jl	 SHORT $LN26@isLegalUTF
  00148	8b 45 08	 mov	 eax, DWORD PTR _source$[ebp]
  0014b	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0014e	81 f9 c2 00 00
	00		 cmp	 ecx, 194		; 000000c2H
  00154	7d 04		 jge	 SHORT $LN26@isLegalUTF
  00156	32 c0		 xor	 al, al
  00158	eb 13		 jmp	 SHORT $LN1@isLegalUTF
$LN26@isLegalUTF:

; 307  :     }
; 308  :     if (*source > 0xF4) return ANTLR3_FALSE;

  0015a	8b 55 08	 mov	 edx, DWORD PTR _source$[ebp]
  0015d	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00160	3d f4 00 00 00	 cmp	 eax, 244		; 000000f4H
  00165	7e 04		 jle	 SHORT $LN27@isLegalUTF
  00167	32 c0		 xor	 al, al
  00169	eb 02		 jmp	 SHORT $LN1@isLegalUTF
$LN27@isLegalUTF:

; 309  :     return ANTLR3_TRUE;

  0016b	b0 01		 mov	 al, 1
$LN1@isLegalUTF:

; 310  : }

  0016d	8b e5		 mov	 esp, ebp
  0016f	5d		 pop	 ebp
  00170	c3		 ret	 0
  00171	0f 1f 00	 npad	 3
$LN29@isLegalUTF:
  00174	00 00 00 00	 DD	 $LN4@isLegalUTF
  00178	00 00 00 00	 DD	 $LN11@isLegalUTF
  0017c	00 00 00 00	 DD	 $LN8@isLegalUTF
  00180	00 00 00 00	 DD	 $LN7@isLegalUTF
$LN31@isLegalUTF:
  00184	00 00 00 00	 DD	 $LN15@isLegalUTF
  00188	00 00 00 00	 DD	 $LN17@isLegalUTF
  0018c	00 00 00 00	 DD	 $LN19@isLegalUTF
  00190	00 00 00 00	 DD	 $LN21@isLegalUTF
  00194	00 00 00 00	 DD	 $LN23@isLegalUTF
$LN30@isLegalUTF:
  00198	00		 DB	 0
  00199	04		 DB	 4
  0019a	04		 DB	 4
  0019b	04		 DB	 4
  0019c	04		 DB	 4
  0019d	04		 DB	 4
  0019e	04		 DB	 4
  0019f	04		 DB	 4
  001a0	04		 DB	 4
  001a1	04		 DB	 4
  001a2	04		 DB	 4
  001a3	04		 DB	 4
  001a4	04		 DB	 4
  001a5	01		 DB	 1
  001a6	04		 DB	 4
  001a7	04		 DB	 4
  001a8	02		 DB	 2
  001a9	04		 DB	 4
  001aa	04		 DB	 4
  001ab	04		 DB	 4
  001ac	03		 DB	 3
_isLegalUTF8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3convertutf.c
;	COMDAT _isLegalUTF8Sequence
_TEXT	SEGMENT
_length$ = -4						; size = 4
_source$ = 8						; size = 4
_sourceEnd$ = 12					; size = 4
_isLegalUTF8Sequence PROC				; COMDAT

; 319  : isLegalUTF8Sequence(const UTF8 *source, const UTF8 *sourceEnd) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 320  :     int length = trailingBytesForUTF8[*source]+1;

  0000b	8b 45 08	 mov	 eax, DWORD PTR _source$[ebp]
  0000e	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00011	0f be 91 00 00
	00 00		 movsx	 edx, BYTE PTR _trailingBytesForUTF8[ecx]
  00018	83 c2 01	 add	 edx, 1
  0001b	89 55 fc	 mov	 DWORD PTR _length$[ebp], edx

; 321  :     if (source+length > sourceEnd) {

  0001e	8b 45 08	 mov	 eax, DWORD PTR _source$[ebp]
  00021	03 45 fc	 add	 eax, DWORD PTR _length$[ebp]
  00024	3b 45 0c	 cmp	 eax, DWORD PTR _sourceEnd$[ebp]
  00027	76 04		 jbe	 SHORT $LN2@isLegalUTF

; 322  : 	return ANTLR3_FALSE;

  00029	32 c0		 xor	 al, al
  0002b	eb 10		 jmp	 SHORT $LN1@isLegalUTF
$LN2@isLegalUTF:

; 323  :     }
; 324  :     return isLegalUTF8(source, length);

  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _length$[ebp]
  00030	51		 push	 ecx
  00031	8b 55 08	 mov	 edx, DWORD PTR _source$[ebp]
  00034	52		 push	 edx
  00035	e8 00 00 00 00	 call	 _isLegalUTF8
  0003a	83 c4 08	 add	 esp, 8
$LN1@isLegalUTF:

; 325  : }

  0003d	83 c4 04	 add	 esp, 4
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
_isLegalUTF8Sequence ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3convertutf.c
;	COMDAT _ConvertUTF32toUTF16
_TEXT	SEGMENT
_ch$1 = -16						; size = 4
_target$ = -12						; size = 4
_source$ = -8						; size = 4
_result$ = -4						; size = 4
_sourceStart$ = 8					; size = 4
_sourceEnd$ = 12					; size = 4
_targetStart$ = 16					; size = 4
_targetEnd$ = 20					; size = 4
_flags$ = 24						; size = 4
_ConvertUTF32toUTF16 PROC				; COMDAT

; 54   : 	UTF16** targetStart, UTF16* targetEnd, ConversionFlags flags) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 55   :     ConversionResult result = conversionOK;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _result$[ebp], 0

; 56   :     const UTF32* source = *sourceStart;

  0000d	8b 45 08	 mov	 eax, DWORD PTR _sourceStart$[ebp]
  00010	8b 08		 mov	 ecx, DWORD PTR [eax]
  00012	89 4d f8	 mov	 DWORD PTR _source$[ebp], ecx

; 57   :     UTF16* target = *targetStart;

  00015	8b 55 10	 mov	 edx, DWORD PTR _targetStart$[ebp]
  00018	8b 02		 mov	 eax, DWORD PTR [edx]
  0001a	89 45 f4	 mov	 DWORD PTR _target$[ebp], eax
$LN2@ConvertUTF:

; 58   :     while (source < sourceEnd) {

  0001d	8b 4d f8	 mov	 ecx, DWORD PTR _source$[ebp]
  00020	3b 4d 0c	 cmp	 ecx, DWORD PTR _sourceEnd$[ebp]
  00023	0f 83 1f 01 00
	00		 jae	 $LN3@ConvertUTF

; 59   : 	UTF32 ch;
; 60   : 	if (target >= targetEnd) {

  00029	8b 55 f4	 mov	 edx, DWORD PTR _target$[ebp]
  0002c	3b 55 14	 cmp	 edx, DWORD PTR _targetEnd$[ebp]
  0002f	72 0c		 jb	 SHORT $LN4@ConvertUTF

; 61   : 	    result = targetExhausted; break;

  00031	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR _result$[ebp], 2
  00038	e9 0b 01 00 00	 jmp	 $LN3@ConvertUTF
$LN4@ConvertUTF:

; 62   : 	}
; 63   : 	ch = *source++;

  0003d	8b 45 f8	 mov	 eax, DWORD PTR _source$[ebp]
  00040	8b 08		 mov	 ecx, DWORD PTR [eax]
  00042	89 4d f0	 mov	 DWORD PTR _ch$1[ebp], ecx
  00045	8b 55 f8	 mov	 edx, DWORD PTR _source$[ebp]
  00048	83 c2 04	 add	 edx, 4
  0004b	89 55 f8	 mov	 DWORD PTR _source$[ebp], edx

; 64   : 	if (ch <= UNI_MAX_BMP) { /* Target is a character <= 0xFFFF */

  0004e	81 7d f0 ff ff
	00 00		 cmp	 DWORD PTR _ch$1[ebp], 65535 ; 0000ffffH
  00055	77 5d		 ja	 SHORT $LN5@ConvertUTF

; 65   : 	    /* UTF-16 surrogate values are illegal in UTF-32; 0xffff or 0xfffe are both reserved values */
; 66   : 	    if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_LOW_END) {

  00057	81 7d f0 00 d8
	00 00		 cmp	 DWORD PTR _ch$1[ebp], 55296 ; 0000d800H
  0005e	72 3c		 jb	 SHORT $LN7@ConvertUTF
  00060	81 7d f0 ff df
	00 00		 cmp	 DWORD PTR _ch$1[ebp], 57343 ; 0000dfffH
  00067	77 33		 ja	 SHORT $LN7@ConvertUTF

; 67   : 		if (flags == strictConversion) {

  00069	83 7d 18 00	 cmp	 DWORD PTR _flags$[ebp], 0
  0006d	75 17		 jne	 SHORT $LN9@ConvertUTF

; 68   : 		    --source; /* return to the illegal value itself */

  0006f	8b 45 f8	 mov	 eax, DWORD PTR _source$[ebp]
  00072	83 e8 04	 sub	 eax, 4
  00075	89 45 f8	 mov	 DWORD PTR _source$[ebp], eax

; 69   : 		    result = sourceIllegal;

  00078	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR _result$[ebp], 3

; 70   : 		    break;

  0007f	e9 c4 00 00 00	 jmp	 $LN3@ConvertUTF

; 71   : 		} else {

  00084	eb 14		 jmp	 SHORT $LN10@ConvertUTF
$LN9@ConvertUTF:

; 72   : 		    *target++ = UNI_REPLACEMENT_CHAR;

  00086	b9 fd ff 00 00	 mov	 ecx, 65533		; 0000fffdH
  0008b	8b 55 f4	 mov	 edx, DWORD PTR _target$[ebp]
  0008e	66 89 0a	 mov	 WORD PTR [edx], cx
  00091	8b 45 f4	 mov	 eax, DWORD PTR _target$[ebp]
  00094	83 c0 02	 add	 eax, 2
  00097	89 45 f4	 mov	 DWORD PTR _target$[ebp], eax
$LN10@ConvertUTF:

; 73   : 		}
; 74   : 	    } else {

  0009a	eb 13		 jmp	 SHORT $LN8@ConvertUTF
$LN7@ConvertUTF:

; 75   : 		*target++ = (UTF16)ch; /* normal case */

  0009c	8b 4d f4	 mov	 ecx, DWORD PTR _target$[ebp]
  0009f	66 8b 55 f0	 mov	 dx, WORD PTR _ch$1[ebp]
  000a3	66 89 11	 mov	 WORD PTR [ecx], dx
  000a6	8b 45 f4	 mov	 eax, DWORD PTR _target$[ebp]
  000a9	83 c0 02	 add	 eax, 2
  000ac	89 45 f4	 mov	 DWORD PTR _target$[ebp], eax
$LN8@ConvertUTF:

; 76   : 	    }

  000af	e9 8f 00 00 00	 jmp	 $LN12@ConvertUTF
$LN5@ConvertUTF:

; 77   : 	} else if (ch > UNI_MAX_LEGAL_UTF32) {

  000b4	81 7d f0 ff ff
	10 00		 cmp	 DWORD PTR _ch$1[ebp], 1114111 ; 0010ffffH
  000bb	76 25		 jbe	 SHORT $LN11@ConvertUTF

; 78   : 	    if (flags == strictConversion) {

  000bd	83 7d 18 00	 cmp	 DWORD PTR _flags$[ebp], 0
  000c1	75 09		 jne	 SHORT $LN13@ConvertUTF

; 79   : 		result = sourceIllegal;

  000c3	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR _result$[ebp], 3

; 80   : 	    } else {

  000ca	eb 14		 jmp	 SHORT $LN14@ConvertUTF
$LN13@ConvertUTF:

; 81   : 		*target++ = UNI_REPLACEMENT_CHAR;

  000cc	b9 fd ff 00 00	 mov	 ecx, 65533		; 0000fffdH
  000d1	8b 55 f4	 mov	 edx, DWORD PTR _target$[ebp]
  000d4	66 89 0a	 mov	 WORD PTR [edx], cx
  000d7	8b 45 f4	 mov	 eax, DWORD PTR _target$[ebp]
  000da	83 c0 02	 add	 eax, 2
  000dd	89 45 f4	 mov	 DWORD PTR _target$[ebp], eax
$LN14@ConvertUTF:

; 82   : 	    }
; 83   : 	} else {

  000e0	eb 61		 jmp	 SHORT $LN12@ConvertUTF
$LN11@ConvertUTF:

; 84   : 	    /* target is a character in range 0xFFFF - 0x10FFFF. */
; 85   : 	    if (target + 1 >= targetEnd) {

  000e2	8b 4d f4	 mov	 ecx, DWORD PTR _target$[ebp]
  000e5	83 c1 02	 add	 ecx, 2
  000e8	3b 4d 14	 cmp	 ecx, DWORD PTR _targetEnd$[ebp]
  000eb	72 12		 jb	 SHORT $LN15@ConvertUTF

; 86   : 		--source; /* Back up source pointer! */

  000ed	8b 55 f8	 mov	 edx, DWORD PTR _source$[ebp]
  000f0	83 ea 04	 sub	 edx, 4
  000f3	89 55 f8	 mov	 DWORD PTR _source$[ebp], edx

; 87   : 		result = targetExhausted; break;

  000f6	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR _result$[ebp], 2
  000fd	eb 49		 jmp	 SHORT $LN3@ConvertUTF
$LN15@ConvertUTF:

; 88   : 	    }
; 89   : 	    ch -= halfBase;

  000ff	8b 45 f0	 mov	 eax, DWORD PTR _ch$1[ebp]
  00102	2d 00 00 01 00	 sub	 eax, 65536		; 00010000H
  00107	89 45 f0	 mov	 DWORD PTR _ch$1[ebp], eax

; 90   : 	    *target++ = (UTF16)((ch >> halfShift) + UNI_SUR_HIGH_START);

  0010a	8b 4d f0	 mov	 ecx, DWORD PTR _ch$1[ebp]
  0010d	c1 e9 0a	 shr	 ecx, 10			; 0000000aH
  00110	81 c1 00 d8 00
	00		 add	 ecx, 55296		; 0000d800H
  00116	8b 55 f4	 mov	 edx, DWORD PTR _target$[ebp]
  00119	66 89 0a	 mov	 WORD PTR [edx], cx
  0011c	8b 45 f4	 mov	 eax, DWORD PTR _target$[ebp]
  0011f	83 c0 02	 add	 eax, 2
  00122	89 45 f4	 mov	 DWORD PTR _target$[ebp], eax

; 91   : 	    *target++ = (UTF16)((ch & halfMask) + UNI_SUR_LOW_START);

  00125	8b 4d f0	 mov	 ecx, DWORD PTR _ch$1[ebp]
  00128	81 e1 ff 03 00
	00		 and	 ecx, 1023		; 000003ffH
  0012e	81 c1 00 dc 00
	00		 add	 ecx, 56320		; 0000dc00H
  00134	8b 55 f4	 mov	 edx, DWORD PTR _target$[ebp]
  00137	66 89 0a	 mov	 WORD PTR [edx], cx
  0013a	8b 45 f4	 mov	 eax, DWORD PTR _target$[ebp]
  0013d	83 c0 02	 add	 eax, 2
  00140	89 45 f4	 mov	 DWORD PTR _target$[ebp], eax
$LN12@ConvertUTF:

; 92   : 	}
; 93   :     }

  00143	e9 d5 fe ff ff	 jmp	 $LN2@ConvertUTF
$LN3@ConvertUTF:

; 94   :     *sourceStart = source;

  00148	8b 4d 08	 mov	 ecx, DWORD PTR _sourceStart$[ebp]
  0014b	8b 55 f8	 mov	 edx, DWORD PTR _source$[ebp]
  0014e	89 11		 mov	 DWORD PTR [ecx], edx

; 95   :     *targetStart = target;

  00150	8b 45 10	 mov	 eax, DWORD PTR _targetStart$[ebp]
  00153	8b 4d f4	 mov	 ecx, DWORD PTR _target$[ebp]
  00156	89 08		 mov	 DWORD PTR [eax], ecx

; 96   :     return result;

  00158	8b 45 fc	 mov	 eax, DWORD PTR _result$[ebp]

; 97   : }

  0015b	8b e5		 mov	 esp, ebp
  0015d	5d		 pop	 ebp
  0015e	c3		 ret	 0
_ConvertUTF32toUTF16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3convertutf.c
;	COMDAT _ConvertUTF16toUTF32
_TEXT	SEGMENT
_oldSource$1 = -24					; size = 4
_ch2$ = -20						; size = 4
_ch$ = -16						; size = 4
_target$ = -12						; size = 4
_source$ = -8						; size = 4
_result$ = -4						; size = 4
_sourceStart$ = 8					; size = 4
_sourceEnd$ = 12					; size = 4
_targetStart$ = 16					; size = 4
_targetEnd$ = 20					; size = 4
_flags$ = 24						; size = 4
_ConvertUTF16toUTF32 PROC				; COMDAT

; 103  : 	UTF32** targetStart, UTF32* targetEnd, ConversionFlags flags) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 104  :     ConversionResult result = conversionOK;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _result$[ebp], 0

; 105  :     const UTF16* source = *sourceStart;

  0000d	8b 45 08	 mov	 eax, DWORD PTR _sourceStart$[ebp]
  00010	8b 08		 mov	 ecx, DWORD PTR [eax]
  00012	89 4d f8	 mov	 DWORD PTR _source$[ebp], ecx

; 106  :     UTF32* target = *targetStart;

  00015	8b 55 10	 mov	 edx, DWORD PTR _targetStart$[ebp]
  00018	8b 02		 mov	 eax, DWORD PTR [edx]
  0001a	89 45 f4	 mov	 DWORD PTR _target$[ebp], eax
$LN2@ConvertUTF:

; 107  :     UTF32 ch, ch2;
; 108  :     while (source < sourceEnd) {

  0001d	8b 4d f8	 mov	 ecx, DWORD PTR _source$[ebp]
  00020	3b 4d 0c	 cmp	 ecx, DWORD PTR _sourceEnd$[ebp]
  00023	0f 83 f5 00 00
	00		 jae	 $LN3@ConvertUTF

; 109  : 	const UTF16* oldSource = source; /*  In case we have to back up because of target overflow. */

  00029	8b 55 f8	 mov	 edx, DWORD PTR _source$[ebp]
  0002c	89 55 e8	 mov	 DWORD PTR _oldSource$1[ebp], edx

; 110  : 	ch = *source++;

  0002f	8b 45 f8	 mov	 eax, DWORD PTR _source$[ebp]
  00032	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00035	89 4d f0	 mov	 DWORD PTR _ch$[ebp], ecx
  00038	8b 55 f8	 mov	 edx, DWORD PTR _source$[ebp]
  0003b	83 c2 02	 add	 edx, 2
  0003e	89 55 f8	 mov	 DWORD PTR _source$[ebp], edx

; 111  : 	/* If we have a surrogate pair, convert to UTF32 first. */
; 112  : 	if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_HIGH_END) {

  00041	81 7d f0 00 d8
	00 00		 cmp	 DWORD PTR _ch$[ebp], 55296 ; 0000d800H
  00048	72 7d		 jb	 SHORT $LN4@ConvertUTF
  0004a	81 7d f0 ff db
	00 00		 cmp	 DWORD PTR _ch$[ebp], 56319 ; 0000dbffH
  00051	77 74		 ja	 SHORT $LN4@ConvertUTF

; 113  : 	    /* If the 16 bits following the high surrogate are in the source buffer... */
; 114  : 	    if (source < sourceEnd) {

  00053	8b 45 f8	 mov	 eax, DWORD PTR _source$[ebp]
  00056	3b 45 0c	 cmp	 eax, DWORD PTR _sourceEnd$[ebp]
  00059	73 58		 jae	 SHORT $LN6@ConvertUTF

; 115  : 		ch2 = *source;

  0005b	8b 4d f8	 mov	 ecx, DWORD PTR _source$[ebp]
  0005e	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  00061	89 55 ec	 mov	 DWORD PTR _ch2$[ebp], edx

; 116  : 		/* If it's a low surrogate, convert to UTF32. */
; 117  : 		if (ch2 >= UNI_SUR_LOW_START && ch2 <= UNI_SUR_LOW_END) {

  00064	81 7d ec 00 dc
	00 00		 cmp	 DWORD PTR _ch2$[ebp], 56320 ; 0000dc00H
  0006b	72 2c		 jb	 SHORT $LN8@ConvertUTF
  0006d	81 7d ec ff df
	00 00		 cmp	 DWORD PTR _ch2$[ebp], 57343 ; 0000dfffH
  00074	77 23		 ja	 SHORT $LN8@ConvertUTF

; 118  : 		    ch = ((ch - UNI_SUR_HIGH_START) << halfShift)

  00076	8b 45 f0	 mov	 eax, DWORD PTR _ch$[ebp]
  00079	2d 00 d8 00 00	 sub	 eax, 55296		; 0000d800H
  0007e	c1 e0 0a	 shl	 eax, 10			; 0000000aH
  00081	8b 4d ec	 mov	 ecx, DWORD PTR _ch2$[ebp]
  00084	8d 94 08 00 24
	00 00		 lea	 edx, DWORD PTR [eax+ecx+9216]
  0008b	89 55 f0	 mov	 DWORD PTR _ch$[ebp], edx

; 119  : 			+ (ch2 - UNI_SUR_LOW_START) + halfBase;
; 120  : 		    ++source;

  0008e	8b 45 f8	 mov	 eax, DWORD PTR _source$[ebp]
  00091	83 c0 02	 add	 eax, 2
  00094	89 45 f8	 mov	 DWORD PTR _source$[ebp], eax
  00097	eb 18		 jmp	 SHORT $LN10@ConvertUTF
$LN8@ConvertUTF:

; 121  : 		} else if (flags == strictConversion) { /* it's an unpaired high surrogate */

  00099	83 7d 18 00	 cmp	 DWORD PTR _flags$[ebp], 0
  0009d	75 12		 jne	 SHORT $LN10@ConvertUTF

; 122  : 		    --source; /* return to the illegal value itself */

  0009f	8b 4d f8	 mov	 ecx, DWORD PTR _source$[ebp]
  000a2	83 e9 02	 sub	 ecx, 2
  000a5	89 4d f8	 mov	 DWORD PTR _source$[ebp], ecx

; 123  : 		    result = sourceIllegal;

  000a8	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR _result$[ebp], 3

; 124  : 		    break;

  000af	eb 6d		 jmp	 SHORT $LN3@ConvertUTF
$LN10@ConvertUTF:

; 125  : 		}
; 126  : 	    } else { /* We don't have the 16 bits following the high surrogate. */

  000b1	eb 12		 jmp	 SHORT $LN7@ConvertUTF
$LN6@ConvertUTF:

; 127  : 		--source; /* return to the high surrogate */

  000b3	8b 55 f8	 mov	 edx, DWORD PTR _source$[ebp]
  000b6	83 ea 02	 sub	 edx, 2
  000b9	89 55 f8	 mov	 DWORD PTR _source$[ebp], edx

; 128  : 		result = sourceExhausted;

  000bc	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _result$[ebp], 1

; 129  : 		break;

  000c3	eb 59		 jmp	 SHORT $LN3@ConvertUTF
$LN7@ConvertUTF:

; 130  : 	    }

  000c5	eb 2a		 jmp	 SHORT $LN12@ConvertUTF
$LN4@ConvertUTF:

; 131  : 	} else if (flags == strictConversion) {

  000c7	83 7d 18 00	 cmp	 DWORD PTR _flags$[ebp], 0
  000cb	75 24		 jne	 SHORT $LN12@ConvertUTF

; 132  : 	    /* UTF-16 surrogate values are illegal in UTF-32 */
; 133  : 	    if (ch >= UNI_SUR_LOW_START && ch <= UNI_SUR_LOW_END) {

  000cd	81 7d f0 00 dc
	00 00		 cmp	 DWORD PTR _ch$[ebp], 56320 ; 0000dc00H
  000d4	72 1b		 jb	 SHORT $LN12@ConvertUTF
  000d6	81 7d f0 ff df
	00 00		 cmp	 DWORD PTR _ch$[ebp], 57343 ; 0000dfffH
  000dd	77 12		 ja	 SHORT $LN12@ConvertUTF

; 134  : 		--source; /* return to the illegal value itself */

  000df	8b 45 f8	 mov	 eax, DWORD PTR _source$[ebp]
  000e2	83 e8 02	 sub	 eax, 2
  000e5	89 45 f8	 mov	 DWORD PTR _source$[ebp], eax

; 135  : 		result = sourceIllegal;

  000e8	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR _result$[ebp], 3

; 136  : 		break;

  000ef	eb 2d		 jmp	 SHORT $LN3@ConvertUTF
$LN12@ConvertUTF:

; 137  : 	    }
; 138  : 	}
; 139  : 	if (target >= targetEnd) {

  000f1	8b 4d f4	 mov	 ecx, DWORD PTR _target$[ebp]
  000f4	3b 4d 14	 cmp	 ecx, DWORD PTR _targetEnd$[ebp]
  000f7	72 0f		 jb	 SHORT $LN13@ConvertUTF

; 140  : 	    source = oldSource; /* Back up source pointer! */

  000f9	8b 55 e8	 mov	 edx, DWORD PTR _oldSource$1[ebp]
  000fc	89 55 f8	 mov	 DWORD PTR _source$[ebp], edx

; 141  : 	    result = targetExhausted; break;

  000ff	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR _result$[ebp], 2
  00106	eb 16		 jmp	 SHORT $LN3@ConvertUTF
$LN13@ConvertUTF:

; 142  : 	}
; 143  : 	*target++ = ch;

  00108	8b 45 f4	 mov	 eax, DWORD PTR _target$[ebp]
  0010b	8b 4d f0	 mov	 ecx, DWORD PTR _ch$[ebp]
  0010e	89 08		 mov	 DWORD PTR [eax], ecx
  00110	8b 55 f4	 mov	 edx, DWORD PTR _target$[ebp]
  00113	83 c2 04	 add	 edx, 4
  00116	89 55 f4	 mov	 DWORD PTR _target$[ebp], edx

; 144  :     }

  00119	e9 ff fe ff ff	 jmp	 $LN2@ConvertUTF
$LN3@ConvertUTF:

; 145  :     *sourceStart = source;

  0011e	8b 45 08	 mov	 eax, DWORD PTR _sourceStart$[ebp]
  00121	8b 4d f8	 mov	 ecx, DWORD PTR _source$[ebp]
  00124	89 08		 mov	 DWORD PTR [eax], ecx

; 146  :     *targetStart = target;

  00126	8b 55 10	 mov	 edx, DWORD PTR _targetStart$[ebp]
  00129	8b 45 f4	 mov	 eax, DWORD PTR _target$[ebp]
  0012c	89 02		 mov	 DWORD PTR [edx], eax

; 147  : #ifdef CVTUTF_DEBUG
; 148  : if (result == sourceIllegal) {
; 149  :     ANTLR3_FPRINTF(stderr, "ConvertUTF16toUTF32 illegal seq 0x%04x,%04x\n", ch, ch2);
; 150  :     fflush(stderr);
; 151  : }
; 152  : #endif
; 153  :     return result;

  0012e	8b 45 fc	 mov	 eax, DWORD PTR _result$[ebp]

; 154  : }

  00131	8b e5		 mov	 esp, ebp
  00133	5d		 pop	 ebp
  00134	c3		 ret	 0
_ConvertUTF16toUTF32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3convertutf.c
;	COMDAT _ConvertUTF32toUTF8
_TEXT	SEGMENT
tv81 = -32						; size = 4
_byteMark$1 = -28					; size = 4
_byteMask$2 = -24					; size = 4
_bytesToWrite$3 = -20					; size = 2
_ch$4 = -16						; size = 4
_target$ = -12						; size = 4
_source$ = -8						; size = 4
_result$ = -4						; size = 4
_sourceStart$ = 8					; size = 4
_sourceEnd$ = 12					; size = 4
_targetStart$ = 16					; size = 4
_targetEnd$ = 20					; size = 4
_flags$ = 24						; size = 4
_ConvertUTF32toUTF8 PROC				; COMDAT

; 404  : 	UTF8** targetStart, UTF8* targetEnd, ConversionFlags flags) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H

; 405  :     ConversionResult result = conversionOK;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _result$[ebp], 0

; 406  :     const UTF32* source = *sourceStart;

  0000d	8b 45 08	 mov	 eax, DWORD PTR _sourceStart$[ebp]
  00010	8b 08		 mov	 ecx, DWORD PTR [eax]
  00012	89 4d f8	 mov	 DWORD PTR _source$[ebp], ecx

; 407  :     UTF8* target = *targetStart;

  00015	8b 55 10	 mov	 edx, DWORD PTR _targetStart$[ebp]
  00018	8b 02		 mov	 eax, DWORD PTR [edx]
  0001a	89 45 f4	 mov	 DWORD PTR _target$[ebp], eax
$LN2@ConvertUTF:

; 408  :     while (source < sourceEnd) {

  0001d	8b 4d f8	 mov	 ecx, DWORD PTR _source$[ebp]
  00020	3b 4d 0c	 cmp	 ecx, DWORD PTR _sourceEnd$[ebp]
  00023	0f 83 9b 01 00
	00		 jae	 $LN3@ConvertUTF

; 409  : 	UTF32 ch;
; 410  : 	unsigned short bytesToWrite = 0;

  00029	33 d2		 xor	 edx, edx
  0002b	66 89 55 ec	 mov	 WORD PTR _bytesToWrite$3[ebp], dx

; 411  : 	const UTF32 byteMask = 0xBF;

  0002f	c7 45 e8 bf 00
	00 00		 mov	 DWORD PTR _byteMask$2[ebp], 191 ; 000000bfH

; 412  : 	const UTF32 byteMark = 0x80; 

  00036	c7 45 e4 80 00
	00 00		 mov	 DWORD PTR _byteMark$1[ebp], 128 ; 00000080H

; 413  : 	ch = *source++;

  0003d	8b 45 f8	 mov	 eax, DWORD PTR _source$[ebp]
  00040	8b 08		 mov	 ecx, DWORD PTR [eax]
  00042	89 4d f0	 mov	 DWORD PTR _ch$4[ebp], ecx
  00045	8b 55 f8	 mov	 edx, DWORD PTR _source$[ebp]
  00048	83 c2 04	 add	 edx, 4
  0004b	89 55 f8	 mov	 DWORD PTR _source$[ebp], edx

; 414  : 	if (flags == strictConversion ) {

  0004e	83 7d 18 00	 cmp	 DWORD PTR _flags$[ebp], 0
  00052	75 27		 jne	 SHORT $LN7@ConvertUTF

; 415  : 	    /* UTF-16 surrogate values are illegal in UTF-32 */
; 416  : 	    if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_LOW_END) {

  00054	81 7d f0 00 d8
	00 00		 cmp	 DWORD PTR _ch$4[ebp], 55296 ; 0000d800H
  0005b	72 1e		 jb	 SHORT $LN7@ConvertUTF
  0005d	81 7d f0 ff df
	00 00		 cmp	 DWORD PTR _ch$4[ebp], 57343 ; 0000dfffH
  00064	77 15		 ja	 SHORT $LN7@ConvertUTF

; 417  : 		--source; /* return to the illegal value itself */

  00066	8b 45 f8	 mov	 eax, DWORD PTR _source$[ebp]
  00069	83 e8 04	 sub	 eax, 4
  0006c	89 45 f8	 mov	 DWORD PTR _source$[ebp], eax

; 418  : 		result = sourceIllegal;

  0006f	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR _result$[ebp], 3

; 419  : 		break;

  00076	e9 49 01 00 00	 jmp	 $LN3@ConvertUTF
$LN7@ConvertUTF:

; 420  : 	    }
; 421  : 	}
; 422  : 	/*
; 423  : 	 * Figure out how many bytes the result will require. Turn any
; 424  : 	 * illegally large UTF32 things (> Plane 17) into replacement chars.
; 425  : 	 */
; 426  : 	if (ch < (UTF32)0x80) {	     bytesToWrite = 1;

  0007b	81 7d f0 80 00
	00 00		 cmp	 DWORD PTR _ch$4[ebp], 128 ; 00000080H
  00082	73 0b		 jae	 SHORT $LN8@ConvertUTF
  00084	b9 01 00 00 00	 mov	 ecx, 1
  00089	66 89 4d ec	 mov	 WORD PTR _bytesToWrite$3[ebp], cx
  0008d	eb 53		 jmp	 SHORT $LN15@ConvertUTF
$LN8@ConvertUTF:

; 427  : 	} else if (ch < (UTF32)0x800) {     bytesToWrite = 2;

  0008f	81 7d f0 00 08
	00 00		 cmp	 DWORD PTR _ch$4[ebp], 2048 ; 00000800H
  00096	73 0b		 jae	 SHORT $LN10@ConvertUTF
  00098	ba 02 00 00 00	 mov	 edx, 2
  0009d	66 89 55 ec	 mov	 WORD PTR _bytesToWrite$3[ebp], dx
  000a1	eb 3f		 jmp	 SHORT $LN15@ConvertUTF
$LN10@ConvertUTF:

; 428  : 	} else if (ch < (UTF32)0x10000) {   bytesToWrite = 3;

  000a3	81 7d f0 00 00
	01 00		 cmp	 DWORD PTR _ch$4[ebp], 65536 ; 00010000H
  000aa	73 0b		 jae	 SHORT $LN12@ConvertUTF
  000ac	b8 03 00 00 00	 mov	 eax, 3
  000b1	66 89 45 ec	 mov	 WORD PTR _bytesToWrite$3[ebp], ax
  000b5	eb 2b		 jmp	 SHORT $LN15@ConvertUTF
$LN12@ConvertUTF:

; 429  : 	} else if (ch <= UNI_MAX_LEGAL_UTF32) {  bytesToWrite = 4;

  000b7	81 7d f0 ff ff
	10 00		 cmp	 DWORD PTR _ch$4[ebp], 1114111 ; 0010ffffH
  000be	77 0b		 ja	 SHORT $LN14@ConvertUTF
  000c0	b9 04 00 00 00	 mov	 ecx, 4
  000c5	66 89 4d ec	 mov	 WORD PTR _bytesToWrite$3[ebp], cx
  000c9	eb 17		 jmp	 SHORT $LN15@ConvertUTF
$LN14@ConvertUTF:

; 430  : 	} else {			    bytesToWrite = 3;

  000cb	ba 03 00 00 00	 mov	 edx, 3
  000d0	66 89 55 ec	 mov	 WORD PTR _bytesToWrite$3[ebp], dx

; 431  : 					    ch = UNI_REPLACEMENT_CHAR;

  000d4	c7 45 f0 fd ff
	00 00		 mov	 DWORD PTR _ch$4[ebp], 65533 ; 0000fffdH

; 432  : 					    result = sourceIllegal;

  000db	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR _result$[ebp], 3
$LN15@ConvertUTF:

; 433  : 	}
; 434  : 	
; 435  : 	target += bytesToWrite;

  000e2	0f b7 45 ec	 movzx	 eax, WORD PTR _bytesToWrite$3[ebp]
  000e6	03 45 f4	 add	 eax, DWORD PTR _target$[ebp]
  000e9	89 45 f4	 mov	 DWORD PTR _target$[ebp], eax

; 436  : 	if (target > targetEnd) {

  000ec	8b 4d f4	 mov	 ecx, DWORD PTR _target$[ebp]
  000ef	3b 4d 14	 cmp	 ecx, DWORD PTR _targetEnd$[ebp]
  000f2	76 21		 jbe	 SHORT $LN16@ConvertUTF

; 437  : 	    --source; /* Back up source pointer! */

  000f4	8b 55 f8	 mov	 edx, DWORD PTR _source$[ebp]
  000f7	83 ea 04	 sub	 edx, 4
  000fa	89 55 f8	 mov	 DWORD PTR _source$[ebp], edx

; 438  : 	    target -= bytesToWrite; result = targetExhausted; break;

  000fd	0f b7 45 ec	 movzx	 eax, WORD PTR _bytesToWrite$3[ebp]
  00101	8b 4d f4	 mov	 ecx, DWORD PTR _target$[ebp]
  00104	2b c8		 sub	 ecx, eax
  00106	89 4d f4	 mov	 DWORD PTR _target$[ebp], ecx
  00109	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR _result$[ebp], 2
  00110	e9 af 00 00 00	 jmp	 $LN3@ConvertUTF
$LN16@ConvertUTF:

; 439  : 	}
; 440  : 	switch (bytesToWrite) { /* note: everything falls through. */

  00115	0f b7 55 ec	 movzx	 edx, WORD PTR _bytesToWrite$3[ebp]
  00119	89 55 e0	 mov	 DWORD PTR tv81[ebp], edx
  0011c	8b 45 e0	 mov	 eax, DWORD PTR tv81[ebp]
  0011f	83 e8 01	 sub	 eax, 1
  00122	89 45 e0	 mov	 DWORD PTR tv81[ebp], eax
  00125	83 7d e0 03	 cmp	 DWORD PTR tv81[ebp], 3
  00129	0f 87 86 00 00
	00		 ja	 $LN4@ConvertUTF
  0012f	8b 4d e0	 mov	 ecx, DWORD PTR tv81[ebp]
  00132	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN22@ConvertUTF[ecx*4]
$LN17@ConvertUTF:

; 441  : 	    case 4: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;

  00139	8b 55 f4	 mov	 edx, DWORD PTR _target$[ebp]
  0013c	83 ea 01	 sub	 edx, 1
  0013f	89 55 f4	 mov	 DWORD PTR _target$[ebp], edx
  00142	8b 45 f0	 mov	 eax, DWORD PTR _ch$4[ebp]
  00145	0b 45 e4	 or	 eax, DWORD PTR _byteMark$1[ebp]
  00148	23 45 e8	 and	 eax, DWORD PTR _byteMask$2[ebp]
  0014b	8b 4d f4	 mov	 ecx, DWORD PTR _target$[ebp]
  0014e	88 01		 mov	 BYTE PTR [ecx], al
  00150	8b 55 f0	 mov	 edx, DWORD PTR _ch$4[ebp]
  00153	c1 ea 06	 shr	 edx, 6
  00156	89 55 f0	 mov	 DWORD PTR _ch$4[ebp], edx
$LN18@ConvertUTF:

; 442  : 	    case 3: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;

  00159	8b 45 f4	 mov	 eax, DWORD PTR _target$[ebp]
  0015c	83 e8 01	 sub	 eax, 1
  0015f	89 45 f4	 mov	 DWORD PTR _target$[ebp], eax
  00162	8b 4d f0	 mov	 ecx, DWORD PTR _ch$4[ebp]
  00165	0b 4d e4	 or	 ecx, DWORD PTR _byteMark$1[ebp]
  00168	23 4d e8	 and	 ecx, DWORD PTR _byteMask$2[ebp]
  0016b	8b 55 f4	 mov	 edx, DWORD PTR _target$[ebp]
  0016e	88 0a		 mov	 BYTE PTR [edx], cl
  00170	8b 45 f0	 mov	 eax, DWORD PTR _ch$4[ebp]
  00173	c1 e8 06	 shr	 eax, 6
  00176	89 45 f0	 mov	 DWORD PTR _ch$4[ebp], eax
$LN19@ConvertUTF:

; 443  : 	    case 2: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;

  00179	8b 4d f4	 mov	 ecx, DWORD PTR _target$[ebp]
  0017c	83 e9 01	 sub	 ecx, 1
  0017f	89 4d f4	 mov	 DWORD PTR _target$[ebp], ecx
  00182	8b 55 f0	 mov	 edx, DWORD PTR _ch$4[ebp]
  00185	0b 55 e4	 or	 edx, DWORD PTR _byteMark$1[ebp]
  00188	23 55 e8	 and	 edx, DWORD PTR _byteMask$2[ebp]
  0018b	8b 45 f4	 mov	 eax, DWORD PTR _target$[ebp]
  0018e	88 10		 mov	 BYTE PTR [eax], dl
  00190	8b 4d f0	 mov	 ecx, DWORD PTR _ch$4[ebp]
  00193	c1 e9 06	 shr	 ecx, 6
  00196	89 4d f0	 mov	 DWORD PTR _ch$4[ebp], ecx
$LN20@ConvertUTF:

; 444  : 	    case 1: *--target = (UTF8) (ch | firstByteMark[bytesToWrite]);

  00199	8b 55 f4	 mov	 edx, DWORD PTR _target$[ebp]
  0019c	83 ea 01	 sub	 edx, 1
  0019f	89 55 f4	 mov	 DWORD PTR _target$[ebp], edx
  001a2	0f b7 45 ec	 movzx	 eax, WORD PTR _bytesToWrite$3[ebp]
  001a6	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _firstByteMark[eax]
  001ad	0b 4d f0	 or	 ecx, DWORD PTR _ch$4[ebp]
  001b0	8b 55 f4	 mov	 edx, DWORD PTR _target$[ebp]
  001b3	88 0a		 mov	 BYTE PTR [edx], cl
$LN4@ConvertUTF:

; 445  : 	}
; 446  : 	target += bytesToWrite;

  001b5	0f b7 45 ec	 movzx	 eax, WORD PTR _bytesToWrite$3[ebp]
  001b9	03 45 f4	 add	 eax, DWORD PTR _target$[ebp]
  001bc	89 45 f4	 mov	 DWORD PTR _target$[ebp], eax

; 447  :     }

  001bf	e9 59 fe ff ff	 jmp	 $LN2@ConvertUTF
$LN3@ConvertUTF:

; 448  :     *sourceStart = source;

  001c4	8b 4d 08	 mov	 ecx, DWORD PTR _sourceStart$[ebp]
  001c7	8b 55 f8	 mov	 edx, DWORD PTR _source$[ebp]
  001ca	89 11		 mov	 DWORD PTR [ecx], edx

; 449  :     *targetStart = target;

  001cc	8b 45 10	 mov	 eax, DWORD PTR _targetStart$[ebp]
  001cf	8b 4d f4	 mov	 ecx, DWORD PTR _target$[ebp]
  001d2	89 08		 mov	 DWORD PTR [eax], ecx

; 450  :     return result;

  001d4	8b 45 fc	 mov	 eax, DWORD PTR _result$[ebp]

; 451  : }

  001d7	8b e5		 mov	 esp, ebp
  001d9	5d		 pop	 ebp
  001da	c3		 ret	 0
  001db	90		 npad	 1
$LN22@ConvertUTF:
  001dc	00 00 00 00	 DD	 $LN20@ConvertUTF
  001e0	00 00 00 00	 DD	 $LN19@ConvertUTF
  001e4	00 00 00 00	 DD	 $LN18@ConvertUTF
  001e8	00 00 00 00	 DD	 $LN17@ConvertUTF
_ConvertUTF32toUTF8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3convertutf.c
;	COMDAT _ConvertUTF8toUTF32
_TEXT	SEGMENT
tv80 = -24						; size = 4
_extraBytesToRead$1 = -20				; size = 2
_ch$2 = -16						; size = 4
_target$ = -12						; size = 4
_source$ = -8						; size = 4
_result$ = -4						; size = 4
_sourceStart$ = 8					; size = 4
_sourceEnd$ = 12					; size = 4
_targetStart$ = 16					; size = 4
_targetEnd$ = 20					; size = 4
_flags$ = 24						; size = 4
_ConvertUTF8toUTF32 PROC				; COMDAT

; 457  : 	UTF32** targetStart, UTF32* targetEnd, ConversionFlags flags) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  0000e	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00011	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00014	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00017	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001a	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 458  :     ConversionResult result = conversionOK;

  0001d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _result$[ebp], 0

; 459  :     const UTF8* source = *sourceStart;

  00024	8b 45 08	 mov	 eax, DWORD PTR _sourceStart$[ebp]
  00027	8b 08		 mov	 ecx, DWORD PTR [eax]
  00029	89 4d f8	 mov	 DWORD PTR _source$[ebp], ecx

; 460  :     UTF32* target = *targetStart;

  0002c	8b 55 10	 mov	 edx, DWORD PTR _targetStart$[ebp]
  0002f	8b 02		 mov	 eax, DWORD PTR [edx]
  00031	89 45 f4	 mov	 DWORD PTR _target$[ebp], eax
$LN2@ConvertUTF:

; 461  :     while (source < sourceEnd) {

  00034	8b 4d f8	 mov	 ecx, DWORD PTR _source$[ebp]
  00037	3b 4d 0c	 cmp	 ecx, DWORD PTR _sourceEnd$[ebp]
  0003a	0f 83 d2 01 00
	00		 jae	 $LN3@ConvertUTF

; 462  : 	UTF32 ch = 0;

  00040	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _ch$2[ebp], 0

; 463  : 	unsigned short extraBytesToRead = trailingBytesForUTF8[*source];

  00047	8b 55 f8	 mov	 edx, DWORD PTR _source$[ebp]
  0004a	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0004d	66 0f be 88 00
	00 00 00	 movsx	 cx, BYTE PTR _trailingBytesForUTF8[eax]
  00055	66 89 4d ec	 mov	 WORD PTR _extraBytesToRead$1[ebp], cx

; 464  : 	if (source + extraBytesToRead >= sourceEnd) {

  00059	0f b7 55 ec	 movzx	 edx, WORD PTR _extraBytesToRead$1[ebp]
  0005d	03 55 f8	 add	 edx, DWORD PTR _source$[ebp]
  00060	3b 55 0c	 cmp	 edx, DWORD PTR _sourceEnd$[ebp]
  00063	72 0c		 jb	 SHORT $LN6@ConvertUTF

; 465  : 	    result = sourceExhausted; break;

  00065	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _result$[ebp], 1
  0006c	e9 a1 01 00 00	 jmp	 $LN3@ConvertUTF
$LN6@ConvertUTF:

; 466  : 	}
; 467  : 	/* Do this check whether lenient or strict */
; 468  : 	if (! isLegalUTF8(source, extraBytesToRead+1)) {

  00071	0f b7 45 ec	 movzx	 eax, WORD PTR _extraBytesToRead$1[ebp]
  00075	83 c0 01	 add	 eax, 1
  00078	50		 push	 eax
  00079	8b 4d f8	 mov	 ecx, DWORD PTR _source$[ebp]
  0007c	51		 push	 ecx
  0007d	e8 00 00 00 00	 call	 _isLegalUTF8
  00082	83 c4 08	 add	 esp, 8
  00085	0f b6 d0	 movzx	 edx, al
  00088	85 d2		 test	 edx, edx
  0008a	75 0c		 jne	 SHORT $LN7@ConvertUTF

; 469  : 	    result = sourceIllegal;

  0008c	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR _result$[ebp], 3

; 470  : 	    break;

  00093	e9 7a 01 00 00	 jmp	 $LN3@ConvertUTF
$LN7@ConvertUTF:

; 471  : 	}
; 472  : 	/*
; 473  : 	 * The cases all fall through. See "Note A" below.
; 474  : 	 */
; 475  : 	switch (extraBytesToRead) {

  00098	0f b7 45 ec	 movzx	 eax, WORD PTR _extraBytesToRead$1[ebp]
  0009c	89 45 e8	 mov	 DWORD PTR tv80[ebp], eax
  0009f	83 7d e8 05	 cmp	 DWORD PTR tv80[ebp], 5
  000a3	0f 87 b5 00 00
	00		 ja	 $LN4@ConvertUTF
  000a9	8b 4d e8	 mov	 ecx, DWORD PTR tv80[ebp]
  000ac	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN22@ConvertUTF[ecx*4]
$LN8@ConvertUTF:

; 476  : 	    case 5: ch += *source++; ch <<= 6;

  000b3	8b 55 f8	 mov	 edx, DWORD PTR _source$[ebp]
  000b6	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  000b9	03 45 f0	 add	 eax, DWORD PTR _ch$2[ebp]
  000bc	89 45 f0	 mov	 DWORD PTR _ch$2[ebp], eax
  000bf	8b 4d f8	 mov	 ecx, DWORD PTR _source$[ebp]
  000c2	83 c1 01	 add	 ecx, 1
  000c5	89 4d f8	 mov	 DWORD PTR _source$[ebp], ecx
  000c8	8b 55 f0	 mov	 edx, DWORD PTR _ch$2[ebp]
  000cb	c1 e2 06	 shl	 edx, 6
  000ce	89 55 f0	 mov	 DWORD PTR _ch$2[ebp], edx
$LN9@ConvertUTF:

; 477  : 	    case 4: ch += *source++; ch <<= 6;

  000d1	8b 45 f8	 mov	 eax, DWORD PTR _source$[ebp]
  000d4	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000d7	03 4d f0	 add	 ecx, DWORD PTR _ch$2[ebp]
  000da	89 4d f0	 mov	 DWORD PTR _ch$2[ebp], ecx
  000dd	8b 55 f8	 mov	 edx, DWORD PTR _source$[ebp]
  000e0	83 c2 01	 add	 edx, 1
  000e3	89 55 f8	 mov	 DWORD PTR _source$[ebp], edx
  000e6	8b 45 f0	 mov	 eax, DWORD PTR _ch$2[ebp]
  000e9	c1 e0 06	 shl	 eax, 6
  000ec	89 45 f0	 mov	 DWORD PTR _ch$2[ebp], eax
$LN10@ConvertUTF:

; 478  : 	    case 3: ch += *source++; ch <<= 6;

  000ef	8b 4d f8	 mov	 ecx, DWORD PTR _source$[ebp]
  000f2	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  000f5	03 55 f0	 add	 edx, DWORD PTR _ch$2[ebp]
  000f8	89 55 f0	 mov	 DWORD PTR _ch$2[ebp], edx
  000fb	8b 45 f8	 mov	 eax, DWORD PTR _source$[ebp]
  000fe	83 c0 01	 add	 eax, 1
  00101	89 45 f8	 mov	 DWORD PTR _source$[ebp], eax
  00104	8b 4d f0	 mov	 ecx, DWORD PTR _ch$2[ebp]
  00107	c1 e1 06	 shl	 ecx, 6
  0010a	89 4d f0	 mov	 DWORD PTR _ch$2[ebp], ecx
$LN11@ConvertUTF:

; 479  : 	    case 2: ch += *source++; ch <<= 6;

  0010d	8b 55 f8	 mov	 edx, DWORD PTR _source$[ebp]
  00110	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00113	03 45 f0	 add	 eax, DWORD PTR _ch$2[ebp]
  00116	89 45 f0	 mov	 DWORD PTR _ch$2[ebp], eax
  00119	8b 4d f8	 mov	 ecx, DWORD PTR _source$[ebp]
  0011c	83 c1 01	 add	 ecx, 1
  0011f	89 4d f8	 mov	 DWORD PTR _source$[ebp], ecx
  00122	8b 55 f0	 mov	 edx, DWORD PTR _ch$2[ebp]
  00125	c1 e2 06	 shl	 edx, 6
  00128	89 55 f0	 mov	 DWORD PTR _ch$2[ebp], edx
$LN12@ConvertUTF:

; 480  : 	    case 1: ch += *source++; ch <<= 6;

  0012b	8b 45 f8	 mov	 eax, DWORD PTR _source$[ebp]
  0012e	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00131	03 4d f0	 add	 ecx, DWORD PTR _ch$2[ebp]
  00134	89 4d f0	 mov	 DWORD PTR _ch$2[ebp], ecx
  00137	8b 55 f8	 mov	 edx, DWORD PTR _source$[ebp]
  0013a	83 c2 01	 add	 edx, 1
  0013d	89 55 f8	 mov	 DWORD PTR _source$[ebp], edx
  00140	8b 45 f0	 mov	 eax, DWORD PTR _ch$2[ebp]
  00143	c1 e0 06	 shl	 eax, 6
  00146	89 45 f0	 mov	 DWORD PTR _ch$2[ebp], eax
$LN13@ConvertUTF:

; 481  : 	    case 0: ch += *source++;

  00149	8b 4d f8	 mov	 ecx, DWORD PTR _source$[ebp]
  0014c	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  0014f	03 55 f0	 add	 edx, DWORD PTR _ch$2[ebp]
  00152	89 55 f0	 mov	 DWORD PTR _ch$2[ebp], edx
  00155	8b 45 f8	 mov	 eax, DWORD PTR _source$[ebp]
  00158	83 c0 01	 add	 eax, 1
  0015b	89 45 f8	 mov	 DWORD PTR _source$[ebp], eax
$LN4@ConvertUTF:

; 482  : 	}
; 483  : 	ch -= offsetsFromUTF8[extraBytesToRead];

  0015e	0f b7 4d ec	 movzx	 ecx, WORD PTR _extraBytesToRead$1[ebp]
  00162	8b 55 f0	 mov	 edx, DWORD PTR _ch$2[ebp]
  00165	2b 14 8d 00 00
	00 00		 sub	 edx, DWORD PTR _offsetsFromUTF8[ecx*4]
  0016c	89 55 f0	 mov	 DWORD PTR _ch$2[ebp], edx

; 484  : 
; 485  : 	if (target >= targetEnd) {

  0016f	8b 45 f4	 mov	 eax, DWORD PTR _target$[ebp]
  00172	3b 45 14	 cmp	 eax, DWORD PTR _targetEnd$[ebp]
  00175	72 1b		 jb	 SHORT $LN14@ConvertUTF

; 486  : 	    source -= (extraBytesToRead+1); /* Back up the source pointer! */

  00177	0f b7 4d ec	 movzx	 ecx, WORD PTR _extraBytesToRead$1[ebp]
  0017b	83 c1 01	 add	 ecx, 1
  0017e	8b 55 f8	 mov	 edx, DWORD PTR _source$[ebp]
  00181	2b d1		 sub	 edx, ecx
  00183	89 55 f8	 mov	 DWORD PTR _source$[ebp], edx

; 487  : 	    result = targetExhausted; break;

  00186	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR _result$[ebp], 2
  0018d	e9 80 00 00 00	 jmp	 $LN3@ConvertUTF
$LN14@ConvertUTF:

; 488  : 	}
; 489  : 	if (ch <= UNI_MAX_LEGAL_UTF32) {

  00192	81 7d f0 ff ff
	10 00		 cmp	 DWORD PTR _ch$2[ebp], 1114111 ; 0010ffffH
  00199	77 59		 ja	 SHORT $LN15@ConvertUTF

; 490  : 	    /*
; 491  : 	     * UTF-16 surrogate values are illegal in UTF-32, and anything
; 492  : 	     * over Plane 17 (> 0x10FFFF) is illegal.
; 493  : 	     */
; 494  : 	    if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_LOW_END) {

  0019b	81 7d f0 00 d8
	00 00		 cmp	 DWORD PTR _ch$2[ebp], 55296 ; 0000d800H
  001a2	72 3d		 jb	 SHORT $LN17@ConvertUTF
  001a4	81 7d f0 ff df
	00 00		 cmp	 DWORD PTR _ch$2[ebp], 57343 ; 0000dfffH
  001ab	77 34		 ja	 SHORT $LN17@ConvertUTF

; 495  : 		if (flags == strictConversion) {

  001ad	83 7d 18 00	 cmp	 DWORD PTR _flags$[ebp], 0
  001b1	75 1a		 jne	 SHORT $LN19@ConvertUTF

; 496  : 		    source -= (extraBytesToRead+1); /* return to the illegal value itself */

  001b3	0f b7 45 ec	 movzx	 eax, WORD PTR _extraBytesToRead$1[ebp]
  001b7	83 c0 01	 add	 eax, 1
  001ba	8b 4d f8	 mov	 ecx, DWORD PTR _source$[ebp]
  001bd	2b c8		 sub	 ecx, eax
  001bf	89 4d f8	 mov	 DWORD PTR _source$[ebp], ecx

; 497  : 		    result = sourceIllegal;

  001c2	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR _result$[ebp], 3

; 498  : 		    break;

  001c9	eb 47		 jmp	 SHORT $LN3@ConvertUTF

; 499  : 		} else {

  001cb	eb 12		 jmp	 SHORT $LN20@ConvertUTF
$LN19@ConvertUTF:

; 500  : 		    *target++ = UNI_REPLACEMENT_CHAR;

  001cd	8b 55 f4	 mov	 edx, DWORD PTR _target$[ebp]
  001d0	c7 02 fd ff 00
	00		 mov	 DWORD PTR [edx], 65533	; 0000fffdH
  001d6	8b 45 f4	 mov	 eax, DWORD PTR _target$[ebp]
  001d9	83 c0 04	 add	 eax, 4
  001dc	89 45 f4	 mov	 DWORD PTR _target$[ebp], eax
$LN20@ConvertUTF:

; 501  : 		}
; 502  : 	    } else {

  001df	eb 11		 jmp	 SHORT $LN18@ConvertUTF
$LN17@ConvertUTF:

; 503  : 		*target++ = ch;

  001e1	8b 4d f4	 mov	 ecx, DWORD PTR _target$[ebp]
  001e4	8b 55 f0	 mov	 edx, DWORD PTR _ch$2[ebp]
  001e7	89 11		 mov	 DWORD PTR [ecx], edx
  001e9	8b 45 f4	 mov	 eax, DWORD PTR _target$[ebp]
  001ec	83 c0 04	 add	 eax, 4
  001ef	89 45 f4	 mov	 DWORD PTR _target$[ebp], eax
$LN18@ConvertUTF:

; 504  : 	    }
; 505  : 	} else { /* i.e., ch > UNI_MAX_LEGAL_UTF32 */

  001f2	eb 19		 jmp	 SHORT $LN16@ConvertUTF
$LN15@ConvertUTF:

; 506  : 	    result = sourceIllegal;

  001f4	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR _result$[ebp], 3

; 507  : 	    *target++ = UNI_REPLACEMENT_CHAR;

  001fb	8b 4d f4	 mov	 ecx, DWORD PTR _target$[ebp]
  001fe	c7 01 fd ff 00
	00		 mov	 DWORD PTR [ecx], 65533	; 0000fffdH
  00204	8b 55 f4	 mov	 edx, DWORD PTR _target$[ebp]
  00207	83 c2 04	 add	 edx, 4
  0020a	89 55 f4	 mov	 DWORD PTR _target$[ebp], edx
$LN16@ConvertUTF:

; 508  : 	}
; 509  :     }

  0020d	e9 22 fe ff ff	 jmp	 $LN2@ConvertUTF
$LN3@ConvertUTF:

; 510  :     *sourceStart = source;

  00212	8b 45 08	 mov	 eax, DWORD PTR _sourceStart$[ebp]
  00215	8b 4d f8	 mov	 ecx, DWORD PTR _source$[ebp]
  00218	89 08		 mov	 DWORD PTR [eax], ecx

; 511  :     *targetStart = target;

  0021a	8b 55 10	 mov	 edx, DWORD PTR _targetStart$[ebp]
  0021d	8b 45 f4	 mov	 eax, DWORD PTR _target$[ebp]
  00220	89 02		 mov	 DWORD PTR [edx], eax

; 512  :     return result;

  00222	8b 45 fc	 mov	 eax, DWORD PTR _result$[ebp]

; 513  : }

  00225	83 c4 18	 add	 esp, 24			; 00000018H
  00228	3b ec		 cmp	 ebp, esp
  0022a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0022f	8b e5		 mov	 esp, ebp
  00231	5d		 pop	 ebp
  00232	c3		 ret	 0
  00233	90		 npad	 1
$LN22@ConvertUTF:
  00234	00 00 00 00	 DD	 $LN13@ConvertUTF
  00238	00 00 00 00	 DD	 $LN12@ConvertUTF
  0023c	00 00 00 00	 DD	 $LN11@ConvertUTF
  00240	00 00 00 00	 DD	 $LN10@ConvertUTF
  00244	00 00 00 00	 DD	 $LN9@ConvertUTF
  00248	00 00 00 00	 DD	 $LN8@ConvertUTF
_ConvertUTF8toUTF32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3convertutf.c
;	COMDAT _ConvertUTF16toUTF8
_TEXT	SEGMENT
tv128 = -40						; size = 4
_ch2$1 = -36						; size = 4
_oldSource$2 = -32					; size = 4
_byteMark$3 = -28					; size = 4
_byteMask$4 = -24					; size = 4
_bytesToWrite$5 = -20					; size = 2
_ch$6 = -16						; size = 4
_target$ = -12						; size = 4
_source$ = -8						; size = 4
_result$ = -4						; size = 4
_sourceStart$ = 8					; size = 4
_sourceEnd$ = 12					; size = 4
_targetStart$ = 16					; size = 4
_targetEnd$ = 20					; size = 4
_flags$ = 24						; size = 4
_ConvertUTF16toUTF8 PROC				; COMDAT

; 207  : 	UTF8** targetStart, UTF8* targetEnd, ConversionFlags flags) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H

; 208  :     ConversionResult result = conversionOK;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _result$[ebp], 0

; 209  :     const UTF16* source = *sourceStart;

  0000d	8b 45 08	 mov	 eax, DWORD PTR _sourceStart$[ebp]
  00010	8b 08		 mov	 ecx, DWORD PTR [eax]
  00012	89 4d f8	 mov	 DWORD PTR _source$[ebp], ecx

; 210  :     UTF8* target = *targetStart;

  00015	8b 55 10	 mov	 edx, DWORD PTR _targetStart$[ebp]
  00018	8b 02		 mov	 eax, DWORD PTR [edx]
  0001a	89 45 f4	 mov	 DWORD PTR _target$[ebp], eax
$LN2@ConvertUTF:

; 211  :     while (source < sourceEnd) {

  0001d	8b 4d f8	 mov	 ecx, DWORD PTR _source$[ebp]
  00020	3b 4d 0c	 cmp	 ecx, DWORD PTR _sourceEnd$[ebp]
  00023	0f 83 29 02 00
	00		 jae	 $LN3@ConvertUTF

; 212  : 	UTF32 ch;
; 213  : 	unsigned short bytesToWrite = 0;

  00029	33 d2		 xor	 edx, edx
  0002b	66 89 55 ec	 mov	 WORD PTR _bytesToWrite$5[ebp], dx

; 214  : 	const UTF32 byteMask = 0xBF;

  0002f	c7 45 e8 bf 00
	00 00		 mov	 DWORD PTR _byteMask$4[ebp], 191 ; 000000bfH

; 215  : 	const UTF32 byteMark = 0x80; 

  00036	c7 45 e4 80 00
	00 00		 mov	 DWORD PTR _byteMark$3[ebp], 128 ; 00000080H

; 216  : 	const UTF16* oldSource = source; /* In case we have to back up because of target overflow. */

  0003d	8b 45 f8	 mov	 eax, DWORD PTR _source$[ebp]
  00040	89 45 e0	 mov	 DWORD PTR _oldSource$2[ebp], eax

; 217  : 	ch = *source++;

  00043	8b 4d f8	 mov	 ecx, DWORD PTR _source$[ebp]
  00046	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  00049	89 55 f0	 mov	 DWORD PTR _ch$6[ebp], edx
  0004c	8b 45 f8	 mov	 eax, DWORD PTR _source$[ebp]
  0004f	83 c0 02	 add	 eax, 2
  00052	89 45 f8	 mov	 DWORD PTR _source$[ebp], eax

; 218  : 	/* If we have a surrogate pair, convert to UTF32 first. */
; 219  : 	if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_HIGH_END) {

  00055	81 7d f0 00 d8
	00 00		 cmp	 DWORD PTR _ch$6[ebp], 55296 ; 0000d800H
  0005c	0f 82 84 00 00
	00		 jb	 $LN6@ConvertUTF
  00062	81 7d f0 ff db
	00 00		 cmp	 DWORD PTR _ch$6[ebp], 56319 ; 0000dbffH
  00069	77 7b		 ja	 SHORT $LN6@ConvertUTF

; 220  : 	    /* If the 16 bits following the high surrogate are in the source buffer... */
; 221  : 	    if (source < sourceEnd) {

  0006b	8b 4d f8	 mov	 ecx, DWORD PTR _source$[ebp]
  0006e	3b 4d 0c	 cmp	 ecx, DWORD PTR _sourceEnd$[ebp]
  00071	73 5c		 jae	 SHORT $LN8@ConvertUTF

; 222  : 		UTF32 ch2 = *source;

  00073	8b 55 f8	 mov	 edx, DWORD PTR _source$[ebp]
  00076	0f b7 02	 movzx	 eax, WORD PTR [edx]
  00079	89 45 dc	 mov	 DWORD PTR _ch2$1[ebp], eax

; 223  : 		/* If it's a low surrogate, convert to UTF32. */
; 224  : 		if (ch2 >= UNI_SUR_LOW_START && ch2 <= UNI_SUR_LOW_END) {

  0007c	81 7d dc 00 dc
	00 00		 cmp	 DWORD PTR _ch2$1[ebp], 56320 ; 0000dc00H
  00083	72 2d		 jb	 SHORT $LN10@ConvertUTF
  00085	81 7d dc ff df
	00 00		 cmp	 DWORD PTR _ch2$1[ebp], 57343 ; 0000dfffH
  0008c	77 24		 ja	 SHORT $LN10@ConvertUTF

; 225  : 		    ch = ((ch - UNI_SUR_HIGH_START) << halfShift)

  0008e	8b 4d f0	 mov	 ecx, DWORD PTR _ch$6[ebp]
  00091	81 e9 00 d8 00
	00		 sub	 ecx, 55296		; 0000d800H
  00097	c1 e1 0a	 shl	 ecx, 10			; 0000000aH
  0009a	8b 55 dc	 mov	 edx, DWORD PTR _ch2$1[ebp]
  0009d	8d 84 11 00 24
	00 00		 lea	 eax, DWORD PTR [ecx+edx+9216]
  000a4	89 45 f0	 mov	 DWORD PTR _ch$6[ebp], eax

; 226  : 			+ (ch2 - UNI_SUR_LOW_START) + halfBase;
; 227  : 		    ++source;

  000a7	8b 4d f8	 mov	 ecx, DWORD PTR _source$[ebp]
  000aa	83 c1 02	 add	 ecx, 2
  000ad	89 4d f8	 mov	 DWORD PTR _source$[ebp], ecx
  000b0	eb 1b		 jmp	 SHORT $LN12@ConvertUTF
$LN10@ConvertUTF:

; 228  : 		} else if (flags == strictConversion) { /* it's an unpaired high surrogate */

  000b2	83 7d 18 00	 cmp	 DWORD PTR _flags$[ebp], 0
  000b6	75 15		 jne	 SHORT $LN12@ConvertUTF

; 229  : 		    --source; /* return to the illegal value itself */

  000b8	8b 55 f8	 mov	 edx, DWORD PTR _source$[ebp]
  000bb	83 ea 02	 sub	 edx, 2
  000be	89 55 f8	 mov	 DWORD PTR _source$[ebp], edx

; 230  : 		    result = sourceIllegal;

  000c1	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR _result$[ebp], 3

; 231  : 		    break;

  000c8	e9 85 01 00 00	 jmp	 $LN3@ConvertUTF
$LN12@ConvertUTF:

; 232  : 		}
; 233  : 	    } else { /* We don't have the 16 bits following the high surrogate. */

  000cd	eb 15		 jmp	 SHORT $LN9@ConvertUTF
$LN8@ConvertUTF:

; 234  : 		--source; /* return to the high surrogate */

  000cf	8b 45 f8	 mov	 eax, DWORD PTR _source$[ebp]
  000d2	83 e8 02	 sub	 eax, 2
  000d5	89 45 f8	 mov	 DWORD PTR _source$[ebp], eax

; 235  : 		result = sourceExhausted;

  000d8	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _result$[ebp], 1

; 236  : 		break;

  000df	e9 6e 01 00 00	 jmp	 $LN3@ConvertUTF
$LN9@ConvertUTF:

; 237  : 	    }

  000e4	eb 2d		 jmp	 SHORT $LN14@ConvertUTF
$LN6@ConvertUTF:

; 238  :         } else if (flags == strictConversion) {

  000e6	83 7d 18 00	 cmp	 DWORD PTR _flags$[ebp], 0
  000ea	75 27		 jne	 SHORT $LN14@ConvertUTF

; 239  : 	    /* UTF-16 surrogate values are illegal in UTF-32 */
; 240  : 	    if (ch >= UNI_SUR_LOW_START && ch <= UNI_SUR_LOW_END) {

  000ec	81 7d f0 00 dc
	00 00		 cmp	 DWORD PTR _ch$6[ebp], 56320 ; 0000dc00H
  000f3	72 1e		 jb	 SHORT $LN14@ConvertUTF
  000f5	81 7d f0 ff df
	00 00		 cmp	 DWORD PTR _ch$6[ebp], 57343 ; 0000dfffH
  000fc	77 15		 ja	 SHORT $LN14@ConvertUTF

; 241  : 		--source; /* return to the illegal value itself */

  000fe	8b 4d f8	 mov	 ecx, DWORD PTR _source$[ebp]
  00101	83 e9 02	 sub	 ecx, 2
  00104	89 4d f8	 mov	 DWORD PTR _source$[ebp], ecx

; 242  : 		result = sourceIllegal;

  00107	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR _result$[ebp], 3

; 243  : 		break;

  0010e	e9 3f 01 00 00	 jmp	 $LN3@ConvertUTF
$LN14@ConvertUTF:

; 244  : 	    }
; 245  : 	}
; 246  : 	/* Figure out how many bytes the result will require */
; 247  : 	if (ch < (UTF32)0x80) {	     bytesToWrite = 1;

  00113	81 7d f0 80 00
	00 00		 cmp	 DWORD PTR _ch$6[ebp], 128 ; 00000080H
  0011a	73 0b		 jae	 SHORT $LN15@ConvertUTF
  0011c	ba 01 00 00 00	 mov	 edx, 1
  00121	66 89 55 ec	 mov	 WORD PTR _bytesToWrite$5[ebp], dx
  00125	eb 4c		 jmp	 SHORT $LN22@ConvertUTF
$LN15@ConvertUTF:

; 248  : 	} else if (ch < (UTF32)0x800) {     bytesToWrite = 2;

  00127	81 7d f0 00 08
	00 00		 cmp	 DWORD PTR _ch$6[ebp], 2048 ; 00000800H
  0012e	73 0b		 jae	 SHORT $LN17@ConvertUTF
  00130	b8 02 00 00 00	 mov	 eax, 2
  00135	66 89 45 ec	 mov	 WORD PTR _bytesToWrite$5[ebp], ax
  00139	eb 38		 jmp	 SHORT $LN22@ConvertUTF
$LN17@ConvertUTF:

; 249  : 	} else if (ch < (UTF32)0x10000) {   bytesToWrite = 3;

  0013b	81 7d f0 00 00
	01 00		 cmp	 DWORD PTR _ch$6[ebp], 65536 ; 00010000H
  00142	73 0b		 jae	 SHORT $LN19@ConvertUTF
  00144	b9 03 00 00 00	 mov	 ecx, 3
  00149	66 89 4d ec	 mov	 WORD PTR _bytesToWrite$5[ebp], cx
  0014d	eb 24		 jmp	 SHORT $LN22@ConvertUTF
$LN19@ConvertUTF:

; 250  : 	} else if (ch < (UTF32)0x110000) {  bytesToWrite = 4;

  0014f	81 7d f0 00 00
	11 00		 cmp	 DWORD PTR _ch$6[ebp], 1114112 ; 00110000H
  00156	73 0b		 jae	 SHORT $LN21@ConvertUTF
  00158	ba 04 00 00 00	 mov	 edx, 4
  0015d	66 89 55 ec	 mov	 WORD PTR _bytesToWrite$5[ebp], dx
  00161	eb 10		 jmp	 SHORT $LN22@ConvertUTF
$LN21@ConvertUTF:

; 251  : 	} else {			    bytesToWrite = 3;

  00163	b8 03 00 00 00	 mov	 eax, 3
  00168	66 89 45 ec	 mov	 WORD PTR _bytesToWrite$5[ebp], ax

; 252  : 					    ch = UNI_REPLACEMENT_CHAR;

  0016c	c7 45 f0 fd ff
	00 00		 mov	 DWORD PTR _ch$6[ebp], 65533 ; 0000fffdH
$LN22@ConvertUTF:

; 253  : 	}
; 254  : 
; 255  : 	target += bytesToWrite;

  00173	0f b7 4d ec	 movzx	 ecx, WORD PTR _bytesToWrite$5[ebp]
  00177	03 4d f4	 add	 ecx, DWORD PTR _target$[ebp]
  0017a	89 4d f4	 mov	 DWORD PTR _target$[ebp], ecx

; 256  : 	if (target > targetEnd) {

  0017d	8b 55 f4	 mov	 edx, DWORD PTR _target$[ebp]
  00180	3b 55 14	 cmp	 edx, DWORD PTR _targetEnd$[ebp]
  00183	76 1e		 jbe	 SHORT $LN23@ConvertUTF

; 257  : 	    source = oldSource; /* Back up source pointer! */

  00185	8b 45 e0	 mov	 eax, DWORD PTR _oldSource$2[ebp]
  00188	89 45 f8	 mov	 DWORD PTR _source$[ebp], eax

; 258  : 	    target -= bytesToWrite; result = targetExhausted; break;

  0018b	0f b7 4d ec	 movzx	 ecx, WORD PTR _bytesToWrite$5[ebp]
  0018f	8b 55 f4	 mov	 edx, DWORD PTR _target$[ebp]
  00192	2b d1		 sub	 edx, ecx
  00194	89 55 f4	 mov	 DWORD PTR _target$[ebp], edx
  00197	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR _result$[ebp], 2
  0019e	e9 af 00 00 00	 jmp	 $LN3@ConvertUTF
$LN23@ConvertUTF:

; 259  : 	}
; 260  : 	switch (bytesToWrite) { /* note: everything falls through. */

  001a3	0f b7 45 ec	 movzx	 eax, WORD PTR _bytesToWrite$5[ebp]
  001a7	89 45 d8	 mov	 DWORD PTR tv128[ebp], eax
  001aa	8b 4d d8	 mov	 ecx, DWORD PTR tv128[ebp]
  001ad	83 e9 01	 sub	 ecx, 1
  001b0	89 4d d8	 mov	 DWORD PTR tv128[ebp], ecx
  001b3	83 7d d8 03	 cmp	 DWORD PTR tv128[ebp], 3
  001b7	0f 87 86 00 00
	00		 ja	 $LN4@ConvertUTF
  001bd	8b 55 d8	 mov	 edx, DWORD PTR tv128[ebp]
  001c0	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN29@ConvertUTF[edx*4]
$LN24@ConvertUTF:

; 261  : 	    case 4: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;

  001c7	8b 45 f4	 mov	 eax, DWORD PTR _target$[ebp]
  001ca	83 e8 01	 sub	 eax, 1
  001cd	89 45 f4	 mov	 DWORD PTR _target$[ebp], eax
  001d0	8b 4d f0	 mov	 ecx, DWORD PTR _ch$6[ebp]
  001d3	0b 4d e4	 or	 ecx, DWORD PTR _byteMark$3[ebp]
  001d6	23 4d e8	 and	 ecx, DWORD PTR _byteMask$4[ebp]
  001d9	8b 55 f4	 mov	 edx, DWORD PTR _target$[ebp]
  001dc	88 0a		 mov	 BYTE PTR [edx], cl
  001de	8b 45 f0	 mov	 eax, DWORD PTR _ch$6[ebp]
  001e1	c1 e8 06	 shr	 eax, 6
  001e4	89 45 f0	 mov	 DWORD PTR _ch$6[ebp], eax
$LN25@ConvertUTF:

; 262  : 	    case 3: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;

  001e7	8b 4d f4	 mov	 ecx, DWORD PTR _target$[ebp]
  001ea	83 e9 01	 sub	 ecx, 1
  001ed	89 4d f4	 mov	 DWORD PTR _target$[ebp], ecx
  001f0	8b 55 f0	 mov	 edx, DWORD PTR _ch$6[ebp]
  001f3	0b 55 e4	 or	 edx, DWORD PTR _byteMark$3[ebp]
  001f6	23 55 e8	 and	 edx, DWORD PTR _byteMask$4[ebp]
  001f9	8b 45 f4	 mov	 eax, DWORD PTR _target$[ebp]
  001fc	88 10		 mov	 BYTE PTR [eax], dl
  001fe	8b 4d f0	 mov	 ecx, DWORD PTR _ch$6[ebp]
  00201	c1 e9 06	 shr	 ecx, 6
  00204	89 4d f0	 mov	 DWORD PTR _ch$6[ebp], ecx
$LN26@ConvertUTF:

; 263  : 	    case 2: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;

  00207	8b 55 f4	 mov	 edx, DWORD PTR _target$[ebp]
  0020a	83 ea 01	 sub	 edx, 1
  0020d	89 55 f4	 mov	 DWORD PTR _target$[ebp], edx
  00210	8b 45 f0	 mov	 eax, DWORD PTR _ch$6[ebp]
  00213	0b 45 e4	 or	 eax, DWORD PTR _byteMark$3[ebp]
  00216	23 45 e8	 and	 eax, DWORD PTR _byteMask$4[ebp]
  00219	8b 4d f4	 mov	 ecx, DWORD PTR _target$[ebp]
  0021c	88 01		 mov	 BYTE PTR [ecx], al
  0021e	8b 55 f0	 mov	 edx, DWORD PTR _ch$6[ebp]
  00221	c1 ea 06	 shr	 edx, 6
  00224	89 55 f0	 mov	 DWORD PTR _ch$6[ebp], edx
$LN27@ConvertUTF:

; 264  : 	    case 1: *--target =  (UTF8)(ch | firstByteMark[bytesToWrite]);

  00227	8b 45 f4	 mov	 eax, DWORD PTR _target$[ebp]
  0022a	83 e8 01	 sub	 eax, 1
  0022d	89 45 f4	 mov	 DWORD PTR _target$[ebp], eax
  00230	0f b7 4d ec	 movzx	 ecx, WORD PTR _bytesToWrite$5[ebp]
  00234	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR _firstByteMark[ecx]
  0023b	0b 55 f0	 or	 edx, DWORD PTR _ch$6[ebp]
  0023e	8b 45 f4	 mov	 eax, DWORD PTR _target$[ebp]
  00241	88 10		 mov	 BYTE PTR [eax], dl
$LN4@ConvertUTF:

; 265  : 	}
; 266  : 	target += bytesToWrite;

  00243	0f b7 4d ec	 movzx	 ecx, WORD PTR _bytesToWrite$5[ebp]
  00247	03 4d f4	 add	 ecx, DWORD PTR _target$[ebp]
  0024a	89 4d f4	 mov	 DWORD PTR _target$[ebp], ecx

; 267  :     }

  0024d	e9 cb fd ff ff	 jmp	 $LN2@ConvertUTF
$LN3@ConvertUTF:

; 268  :     *sourceStart = source;

  00252	8b 55 08	 mov	 edx, DWORD PTR _sourceStart$[ebp]
  00255	8b 45 f8	 mov	 eax, DWORD PTR _source$[ebp]
  00258	89 02		 mov	 DWORD PTR [edx], eax

; 269  :     *targetStart = target;

  0025a	8b 4d 10	 mov	 ecx, DWORD PTR _targetStart$[ebp]
  0025d	8b 55 f4	 mov	 edx, DWORD PTR _target$[ebp]
  00260	89 11		 mov	 DWORD PTR [ecx], edx

; 270  :     return result;

  00262	8b 45 fc	 mov	 eax, DWORD PTR _result$[ebp]

; 271  : }

  00265	8b e5		 mov	 esp, ebp
  00267	5d		 pop	 ebp
  00268	c3		 ret	 0
  00269	0f 1f 00	 npad	 3
$LN29@ConvertUTF:
  0026c	00 00 00 00	 DD	 $LN27@ConvertUTF
  00270	00 00 00 00	 DD	 $LN26@ConvertUTF
  00274	00 00 00 00	 DD	 $LN25@ConvertUTF
  00278	00 00 00 00	 DD	 $LN24@ConvertUTF
_ConvertUTF16toUTF8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3convertutf.c
;	COMDAT _ConvertUTF8toUTF16
_TEXT	SEGMENT
tv80 = -24						; size = 4
_extraBytesToRead$1 = -20				; size = 2
_ch$2 = -16						; size = 4
_target$ = -12						; size = 4
_source$ = -8						; size = 4
_result$ = -4						; size = 4
_sourceStart$ = 8					; size = 4
_sourceEnd$ = 12					; size = 4
_targetStart$ = 16					; size = 4
_targetEnd$ = 20					; size = 4
_flags$ = 24						; size = 4
_ConvertUTF8toUTF16 PROC				; COMDAT

; 331  : 	UTF16** targetStart, UTF16* targetEnd, ConversionFlags flags) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  0000e	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00011	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00014	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00017	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001a	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 332  :     ConversionResult result = conversionOK;

  0001d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _result$[ebp], 0

; 333  :     const UTF8* source = *sourceStart;

  00024	8b 45 08	 mov	 eax, DWORD PTR _sourceStart$[ebp]
  00027	8b 08		 mov	 ecx, DWORD PTR [eax]
  00029	89 4d f8	 mov	 DWORD PTR _source$[ebp], ecx

; 334  :     UTF16* target = *targetStart;

  0002c	8b 55 10	 mov	 edx, DWORD PTR _targetStart$[ebp]
  0002f	8b 02		 mov	 eax, DWORD PTR [edx]
  00031	89 45 f4	 mov	 DWORD PTR _target$[ebp], eax
$LN2@ConvertUTF:

; 335  :     while (source < sourceEnd) {

  00034	8b 4d f8	 mov	 ecx, DWORD PTR _source$[ebp]
  00037	3b 4d 0c	 cmp	 ecx, DWORD PTR _sourceEnd$[ebp]
  0003a	0f 83 6d 02 00
	00		 jae	 $LN3@ConvertUTF

; 336  : 	UTF32 ch = 0;

  00040	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _ch$2[ebp], 0

; 337  : 	unsigned short extraBytesToRead = trailingBytesForUTF8[*source];

  00047	8b 55 f8	 mov	 edx, DWORD PTR _source$[ebp]
  0004a	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0004d	66 0f be 88 00
	00 00 00	 movsx	 cx, BYTE PTR _trailingBytesForUTF8[eax]
  00055	66 89 4d ec	 mov	 WORD PTR _extraBytesToRead$1[ebp], cx

; 338  : 	if (source + extraBytesToRead >= sourceEnd) {

  00059	0f b7 55 ec	 movzx	 edx, WORD PTR _extraBytesToRead$1[ebp]
  0005d	03 55 f8	 add	 edx, DWORD PTR _source$[ebp]
  00060	3b 55 0c	 cmp	 edx, DWORD PTR _sourceEnd$[ebp]
  00063	72 0c		 jb	 SHORT $LN6@ConvertUTF

; 339  : 	    result = sourceExhausted; break;

  00065	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _result$[ebp], 1
  0006c	e9 3c 02 00 00	 jmp	 $LN3@ConvertUTF
$LN6@ConvertUTF:

; 340  : 	}
; 341  : 	/* Do this check whether lenient or strict */
; 342  : 	if (! isLegalUTF8(source, extraBytesToRead+1)) {

  00071	0f b7 45 ec	 movzx	 eax, WORD PTR _extraBytesToRead$1[ebp]
  00075	83 c0 01	 add	 eax, 1
  00078	50		 push	 eax
  00079	8b 4d f8	 mov	 ecx, DWORD PTR _source$[ebp]
  0007c	51		 push	 ecx
  0007d	e8 00 00 00 00	 call	 _isLegalUTF8
  00082	83 c4 08	 add	 esp, 8
  00085	0f b6 d0	 movzx	 edx, al
  00088	85 d2		 test	 edx, edx
  0008a	75 0c		 jne	 SHORT $LN7@ConvertUTF

; 343  : 	    result = sourceIllegal;

  0008c	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR _result$[ebp], 3

; 344  : 	    break;

  00093	e9 15 02 00 00	 jmp	 $LN3@ConvertUTF
$LN7@ConvertUTF:

; 345  : 	}
; 346  : 	/*
; 347  : 	 * The cases all fall through. See "Note A" below.
; 348  : 	 */
; 349  : 	switch (extraBytesToRead) {

  00098	0f b7 45 ec	 movzx	 eax, WORD PTR _extraBytesToRead$1[ebp]
  0009c	89 45 e8	 mov	 DWORD PTR tv80[ebp], eax
  0009f	83 7d e8 05	 cmp	 DWORD PTR tv80[ebp], 5
  000a3	0f 87 b5 00 00
	00		 ja	 $LN4@ConvertUTF
  000a9	8b 4d e8	 mov	 ecx, DWORD PTR tv80[ebp]
  000ac	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN27@ConvertUTF[ecx*4]
$LN8@ConvertUTF:

; 350  : 	    case 5: ch += *source++; ch <<= 6; /* remember, illegal UTF-8 */

  000b3	8b 55 f8	 mov	 edx, DWORD PTR _source$[ebp]
  000b6	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  000b9	03 45 f0	 add	 eax, DWORD PTR _ch$2[ebp]
  000bc	89 45 f0	 mov	 DWORD PTR _ch$2[ebp], eax
  000bf	8b 4d f8	 mov	 ecx, DWORD PTR _source$[ebp]
  000c2	83 c1 01	 add	 ecx, 1
  000c5	89 4d f8	 mov	 DWORD PTR _source$[ebp], ecx
  000c8	8b 55 f0	 mov	 edx, DWORD PTR _ch$2[ebp]
  000cb	c1 e2 06	 shl	 edx, 6
  000ce	89 55 f0	 mov	 DWORD PTR _ch$2[ebp], edx
$LN9@ConvertUTF:

; 351  : 	    case 4: ch += *source++; ch <<= 6; /* remember, illegal UTF-8 */

  000d1	8b 45 f8	 mov	 eax, DWORD PTR _source$[ebp]
  000d4	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000d7	03 4d f0	 add	 ecx, DWORD PTR _ch$2[ebp]
  000da	89 4d f0	 mov	 DWORD PTR _ch$2[ebp], ecx
  000dd	8b 55 f8	 mov	 edx, DWORD PTR _source$[ebp]
  000e0	83 c2 01	 add	 edx, 1
  000e3	89 55 f8	 mov	 DWORD PTR _source$[ebp], edx
  000e6	8b 45 f0	 mov	 eax, DWORD PTR _ch$2[ebp]
  000e9	c1 e0 06	 shl	 eax, 6
  000ec	89 45 f0	 mov	 DWORD PTR _ch$2[ebp], eax
$LN10@ConvertUTF:

; 352  : 	    case 3: ch += *source++; ch <<= 6;

  000ef	8b 4d f8	 mov	 ecx, DWORD PTR _source$[ebp]
  000f2	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  000f5	03 55 f0	 add	 edx, DWORD PTR _ch$2[ebp]
  000f8	89 55 f0	 mov	 DWORD PTR _ch$2[ebp], edx
  000fb	8b 45 f8	 mov	 eax, DWORD PTR _source$[ebp]
  000fe	83 c0 01	 add	 eax, 1
  00101	89 45 f8	 mov	 DWORD PTR _source$[ebp], eax
  00104	8b 4d f0	 mov	 ecx, DWORD PTR _ch$2[ebp]
  00107	c1 e1 06	 shl	 ecx, 6
  0010a	89 4d f0	 mov	 DWORD PTR _ch$2[ebp], ecx
$LN11@ConvertUTF:

; 353  : 	    case 2: ch += *source++; ch <<= 6;

  0010d	8b 55 f8	 mov	 edx, DWORD PTR _source$[ebp]
  00110	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00113	03 45 f0	 add	 eax, DWORD PTR _ch$2[ebp]
  00116	89 45 f0	 mov	 DWORD PTR _ch$2[ebp], eax
  00119	8b 4d f8	 mov	 ecx, DWORD PTR _source$[ebp]
  0011c	83 c1 01	 add	 ecx, 1
  0011f	89 4d f8	 mov	 DWORD PTR _source$[ebp], ecx
  00122	8b 55 f0	 mov	 edx, DWORD PTR _ch$2[ebp]
  00125	c1 e2 06	 shl	 edx, 6
  00128	89 55 f0	 mov	 DWORD PTR _ch$2[ebp], edx
$LN12@ConvertUTF:

; 354  : 	    case 1: ch += *source++; ch <<= 6;

  0012b	8b 45 f8	 mov	 eax, DWORD PTR _source$[ebp]
  0012e	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00131	03 4d f0	 add	 ecx, DWORD PTR _ch$2[ebp]
  00134	89 4d f0	 mov	 DWORD PTR _ch$2[ebp], ecx
  00137	8b 55 f8	 mov	 edx, DWORD PTR _source$[ebp]
  0013a	83 c2 01	 add	 edx, 1
  0013d	89 55 f8	 mov	 DWORD PTR _source$[ebp], edx
  00140	8b 45 f0	 mov	 eax, DWORD PTR _ch$2[ebp]
  00143	c1 e0 06	 shl	 eax, 6
  00146	89 45 f0	 mov	 DWORD PTR _ch$2[ebp], eax
$LN13@ConvertUTF:

; 355  : 	    case 0: ch += *source++;

  00149	8b 4d f8	 mov	 ecx, DWORD PTR _source$[ebp]
  0014c	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  0014f	03 55 f0	 add	 edx, DWORD PTR _ch$2[ebp]
  00152	89 55 f0	 mov	 DWORD PTR _ch$2[ebp], edx
  00155	8b 45 f8	 mov	 eax, DWORD PTR _source$[ebp]
  00158	83 c0 01	 add	 eax, 1
  0015b	89 45 f8	 mov	 DWORD PTR _source$[ebp], eax
$LN4@ConvertUTF:

; 356  : 	}
; 357  : 	ch -= offsetsFromUTF8[extraBytesToRead];

  0015e	0f b7 4d ec	 movzx	 ecx, WORD PTR _extraBytesToRead$1[ebp]
  00162	8b 55 f0	 mov	 edx, DWORD PTR _ch$2[ebp]
  00165	2b 14 8d 00 00
	00 00		 sub	 edx, DWORD PTR _offsetsFromUTF8[ecx*4]
  0016c	89 55 f0	 mov	 DWORD PTR _ch$2[ebp], edx

; 358  : 
; 359  : 	if (target >= targetEnd) {

  0016f	8b 45 f4	 mov	 eax, DWORD PTR _target$[ebp]
  00172	3b 45 14	 cmp	 eax, DWORD PTR _targetEnd$[ebp]
  00175	72 1b		 jb	 SHORT $LN14@ConvertUTF

; 360  : 	    source -= (extraBytesToRead+1); /* Back up source pointer! */

  00177	0f b7 4d ec	 movzx	 ecx, WORD PTR _extraBytesToRead$1[ebp]
  0017b	83 c1 01	 add	 ecx, 1
  0017e	8b 55 f8	 mov	 edx, DWORD PTR _source$[ebp]
  00181	2b d1		 sub	 edx, ecx
  00183	89 55 f8	 mov	 DWORD PTR _source$[ebp], edx

; 361  : 	    result = targetExhausted; break;

  00186	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR _result$[ebp], 2
  0018d	e9 1b 01 00 00	 jmp	 $LN3@ConvertUTF
$LN14@ConvertUTF:

; 362  : 	}
; 363  : 	if (ch <= UNI_MAX_BMP) { /* Target is a character <= 0xFFFF */

  00192	81 7d f0 ff ff
	00 00		 cmp	 DWORD PTR _ch$2[ebp], 65535 ; 0000ffffH
  00199	77 63		 ja	 SHORT $LN15@ConvertUTF

; 364  : 	    /* UTF-16 surrogate values are illegal in UTF-32 */
; 365  : 	    if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_LOW_END) {

  0019b	81 7d f0 00 d8
	00 00		 cmp	 DWORD PTR _ch$2[ebp], 55296 ; 0000d800H
  001a2	72 42		 jb	 SHORT $LN17@ConvertUTF
  001a4	81 7d f0 ff df
	00 00		 cmp	 DWORD PTR _ch$2[ebp], 57343 ; 0000dfffH
  001ab	77 39		 ja	 SHORT $LN17@ConvertUTF

; 366  : 		if (flags == strictConversion) {

  001ad	83 7d 18 00	 cmp	 DWORD PTR _flags$[ebp], 0
  001b1	75 1d		 jne	 SHORT $LN19@ConvertUTF

; 367  : 		    source -= (extraBytesToRead+1); /* return to the illegal value itself */

  001b3	0f b7 45 ec	 movzx	 eax, WORD PTR _extraBytesToRead$1[ebp]
  001b7	83 c0 01	 add	 eax, 1
  001ba	8b 4d f8	 mov	 ecx, DWORD PTR _source$[ebp]
  001bd	2b c8		 sub	 ecx, eax
  001bf	89 4d f8	 mov	 DWORD PTR _source$[ebp], ecx

; 368  : 		    result = sourceIllegal;

  001c2	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR _result$[ebp], 3

; 369  : 		    break;

  001c9	e9 df 00 00 00	 jmp	 $LN3@ConvertUTF

; 370  : 		} else {

  001ce	eb 14		 jmp	 SHORT $LN20@ConvertUTF
$LN19@ConvertUTF:

; 371  : 		    *target++ = UNI_REPLACEMENT_CHAR;

  001d0	ba fd ff 00 00	 mov	 edx, 65533		; 0000fffdH
  001d5	8b 45 f4	 mov	 eax, DWORD PTR _target$[ebp]
  001d8	66 89 10	 mov	 WORD PTR [eax], dx
  001db	8b 4d f4	 mov	 ecx, DWORD PTR _target$[ebp]
  001de	83 c1 02	 add	 ecx, 2
  001e1	89 4d f4	 mov	 DWORD PTR _target$[ebp], ecx
$LN20@ConvertUTF:

; 372  : 		}
; 373  : 	    } else {

  001e4	eb 13		 jmp	 SHORT $LN18@ConvertUTF
$LN17@ConvertUTF:

; 374  : 		*target++ = (UTF16)ch; /* normal case */

  001e6	8b 55 f4	 mov	 edx, DWORD PTR _target$[ebp]
  001e9	66 8b 45 f0	 mov	 ax, WORD PTR _ch$2[ebp]
  001ed	66 89 02	 mov	 WORD PTR [edx], ax
  001f0	8b 4d f4	 mov	 ecx, DWORD PTR _target$[ebp]
  001f3	83 c1 02	 add	 ecx, 2
  001f6	89 4d f4	 mov	 DWORD PTR _target$[ebp], ecx
$LN18@ConvertUTF:

; 375  : 	    }

  001f9	e9 aa 00 00 00	 jmp	 $LN22@ConvertUTF
$LN15@ConvertUTF:

; 376  : 	} else if (ch > UNI_MAX_UTF16) {

  001fe	81 7d f0 ff ff
	10 00		 cmp	 DWORD PTR _ch$2[ebp], 1114111 ; 0010ffffH
  00205	76 39		 jbe	 SHORT $LN21@ConvertUTF

; 377  : 	    if (flags == strictConversion) {

  00207	83 7d 18 00	 cmp	 DWORD PTR _flags$[ebp], 0
  0020b	75 1d		 jne	 SHORT $LN23@ConvertUTF

; 378  : 		result = sourceIllegal;

  0020d	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR _result$[ebp], 3

; 379  : 		source -= (extraBytesToRead+1); /* return to the start */

  00214	0f b7 55 ec	 movzx	 edx, WORD PTR _extraBytesToRead$1[ebp]
  00218	83 c2 01	 add	 edx, 1
  0021b	8b 45 f8	 mov	 eax, DWORD PTR _source$[ebp]
  0021e	2b c2		 sub	 eax, edx
  00220	89 45 f8	 mov	 DWORD PTR _source$[ebp], eax

; 380  : 		break; /* Bail out; shouldn't continue */

  00223	e9 85 00 00 00	 jmp	 $LN3@ConvertUTF

; 381  : 	    } else {

  00228	eb 14		 jmp	 SHORT $LN24@ConvertUTF
$LN23@ConvertUTF:

; 382  : 		*target++ = UNI_REPLACEMENT_CHAR;

  0022a	b9 fd ff 00 00	 mov	 ecx, 65533		; 0000fffdH
  0022f	8b 55 f4	 mov	 edx, DWORD PTR _target$[ebp]
  00232	66 89 0a	 mov	 WORD PTR [edx], cx
  00235	8b 45 f4	 mov	 eax, DWORD PTR _target$[ebp]
  00238	83 c0 02	 add	 eax, 2
  0023b	89 45 f4	 mov	 DWORD PTR _target$[ebp], eax
$LN24@ConvertUTF:

; 383  : 	    }
; 384  : 	} else {

  0023e	eb 68		 jmp	 SHORT $LN22@ConvertUTF
$LN21@ConvertUTF:

; 385  : 	    /* target is a character in range 0xFFFF - 0x10FFFF. */
; 386  : 	    if (target + 1 >= targetEnd) {

  00240	8b 4d f4	 mov	 ecx, DWORD PTR _target$[ebp]
  00243	83 c1 02	 add	 ecx, 2
  00246	3b 4d 14	 cmp	 ecx, DWORD PTR _targetEnd$[ebp]
  00249	72 18		 jb	 SHORT $LN25@ConvertUTF

; 387  : 		source -= (extraBytesToRead+1); /* Back up source pointer! */

  0024b	0f b7 55 ec	 movzx	 edx, WORD PTR _extraBytesToRead$1[ebp]
  0024f	83 c2 01	 add	 edx, 1
  00252	8b 45 f8	 mov	 eax, DWORD PTR _source$[ebp]
  00255	2b c2		 sub	 eax, edx
  00257	89 45 f8	 mov	 DWORD PTR _source$[ebp], eax

; 388  : 		result = targetExhausted; break;

  0025a	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR _result$[ebp], 2
  00261	eb 4a		 jmp	 SHORT $LN3@ConvertUTF
$LN25@ConvertUTF:

; 389  : 	    }
; 390  : 	    ch -= halfBase;

  00263	8b 4d f0	 mov	 ecx, DWORD PTR _ch$2[ebp]
  00266	81 e9 00 00 01
	00		 sub	 ecx, 65536		; 00010000H
  0026c	89 4d f0	 mov	 DWORD PTR _ch$2[ebp], ecx

; 391  : 	    *target++ = (UTF16)((ch >> halfShift) + UNI_SUR_HIGH_START);

  0026f	8b 55 f0	 mov	 edx, DWORD PTR _ch$2[ebp]
  00272	c1 ea 0a	 shr	 edx, 10			; 0000000aH
  00275	81 c2 00 d8 00
	00		 add	 edx, 55296		; 0000d800H
  0027b	8b 45 f4	 mov	 eax, DWORD PTR _target$[ebp]
  0027e	66 89 10	 mov	 WORD PTR [eax], dx
  00281	8b 4d f4	 mov	 ecx, DWORD PTR _target$[ebp]
  00284	83 c1 02	 add	 ecx, 2
  00287	89 4d f4	 mov	 DWORD PTR _target$[ebp], ecx

; 392  : 	    *target++ = (UTF16)((ch & halfMask) + UNI_SUR_LOW_START);

  0028a	8b 55 f0	 mov	 edx, DWORD PTR _ch$2[ebp]
  0028d	81 e2 ff 03 00
	00		 and	 edx, 1023		; 000003ffH
  00293	81 c2 00 dc 00
	00		 add	 edx, 56320		; 0000dc00H
  00299	8b 45 f4	 mov	 eax, DWORD PTR _target$[ebp]
  0029c	66 89 10	 mov	 WORD PTR [eax], dx
  0029f	8b 4d f4	 mov	 ecx, DWORD PTR _target$[ebp]
  002a2	83 c1 02	 add	 ecx, 2
  002a5	89 4d f4	 mov	 DWORD PTR _target$[ebp], ecx
$LN22@ConvertUTF:

; 393  : 	}
; 394  :     }

  002a8	e9 87 fd ff ff	 jmp	 $LN2@ConvertUTF
$LN3@ConvertUTF:

; 395  :     *sourceStart = source;

  002ad	8b 55 08	 mov	 edx, DWORD PTR _sourceStart$[ebp]
  002b0	8b 45 f8	 mov	 eax, DWORD PTR _source$[ebp]
  002b3	89 02		 mov	 DWORD PTR [edx], eax

; 396  :     *targetStart = target;

  002b5	8b 4d 10	 mov	 ecx, DWORD PTR _targetStart$[ebp]
  002b8	8b 55 f4	 mov	 edx, DWORD PTR _target$[ebp]
  002bb	89 11		 mov	 DWORD PTR [ecx], edx

; 397  :     return result;

  002bd	8b 45 fc	 mov	 eax, DWORD PTR _result$[ebp]

; 398  : }

  002c0	83 c4 18	 add	 esp, 24			; 00000018H
  002c3	3b ec		 cmp	 ebp, esp
  002c5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002ca	8b e5		 mov	 esp, ebp
  002cc	5d		 pop	 ebp
  002cd	c3		 ret	 0
  002ce	66 90		 npad	 2
$LN27@ConvertUTF:
  002d0	00 00 00 00	 DD	 $LN13@ConvertUTF
  002d4	00 00 00 00	 DD	 $LN12@ConvertUTF
  002d8	00 00 00 00	 DD	 $LN11@ConvertUTF
  002dc	00 00 00 00	 DD	 $LN10@ConvertUTF
  002e0	00 00 00 00	 DD	 $LN9@ConvertUTF
  002e4	00 00 00 00	 DD	 $LN8@ConvertUTF
_ConvertUTF8toUTF16 ENDP
_TEXT	ENDS
END
