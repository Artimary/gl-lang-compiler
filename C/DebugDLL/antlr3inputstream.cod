; Listing generated by Microsoft (R) Optimizing Compiler Version 19.42.34436.0 

	TITLE	C:\SPO_labs\C\DebugDLL\antlr3inputstream.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_e2a
CONST	SEGMENT
_trailingBytesForUTF8 DD 00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	03H
	DD	03H
	DD	03H
	DD	03H
	DD	03H
	DD	03H
	DD	03H
	DD	03H
	DD	04H
	DD	04H
	DD	04H
	DD	04H
	DD	05H
	DD	05H
	DD	05H
	DD	05H
_offsetsFromUTF8 DD 00H
	DD	03080H
	DD	0e2080H
	DD	03c82080H
	DD	0fa082080H
	DD	082082080H
_e2a	DD	00H
	DD	01H
	DD	02H
	DD	03H
	DD	085H
	DD	09H
	DD	086H
	DD	07fH
	DD	087H
	DD	08dH
	DD	08eH
	DD	0bH
	DD	0cH
	DD	0dH
	DD	0eH
	DD	0fH
	DD	010H
	DD	011H
	DD	012H
	DD	013H
	DD	08fH
	DD	0aH
	DD	08H
	DD	097H
	DD	018H
	DD	019H
	DD	09cH
	DD	09dH
	DD	01cH
	DD	01dH
	DD	01eH
	DD	01fH
	DD	080H
	DD	081H
	DD	082H
	DD	083H
	DD	084H
	DD	092H
	DD	017H
	DD	01bH
	DD	088H
	DD	089H
	DD	08aH
	DD	08bH
	DD	08cH
	DD	05H
	DD	06H
	DD	07H
	DD	090H
	DD	091H
	DD	016H
	DD	093H
	DD	094H
	DD	095H
	DD	096H
	DD	04H
	DD	098H
	DD	099H
	DD	09aH
	DD	09bH
	DD	014H
	DD	015H
	DD	09eH
	DD	01aH
	DD	020H
	DD	0a0H
	DD	0e2H
	DD	0e4H
	DD	0e0H
	DD	0e1H
	DD	0e3H
	DD	0e5H
	DD	0e7H
	DD	0f1H
	DD	060H
	DD	02eH
	DD	03cH
	DD	028H
	DD	02bH
	DD	07cH
	DD	026H
	DD	0e9H
	DD	0eaH
	DD	0ebH
	DD	0e8H
	DD	0edH
	DD	0eeH
	DD	0efH
	DD	0ecH
	DD	0dfH
	DD	021H
	DD	024H
	DD	02aH
	DD	029H
	DD	03bH
	DD	09fH
	DD	02dH
	DD	02fH
	DD	0c2H
	DD	0c4H
	DD	0c0H
	DD	0c1H
	DD	0c3H
	DD	0c5H
	DD	0c7H
	DD	0d1H
	DD	05eH
	DD	02cH
	DD	025H
	DD	05fH
	DD	03eH
	DD	03fH
	DD	0f8H
	DD	0c9H
	DD	0caH
	DD	0cbH
	DD	0c8H
	DD	0cdH
	DD	0ceH
	DD	0cfH
	DD	0ccH
	DD	0a8H
	DD	03aH
	DD	023H
	DD	040H
	DD	027H
	DD	03dH
	DD	022H
	DD	0d8H
	DD	061H
	DD	062H
	DD	063H
	DD	064H
	DD	065H
	DD	066H
	DD	067H
	DD	068H
	DD	069H
	DD	0abH
	DD	0bbH
	DD	0f0H
	DD	0fdH
	DD	0feH
	DD	0b1H
	DD	0b0H
	DD	06aH
	DD	06bH
	DD	06cH
	DD	06dH
	DD	06eH
	DD	06fH
	DD	070H
	DD	071H
	DD	072H
	DD	0aaH
	DD	0baH
	DD	0e6H
	DD	0b8H
	DD	0c6H
	DD	0a4H
	DD	0b5H
	DD	0afH
	DD	073H
	DD	074H
	DD	075H
	DD	076H
	DD	077H
	DD	078H
	DD	079H
	DD	07aH
	DD	0a1H
	DD	0bfH
	DD	0d0H
	DD	0ddH
	DD	0deH
	DD	0aeH
	DD	0a2H
	DD	0a3H
	DD	0a5H
	DD	0b7H
	DD	0a9H
	DD	0a7H
	DD	0b6H
	DD	0bcH
	DD	0bdH
	DD	0beH
	DD	0acH
	DD	05bH
	DD	05cH
	DD	05dH
	DD	0b4H
	DD	0d7H
	DD	0f9H
	DD	041H
	DD	042H
	DD	043H
	DD	044H
	DD	045H
	DD	046H
	DD	047H
	DD	048H
	DD	049H
	DD	0adH
	DD	0f4H
	DD	0f6H
	DD	0f2H
	DD	0f3H
	DD	0f5H
	DD	0a6H
	DD	04aH
	DD	04bH
	DD	04cH
	DD	04dH
	DD	04eH
	DD	04fH
	DD	050H
	DD	051H
	DD	052H
	DD	0b9H
	DD	0fbH
	DD	0fcH
	DD	0dbH
	DD	0faH
	DD	0ffH
	DD	0d9H
	DD	0f7H
	DD	053H
	DD	054H
	DD	055H
	DD	056H
	DD	057H
	DD	058H
	DD	059H
	DD	05aH
	DD	0b2H
	DD	0d4H
	DD	0d6H
	DD	0d2H
	DD	0d3H
	DD	0d5H
	DD	030H
	DD	031H
	DD	032H
	DD	033H
	DD	034H
	DD	035H
	DD	036H
	DD	037H
	DD	038H
	DD	039H
	DD	0b3H
	DD	07bH
	DD	0dcH
	DD	07dH
	DD	0daH
	DD	07eH
CONST	ENDS
PUBLIC	_antlr38BitSetupStream
PUBLIC	_antlr3UTF16SetupStream
PUBLIC	_antlr3UTF32SetupStream
PUBLIC	_antlr3UTF8SetupStream
PUBLIC	_antlr3EBCDICSetupStream
PUBLIC	_antlr3GenericSetupStream
PUBLIC	??_C@_08ONBMMFLC@?9memory?9@			; `string'
EXTRN	__imp__toupper:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	_antlr3VectorNew:PROC
EXTRN	_antlr3IntStreamNew:PROC
EXTRN	_antlr3StringFactoryNew:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_08ONBMMFLC@?9memory?9@
CONST	SEGMENT
??_C@_08ONBMMFLC@?9memory?9@ DB '-memory-', 00H		; `string'
CONST	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3inputstream.c
;	COMDAT _antlr3EBCDICLA
_TEXT	SEGMENT
_input$ = -4						; size = 4
_is$ = 8						; size = 4
_la$ = 12						; size = 4
_antlr3EBCDICLA PROC					; COMDAT

; 2042 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2043 :     pANTLR3_INPUT_STREAM input;
; 2044 : 
; 2045 :     input   = ((pANTLR3_INPUT_STREAM) (is->super));

  00004	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  00007	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000a	89 4d fc	 mov	 DWORD PTR _input$[ebp], ecx

; 2046 : 
; 2047 :     if	(( ((pANTLR3_UINT8)input->nextChar) + la - 1) >= (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  0000d	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  00010	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR _la$[ebp]
  00016	8d 54 08 ff	 lea	 edx, DWORD PTR [eax+ecx-1]
  0001a	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  0001d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00020	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  00023	03 48 18	 add	 ecx, DWORD PTR [eax+24]
  00026	3b d1		 cmp	 edx, ecx
  00028	72 07		 jb	 SHORT $LN2@antlr3EBCD

; 2048 :     {
; 2049 :         return	ANTLR3_CHARSTREAM_EOF;

  0002a	83 c8 ff	 or	 eax, -1
  0002d	eb 17		 jmp	 SHORT $LN3@antlr3EBCD

; 2050 :     }

  0002f	eb 15		 jmp	 SHORT $LN3@antlr3EBCD
$LN2@antlr3EBCD:

; 2051 :     else
; 2052 :     {
; 2053 :         // Translate the required character via the constant conversion table
; 2054 :         //
; 2055 :         return	e2a[(*((pANTLR3_UINT8)input->nextChar + la - 1))];

  00031	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  00034	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00037	8b 45 0c	 mov	 eax, DWORD PTR _la$[ebp]
  0003a	0f b6 4c 02 ff	 movzx	 ecx, BYTE PTR [edx+eax-1]
  0003f	8b 04 8d 00 00
	00 00		 mov	 eax, DWORD PTR _e2a[ecx*4]
$LN3@antlr3EBCD:

; 2056 :     }
; 2057 : }

  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
_antlr3EBCDICLA ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3inputstream.c
;	COMDAT _antlr3UTF8LA
_TEXT	SEGMENT
tv134 = -28						; size = 4
tv87 = -24						; size = 4
tv86 = -20						; size = 4
_nextChar$ = -16					; size = 4
_ch$ = -12						; size = 4
_extraBytesToRead$ = -8					; size = 4
_input$ = -4						; size = 4
_is$ = 8						; size = 4
_la$ = 12						; size = 4
_antlr3UTF8LA PROC					; COMDAT

; 1878 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 1879 :     pANTLR3_INPUT_STREAM    input;
; 1880 :     ANTLR3_UINT32           extraBytesToRead;
; 1881 :     ANTLR3_UCHAR            ch;
; 1882 :     pANTLR3_UINT8           nextChar;
; 1883 : 
; 1884 :     input   = ((pANTLR3_INPUT_STREAM) (is->super));

  00006	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  00009	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000c	89 4d fc	 mov	 DWORD PTR _input$[ebp], ecx

; 1885 : 
; 1886 :     nextChar = (pANTLR3_UINT8)input->nextChar;

  0000f	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  00012	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00015	89 45 f0	 mov	 DWORD PTR _nextChar$[ebp], eax

; 1887 : 
; 1888 :     // Do we need to traverse forwards or backwards?
; 1889 :     // - LA(0) is treated as LA(1) and we assume that the nextChar is
; 1890 :     //   already positioned.
; 1891 :     // - LA(n+) ; n>1 means we must traverse forward n-1 characters catering for UTF8 encoding
; 1892 :     // - LA(-n) means we must traverse backwards n chracters
; 1893 :     //
; 1894 :     if (la > 1) {

  00018	83 7d 0c 01	 cmp	 DWORD PTR _la$[ebp], 1
  0001c	7e 5e		 jle	 SHORT $LN10@antlr3UTF8

; 1895 : 
; 1896 :         // Make sure that we have at least one character left before trying to
; 1897 :         // loop through the buffer.
; 1898 :         //
; 1899 :         if	(nextChar < (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  00021	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00024	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  00027	03 50 18	 add	 edx, DWORD PTR [eax+24]
  0002a	39 55 f0	 cmp	 DWORD PTR _nextChar$[ebp], edx
  0002d	73 43		 jae	 SHORT $LN12@antlr3UTF8
$LN2@antlr3UTF8:

; 1900 :         {	
; 1901 :             // Now traverse n-1 characters forward
; 1902 :             //
; 1903 :             while (--la > 0)

  0002f	8b 4d 0c	 mov	 ecx, DWORD PTR _la$[ebp]
  00032	83 e9 01	 sub	 ecx, 1
  00035	89 4d 0c	 mov	 DWORD PTR _la$[ebp], ecx
  00038	83 7d 0c 00	 cmp	 DWORD PTR _la$[ebp], 0
  0003c	7e 32		 jle	 SHORT $LN3@antlr3UTF8

; 1904 :             {
; 1905 :                 // Does the next character require trailing bytes?
; 1906 :                 // If so advance the pointer by that many bytes as well as advancing
; 1907 :                 // one position for what will be at least a single byte character.
; 1908 :                 //
; 1909 :                 nextChar += trailingBytesForUTF8[*nextChar] + 1;

  0003e	8b 55 f0	 mov	 edx, DWORD PTR _nextChar$[ebp]
  00041	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00044	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _trailingBytesForUTF8[eax*4]
  0004b	8b 55 f0	 mov	 edx, DWORD PTR _nextChar$[ebp]
  0004e	8d 44 0a 01	 lea	 eax, DWORD PTR [edx+ecx+1]
  00052	89 45 f0	 mov	 DWORD PTR _nextChar$[ebp], eax

; 1910 : 
; 1911 :                 // Does that calculation take us past the byte length of the buffer?
; 1912 :                 //
; 1913 :                 if	(nextChar >= (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  00055	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  00058	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0005b	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  0005e	03 50 18	 add	 edx, DWORD PTR [eax+24]
  00061	39 55 f0	 cmp	 DWORD PTR _nextChar$[ebp], edx
  00064	72 08		 jb	 SHORT $LN14@antlr3UTF8

; 1914 :                 {
; 1915 :                     return ANTLR3_CHARSTREAM_EOF;

  00066	83 c8 ff	 or	 eax, -1
  00069	e9 7b 01 00 00	 jmp	 $LN1@antlr3UTF8
$LN14@antlr3UTF8:

; 1916 :                 }
; 1917 :             }

  0006e	eb bf		 jmp	 SHORT $LN2@antlr3UTF8
$LN3@antlr3UTF8:

; 1918 :         }

  00070	eb 08		 jmp	 SHORT $LN13@antlr3UTF8
$LN12@antlr3UTF8:

; 1919 :         else
; 1920 :         {
; 1921 :             return ANTLR3_CHARSTREAM_EOF;

  00072	83 c8 ff	 or	 eax, -1
  00075	e9 6f 01 00 00	 jmp	 $LN1@antlr3UTF8
$LN13@antlr3UTF8:

; 1922 :         }
; 1923 :     }

  0007a	eb 60		 jmp	 SHORT $LN5@antlr3UTF8
$LN10@antlr3UTF8:

; 1924 :     else
; 1925 :     {
; 1926 :         // LA is negative so we decrease the pointer by n character positions
; 1927 :         //
; 1928 :         while   (nextChar > (pANTLR3_UINT8)input->data && la++ < 0)

  0007c	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  0007f	8b 55 f0	 mov	 edx, DWORD PTR _nextChar$[ebp]
  00082	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00085	76 55		 jbe	 SHORT $LN5@antlr3UTF8
  00087	8b 45 0c	 mov	 eax, DWORD PTR _la$[ebp]
  0008a	89 45 ec	 mov	 DWORD PTR tv86[ebp], eax
  0008d	8b 4d 0c	 mov	 ecx, DWORD PTR _la$[ebp]
  00090	83 c1 01	 add	 ecx, 1
  00093	89 4d 0c	 mov	 DWORD PTR _la$[ebp], ecx
  00096	83 7d ec 00	 cmp	 DWORD PTR tv86[ebp], 0
  0009a	7d 09		 jge	 SHORT $LN23@antlr3UTF8
  0009c	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv87[ebp], 1
  000a3	eb 07		 jmp	 SHORT $LN24@antlr3UTF8
$LN23@antlr3UTF8:
  000a5	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv87[ebp], 0
$LN24@antlr3UTF8:
  000ac	83 7d e8 00	 cmp	 DWORD PTR tv87[ebp], 0
  000b0	74 2a		 je	 SHORT $LN5@antlr3UTF8

; 1929 :         {
; 1930 :             // Traversing backwards in UTF8 means decermenting by one
; 1931 :             // then continuing to decrement while ever a character pattern
; 1932 :             // is flagged as being a trailing byte of an encoded code point.
; 1933 :             // Trailing UTF8 bytes always start with 10 in binary. We assumne that
; 1934 :             // the UTF8 is well formed and do not check boundary conditions
; 1935 :             //
; 1936 :             nextChar--;

  000b2	8b 55 f0	 mov	 edx, DWORD PTR _nextChar$[ebp]
  000b5	83 ea 01	 sub	 edx, 1
  000b8	89 55 f0	 mov	 DWORD PTR _nextChar$[ebp], edx
$LN6@antlr3UTF8:

; 1937 :             while ((*nextChar & 0xC0) == 0x80)

  000bb	8b 45 f0	 mov	 eax, DWORD PTR _nextChar$[ebp]
  000be	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000c1	81 e1 c0 00 00
	00		 and	 ecx, 192		; 000000c0H
  000c7	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  000cd	75 0b		 jne	 SHORT $LN7@antlr3UTF8

; 1938 :             {
; 1939 :                 nextChar--;

  000cf	8b 55 f0	 mov	 edx, DWORD PTR _nextChar$[ebp]
  000d2	83 ea 01	 sub	 edx, 1
  000d5	89 55 f0	 mov	 DWORD PTR _nextChar$[ebp], edx

; 1940 :             }

  000d8	eb e1		 jmp	 SHORT $LN6@antlr3UTF8
$LN7@antlr3UTF8:

; 1941 :         }

  000da	eb a0		 jmp	 SHORT $LN10@antlr3UTF8
$LN5@antlr3UTF8:

; 1942 :     }
; 1943 : 
; 1944 :     // nextChar is now pointing at the UTF8 encoded character that we need to
; 1945 :     // decode and return.
; 1946 :     //
; 1947 :     // Are there more bytes needed to make up the whole thing?
; 1948 :     //
; 1949 :     extraBytesToRead = trailingBytesForUTF8[*nextChar];

  000dc	8b 45 f0	 mov	 eax, DWORD PTR _nextChar$[ebp]
  000df	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000e2	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR _trailingBytesForUTF8[ecx*4]
  000e9	89 55 f8	 mov	 DWORD PTR _extraBytesToRead$[ebp], edx

; 1950 :     if	(nextChar + extraBytesToRead >= (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  000ec	8b 45 f0	 mov	 eax, DWORD PTR _nextChar$[ebp]
  000ef	03 45 f8	 add	 eax, DWORD PTR _extraBytesToRead$[ebp]
  000f2	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  000f5	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000f8	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  000fb	03 51 18	 add	 edx, DWORD PTR [ecx+24]
  000fe	3b c2		 cmp	 eax, edx
  00100	72 08		 jb	 SHORT $LN15@antlr3UTF8

; 1951 :     {
; 1952 :         return ANTLR3_CHARSTREAM_EOF;

  00102	83 c8 ff	 or	 eax, -1
  00105	e9 df 00 00 00	 jmp	 $LN1@antlr3UTF8
$LN15@antlr3UTF8:

; 1953 :     }
; 1954 : 
; 1955 :     // Cases deliberately fall through (see note A in antlrconvertutf.c)
; 1956 :     // 
; 1957 :     ch  = 0;

  0010a	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _ch$[ebp], 0

; 1958 :     switch (extraBytesToRead) {

  00111	8b 55 f8	 mov	 edx, DWORD PTR _extraBytesToRead$[ebp]
  00114	89 55 e4	 mov	 DWORD PTR tv134[ebp], edx
  00117	83 7d e4 05	 cmp	 DWORD PTR tv134[ebp], 5
  0011b	0f 87 b5 00 00
	00		 ja	 $LN8@antlr3UTF8
  00121	8b 45 e4	 mov	 eax, DWORD PTR tv134[ebp]
  00124	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN25@antlr3UTF8[eax*4]
$LN16@antlr3UTF8:

; 1959 :             case 5: ch += *nextChar++; ch <<= 6;

  0012b	8b 4d f0	 mov	 ecx, DWORD PTR _nextChar$[ebp]
  0012e	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00131	03 55 f4	 add	 edx, DWORD PTR _ch$[ebp]
  00134	89 55 f4	 mov	 DWORD PTR _ch$[ebp], edx
  00137	8b 45 f0	 mov	 eax, DWORD PTR _nextChar$[ebp]
  0013a	83 c0 01	 add	 eax, 1
  0013d	89 45 f0	 mov	 DWORD PTR _nextChar$[ebp], eax
  00140	8b 4d f4	 mov	 ecx, DWORD PTR _ch$[ebp]
  00143	c1 e1 06	 shl	 ecx, 6
  00146	89 4d f4	 mov	 DWORD PTR _ch$[ebp], ecx
$LN17@antlr3UTF8:

; 1960 :             case 4: ch += *nextChar++; ch <<= 6;

  00149	8b 55 f0	 mov	 edx, DWORD PTR _nextChar$[ebp]
  0014c	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0014f	03 45 f4	 add	 eax, DWORD PTR _ch$[ebp]
  00152	89 45 f4	 mov	 DWORD PTR _ch$[ebp], eax
  00155	8b 4d f0	 mov	 ecx, DWORD PTR _nextChar$[ebp]
  00158	83 c1 01	 add	 ecx, 1
  0015b	89 4d f0	 mov	 DWORD PTR _nextChar$[ebp], ecx
  0015e	8b 55 f4	 mov	 edx, DWORD PTR _ch$[ebp]
  00161	c1 e2 06	 shl	 edx, 6
  00164	89 55 f4	 mov	 DWORD PTR _ch$[ebp], edx
$LN18@antlr3UTF8:

; 1961 :             case 3: ch += *nextChar++; ch <<= 6;

  00167	8b 45 f0	 mov	 eax, DWORD PTR _nextChar$[ebp]
  0016a	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0016d	03 4d f4	 add	 ecx, DWORD PTR _ch$[ebp]
  00170	89 4d f4	 mov	 DWORD PTR _ch$[ebp], ecx
  00173	8b 55 f0	 mov	 edx, DWORD PTR _nextChar$[ebp]
  00176	83 c2 01	 add	 edx, 1
  00179	89 55 f0	 mov	 DWORD PTR _nextChar$[ebp], edx
  0017c	8b 45 f4	 mov	 eax, DWORD PTR _ch$[ebp]
  0017f	c1 e0 06	 shl	 eax, 6
  00182	89 45 f4	 mov	 DWORD PTR _ch$[ebp], eax
$LN19@antlr3UTF8:

; 1962 :             case 2: ch += *nextChar++; ch <<= 6;

  00185	8b 4d f0	 mov	 ecx, DWORD PTR _nextChar$[ebp]
  00188	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  0018b	03 55 f4	 add	 edx, DWORD PTR _ch$[ebp]
  0018e	89 55 f4	 mov	 DWORD PTR _ch$[ebp], edx
  00191	8b 45 f0	 mov	 eax, DWORD PTR _nextChar$[ebp]
  00194	83 c0 01	 add	 eax, 1
  00197	89 45 f0	 mov	 DWORD PTR _nextChar$[ebp], eax
  0019a	8b 4d f4	 mov	 ecx, DWORD PTR _ch$[ebp]
  0019d	c1 e1 06	 shl	 ecx, 6
  001a0	89 4d f4	 mov	 DWORD PTR _ch$[ebp], ecx
$LN20@antlr3UTF8:

; 1963 :             case 1: ch += *nextChar++; ch <<= 6;

  001a3	8b 55 f0	 mov	 edx, DWORD PTR _nextChar$[ebp]
  001a6	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  001a9	03 45 f4	 add	 eax, DWORD PTR _ch$[ebp]
  001ac	89 45 f4	 mov	 DWORD PTR _ch$[ebp], eax
  001af	8b 4d f0	 mov	 ecx, DWORD PTR _nextChar$[ebp]
  001b2	83 c1 01	 add	 ecx, 1
  001b5	89 4d f0	 mov	 DWORD PTR _nextChar$[ebp], ecx
  001b8	8b 55 f4	 mov	 edx, DWORD PTR _ch$[ebp]
  001bb	c1 e2 06	 shl	 edx, 6
  001be	89 55 f4	 mov	 DWORD PTR _ch$[ebp], edx
$LN21@antlr3UTF8:

; 1964 :             case 0: ch += *nextChar++;

  001c1	8b 45 f0	 mov	 eax, DWORD PTR _nextChar$[ebp]
  001c4	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  001c7	03 4d f4	 add	 ecx, DWORD PTR _ch$[ebp]
  001ca	89 4d f4	 mov	 DWORD PTR _ch$[ebp], ecx
  001cd	8b 55 f0	 mov	 edx, DWORD PTR _nextChar$[ebp]
  001d0	83 c2 01	 add	 edx, 1
  001d3	89 55 f0	 mov	 DWORD PTR _nextChar$[ebp], edx
$LN8@antlr3UTF8:

; 1965 :     }
; 1966 : 
; 1967 :     // Magically correct the input value
; 1968 :     //
; 1969 :     ch -= offsetsFromUTF8[extraBytesToRead];

  001d6	8b 45 f8	 mov	 eax, DWORD PTR _extraBytesToRead$[ebp]
  001d9	8b 4d f4	 mov	 ecx, DWORD PTR _ch$[ebp]
  001dc	2b 0c 85 00 00
	00 00		 sub	 ecx, DWORD PTR _offsetsFromUTF8[eax*4]
  001e3	89 4d f4	 mov	 DWORD PTR _ch$[ebp], ecx

; 1970 : 
; 1971 :     return ch;

  001e6	8b 45 f4	 mov	 eax, DWORD PTR _ch$[ebp]
$LN1@antlr3UTF8:

; 1972 : }

  001e9	8b e5		 mov	 esp, ebp
  001eb	5d		 pop	 ebp
  001ec	c3		 ret	 0
  001ed	0f 1f 00	 npad	 3
$LN25@antlr3UTF8:
  001f0	00 00 00 00	 DD	 $LN21@antlr3UTF8
  001f4	00 00 00 00	 DD	 $LN20@antlr3UTF8
  001f8	00 00 00 00	 DD	 $LN19@antlr3UTF8
  001fc	00 00 00 00	 DD	 $LN18@antlr3UTF8
  00200	00 00 00 00	 DD	 $LN17@antlr3UTF8
  00204	00 00 00 00	 DD	 $LN16@antlr3UTF8
_antlr3UTF8LA ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3inputstream.c
;	COMDAT _antlr3UTF8Consume
_TEXT	SEGMENT
tv86 = -20						; size = 4
_nextChar$ = -16					; size = 4
_ch$ = -12						; size = 4
_extraBytesToRead$ = -8					; size = 4
_input$ = -4						; size = 4
_is$ = 8						; size = 4
_antlr3UTF8Consume PROC					; COMDAT

; 1812 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 1813 :     pANTLR3_INPUT_STREAM    input;
; 1814 :     ANTLR3_UINT32           extraBytesToRead;
; 1815 :     ANTLR3_UCHAR            ch;
; 1816 :     pANTLR3_UINT8           nextChar;
; 1817 : 
; 1818 :     input   = ((pANTLR3_INPUT_STREAM) (is->super));

  00006	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  00009	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000c	89 4d fc	 mov	 DWORD PTR _input$[ebp], ecx

; 1819 : 
; 1820 :     nextChar = (pANTLR3_UINT8)input->nextChar;

  0000f	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  00012	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00015	89 45 f0	 mov	 DWORD PTR _nextChar$[ebp], eax

; 1821 : 
; 1822 :     if	(nextChar < (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  00018	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  0001b	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0001e	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  00021	03 50 18	 add	 edx, DWORD PTR [eax+24]
  00024	39 55 f0	 cmp	 DWORD PTR _nextChar$[ebp], edx
  00027	0f 83 5e 01 00
	00		 jae	 $LN4@antlr3UTF8

; 1823 :     {	
; 1824 : 	// Indicate one more character in this line
; 1825 : 	//
; 1826 : 	input->charPositionInLine++;

  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  00030	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00033	83 c2 01	 add	 edx, 1
  00036	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  00039	89 50 24	 mov	 DWORD PTR [eax+36], edx

; 1827 : 	
; 1828 :         // Are there more bytes needed to make up the whole thing?
; 1829 :         //
; 1830 :         extraBytesToRead = trailingBytesForUTF8[*nextChar];

  0003c	8b 4d f0	 mov	 ecx, DWORD PTR _nextChar$[ebp]
  0003f	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00042	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR _trailingBytesForUTF8[edx*4]
  00049	89 45 f8	 mov	 DWORD PTR _extraBytesToRead$[ebp], eax

; 1831 : 
; 1832 :         if	(nextChar + extraBytesToRead >= (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  0004c	8b 4d f0	 mov	 ecx, DWORD PTR _nextChar$[ebp]
  0004f	03 4d f8	 add	 ecx, DWORD PTR _extraBytesToRead$[ebp]
  00052	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  00055	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00058	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  0005b	03 42 18	 add	 eax, DWORD PTR [edx+24]
  0005e	3b c8		 cmp	 ecx, eax
  00060	72 17		 jb	 SHORT $LN5@antlr3UTF8

; 1833 :         {
; 1834 :             input->nextChar = (((pANTLR3_UINT8)input->data) + input->sizeBuf);

  00062	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  00065	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00068	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  0006b	03 4a 18	 add	 ecx, DWORD PTR [edx+24]
  0006e	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  00071	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 1835 :             return;

  00074	e9 12 01 00 00	 jmp	 $LN4@antlr3UTF8
$LN5@antlr3UTF8:

; 1836 :         }
; 1837 : 
; 1838 :         // Cases deliberately fall through (see note A in antlrconvertutf.c)
; 1839 :         // Legal UTF8 is only 4 bytes but 6 bytes could be used in old UTF8 so
; 1840 :         // we allow it.
; 1841 :         //
; 1842 :         ch  = 0;

  00079	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _ch$[ebp], 0

; 1843 :        	switch (extraBytesToRead) {

  00080	8b 4d f8	 mov	 ecx, DWORD PTR _extraBytesToRead$[ebp]
  00083	89 4d ec	 mov	 DWORD PTR tv86[ebp], ecx
  00086	83 7d ec 05	 cmp	 DWORD PTR tv86[ebp], 5
  0008a	0f 87 b5 00 00
	00		 ja	 $LN2@antlr3UTF8
  00090	8b 55 ec	 mov	 edx, DWORD PTR tv86[ebp]
  00093	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN14@antlr3UTF8[edx*4]
$LN6@antlr3UTF8:

; 1844 : 	    case 5: ch += *nextChar++; ch <<= 6;

  0009a	8b 45 f0	 mov	 eax, DWORD PTR _nextChar$[ebp]
  0009d	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000a0	03 4d f4	 add	 ecx, DWORD PTR _ch$[ebp]
  000a3	89 4d f4	 mov	 DWORD PTR _ch$[ebp], ecx
  000a6	8b 55 f0	 mov	 edx, DWORD PTR _nextChar$[ebp]
  000a9	83 c2 01	 add	 edx, 1
  000ac	89 55 f0	 mov	 DWORD PTR _nextChar$[ebp], edx
  000af	8b 45 f4	 mov	 eax, DWORD PTR _ch$[ebp]
  000b2	c1 e0 06	 shl	 eax, 6
  000b5	89 45 f4	 mov	 DWORD PTR _ch$[ebp], eax
$LN7@antlr3UTF8:

; 1845 : 	    case 4: ch += *nextChar++; ch <<= 6;

  000b8	8b 4d f0	 mov	 ecx, DWORD PTR _nextChar$[ebp]
  000bb	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  000be	03 55 f4	 add	 edx, DWORD PTR _ch$[ebp]
  000c1	89 55 f4	 mov	 DWORD PTR _ch$[ebp], edx
  000c4	8b 45 f0	 mov	 eax, DWORD PTR _nextChar$[ebp]
  000c7	83 c0 01	 add	 eax, 1
  000ca	89 45 f0	 mov	 DWORD PTR _nextChar$[ebp], eax
  000cd	8b 4d f4	 mov	 ecx, DWORD PTR _ch$[ebp]
  000d0	c1 e1 06	 shl	 ecx, 6
  000d3	89 4d f4	 mov	 DWORD PTR _ch$[ebp], ecx
$LN8@antlr3UTF8:

; 1846 : 	    case 3: ch += *nextChar++; ch <<= 6;

  000d6	8b 55 f0	 mov	 edx, DWORD PTR _nextChar$[ebp]
  000d9	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  000dc	03 45 f4	 add	 eax, DWORD PTR _ch$[ebp]
  000df	89 45 f4	 mov	 DWORD PTR _ch$[ebp], eax
  000e2	8b 4d f0	 mov	 ecx, DWORD PTR _nextChar$[ebp]
  000e5	83 c1 01	 add	 ecx, 1
  000e8	89 4d f0	 mov	 DWORD PTR _nextChar$[ebp], ecx
  000eb	8b 55 f4	 mov	 edx, DWORD PTR _ch$[ebp]
  000ee	c1 e2 06	 shl	 edx, 6
  000f1	89 55 f4	 mov	 DWORD PTR _ch$[ebp], edx
$LN9@antlr3UTF8:

; 1847 : 	    case 2: ch += *nextChar++; ch <<= 6;

  000f4	8b 45 f0	 mov	 eax, DWORD PTR _nextChar$[ebp]
  000f7	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000fa	03 4d f4	 add	 ecx, DWORD PTR _ch$[ebp]
  000fd	89 4d f4	 mov	 DWORD PTR _ch$[ebp], ecx
  00100	8b 55 f0	 mov	 edx, DWORD PTR _nextChar$[ebp]
  00103	83 c2 01	 add	 edx, 1
  00106	89 55 f0	 mov	 DWORD PTR _nextChar$[ebp], edx
  00109	8b 45 f4	 mov	 eax, DWORD PTR _ch$[ebp]
  0010c	c1 e0 06	 shl	 eax, 6
  0010f	89 45 f4	 mov	 DWORD PTR _ch$[ebp], eax
$LN10@antlr3UTF8:

; 1848 : 	    case 1: ch += *nextChar++; ch <<= 6;

  00112	8b 4d f0	 mov	 ecx, DWORD PTR _nextChar$[ebp]
  00115	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00118	03 55 f4	 add	 edx, DWORD PTR _ch$[ebp]
  0011b	89 55 f4	 mov	 DWORD PTR _ch$[ebp], edx
  0011e	8b 45 f0	 mov	 eax, DWORD PTR _nextChar$[ebp]
  00121	83 c0 01	 add	 eax, 1
  00124	89 45 f0	 mov	 DWORD PTR _nextChar$[ebp], eax
  00127	8b 4d f4	 mov	 ecx, DWORD PTR _ch$[ebp]
  0012a	c1 e1 06	 shl	 ecx, 6
  0012d	89 4d f4	 mov	 DWORD PTR _ch$[ebp], ecx
$LN11@antlr3UTF8:

; 1849 : 	    case 0: ch += *nextChar++;

  00130	8b 55 f0	 mov	 edx, DWORD PTR _nextChar$[ebp]
  00133	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00136	03 45 f4	 add	 eax, DWORD PTR _ch$[ebp]
  00139	89 45 f4	 mov	 DWORD PTR _ch$[ebp], eax
  0013c	8b 4d f0	 mov	 ecx, DWORD PTR _nextChar$[ebp]
  0013f	83 c1 01	 add	 ecx, 1
  00142	89 4d f0	 mov	 DWORD PTR _nextChar$[ebp], ecx
$LN2@antlr3UTF8:

; 1850 : 	}
; 1851 : 
; 1852 :         // Magically correct the input value
; 1853 :         //
; 1854 : 	ch -= offsetsFromUTF8[extraBytesToRead];

  00145	8b 55 f8	 mov	 edx, DWORD PTR _extraBytesToRead$[ebp]
  00148	8b 45 f4	 mov	 eax, DWORD PTR _ch$[ebp]
  0014b	2b 04 95 00 00
	00 00		 sub	 eax, DWORD PTR _offsetsFromUTF8[edx*4]
  00152	89 45 f4	 mov	 DWORD PTR _ch$[ebp], eax

; 1855 : 	if  (ch == input->newlineChar)

  00155	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  00158	8b 55 f4	 mov	 edx, DWORD PTR _ch$[ebp]
  0015b	3b 51 70	 cmp	 edx, DWORD PTR [ecx+112]
  0015e	75 22		 jne	 SHORT $LN12@antlr3UTF8

; 1856 : 	{
; 1857 : 	    /* Reset for start of a new line of input
; 1858 : 	     */
; 1859 : 	    input->line++;

  00160	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  00163	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00166	83 c1 01	 add	 ecx, 1
  00169	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  0016c	89 4a 1c	 mov	 DWORD PTR [edx+28], ecx

; 1860 : 	    input->charPositionInLine	= 0;

  0016f	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  00172	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], 0

; 1861 : 	    input->currentLine		= (void *)nextChar;

  00179	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  0017c	8b 55 f0	 mov	 edx, DWORD PTR _nextChar$[ebp]
  0017f	89 51 20	 mov	 DWORD PTR [ecx+32], edx
$LN12@antlr3UTF8:

; 1862 : 	}
; 1863 : 
; 1864 :         // Update input pointer
; 1865 :         //
; 1866 :         input->nextChar = nextChar;

  00182	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  00185	8b 4d f0	 mov	 ecx, DWORD PTR _nextChar$[ebp]
  00188	89 48 14	 mov	 DWORD PTR [eax+20], ecx
$LN4@antlr3UTF8:

; 1867 :     }
; 1868 : }

  0018b	8b e5		 mov	 esp, ebp
  0018d	5d		 pop	 ebp
  0018e	c3		 ret	 0
  0018f	90		 npad	 1
$LN14@antlr3UTF8:
  00190	00 00 00 00	 DD	 $LN11@antlr3UTF8
  00194	00 00 00 00	 DD	 $LN10@antlr3UTF8
  00198	00 00 00 00	 DD	 $LN9@antlr3UTF8
  0019c	00 00 00 00	 DD	 $LN8@antlr3UTF8
  001a0	00 00 00 00	 DD	 $LN7@antlr3UTF8
  001a4	00 00 00 00	 DD	 $LN6@antlr3UTF8
_antlr3UTF8Consume ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3inputstream.c
;	COMDAT _antlr3UTF32Substr
_TEXT	SEGMENT
_input$ = 8						; size = 4
_start$ = 12						; size = 4
_stop$ = 16						; size = 4
_antlr3UTF32Substr PROC					; COMDAT

; 1628 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1629 :     return  input->strFactory->newPtr(input->strFactory, (pANTLR3_UINT8)start, ((ANTLR3_UINT32_CAST(stop - start))/4) + 1);

  00004	8b 45 10	 mov	 eax, DWORD PTR _stop$[ebp]
  00007	2b 45 0c	 sub	 eax, DWORD PTR _start$[ebp]
  0000a	c1 e8 02	 shr	 eax, 2
  0000d	83 c0 01	 add	 eax, 1
  00010	8b f4		 mov	 esi, esp
  00012	50		 push	 eax
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR _start$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  0001a	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0001d	50		 push	 eax
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  00021	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00024	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00027	ff d0		 call	 eax
  00029	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002c	3b f4		 cmp	 esi, esp
  0002e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1630 : }

  00033	5e		 pop	 esi
  00034	3b ec		 cmp	 ebp, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
_antlr3UTF32Substr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3inputstream.c
;	COMDAT _antlr3UTF32Seek
_TEXT	SEGMENT
_input$ = -4						; size = 4
_is$ = 8						; size = 4
_seekPoint$ = 12					; size = 4
_antlr3UTF32Seek PROC					; COMDAT

; 1641 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 1642 : 	pANTLR3_INPUT_STREAM input;
; 1643 : 
; 1644 : 	input   = ((pANTLR3_INPUT_STREAM) is->super);

  0000c	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  0000f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00012	89 4d fc	 mov	 DWORD PTR _input$[ebp], ecx

; 1645 : 
; 1646 : 	// If the requested seek point is less than the current
; 1647 : 	// input point, then we assume that we are resetting from a mark
; 1648 : 	// and do not need to scan, but can just set to there as rewind will
; 1649 :         // reset line numbers and so on.
; 1650 : 	//
; 1651 : 	if	(seekPoint <= (ANTLR3_MARKER)(input->nextChar))

  00015	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  00018	8b 45 0c	 mov	 eax, DWORD PTR _seekPoint$[ebp]
  0001b	3b 42 14	 cmp	 eax, DWORD PTR [edx+20]
  0001e	7f 0b		 jg	 SHORT $LN4@antlr3UTF3

; 1652 : 	{
; 1653 : 		input->nextChar	= (void *)seekPoint;

  00020	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  00023	8b 55 0c	 mov	 edx, DWORD PTR _seekPoint$[ebp]
  00026	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 1654 : 	}

  00029	eb 45		 jmp	 SHORT $LN3@antlr3UTF3
$LN4@antlr3UTF3:

; 1655 : 	else
; 1656 : 	{
; 1657 :             // Call consume until we reach the asked for seek point or EOF
; 1658 :             //
; 1659 :             while (is->_LA(is, 1) != ANTLR3_CHARSTREAM_EOF && seekPoint < (ANTLR3_MARKER)input->nextChar)

  0002b	8b f4		 mov	 esi, esp
  0002d	6a 01		 push	 1
  0002f	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  00032	50		 push	 eax
  00033	8b 4d 08	 mov	 ecx, DWORD PTR _is$[ebp]
  00036	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00039	ff d2		 call	 edx
  0003b	83 c4 08	 add	 esp, 8
  0003e	3b f4		 cmp	 esi, esp
  00040	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00045	83 f8 ff	 cmp	 eax, -1
  00048	74 26		 je	 SHORT $LN3@antlr3UTF3
  0004a	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  0004d	8b 4d 0c	 mov	 ecx, DWORD PTR _seekPoint$[ebp]
  00050	3b 48 14	 cmp	 ecx, DWORD PTR [eax+20]
  00053	7d 1b		 jge	 SHORT $LN3@antlr3UTF3

; 1660 : 	    {
; 1661 : 		is->consume(is);

  00055	8b f4		 mov	 esi, esp
  00057	8b 55 08	 mov	 edx, DWORD PTR _is$[ebp]
  0005a	52		 push	 edx
  0005b	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  0005e	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00061	ff d1		 call	 ecx
  00063	83 c4 04	 add	 esp, 4
  00066	3b f4		 cmp	 esi, esp
  00068	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006d	90		 npad	 1

; 1662 : 	    }

  0006e	eb bb		 jmp	 SHORT $LN4@antlr3UTF3
$LN3@antlr3UTF3:

; 1663 : 	}
; 1664 : }

  00070	5e		 pop	 esi
  00071	83 c4 04	 add	 esp, 4
  00074	3b ec		 cmp	 ebp, esp
  00076	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
_antlr3UTF32Seek ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3inputstream.c
;	COMDAT _antlr3UTF32Index
_TEXT	SEGMENT
_input$ = -4						; size = 4
_is$ = 8						; size = 4
_antlr3UTF32Index PROC					; COMDAT

; 1611 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1612 :     pANTLR3_INPUT_STREAM input;
; 1613 : 
; 1614 :     input   = ((pANTLR3_INPUT_STREAM) (is->super));

  00004	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  00007	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000a	89 4d fc	 mov	 DWORD PTR _input$[ebp], ecx

; 1615 : 
; 1616 :     return  (ANTLR3_MARKER)(input->nextChar);

  0000d	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  00010	8b 42 14	 mov	 eax, DWORD PTR [edx+20]

; 1617 : }

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
_antlr3UTF32Index ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3inputstream.c
;	COMDAT _antlr3UTF32LABE
_TEXT	SEGMENT
_c$1 = -8						; size = 4
_input$ = -4						; size = 4
_is$ = 8						; size = 4
_la$ = 12						; size = 4
_antlr3UTF32LABE PROC					; COMDAT

; 1730 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1731 :     pANTLR3_INPUT_STREAM input;
; 1732 : 	
; 1733 :     input   = ((pANTLR3_INPUT_STREAM) (is->super));

  00006	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  00009	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000c	89 4d fc	 mov	 DWORD PTR _input$[ebp], ecx

; 1734 : 
; 1735 :     if	(( ((pANTLR3_UINT8)input->nextChar) + la - 1) >= (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  0000f	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  00012	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00015	8b 4d 0c	 mov	 ecx, DWORD PTR _la$[ebp]
  00018	8d 54 08 ff	 lea	 edx, DWORD PTR [eax+ecx-1]
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  0001f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00022	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  00025	03 48 18	 add	 ecx, DWORD PTR [eax+24]
  00028	3b d1		 cmp	 edx, ecx
  0002a	72 07		 jb	 SHORT $LN2@antlr3UTF3

; 1736 :     {
; 1737 : 		return	ANTLR3_CHARSTREAM_EOF;

  0002c	83 c8 ff	 or	 eax, -1
  0002f	eb 3c		 jmp	 SHORT $LN3@antlr3UTF3

; 1738 :     }

  00031	eb 3a		 jmp	 SHORT $LN3@antlr3UTF3
$LN2@antlr3UTF3:

; 1739 :     else
; 1740 :     {
; 1741 :         ANTLR3_UCHAR   c;
; 1742 : 
; 1743 :         c = (ANTLR3_UCHAR)(*((pANTLR3_UINT32)input->nextChar + la - 1));

  00033	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  00036	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00039	8b 45 0c	 mov	 eax, DWORD PTR _la$[ebp]
  0003c	8b 4c 82 fc	 mov	 ecx, DWORD PTR [edx+eax*4-4]
  00040	89 4d f8	 mov	 DWORD PTR _c$1[ebp], ecx

; 1744 : 
; 1745 :         // Swap Endianess to Little Endian
; 1746 :         //
; 1747 :         return (c>>24) | ((c<<8) & 0x00FF0000) | ((c>>8) & 0x0000FF00) | (c<<24);

  00043	8b 45 f8	 mov	 eax, DWORD PTR _c$1[ebp]
  00046	c1 e8 18	 shr	 eax, 24			; 00000018H
  00049	8b 55 f8	 mov	 edx, DWORD PTR _c$1[ebp]
  0004c	c1 e2 08	 shl	 edx, 8
  0004f	81 e2 00 00 ff
	00		 and	 edx, 16711680		; 00ff0000H
  00055	0b c2		 or	 eax, edx
  00057	8b 4d f8	 mov	 ecx, DWORD PTR _c$1[ebp]
  0005a	c1 e9 08	 shr	 ecx, 8
  0005d	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00063	0b c1		 or	 eax, ecx
  00065	8b 55 f8	 mov	 edx, DWORD PTR _c$1[ebp]
  00068	c1 e2 18	 shl	 edx, 24			; 00000018H
  0006b	0b c2		 or	 eax, edx
$LN3@antlr3UTF3:

; 1748 :     }
; 1749 : }

  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
_antlr3UTF32LABE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3inputstream.c
;	COMDAT _antlr3UTF32LALE
_TEXT	SEGMENT
_c$1 = -8						; size = 4
_input$ = -4						; size = 4
_is$ = 8						; size = 4
_la$ = 12						; size = 4
_antlr3UTF32LALE PROC					; COMDAT

; 1699 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1700 :     pANTLR3_INPUT_STREAM input;
; 1701 : 	
; 1702 :     input   = ((pANTLR3_INPUT_STREAM) (is->super));

  00006	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  00009	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000c	89 4d fc	 mov	 DWORD PTR _input$[ebp], ecx

; 1703 : 
; 1704 :     if	(( ((pANTLR3_UINT8)input->nextChar) + la - 1) >= (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  0000f	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  00012	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00015	8b 4d 0c	 mov	 ecx, DWORD PTR _la$[ebp]
  00018	8d 54 08 ff	 lea	 edx, DWORD PTR [eax+ecx-1]
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  0001f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00022	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  00025	03 48 18	 add	 ecx, DWORD PTR [eax+24]
  00028	3b d1		 cmp	 edx, ecx
  0002a	72 07		 jb	 SHORT $LN2@antlr3UTF3

; 1705 :     {
; 1706 : 		return	ANTLR3_CHARSTREAM_EOF;

  0002c	83 c8 ff	 or	 eax, -1
  0002f	eb 3c		 jmp	 SHORT $LN3@antlr3UTF3

; 1707 :     }

  00031	eb 3a		 jmp	 SHORT $LN3@antlr3UTF3
$LN2@antlr3UTF3:

; 1708 :     else
; 1709 :     {
; 1710 :         ANTLR3_UCHAR   c;
; 1711 : 
; 1712 :         c = (ANTLR3_UCHAR)(*((pANTLR3_UINT32)input->nextChar + la - 1));

  00033	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  00036	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00039	8b 45 0c	 mov	 eax, DWORD PTR _la$[ebp]
  0003c	8b 4c 82 fc	 mov	 ecx, DWORD PTR [edx+eax*4-4]
  00040	89 4d f8	 mov	 DWORD PTR _c$1[ebp], ecx

; 1713 : 
; 1714 :         // Swap Endianess to Big Endian
; 1715 :         //
; 1716 :         return (c>>24) | ((c<<8) & 0x00FF0000) | ((c>>8) & 0x0000FF00) | (c<<24);

  00043	8b 45 f8	 mov	 eax, DWORD PTR _c$1[ebp]
  00046	c1 e8 18	 shr	 eax, 24			; 00000018H
  00049	8b 55 f8	 mov	 edx, DWORD PTR _c$1[ebp]
  0004c	c1 e2 08	 shl	 edx, 8
  0004f	81 e2 00 00 ff
	00		 and	 edx, 16711680		; 00ff0000H
  00055	0b c2		 or	 eax, edx
  00057	8b 4d f8	 mov	 ecx, DWORD PTR _c$1[ebp]
  0005a	c1 e9 08	 shr	 ecx, 8
  0005d	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00063	0b c1		 or	 eax, ecx
  00065	8b 55 f8	 mov	 edx, DWORD PTR _c$1[ebp]
  00068	c1 e2 18	 shl	 edx, 24			; 00000018H
  0006b	0b c2		 or	 eax, edx
$LN3@antlr3UTF3:

; 1717 :     }
; 1718 : }

  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
_antlr3UTF32LALE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3inputstream.c
;	COMDAT _antlr3UTF32LA
_TEXT	SEGMENT
_input$ = -4						; size = 4
_is$ = 8						; size = 4
_la$ = 12						; size = 4
_antlr3UTF32LA PROC					; COMDAT

; 1675 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1676 :     pANTLR3_INPUT_STREAM input;
; 1677 : 	
; 1678 :     input   = ((pANTLR3_INPUT_STREAM) (is->super));

  00004	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  00007	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000a	89 4d fc	 mov	 DWORD PTR _input$[ebp], ecx

; 1679 : 
; 1680 :     if	(( ((pANTLR3_UINT8)input->nextChar) + la - 1) >= (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  0000d	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  00010	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR _la$[ebp]
  00016	8d 54 08 ff	 lea	 edx, DWORD PTR [eax+ecx-1]
  0001a	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  0001d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00020	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  00023	03 48 18	 add	 ecx, DWORD PTR [eax+24]
  00026	3b d1		 cmp	 edx, ecx
  00028	72 07		 jb	 SHORT $LN2@antlr3UTF3

; 1681 :     {
; 1682 : 		return	ANTLR3_CHARSTREAM_EOF;

  0002a	83 c8 ff	 or	 eax, -1
  0002d	eb 0f		 jmp	 SHORT $LN3@antlr3UTF3

; 1683 :     }

  0002f	eb 0d		 jmp	 SHORT $LN3@antlr3UTF3
$LN2@antlr3UTF3:

; 1684 :     else
; 1685 :     {
; 1686 : 		return	(ANTLR3_UCHAR)(*((pANTLR3_UINT32)input->nextChar + la - 1));

  00031	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  00034	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00037	8b 45 0c	 mov	 eax, DWORD PTR _la$[ebp]
  0003a	8b 44 82 fc	 mov	 eax, DWORD PTR [edx+eax*4-4]
$LN3@antlr3UTF3:

; 1687 :     }
; 1688 : }

  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
_antlr3UTF32LA ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3inputstream.c
;	COMDAT _antlr3UTF32Consume
_TEXT	SEGMENT
_input$ = -4						; size = 4
_is$ = 8						; size = 4
_antlr3UTF32Consume PROC				; COMDAT

; 1578 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1579 :     pANTLR3_INPUT_STREAM input;
; 1580 : 
; 1581 :     input   = ((pANTLR3_INPUT_STREAM) (is->super));

  00004	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  00007	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000a	89 4d fc	 mov	 DWORD PTR _input$[ebp], ecx

; 1582 : 
; 1583 :     // SizeBuf is always in bytes
; 1584 :     //
; 1585 :     if	((pANTLR3_UINT8)(input->nextChar) < (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  0000d	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  00010	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  00016	03 41 18	 add	 eax, DWORD PTR [ecx+24]
  00019	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  0001c	39 42 14	 cmp	 DWORD PTR [edx+20], eax
  0001f	73 56		 jae	 SHORT $LN2@antlr3UTF3

; 1586 :     {	
; 1587 : 	/* Indicate one more character in this line
; 1588 : 	 */
; 1589 : 	input->charPositionInLine++;

  00021	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  00024	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00027	83 c1 01	 add	 ecx, 1
  0002a	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  0002d	89 4a 24	 mov	 DWORD PTR [edx+36], ecx

; 1590 : 	
; 1591 : 	if  ((ANTLR3_UCHAR)(*((pANTLR3_UINT32)input->nextChar)) == input->newlineChar)

  00030	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  00033	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00036	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  00039	8b 01		 mov	 eax, DWORD PTR [ecx]
  0003b	3b 42 70	 cmp	 eax, DWORD PTR [edx+112]
  0003e	75 28		 jne	 SHORT $LN3@antlr3UTF3

; 1592 : 	{
; 1593 : 	    /* Reset for start of a new line of input
; 1594 : 	     */
; 1595 : 	    input->line++;

  00040	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  00043	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00046	83 c2 01	 add	 edx, 1
  00049	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  0004c	89 50 1c	 mov	 DWORD PTR [eax+28], edx

; 1596 : 	    input->charPositionInLine	= 0;

  0004f	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  00052	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], 0

; 1597 : 	    input->currentLine		= (void *)(((pANTLR3_UINT32)input->nextChar) + 1);

  00059	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  0005c	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0005f	83 c0 04	 add	 eax, 4
  00062	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  00065	89 41 20	 mov	 DWORD PTR [ecx+32], eax
$LN3@antlr3UTF3:

; 1598 : 	}
; 1599 : 
; 1600 : 	/* Increment to next character position
; 1601 : 	 */
; 1602 : 	input->nextChar = (void *)(((pANTLR3_UINT32)input->nextChar) + 1);

  00068	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  0006b	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0006e	83 c0 04	 add	 eax, 4
  00071	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  00074	89 41 14	 mov	 DWORD PTR [ecx+20], eax
$LN2@antlr3UTF3:

; 1603 :     }
; 1604 : }

  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
_antlr3UTF32Consume ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3inputstream.c
;	COMDAT _antlr3UTF16Substr
_TEXT	SEGMENT
_input$ = 8						; size = 4
_start$ = 12						; size = 4
_stop$ = 16						; size = 4
_antlr3UTF16Substr PROC					; COMDAT

; 1054 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1055 :     return  input->strFactory->newPtr(input->strFactory, (pANTLR3_UINT8)start, ((ANTLR3_UINT32_CAST(stop - start))/2) + 1);

  00004	8b 45 10	 mov	 eax, DWORD PTR _stop$[ebp]
  00007	2b 45 0c	 sub	 eax, DWORD PTR _start$[ebp]
  0000a	d1 e8		 shr	 eax, 1
  0000c	83 c0 01	 add	 eax, 1
  0000f	8b f4		 mov	 esi, esp
  00011	50		 push	 eax
  00012	8b 4d 0c	 mov	 ecx, DWORD PTR _start$[ebp]
  00015	51		 push	 ecx
  00016	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  00019	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0001c	50		 push	 eax
  0001d	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  00020	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00023	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00026	ff d0		 call	 eax
  00028	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002b	3b f4		 cmp	 esi, esp
  0002d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1056 : }

  00032	5e		 pop	 esi
  00033	3b ec		 cmp	 ebp, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
_antlr3UTF16Substr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3inputstream.c
;	COMDAT _antlr3UTF16Seek
_TEXT	SEGMENT
_input$ = -4						; size = 4
_is$ = 8						; size = 4
_seekPoint$ = 12					; size = 4
_antlr3UTF16Seek PROC					; COMDAT

; 1021 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 1022 : 	pANTLR3_INPUT_STREAM input;
; 1023 : 
; 1024 : 	input   = ((pANTLR3_INPUT_STREAM) is->super);

  0000c	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  0000f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00012	89 4d fc	 mov	 DWORD PTR _input$[ebp], ecx

; 1025 : 
; 1026 : 	// If the requested seek point is less than the current
; 1027 : 	// input point, then we assume that we are resetting from a mark
; 1028 : 	// and do not need to scan, but can just set to there as rewind will
; 1029 :         // reset line numbers and so on.
; 1030 : 	//
; 1031 : 	if	(seekPoint <= (ANTLR3_MARKER)(input->nextChar))

  00015	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  00018	8b 45 0c	 mov	 eax, DWORD PTR _seekPoint$[ebp]
  0001b	3b 42 14	 cmp	 eax, DWORD PTR [edx+20]
  0001e	7f 0b		 jg	 SHORT $LN4@antlr3UTF1

; 1032 : 	{
; 1033 : 		input->nextChar	= (void *)seekPoint;

  00020	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  00023	8b 55 0c	 mov	 edx, DWORD PTR _seekPoint$[ebp]
  00026	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 1034 : 	}

  00029	eb 45		 jmp	 SHORT $LN3@antlr3UTF1
$LN4@antlr3UTF1:

; 1035 : 	else
; 1036 : 	{
; 1037 :             // Call consume until we reach the asked for seek point or EOF
; 1038 :             //
; 1039 :             while (is->_LA(is, 1) != ANTLR3_CHARSTREAM_EOF && seekPoint < (ANTLR3_MARKER)input->nextChar)

  0002b	8b f4		 mov	 esi, esp
  0002d	6a 01		 push	 1
  0002f	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  00032	50		 push	 eax
  00033	8b 4d 08	 mov	 ecx, DWORD PTR _is$[ebp]
  00036	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00039	ff d2		 call	 edx
  0003b	83 c4 08	 add	 esp, 8
  0003e	3b f4		 cmp	 esi, esp
  00040	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00045	83 f8 ff	 cmp	 eax, -1
  00048	74 26		 je	 SHORT $LN3@antlr3UTF1
  0004a	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  0004d	8b 4d 0c	 mov	 ecx, DWORD PTR _seekPoint$[ebp]
  00050	3b 48 14	 cmp	 ecx, DWORD PTR [eax+20]
  00053	7d 1b		 jge	 SHORT $LN3@antlr3UTF1

; 1040 : 	    {
; 1041 : 		is->consume(is);

  00055	8b f4		 mov	 esi, esp
  00057	8b 55 08	 mov	 edx, DWORD PTR _is$[ebp]
  0005a	52		 push	 edx
  0005b	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  0005e	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00061	ff d1		 call	 ecx
  00063	83 c4 04	 add	 esp, 4
  00066	3b f4		 cmp	 esi, esp
  00068	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006d	90		 npad	 1

; 1042 : 	    }

  0006e	eb bb		 jmp	 SHORT $LN4@antlr3UTF1
$LN3@antlr3UTF1:

; 1043 : 	}
; 1044 : }

  00070	5e		 pop	 esi
  00071	83 c4 04	 add	 esp, 4
  00074	3b ec		 cmp	 ebp, esp
  00076	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
_antlr3UTF16Seek ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3inputstream.c
;	COMDAT _antlr3UTF16Index
_TEXT	SEGMENT
_input$ = -4						; size = 4
_is$ = 8						; size = 4
_antlr3UTF16Index PROC					; COMDAT

; 1004 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1005 :     pANTLR3_INPUT_STREAM input;
; 1006 : 
; 1007 :     input   = ((pANTLR3_INPUT_STREAM) (is->super));

  00004	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  00007	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000a	89 4d fc	 mov	 DWORD PTR _input$[ebp], ecx

; 1008 : 
; 1009 :     return  (ANTLR3_MARKER)(input->nextChar);

  0000d	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  00010	8b 42 14	 mov	 eax, DWORD PTR [edx+20]

; 1010 : }

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
_antlr3UTF16Index ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3inputstream.c
;	COMDAT _antlr3UTF16LABE
_TEXT	SEGMENT
tv92 = -24						; size = 4
tv91 = -20						; size = 4
_nextChar$ = -16					; size = 4
_ch2$ = -12						; size = 4
_ch$ = -8						; size = 4
_input$ = -4						; size = 4
_is$ = 8						; size = 4
_la$ = 12						; size = 4
_antlr3UTF16LABE PROC					; COMDAT

; 1366 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 1367 : 	pANTLR3_INPUT_STREAM input;
; 1368 :         UTF32           ch;
; 1369 :         UTF32           ch2;
; 1370 :         pANTLR3_UCHAR   nextChar;
; 1371 : 
; 1372 :         // Find the input interface and where we are currently pointing to
; 1373 :         // in the input stream
; 1374 :         //
; 1375 : 	input       = ((pANTLR3_INPUT_STREAM) (is->super));

  00006	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  00009	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000c	89 4d fc	 mov	 DWORD PTR _input$[ebp], ecx

; 1376 :         nextChar    = (pANTLR3_UCHAR)input->nextChar;

  0000f	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  00012	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00015	89 45 f0	 mov	 DWORD PTR _nextChar$[ebp], eax

; 1377 : 
; 1378 :         // If a positive offset then advance forward, else retreat
; 1379 :         //
; 1380 :         if  (la >= 0)

  00018	83 7d 0c 00	 cmp	 DWORD PTR _la$[ebp], 0
  0001c	0f 8c 93 00 00
	00		 jl	 $LN6@antlr3UTF1
$LN2@antlr3UTF1:

; 1381 :         {
; 1382 :             while   (--la > 0 && (pANTLR3_UINT8)nextChar < ((pANTLR3_UINT8)input->data) + input->sizeBuf )

  00022	8b 4d 0c	 mov	 ecx, DWORD PTR _la$[ebp]
  00025	83 e9 01	 sub	 ecx, 1
  00028	89 4d 0c	 mov	 DWORD PTR _la$[ebp], ecx
  0002b	83 7d 0c 00	 cmp	 DWORD PTR _la$[ebp], 0
  0002f	7e 7f		 jle	 SHORT $LN3@antlr3UTF1
  00031	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  00034	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00037	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  0003a	03 41 18	 add	 eax, DWORD PTR [ecx+24]
  0003d	39 45 f0	 cmp	 DWORD PTR _nextChar$[ebp], eax
  00040	73 6e		 jae	 SHORT $LN3@antlr3UTF1

; 1383 :             {
; 1384 :                 // Advance our copy of the input pointer
; 1385 :                 //
; 1386 :                 // Next char in Big Endian byte order
; 1387 :                 //
; 1388 :                 ch  = ((*nextChar) << 8) + *(nextChar+1);

  00042	8b 55 f0	 mov	 edx, DWORD PTR _nextChar$[ebp]
  00045	8b 02		 mov	 eax, DWORD PTR [edx]
  00047	c1 e0 08	 shl	 eax, 8
  0004a	8b 4d f0	 mov	 ecx, DWORD PTR _nextChar$[ebp]
  0004d	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  00050	89 45 f8	 mov	 DWORD PTR _ch$[ebp], eax

; 1389 :                 nextChar += 2;

  00053	8b 55 f0	 mov	 edx, DWORD PTR _nextChar$[ebp]
  00056	83 c2 08	 add	 edx, 8
  00059	89 55 f0	 mov	 DWORD PTR _nextChar$[ebp], edx

; 1390 : 
; 1391 :                 // If we have a surrogate pair then we need to consume
; 1392 :                 // a following valid LO surrogate.
; 1393 :                 //
; 1394 :                 if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_HIGH_END) 

  0005c	81 7d f8 00 d8
	00 00		 cmp	 DWORD PTR _ch$[ebp], 55296 ; 0000d800H
  00063	72 46		 jb	 SHORT $LN10@antlr3UTF1
  00065	81 7d f8 ff db
	00 00		 cmp	 DWORD PTR _ch$[ebp], 56319 ; 0000dbffH
  0006c	77 3d		 ja	 SHORT $LN10@antlr3UTF1

; 1395 :                 {
; 1396 :                     // If the 16 bits following the high surrogate are in the source buffer...
; 1397 :                     //
; 1398 :                     if	((pANTLR3_UINT8)(nextChar) < (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  0006e	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  00071	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00074	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  00077	03 4a 18	 add	 ecx, DWORD PTR [edx+24]
  0007a	39 4d f0	 cmp	 DWORD PTR _nextChar$[ebp], ecx
  0007d	73 2c		 jae	 SHORT $LN10@antlr3UTF1

; 1399 :                     {
; 1400 :                         // Next character is in big endian byte order
; 1401 :                         //
; 1402 :                         ch2 = ((*nextChar) << 8) + *(nextChar+1);

  0007f	8b 45 f0	 mov	 eax, DWORD PTR _nextChar$[ebp]
  00082	8b 08		 mov	 ecx, DWORD PTR [eax]
  00084	c1 e1 08	 shl	 ecx, 8
  00087	8b 55 f0	 mov	 edx, DWORD PTR _nextChar$[ebp]
  0008a	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  0008d	89 4d f4	 mov	 DWORD PTR _ch2$[ebp], ecx

; 1403 : 
; 1404 :                         // If it's a valid low surrogate, consume it
; 1405 :                         //
; 1406 :                         if (ch2 >= UNI_SUR_LOW_START && ch2 <= UNI_SUR_LOW_END) 

  00090	81 7d f4 00 dc
	00 00		 cmp	 DWORD PTR _ch2$[ebp], 56320 ; 0000dc00H
  00097	72 12		 jb	 SHORT $LN10@antlr3UTF1
  00099	81 7d f4 ff df
	00 00		 cmp	 DWORD PTR _ch2$[ebp], 57343 ; 0000dfffH
  000a0	77 09		 ja	 SHORT $LN10@antlr3UTF1

; 1407 :                         {
; 1408 :                             // We consumed one 16 bit character
; 1409 :                             //
; 1410 : 		            nextChar += 2;

  000a2	8b 45 f0	 mov	 eax, DWORD PTR _nextChar$[ebp]
  000a5	83 c0 08	 add	 eax, 8
  000a8	89 45 f0	 mov	 DWORD PTR _nextChar$[ebp], eax
$LN10@antlr3UTF1:

; 1411 :                         }
; 1412 :                         // Note that we ignore a valid hi surrogate that has no lo surrogate to go with
; 1413 :                         // it.
; 1414 :                         //
; 1415 :                     } 
; 1416 :                     // Note that we ignore a valid hi surrogate that has no lo surrogate to go with
; 1417 :                     // it because the buffer ended
; 1418 :                     //
; 1419 :                 }
; 1420 :                 // Note that we did not check for an invalid low surrogate here, or that fact that the
; 1421 :                 // lo surrogate was missing. We just picked out one 16 bit character unless the character
; 1422 :                 // was a valid hi surrogate, in whcih case we consumed two 16 bit characters.
; 1423 :                 //
; 1424 :             }

  000ab	e9 72 ff ff ff	 jmp	 $LN2@antlr3UTF1
$LN3@antlr3UTF1:

; 1425 :         }

  000b0	e9 9f 00 00 00	 jmp	 $LN5@antlr3UTF1
$LN6@antlr3UTF1:

; 1426 :         else
; 1427 :         {
; 1428 :             // We need to go backwards from our input point
; 1429 :             //
; 1430 :             while   (la++ < 0 && (pANTLR3_UINT8)nextChar > (pANTLR3_UINT8)input->data )

  000b5	8b 4d 0c	 mov	 ecx, DWORD PTR _la$[ebp]
  000b8	89 4d ec	 mov	 DWORD PTR tv91[ebp], ecx
  000bb	8b 55 0c	 mov	 edx, DWORD PTR _la$[ebp]
  000be	83 c2 01	 add	 edx, 1
  000c1	89 55 0c	 mov	 DWORD PTR _la$[ebp], edx
  000c4	83 7d ec 00	 cmp	 DWORD PTR tv91[ebp], 0
  000c8	7d 09		 jge	 SHORT $LN19@antlr3UTF1
  000ca	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv92[ebp], 1
  000d1	eb 07		 jmp	 SHORT $LN20@antlr3UTF1
$LN19@antlr3UTF1:
  000d3	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv92[ebp], 0
$LN20@antlr3UTF1:
  000da	83 7d e8 00	 cmp	 DWORD PTR tv92[ebp], 0
  000de	74 74		 je	 SHORT $LN5@antlr3UTF1
  000e0	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  000e3	8b 4d f0	 mov	 ecx, DWORD PTR _nextChar$[ebp]
  000e6	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  000e9	76 69		 jbe	 SHORT $LN5@antlr3UTF1

; 1431 :             {
; 1432 :                 // Get the previous 16 bit character
; 1433 :                 //
; 1434 :                 ch = ((*nextChar - 2) << 8) + (*nextChar -1);

  000eb	8b 55 f0	 mov	 edx, DWORD PTR _nextChar$[ebp]
  000ee	8b 02		 mov	 eax, DWORD PTR [edx]
  000f0	83 e8 02	 sub	 eax, 2
  000f3	c1 e0 08	 shl	 eax, 8
  000f6	8b 4d f0	 mov	 ecx, DWORD PTR _nextChar$[ebp]
  000f9	8b 11		 mov	 edx, DWORD PTR [ecx]
  000fb	8d 44 10 ff	 lea	 eax, DWORD PTR [eax+edx-1]
  000ff	89 45 f8	 mov	 DWORD PTR _ch$[ebp], eax

; 1435 :                 nextChar -= 2;

  00102	8b 4d f0	 mov	 ecx, DWORD PTR _nextChar$[ebp]
  00105	83 e9 08	 sub	 ecx, 8
  00108	89 4d f0	 mov	 DWORD PTR _nextChar$[ebp], ecx

; 1436 : 
; 1437 :                 // If we found a low surrogate then go back one more character if
; 1438 :                 // the hi surrogate is there
; 1439 :                 //
; 1440 :                 if (ch >= UNI_SUR_LOW_START && ch <= UNI_SUR_LOW_END) 

  0010b	81 7d f8 00 dc
	00 00		 cmp	 DWORD PTR _ch$[ebp], 56320 ; 0000dc00H
  00112	72 3b		 jb	 SHORT $LN12@antlr3UTF1
  00114	81 7d f8 ff df
	00 00		 cmp	 DWORD PTR _ch$[ebp], 57343 ; 0000dfffH
  0011b	77 32		 ja	 SHORT $LN12@antlr3UTF1

; 1441 :                 {
; 1442 :                     ch2 = ((*nextChar - 2) << 8) + (*nextChar -1);

  0011d	8b 55 f0	 mov	 edx, DWORD PTR _nextChar$[ebp]
  00120	8b 02		 mov	 eax, DWORD PTR [edx]
  00122	83 e8 02	 sub	 eax, 2
  00125	c1 e0 08	 shl	 eax, 8
  00128	8b 4d f0	 mov	 ecx, DWORD PTR _nextChar$[ebp]
  0012b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0012d	8d 44 10 ff	 lea	 eax, DWORD PTR [eax+edx-1]
  00131	89 45 f4	 mov	 DWORD PTR _ch2$[ebp], eax

; 1443 :                     if (ch2 >= UNI_SUR_HIGH_START && ch2 <= UNI_SUR_HIGH_END) 

  00134	81 7d f4 00 d8
	00 00		 cmp	 DWORD PTR _ch2$[ebp], 55296 ; 0000d800H
  0013b	72 12		 jb	 SHORT $LN12@antlr3UTF1
  0013d	81 7d f4 ff db
	00 00		 cmp	 DWORD PTR _ch2$[ebp], 56319 ; 0000dbffH
  00144	77 09		 ja	 SHORT $LN12@antlr3UTF1

; 1444 :                     {
; 1445 :                         // Yes, there is a high surrogate to match it so decrement one more and point to that
; 1446 :                         //
; 1447 :                         nextChar -=2;

  00146	8b 4d f0	 mov	 ecx, DWORD PTR _nextChar$[ebp]
  00149	83 e9 08	 sub	 ecx, 8
  0014c	89 4d f0	 mov	 DWORD PTR _nextChar$[ebp], ecx
$LN12@antlr3UTF1:

; 1448 :                     }
; 1449 :                 }
; 1450 :             }

  0014f	e9 61 ff ff ff	 jmp	 $LN6@antlr3UTF1
$LN5@antlr3UTF1:

; 1451 :         }
; 1452 : 
; 1453 :         // Our local copy of nextChar is now pointing to either the correct character or end of file
; 1454 :         //
; 1455 :         // Input buffer size is always in bytes
; 1456 :         //
; 1457 : 	if	( (pANTLR3_UINT8)nextChar >= (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  00154	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  00157	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0015a	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  0015d	03 41 18	 add	 eax, DWORD PTR [ecx+24]
  00160	39 45 f0	 cmp	 DWORD PTR _nextChar$[ebp], eax
  00163	72 07		 jb	 SHORT $LN13@antlr3UTF1

; 1458 : 	{
; 1459 : 		return	ANTLR3_CHARSTREAM_EOF;

  00165	83 c8 ff	 or	 eax, -1
  00168	eb 7d		 jmp	 SHORT $LN1@antlr3UTF1

; 1460 : 	}

  0016a	eb 78		 jmp	 SHORT $LN17@antlr3UTF1
$LN13@antlr3UTF1:

; 1461 : 	else
; 1462 : 	{
; 1463 :             // Pick up the next 16 character (big endian byte order)
; 1464 :             //
; 1465 :             ch = ((*nextChar) << 8) + *(nextChar+1);

  0016c	8b 55 f0	 mov	 edx, DWORD PTR _nextChar$[ebp]
  0016f	8b 02		 mov	 eax, DWORD PTR [edx]
  00171	c1 e0 08	 shl	 eax, 8
  00174	8b 4d f0	 mov	 ecx, DWORD PTR _nextChar$[ebp]
  00177	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  0017a	89 45 f8	 mov	 DWORD PTR _ch$[ebp], eax

; 1466 :             nextChar += 2;

  0017d	8b 55 f0	 mov	 edx, DWORD PTR _nextChar$[ebp]
  00180	83 c2 08	 add	 edx, 8
  00183	89 55 f0	 mov	 DWORD PTR _nextChar$[ebp], edx

; 1467 : 
; 1468 :             // If we have a surrogate pair then we need to consume
; 1469 :             // a following valid LO surrogate.
; 1470 :             //
; 1471 :             if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_HIGH_END) 

  00186	81 7d f8 00 d8
	00 00		 cmp	 DWORD PTR _ch$[ebp], 55296 ; 0000d800H
  0018d	72 55		 jb	 SHORT $LN17@antlr3UTF1
  0018f	81 7d f8 ff db
	00 00		 cmp	 DWORD PTR _ch$[ebp], 56319 ; 0000dbffH
  00196	77 4c		 ja	 SHORT $LN17@antlr3UTF1

; 1472 :             {
; 1473 :                 // If the 16 bits following the high surrogate are in the source buffer...
; 1474 :                 //
; 1475 :                 if	((pANTLR3_UINT8)(nextChar) < (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  00198	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  0019b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0019e	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  001a1	03 4a 18	 add	 ecx, DWORD PTR [edx+24]
  001a4	39 4d f0	 cmp	 DWORD PTR _nextChar$[ebp], ecx
  001a7	73 3b		 jae	 SHORT $LN17@antlr3UTF1

; 1476 :                 {
; 1477 :                     // Next character is in big endian byte order
; 1478 :                     //
; 1479 :                     ch2 = ((*nextChar) << 8) + *(nextChar+1);

  001a9	8b 45 f0	 mov	 eax, DWORD PTR _nextChar$[ebp]
  001ac	8b 08		 mov	 ecx, DWORD PTR [eax]
  001ae	c1 e1 08	 shl	 ecx, 8
  001b1	8b 55 f0	 mov	 edx, DWORD PTR _nextChar$[ebp]
  001b4	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  001b7	89 4d f4	 mov	 DWORD PTR _ch2$[ebp], ecx

; 1480 : 
; 1481 :                     // If it's a valid low surrogate, consume it
; 1482 :                     //
; 1483 :                     if (ch2 >= UNI_SUR_LOW_START && ch2 <= UNI_SUR_LOW_END) 

  001ba	81 7d f4 00 dc
	00 00		 cmp	 DWORD PTR _ch2$[ebp], 56320 ; 0000dc00H
  001c1	72 21		 jb	 SHORT $LN17@antlr3UTF1
  001c3	81 7d f4 ff df
	00 00		 cmp	 DWORD PTR _ch2$[ebp], 57343 ; 0000dfffH
  001ca	77 18		 ja	 SHORT $LN17@antlr3UTF1

; 1484 :                     {
; 1485 :                         // Construct the UTF32 code point
; 1486 :                         //
; 1487 :                         ch = ((ch - UNI_SUR_HIGH_START) << halfShift)

  001cc	8b 45 f8	 mov	 eax, DWORD PTR _ch$[ebp]
  001cf	2d 00 d8 00 00	 sub	 eax, 55296		; 0000d800H
  001d4	c1 e0 0a	 shl	 eax, 10			; 0000000aH
  001d7	8b 4d f4	 mov	 ecx, DWORD PTR _ch2$[ebp]
  001da	8d 94 08 00 24
	00 00		 lea	 edx, DWORD PTR [eax+ecx+9216]
  001e1	89 55 f8	 mov	 DWORD PTR _ch$[ebp], edx
$LN17@antlr3UTF1:

; 1488 : 			    + (ch2 - UNI_SUR_LOW_START) + halfBase;
; 1489 :                     }
; 1490 :                     // Note that we ignore a valid hi surrogate that has no lo surrogate to go with
; 1491 :                     // it.
; 1492 :                     //
; 1493 :                 } 
; 1494 :                 // Note that we ignore a valid hi surrogate that has no lo surrogate to go with
; 1495 :                 // it because the buffer ended
; 1496 :                 //
; 1497 :             }
; 1498 :         }
; 1499 :         return ch;

  001e4	8b 45 f8	 mov	 eax, DWORD PTR _ch$[ebp]
$LN1@antlr3UTF1:

; 1500 : }

  001e7	8b e5		 mov	 esp, ebp
  001e9	5d		 pop	 ebp
  001ea	c3		 ret	 0
_antlr3UTF16LABE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3inputstream.c
;	COMDAT _antlr3UTF16ConsumeBE
_TEXT	SEGMENT
_ch2$ = -12						; size = 4
_ch$ = -8						; size = 4
_input$ = -4						; size = 4
_is$ = 8						; size = 4
_antlr3UTF16ConsumeBE PROC				; COMDAT

; 1287 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1288 : 	pANTLR3_INPUT_STREAM input;
; 1289 :         UTF32   ch;
; 1290 :         UTF32   ch2;
; 1291 : 
; 1292 : 	input   = ((pANTLR3_INPUT_STREAM) (is->super));

  00006	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  00009	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000c	89 4d fc	 mov	 DWORD PTR _input$[ebp], ecx

; 1293 : 
; 1294 :         // Buffer size is always in bytes
; 1295 :         //
; 1296 : 	if	((pANTLR3_UINT8)(input->nextChar) < (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  0000f	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  00012	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  00018	03 41 18	 add	 eax, DWORD PTR [ecx+24]
  0001b	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  0001e	39 42 14	 cmp	 DWORD PTR [edx+20], eax
  00021	0f 83 d4 00 00
	00		 jae	 $LN6@antlr3UTF1

; 1297 : 	{	
; 1298 : 		// Indicate one more character in this line
; 1299 : 		//
; 1300 : 		input->charPositionInLine++;

  00027	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  0002a	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0002d	83 c1 01	 add	 ecx, 1
  00030	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  00033	89 4a 24	 mov	 DWORD PTR [edx+36], ecx

; 1301 : 
; 1302 : 		if  ((ANTLR3_UCHAR)(*((pANTLR3_UINT16)input->nextChar)) == input->newlineChar)

  00036	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  00039	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0003c	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  0003f	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  00042	3b 50 70	 cmp	 edx, DWORD PTR [eax+112]
  00045	75 28		 jne	 SHORT $LN3@antlr3UTF1

; 1303 : 		{
; 1304 : 			// Reset for start of a new line of input
; 1305 : 			//
; 1306 : 			input->line++;

  00047	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  0004a	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0004d	83 c2 01	 add	 edx, 1
  00050	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  00053	89 50 1c	 mov	 DWORD PTR [eax+28], edx

; 1307 : 			input->charPositionInLine	= 0;

  00056	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  00059	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], 0

; 1308 : 			input->currentLine		= (void *)(((pANTLR3_UINT16)input->nextChar) + 1);

  00060	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  00063	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00066	83 c0 02	 add	 eax, 2
  00069	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  0006c	89 41 20	 mov	 DWORD PTR [ecx+32], eax
$LN3@antlr3UTF1:

; 1309 : 		}
; 1310 : 
; 1311 : 		// Increment to next character position, accounting for any surrogates
; 1312 : 		//
; 1313 :                 // Next char in big endian form
; 1314 :                 //
; 1315 :                 ch  = *((pANTLR3_UINT8)input->nextChar + 1) + (*((pANTLR3_UINT8)input->nextChar ) <<8);

  0006f	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  00072	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00075	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00079	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  0007c	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0007f	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  00082	c1 e2 08	 shl	 edx, 8
  00085	03 ca		 add	 ecx, edx
  00087	89 4d f8	 mov	 DWORD PTR _ch$[ebp], ecx

; 1316 : 
; 1317 :                 // We consumed one 16 bit character
; 1318 :                 //
; 1319 : 		input->nextChar = (void *)(((pANTLR3_UINT16)input->nextChar) + 1);

  0008a	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  0008d	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00090	83 c1 02	 add	 ecx, 2
  00093	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  00096	89 4a 14	 mov	 DWORD PTR [edx+20], ecx

; 1320 : 
; 1321 :                 // If we have a surrogate pair then we need to consume
; 1322 :                 // a following valid LO surrogate.
; 1323 :                 //
; 1324 :                 if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_HIGH_END) {

  00099	81 7d f8 00 d8
	00 00		 cmp	 DWORD PTR _ch$[ebp], 55296 ; 0000d800H
  000a0	72 59		 jb	 SHORT $LN6@antlr3UTF1
  000a2	81 7d f8 ff db
	00 00		 cmp	 DWORD PTR _ch$[ebp], 56319 ; 0000dbffH
  000a9	77 50		 ja	 SHORT $LN6@antlr3UTF1

; 1325 : 
; 1326 :                     // If the 16 bits following the high surrogate are in the source buffer...
; 1327 :                     //
; 1328 :                     if	((pANTLR3_UINT8)(input->nextChar) < (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  000ab	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  000ae	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000b1	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  000b4	03 4a 18	 add	 ecx, DWORD PTR [edx+24]
  000b7	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  000ba	39 48 14	 cmp	 DWORD PTR [eax+20], ecx
  000bd	73 3c		 jae	 SHORT $LN6@antlr3UTF1

; 1329 :                     {
; 1330 :                         // Big endian
; 1331 :                         //
; 1332 :                         ch2 = *((pANTLR3_UINT8)input->nextChar + 1) + (*((pANTLR3_UINT8)input->nextChar ) <<8);

  000bf	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  000c2	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  000c5	0f b6 42 01	 movzx	 eax, BYTE PTR [edx+1]
  000c9	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  000cc	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  000cf	0f b6 0a	 movzx	 ecx, BYTE PTR [edx]
  000d2	c1 e1 08	 shl	 ecx, 8
  000d5	03 c1		 add	 eax, ecx
  000d7	89 45 f4	 mov	 DWORD PTR _ch2$[ebp], eax

; 1333 : 
; 1334 :                         // If it's a valid low surrogate, consume it
; 1335 :                         //
; 1336 :                         if (ch2 >= UNI_SUR_LOW_START && ch2 <= UNI_SUR_LOW_END) 

  000da	81 7d f4 00 dc
	00 00		 cmp	 DWORD PTR _ch2$[ebp], 56320 ; 0000dc00H
  000e1	72 18		 jb	 SHORT $LN6@antlr3UTF1
  000e3	81 7d f4 ff df
	00 00		 cmp	 DWORD PTR _ch2$[ebp], 57343 ; 0000dfffH
  000ea	77 0f		 ja	 SHORT $LN6@antlr3UTF1

; 1337 :                         {
; 1338 :                             // We consumed one 16 bit character
; 1339 :                             //
; 1340 : 		            input->nextChar = (void *)(((pANTLR3_UINT16)input->nextChar) + 1);

  000ec	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  000ef	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  000f2	83 c0 02	 add	 eax, 2
  000f5	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  000f8	89 41 14	 mov	 DWORD PTR [ecx+20], eax
$LN6@antlr3UTF1:

; 1341 :                         }
; 1342 :                         // Note that we ignore a valid hi surrogate that has no lo surrogate to go with
; 1343 :                         // it.
; 1344 :                         //
; 1345 :                     } 
; 1346 :                     // Note that we ignore a valid hi surrogate that has no lo surrogate to go with
; 1347 :                     // it because the buffer ended
; 1348 :                     //
; 1349 :                 } 
; 1350 :                 // Note that we did not check for an invalid low surrogate here, or that fact that the
; 1351 :                 // lo surrogate was missing. We just picked out one 16 bit character unless the character
; 1352 :                 // was a valid hi surrogate, in whcih case we consumed two 16 bit characters.
; 1353 :                 //
; 1354 : 	}
; 1355 : }

  000fb	8b e5		 mov	 esp, ebp
  000fd	5d		 pop	 ebp
  000fe	c3		 ret	 0
_antlr3UTF16ConsumeBE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3inputstream.c
;	COMDAT _antlr3UTF16LALE
_TEXT	SEGMENT
tv92 = -24						; size = 4
tv91 = -20						; size = 4
_nextChar$ = -16					; size = 4
_ch2$ = -12						; size = 4
_ch$ = -8						; size = 4
_input$ = -4						; size = 4
_is$ = 8						; size = 4
_la$ = 12						; size = 4
_antlr3UTF16LALE PROC					; COMDAT

; 1145 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 1146 : 	pANTLR3_INPUT_STREAM input;
; 1147 :         UTF32           ch;
; 1148 :         UTF32           ch2;
; 1149 :         pANTLR3_UCHAR   nextChar;
; 1150 : 
; 1151 :         // Find the input interface and where we are currently pointing to
; 1152 :         // in the input stream
; 1153 :         //
; 1154 : 	input       = ((pANTLR3_INPUT_STREAM) (is->super));

  00006	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  00009	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000c	89 4d fc	 mov	 DWORD PTR _input$[ebp], ecx

; 1155 :         nextChar    = (pANTLR3_UCHAR)input->nextChar;

  0000f	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  00012	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00015	89 45 f0	 mov	 DWORD PTR _nextChar$[ebp], eax

; 1156 : 
; 1157 :         // If a positive offset then advance forward, else retreat
; 1158 :         //
; 1159 :         if  (la >= 0)

  00018	83 7d 0c 00	 cmp	 DWORD PTR _la$[ebp], 0
  0001c	0f 8c 93 00 00
	00		 jl	 $LN6@antlr3UTF1
$LN2@antlr3UTF1:

; 1160 :         {
; 1161 :             while   (--la > 0 && (pANTLR3_UINT8)nextChar < ((pANTLR3_UINT8)input->data) + input->sizeBuf )

  00022	8b 4d 0c	 mov	 ecx, DWORD PTR _la$[ebp]
  00025	83 e9 01	 sub	 ecx, 1
  00028	89 4d 0c	 mov	 DWORD PTR _la$[ebp], ecx
  0002b	83 7d 0c 00	 cmp	 DWORD PTR _la$[ebp], 0
  0002f	7e 7f		 jle	 SHORT $LN3@antlr3UTF1
  00031	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  00034	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00037	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  0003a	03 41 18	 add	 eax, DWORD PTR [ecx+24]
  0003d	39 45 f0	 cmp	 DWORD PTR _nextChar$[ebp], eax
  00040	73 6e		 jae	 SHORT $LN3@antlr3UTF1

; 1162 :             {
; 1163 :                 // Advance our copy of the input pointer
; 1164 :                 //
; 1165 :                 // Next char in Little Endian byte order
; 1166 :                 //
; 1167 :                 ch  = (*nextChar) + (*(nextChar+1) << 8);

  00042	8b 55 f0	 mov	 edx, DWORD PTR _nextChar$[ebp]
  00045	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00048	c1 e0 08	 shl	 eax, 8
  0004b	8b 4d f0	 mov	 ecx, DWORD PTR _nextChar$[ebp]
  0004e	03 01		 add	 eax, DWORD PTR [ecx]
  00050	89 45 f8	 mov	 DWORD PTR _ch$[ebp], eax

; 1168 :                 nextChar += 2;

  00053	8b 55 f0	 mov	 edx, DWORD PTR _nextChar$[ebp]
  00056	83 c2 08	 add	 edx, 8
  00059	89 55 f0	 mov	 DWORD PTR _nextChar$[ebp], edx

; 1169 : 
; 1170 :                 // If we have a surrogate pair then we need to consume
; 1171 :                 // a following valid LO surrogate.
; 1172 :                 //
; 1173 :                 if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_HIGH_END) 

  0005c	81 7d f8 00 d8
	00 00		 cmp	 DWORD PTR _ch$[ebp], 55296 ; 0000d800H
  00063	72 46		 jb	 SHORT $LN10@antlr3UTF1
  00065	81 7d f8 ff db
	00 00		 cmp	 DWORD PTR _ch$[ebp], 56319 ; 0000dbffH
  0006c	77 3d		 ja	 SHORT $LN10@antlr3UTF1

; 1174 :                 {
; 1175 :                     // If the 16 bits following the high surrogate are in the source buffer...
; 1176 :                     //
; 1177 :                     if	((pANTLR3_UINT8)(nextChar) < (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  0006e	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  00071	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00074	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  00077	03 4a 18	 add	 ecx, DWORD PTR [edx+24]
  0007a	39 4d f0	 cmp	 DWORD PTR _nextChar$[ebp], ecx
  0007d	73 2c		 jae	 SHORT $LN10@antlr3UTF1

; 1178 :                     {
; 1179 :                         // Next character is in little endian byte order
; 1180 :                         //
; 1181 :                         ch2 = (*nextChar) + (*(nextChar+1) << 8);

  0007f	8b 45 f0	 mov	 eax, DWORD PTR _nextChar$[ebp]
  00082	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00085	c1 e1 08	 shl	 ecx, 8
  00088	8b 55 f0	 mov	 edx, DWORD PTR _nextChar$[ebp]
  0008b	03 0a		 add	 ecx, DWORD PTR [edx]
  0008d	89 4d f4	 mov	 DWORD PTR _ch2$[ebp], ecx

; 1182 : 
; 1183 :                         // If it's a valid low surrogate, consume it
; 1184 :                         //
; 1185 :                         if (ch2 >= UNI_SUR_LOW_START && ch2 <= UNI_SUR_LOW_END) 

  00090	81 7d f4 00 dc
	00 00		 cmp	 DWORD PTR _ch2$[ebp], 56320 ; 0000dc00H
  00097	72 12		 jb	 SHORT $LN10@antlr3UTF1
  00099	81 7d f4 ff df
	00 00		 cmp	 DWORD PTR _ch2$[ebp], 57343 ; 0000dfffH
  000a0	77 09		 ja	 SHORT $LN10@antlr3UTF1

; 1186 :                         {
; 1187 :                             // We consumed one 16 bit character
; 1188 :                             //
; 1189 : 		            nextChar += 2;

  000a2	8b 45 f0	 mov	 eax, DWORD PTR _nextChar$[ebp]
  000a5	83 c0 08	 add	 eax, 8
  000a8	89 45 f0	 mov	 DWORD PTR _nextChar$[ebp], eax
$LN10@antlr3UTF1:

; 1190 :                         }
; 1191 :                         // Note that we ignore a valid hi surrogate that has no lo surrogate to go with
; 1192 :                         // it.
; 1193 :                         //
; 1194 :                     } 
; 1195 :                     // Note that we ignore a valid hi surrogate that has no lo surrogate to go with
; 1196 :                     // it because the buffer ended
; 1197 :                     //
; 1198 :                 }
; 1199 :                 // Note that we did not check for an invalid low surrogate here, or that fact that the
; 1200 :                 // lo surrogate was missing. We just picked out one 16 bit character unless the character
; 1201 :                 // was a valid hi surrogate, in whcih case we consumed two 16 bit characters.
; 1202 :                 //
; 1203 :             }

  000ab	e9 72 ff ff ff	 jmp	 $LN2@antlr3UTF1
$LN3@antlr3UTF1:

; 1204 :         }

  000b0	e9 9f 00 00 00	 jmp	 $LN5@antlr3UTF1
$LN6@antlr3UTF1:

; 1205 :         else
; 1206 :         {
; 1207 :             // We need to go backwards from our input point
; 1208 :             //
; 1209 :             while   (la++ < 0 && (pANTLR3_UINT8)nextChar > (pANTLR3_UINT8)input->data )

  000b5	8b 4d 0c	 mov	 ecx, DWORD PTR _la$[ebp]
  000b8	89 4d ec	 mov	 DWORD PTR tv91[ebp], ecx
  000bb	8b 55 0c	 mov	 edx, DWORD PTR _la$[ebp]
  000be	83 c2 01	 add	 edx, 1
  000c1	89 55 0c	 mov	 DWORD PTR _la$[ebp], edx
  000c4	83 7d ec 00	 cmp	 DWORD PTR tv91[ebp], 0
  000c8	7d 09		 jge	 SHORT $LN19@antlr3UTF1
  000ca	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv92[ebp], 1
  000d1	eb 07		 jmp	 SHORT $LN20@antlr3UTF1
$LN19@antlr3UTF1:
  000d3	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv92[ebp], 0
$LN20@antlr3UTF1:
  000da	83 7d e8 00	 cmp	 DWORD PTR tv92[ebp], 0
  000de	74 74		 je	 SHORT $LN5@antlr3UTF1
  000e0	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  000e3	8b 4d f0	 mov	 ecx, DWORD PTR _nextChar$[ebp]
  000e6	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  000e9	76 69		 jbe	 SHORT $LN5@antlr3UTF1

; 1210 :             {
; 1211 :                 // Get the previous 16 bit character
; 1212 :                 //
; 1213 :                 ch = (*nextChar - 2) + ((*nextChar -1) << 8);

  000eb	8b 55 f0	 mov	 edx, DWORD PTR _nextChar$[ebp]
  000ee	8b 02		 mov	 eax, DWORD PTR [edx]
  000f0	8b 4d f0	 mov	 ecx, DWORD PTR _nextChar$[ebp]
  000f3	8b 11		 mov	 edx, DWORD PTR [ecx]
  000f5	83 ea 01	 sub	 edx, 1
  000f8	c1 e2 08	 shl	 edx, 8
  000fb	8d 44 10 fe	 lea	 eax, DWORD PTR [eax+edx-2]
  000ff	89 45 f8	 mov	 DWORD PTR _ch$[ebp], eax

; 1214 :                 nextChar -= 2;

  00102	8b 4d f0	 mov	 ecx, DWORD PTR _nextChar$[ebp]
  00105	83 e9 08	 sub	 ecx, 8
  00108	89 4d f0	 mov	 DWORD PTR _nextChar$[ebp], ecx

; 1215 : 
; 1216 :                 // If we found a low surrogate then go back one more character if
; 1217 :                 // the hi surrogate is there
; 1218 :                 //
; 1219 :                 if (ch >= UNI_SUR_LOW_START && ch <= UNI_SUR_LOW_END) 

  0010b	81 7d f8 00 dc
	00 00		 cmp	 DWORD PTR _ch$[ebp], 56320 ; 0000dc00H
  00112	72 3b		 jb	 SHORT $LN12@antlr3UTF1
  00114	81 7d f8 ff df
	00 00		 cmp	 DWORD PTR _ch$[ebp], 57343 ; 0000dfffH
  0011b	77 32		 ja	 SHORT $LN12@antlr3UTF1

; 1220 :                 {
; 1221 :                     ch2 = (*nextChar - 2) + ((*nextChar -1) << 8);

  0011d	8b 55 f0	 mov	 edx, DWORD PTR _nextChar$[ebp]
  00120	8b 02		 mov	 eax, DWORD PTR [edx]
  00122	8b 4d f0	 mov	 ecx, DWORD PTR _nextChar$[ebp]
  00125	8b 11		 mov	 edx, DWORD PTR [ecx]
  00127	83 ea 01	 sub	 edx, 1
  0012a	c1 e2 08	 shl	 edx, 8
  0012d	8d 44 10 fe	 lea	 eax, DWORD PTR [eax+edx-2]
  00131	89 45 f4	 mov	 DWORD PTR _ch2$[ebp], eax

; 1222 :                     if (ch2 >= UNI_SUR_HIGH_START && ch2 <= UNI_SUR_HIGH_END) 

  00134	81 7d f4 00 d8
	00 00		 cmp	 DWORD PTR _ch2$[ebp], 55296 ; 0000d800H
  0013b	72 12		 jb	 SHORT $LN12@antlr3UTF1
  0013d	81 7d f4 ff db
	00 00		 cmp	 DWORD PTR _ch2$[ebp], 56319 ; 0000dbffH
  00144	77 09		 ja	 SHORT $LN12@antlr3UTF1

; 1223 :                     {
; 1224 :                         // Yes, there is a high surrogate to match it so decrement one more and point to that
; 1225 :                         //
; 1226 :                         nextChar -=2;

  00146	8b 4d f0	 mov	 ecx, DWORD PTR _nextChar$[ebp]
  00149	83 e9 08	 sub	 ecx, 8
  0014c	89 4d f0	 mov	 DWORD PTR _nextChar$[ebp], ecx
$LN12@antlr3UTF1:

; 1227 :                     }
; 1228 :                 }
; 1229 :             }

  0014f	e9 61 ff ff ff	 jmp	 $LN6@antlr3UTF1
$LN5@antlr3UTF1:

; 1230 :         }
; 1231 : 
; 1232 :         // Our local copy of nextChar is now pointing to either the correct character or end of file
; 1233 :         //
; 1234 :         // Input buffer size is always in bytes
; 1235 :         //
; 1236 : 	if	( (pANTLR3_UINT8)nextChar >= (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  00154	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  00157	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0015a	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  0015d	03 41 18	 add	 eax, DWORD PTR [ecx+24]
  00160	39 45 f0	 cmp	 DWORD PTR _nextChar$[ebp], eax
  00163	72 07		 jb	 SHORT $LN13@antlr3UTF1

; 1237 : 	{
; 1238 : 		return	ANTLR3_CHARSTREAM_EOF;

  00165	83 c8 ff	 or	 eax, -1
  00168	eb 7d		 jmp	 SHORT $LN1@antlr3UTF1

; 1239 : 	}

  0016a	eb 78		 jmp	 SHORT $LN17@antlr3UTF1
$LN13@antlr3UTF1:

; 1240 : 	else
; 1241 : 	{
; 1242 :             // Pick up the next 16 character (little endian byte order)
; 1243 :             //
; 1244 :             ch = (*nextChar) + (*(nextChar+1) << 8);

  0016c	8b 55 f0	 mov	 edx, DWORD PTR _nextChar$[ebp]
  0016f	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00172	c1 e0 08	 shl	 eax, 8
  00175	8b 4d f0	 mov	 ecx, DWORD PTR _nextChar$[ebp]
  00178	03 01		 add	 eax, DWORD PTR [ecx]
  0017a	89 45 f8	 mov	 DWORD PTR _ch$[ebp], eax

; 1245 :             nextChar += 2;

  0017d	8b 55 f0	 mov	 edx, DWORD PTR _nextChar$[ebp]
  00180	83 c2 08	 add	 edx, 8
  00183	89 55 f0	 mov	 DWORD PTR _nextChar$[ebp], edx

; 1246 : 
; 1247 :             // If we have a surrogate pair then we need to consume
; 1248 :             // a following valid LO surrogate.
; 1249 :             //
; 1250 :             if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_HIGH_END) 

  00186	81 7d f8 00 d8
	00 00		 cmp	 DWORD PTR _ch$[ebp], 55296 ; 0000d800H
  0018d	72 55		 jb	 SHORT $LN17@antlr3UTF1
  0018f	81 7d f8 ff db
	00 00		 cmp	 DWORD PTR _ch$[ebp], 56319 ; 0000dbffH
  00196	77 4c		 ja	 SHORT $LN17@antlr3UTF1

; 1251 :             {
; 1252 :                 // If the 16 bits following the high surrogate are in the source buffer...
; 1253 :                 //
; 1254 :                 if	((pANTLR3_UINT8)(nextChar) < (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  00198	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  0019b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0019e	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  001a1	03 4a 18	 add	 ecx, DWORD PTR [edx+24]
  001a4	39 4d f0	 cmp	 DWORD PTR _nextChar$[ebp], ecx
  001a7	73 3b		 jae	 SHORT $LN17@antlr3UTF1

; 1255 :                 {
; 1256 :                     // Next character is in little endian byte order
; 1257 :                     //
; 1258 :                     ch2 = (*nextChar) + (*(nextChar+1) << 8);

  001a9	8b 45 f0	 mov	 eax, DWORD PTR _nextChar$[ebp]
  001ac	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001af	c1 e1 08	 shl	 ecx, 8
  001b2	8b 55 f0	 mov	 edx, DWORD PTR _nextChar$[ebp]
  001b5	03 0a		 add	 ecx, DWORD PTR [edx]
  001b7	89 4d f4	 mov	 DWORD PTR _ch2$[ebp], ecx

; 1259 : 
; 1260 :                     // If it's a valid low surrogate, consume it
; 1261 :                     //
; 1262 :                     if (ch2 >= UNI_SUR_LOW_START && ch2 <= UNI_SUR_LOW_END) 

  001ba	81 7d f4 00 dc
	00 00		 cmp	 DWORD PTR _ch2$[ebp], 56320 ; 0000dc00H
  001c1	72 21		 jb	 SHORT $LN17@antlr3UTF1
  001c3	81 7d f4 ff df
	00 00		 cmp	 DWORD PTR _ch2$[ebp], 57343 ; 0000dfffH
  001ca	77 18		 ja	 SHORT $LN17@antlr3UTF1

; 1263 :                     {
; 1264 :                         // Construct the UTF32 code point
; 1265 :                         //
; 1266 :                         ch = ((ch - UNI_SUR_HIGH_START) << halfShift)

  001cc	8b 45 f8	 mov	 eax, DWORD PTR _ch$[ebp]
  001cf	2d 00 d8 00 00	 sub	 eax, 55296		; 0000d800H
  001d4	c1 e0 0a	 shl	 eax, 10			; 0000000aH
  001d7	8b 4d f4	 mov	 ecx, DWORD PTR _ch2$[ebp]
  001da	8d 94 08 00 24
	00 00		 lea	 edx, DWORD PTR [eax+ecx+9216]
  001e1	89 55 f8	 mov	 DWORD PTR _ch$[ebp], edx
$LN17@antlr3UTF1:

; 1267 : 			    + (ch2 - UNI_SUR_LOW_START) + halfBase;
; 1268 :                     }
; 1269 :                     // Note that we ignore a valid hi surrogate that has no lo surrogate to go with
; 1270 :                     // it.
; 1271 :                     //
; 1272 :                 } 
; 1273 :                 // Note that we ignore a valid hi surrogate that has no lo surrogate to go with
; 1274 :                 // it because the buffer ended
; 1275 :                 //
; 1276 :             }
; 1277 :         }
; 1278 :         return ch;

  001e4	8b 45 f8	 mov	 eax, DWORD PTR _ch$[ebp]
$LN1@antlr3UTF1:

; 1279 : }

  001e7	8b e5		 mov	 esp, ebp
  001e9	5d		 pop	 ebp
  001ea	c3		 ret	 0
_antlr3UTF16LALE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3inputstream.c
;	COMDAT _antlr3UTF16ConsumeLE
_TEXT	SEGMENT
_ch2$ = -12						; size = 4
_ch$ = -8						; size = 4
_input$ = -4						; size = 4
_is$ = 8						; size = 4
_antlr3UTF16ConsumeLE PROC				; COMDAT

; 1068 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1069 : 	pANTLR3_INPUT_STREAM input;
; 1070 :         UTF32   ch;
; 1071 :         UTF32   ch2;
; 1072 : 
; 1073 : 	input   = ((pANTLR3_INPUT_STREAM) (is->super));

  00006	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  00009	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000c	89 4d fc	 mov	 DWORD PTR _input$[ebp], ecx

; 1074 : 
; 1075 :         // Buffer size is always in bytes
; 1076 :         //
; 1077 : 	if	((pANTLR3_UINT8)(input->nextChar) < (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  0000f	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  00012	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  00018	03 41 18	 add	 eax, DWORD PTR [ecx+24]
  0001b	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  0001e	39 42 14	 cmp	 DWORD PTR [edx+20], eax
  00021	0f 83 d4 00 00
	00		 jae	 $LN6@antlr3UTF1

; 1078 : 	{	
; 1079 : 		// Indicate one more character in this line
; 1080 : 		//
; 1081 : 		input->charPositionInLine++;

  00027	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  0002a	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0002d	83 c1 01	 add	 ecx, 1
  00030	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  00033	89 4a 24	 mov	 DWORD PTR [edx+36], ecx

; 1082 : 
; 1083 : 		if  ((ANTLR3_UCHAR)(*((pANTLR3_UINT16)input->nextChar)) == input->newlineChar)

  00036	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  00039	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0003c	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  0003f	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  00042	3b 50 70	 cmp	 edx, DWORD PTR [eax+112]
  00045	75 28		 jne	 SHORT $LN3@antlr3UTF1

; 1084 : 		{
; 1085 : 			// Reset for start of a new line of input
; 1086 : 			//
; 1087 : 			input->line++;

  00047	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  0004a	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0004d	83 c2 01	 add	 edx, 1
  00050	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  00053	89 50 1c	 mov	 DWORD PTR [eax+28], edx

; 1088 : 			input->charPositionInLine	= 0;

  00056	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  00059	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], 0

; 1089 : 			input->currentLine		= (void *)(((pANTLR3_UINT16)input->nextChar) + 1);

  00060	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  00063	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00066	83 c0 02	 add	 eax, 2
  00069	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  0006c	89 41 20	 mov	 DWORD PTR [ecx+32], eax
$LN3@antlr3UTF1:

; 1090 : 		}
; 1091 : 
; 1092 : 		// Increment to next character position, accounting for any surrogates
; 1093 : 		//
; 1094 :                 // Next char in litle endian form
; 1095 :                 //
; 1096 :                 ch  = *((pANTLR3_UINT8)input->nextChar) + (*((pANTLR3_UINT8)input->nextChar + 1) <<8);

  0006f	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  00072	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00075	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00078	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  0007b	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0007e	0f b6 50 01	 movzx	 edx, BYTE PTR [eax+1]
  00082	c1 e2 08	 shl	 edx, 8
  00085	03 ca		 add	 ecx, edx
  00087	89 4d f8	 mov	 DWORD PTR _ch$[ebp], ecx

; 1097 : 
; 1098 :                 // We consumed one 16 bit character
; 1099 :                 //
; 1100 : 		input->nextChar = (void *)(((pANTLR3_UINT16)input->nextChar) + 1);

  0008a	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  0008d	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00090	83 c1 02	 add	 ecx, 2
  00093	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  00096	89 4a 14	 mov	 DWORD PTR [edx+20], ecx

; 1101 : 
; 1102 :                 // If we have a surrogate pair then we need to consume
; 1103 :                 // a following valid LO surrogate.
; 1104 :                 //
; 1105 :                 if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_HIGH_END) {

  00099	81 7d f8 00 d8
	00 00		 cmp	 DWORD PTR _ch$[ebp], 55296 ; 0000d800H
  000a0	72 59		 jb	 SHORT $LN6@antlr3UTF1
  000a2	81 7d f8 ff db
	00 00		 cmp	 DWORD PTR _ch$[ebp], 56319 ; 0000dbffH
  000a9	77 50		 ja	 SHORT $LN6@antlr3UTF1

; 1106 : 
; 1107 :                     // If the 16 bits following the high surrogate are in the source buffer...
; 1108 :                     //
; 1109 :                     if	((pANTLR3_UINT8)(input->nextChar) < (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  000ab	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  000ae	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000b1	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  000b4	03 4a 18	 add	 ecx, DWORD PTR [edx+24]
  000b7	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  000ba	39 48 14	 cmp	 DWORD PTR [eax+20], ecx
  000bd	73 3c		 jae	 SHORT $LN6@antlr3UTF1

; 1110 :                     {
; 1111 :                         ch2 = *((pANTLR3_UINT8)input->nextChar) + (*((pANTLR3_UINT8)input->nextChar + 1) <<8);

  000bf	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  000c2	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  000c5	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  000c8	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  000cb	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  000ce	0f b6 4a 01	 movzx	 ecx, BYTE PTR [edx+1]
  000d2	c1 e1 08	 shl	 ecx, 8
  000d5	03 c1		 add	 eax, ecx
  000d7	89 45 f4	 mov	 DWORD PTR _ch2$[ebp], eax

; 1112 : 
; 1113 :                         // If it's a valid low surrogate, consume it
; 1114 :                         //
; 1115 :                         if (ch2 >= UNI_SUR_LOW_START && ch2 <= UNI_SUR_LOW_END) 

  000da	81 7d f4 00 dc
	00 00		 cmp	 DWORD PTR _ch2$[ebp], 56320 ; 0000dc00H
  000e1	72 18		 jb	 SHORT $LN6@antlr3UTF1
  000e3	81 7d f4 ff df
	00 00		 cmp	 DWORD PTR _ch2$[ebp], 57343 ; 0000dfffH
  000ea	77 0f		 ja	 SHORT $LN6@antlr3UTF1

; 1116 :                         {
; 1117 :                             // We consumed one 16 bit character
; 1118 :                             //
; 1119 : 		            input->nextChar = (void *)(((pANTLR3_UINT16)input->nextChar) + 1);

  000ec	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  000ef	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  000f2	83 c0 02	 add	 eax, 2
  000f5	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  000f8	89 41 14	 mov	 DWORD PTR [ecx+20], eax
$LN6@antlr3UTF1:

; 1120 :                         }
; 1121 :                         // Note that we ignore a valid hi surrogate that has no lo surrogate to go with
; 1122 :                         // it.
; 1123 :                         //
; 1124 :                     } 
; 1125 :                     // Note that we ignore a valid hi surrogate that has no lo surrogate to go with
; 1126 :                     // it because the buffer ended
; 1127 :                     //
; 1128 :                 } 
; 1129 :                 // Note that we did not check for an invalid low surrogate here, or that fact that the
; 1130 :                 // lo surrogate was missing. We just picked out one 16 bit character unless the character
; 1131 :                 // was a valid hi surrogate, in whcih case we consumed two 16 bit characters.
; 1132 :                 //
; 1133 : 	}
; 1134 : }

  000fb	8b e5		 mov	 esp, ebp
  000fd	5d		 pop	 ebp
  000fe	c3		 ret	 0
_antlr3UTF16ConsumeLE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3inputstream.c
;	COMDAT _antlr3UTF16LA
_TEXT	SEGMENT
tv88 = -24						; size = 4
tv87 = -20						; size = 4
_nextChar$ = -16					; size = 4
_ch2$ = -12						; size = 4
_ch$ = -8						; size = 4
_input$ = -4						; size = 4
_is$ = 8						; size = 4
_la$ = 12						; size = 4
_antlr3UTF16LA PROC					; COMDAT

; 865  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 866  : 	pANTLR3_INPUT_STREAM input;
; 867  :         UTF32   ch;
; 868  :         UTF32   ch2;
; 869  :         UTF16   * nextChar;
; 870  : 
; 871  :         // Find the input interface and where we are currently pointing to
; 872  :         // in the input stream
; 873  :         //
; 874  : 	input       = ((pANTLR3_INPUT_STREAM) (is->super));

  00006	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  00009	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000c	89 4d fc	 mov	 DWORD PTR _input$[ebp], ecx

; 875  :         nextChar    = (UTF16*)input->nextChar;

  0000f	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  00012	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00015	89 45 f0	 mov	 DWORD PTR _nextChar$[ebp], eax

; 876  : 
; 877  :         // If a positive offset then advance forward, else retreat
; 878  :         //
; 879  :         if  (la >= 0)

  00018	83 7d 0c 00	 cmp	 DWORD PTR _la$[ebp], 0
  0001c	0f 8c 80 00 00
	00		 jl	 $LN6@antlr3UTF1
$LN2@antlr3UTF1:

; 880  :         {
; 881  :             while   (--la > 0 && (pANTLR3_UINT8)nextChar < ((pANTLR3_UINT8)input->data) + input->sizeBuf )

  00022	8b 4d 0c	 mov	 ecx, DWORD PTR _la$[ebp]
  00025	83 e9 01	 sub	 ecx, 1
  00028	89 4d 0c	 mov	 DWORD PTR _la$[ebp], ecx
  0002b	83 7d 0c 00	 cmp	 DWORD PTR _la$[ebp], 0
  0002f	7e 6c		 jle	 SHORT $LN3@antlr3UTF1
  00031	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  00034	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00037	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  0003a	03 41 18	 add	 eax, DWORD PTR [ecx+24]
  0003d	39 45 f0	 cmp	 DWORD PTR _nextChar$[ebp], eax
  00040	73 5b		 jae	 SHORT $LN3@antlr3UTF1

; 882  :             {
; 883  :                 // Advance our copy of the input pointer
; 884  :                 //
; 885  :                 // Next char in natural machine byte order
; 886  :                 //
; 887  :                 ch  = *nextChar++;

  00042	8b 55 f0	 mov	 edx, DWORD PTR _nextChar$[ebp]
  00045	0f b7 02	 movzx	 eax, WORD PTR [edx]
  00048	89 45 f8	 mov	 DWORD PTR _ch$[ebp], eax
  0004b	8b 4d f0	 mov	 ecx, DWORD PTR _nextChar$[ebp]
  0004e	83 c1 02	 add	 ecx, 2
  00051	89 4d f0	 mov	 DWORD PTR _nextChar$[ebp], ecx

; 888  : 
; 889  :                 // If we have a surrogate pair then we need to consume
; 890  :                 // a following valid LO surrogate.
; 891  :                 //
; 892  :                 if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_HIGH_END) 

  00054	81 7d f8 00 d8
	00 00		 cmp	 DWORD PTR _ch$[ebp], 55296 ; 0000d800H
  0005b	72 3e		 jb	 SHORT $LN10@antlr3UTF1
  0005d	81 7d f8 ff db
	00 00		 cmp	 DWORD PTR _ch$[ebp], 56319 ; 0000dbffH
  00064	77 35		 ja	 SHORT $LN10@antlr3UTF1

; 893  :                 {
; 894  :                     // If the 16 bits following the high surrogate are in the source buffer...
; 895  :                     //
; 896  :                     if	((pANTLR3_UINT8)(nextChar) < (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  00066	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  00069	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0006c	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  0006f	03 41 18	 add	 eax, DWORD PTR [ecx+24]
  00072	39 45 f0	 cmp	 DWORD PTR _nextChar$[ebp], eax
  00075	73 24		 jae	 SHORT $LN10@antlr3UTF1

; 897  :                     {
; 898  :                         // Next character is in natural machine byte order
; 899  :                         //
; 900  :                         ch2 = *nextChar;

  00077	8b 55 f0	 mov	 edx, DWORD PTR _nextChar$[ebp]
  0007a	0f b7 02	 movzx	 eax, WORD PTR [edx]
  0007d	89 45 f4	 mov	 DWORD PTR _ch2$[ebp], eax

; 901  : 
; 902  :                         // If it's a valid low surrogate, consume it
; 903  :                         //
; 904  :                         if (ch2 >= UNI_SUR_LOW_START && ch2 <= UNI_SUR_LOW_END) 

  00080	81 7d f4 00 dc
	00 00		 cmp	 DWORD PTR _ch2$[ebp], 56320 ; 0000dc00H
  00087	72 12		 jb	 SHORT $LN10@antlr3UTF1
  00089	81 7d f4 ff df
	00 00		 cmp	 DWORD PTR _ch2$[ebp], 57343 ; 0000dfffH
  00090	77 09		 ja	 SHORT $LN10@antlr3UTF1

; 905  :                         {
; 906  :                             // We consumed one 16 bit character
; 907  :                             //
; 908  : 		            nextChar++;

  00092	8b 4d f0	 mov	 ecx, DWORD PTR _nextChar$[ebp]
  00095	83 c1 02	 add	 ecx, 2
  00098	89 4d f0	 mov	 DWORD PTR _nextChar$[ebp], ecx
$LN10@antlr3UTF1:

; 909  :                         }
; 910  :                         // Note that we ignore a valid hi surrogate that has no lo surrogate to go with
; 911  :                         // it.
; 912  :                         //
; 913  :                     } 
; 914  :                     // Note that we ignore a valid hi surrogate that has no lo surrogate to go with
; 915  :                     // it because the buffer ended
; 916  :                     //
; 917  :                 }
; 918  :                 // Note that we did not check for an invalid low surrogate here, or that fact that the
; 919  :                 // lo surrogate was missing. We just picked out one 16 bit character unless the character
; 920  :                 // was a valid hi surrogate, in whcih case we consumed two 16 bit characters.
; 921  :                 //
; 922  :             }

  0009b	eb 85		 jmp	 SHORT $LN2@antlr3UTF1
$LN3@antlr3UTF1:

; 923  :         }

  0009d	e9 84 00 00 00	 jmp	 $LN5@antlr3UTF1
$LN6@antlr3UTF1:

; 924  :         else
; 925  :         {
; 926  :             // We need to go backwards from our input point
; 927  :             //
; 928  :             while   (la++ < 0 && (pANTLR3_UINT8)nextChar > (pANTLR3_UINT8)input->data )

  000a2	8b 55 0c	 mov	 edx, DWORD PTR _la$[ebp]
  000a5	89 55 ec	 mov	 DWORD PTR tv87[ebp], edx
  000a8	8b 45 0c	 mov	 eax, DWORD PTR _la$[ebp]
  000ab	83 c0 01	 add	 eax, 1
  000ae	89 45 0c	 mov	 DWORD PTR _la$[ebp], eax
  000b1	83 7d ec 00	 cmp	 DWORD PTR tv87[ebp], 0
  000b5	7d 09		 jge	 SHORT $LN19@antlr3UTF1
  000b7	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv88[ebp], 1
  000be	eb 07		 jmp	 SHORT $LN20@antlr3UTF1
$LN19@antlr3UTF1:
  000c0	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv88[ebp], 0
$LN20@antlr3UTF1:
  000c7	83 7d e8 00	 cmp	 DWORD PTR tv88[ebp], 0
  000cb	74 59		 je	 SHORT $LN5@antlr3UTF1
  000cd	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  000d0	8b 55 f0	 mov	 edx, DWORD PTR _nextChar$[ebp]
  000d3	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  000d6	76 4e		 jbe	 SHORT $LN5@antlr3UTF1

; 929  :             {
; 930  :                 // Get the previous 16 bit character
; 931  :                 //
; 932  :                 ch = *--nextChar;

  000d8	8b 45 f0	 mov	 eax, DWORD PTR _nextChar$[ebp]
  000db	83 e8 02	 sub	 eax, 2
  000de	89 45 f0	 mov	 DWORD PTR _nextChar$[ebp], eax
  000e1	8b 4d f0	 mov	 ecx, DWORD PTR _nextChar$[ebp]
  000e4	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  000e7	89 55 f8	 mov	 DWORD PTR _ch$[ebp], edx

; 933  : 
; 934  :                 // If we found a low surrogate then go back one more character if
; 935  :                 // the hi surrogate is there
; 936  :                 //
; 937  :                 if (ch >= UNI_SUR_LOW_START && ch <= UNI_SUR_LOW_END) 

  000ea	81 7d f8 00 dc
	00 00		 cmp	 DWORD PTR _ch$[ebp], 56320 ; 0000dc00H
  000f1	72 2e		 jb	 SHORT $LN12@antlr3UTF1
  000f3	81 7d f8 ff df
	00 00		 cmp	 DWORD PTR _ch$[ebp], 57343 ; 0000dfffH
  000fa	77 25		 ja	 SHORT $LN12@antlr3UTF1

; 938  :                 {
; 939  :                     ch2 = *(nextChar-1);

  000fc	8b 45 f0	 mov	 eax, DWORD PTR _nextChar$[ebp]
  000ff	0f b7 48 fe	 movzx	 ecx, WORD PTR [eax-2]
  00103	89 4d f4	 mov	 DWORD PTR _ch2$[ebp], ecx

; 940  :                     if (ch2 >= UNI_SUR_HIGH_START && ch2 <= UNI_SUR_HIGH_END) 

  00106	81 7d f4 00 d8
	00 00		 cmp	 DWORD PTR _ch2$[ebp], 55296 ; 0000d800H
  0010d	72 12		 jb	 SHORT $LN12@antlr3UTF1
  0010f	81 7d f4 ff db
	00 00		 cmp	 DWORD PTR _ch2$[ebp], 56319 ; 0000dbffH
  00116	77 09		 ja	 SHORT $LN12@antlr3UTF1

; 941  :                     {
; 942  :                         // Yes, there is a high surrogate to match it so decrement one more and point to that
; 943  :                         //
; 944  :                         nextChar--;

  00118	8b 55 f0	 mov	 edx, DWORD PTR _nextChar$[ebp]
  0011b	83 ea 02	 sub	 edx, 2
  0011e	89 55 f0	 mov	 DWORD PTR _nextChar$[ebp], edx
$LN12@antlr3UTF1:

; 945  :                     }
; 946  :                 }
; 947  :             }

  00121	e9 7c ff ff ff	 jmp	 $LN6@antlr3UTF1
$LN5@antlr3UTF1:

; 948  :         }
; 949  : 
; 950  :         // Our local copy of nextChar is now pointing to either the correct character or end of file
; 951  :         //
; 952  :         // Input buffer size is always in bytes
; 953  :         //
; 954  : 	if	( (pANTLR3_UINT8)nextChar >= (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  00126	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  00129	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0012c	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  0012f	03 4a 18	 add	 ecx, DWORD PTR [edx+24]
  00132	39 4d f0	 cmp	 DWORD PTR _nextChar$[ebp], ecx
  00135	72 07		 jb	 SHORT $LN13@antlr3UTF1

; 955  : 	{
; 956  : 		return	ANTLR3_CHARSTREAM_EOF;

  00137	83 c8 ff	 or	 eax, -1
  0013a	eb 6e		 jmp	 SHORT $LN1@antlr3UTF1

; 957  : 	}

  0013c	eb 69		 jmp	 SHORT $LN17@antlr3UTF1
$LN13@antlr3UTF1:

; 958  : 	else
; 959  : 	{
; 960  :             // Pick up the next 16 character (native machine byte order)
; 961  :             //
; 962  :             ch = *nextChar++;

  0013e	8b 45 f0	 mov	 eax, DWORD PTR _nextChar$[ebp]
  00141	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00144	89 4d f8	 mov	 DWORD PTR _ch$[ebp], ecx
  00147	8b 55 f0	 mov	 edx, DWORD PTR _nextChar$[ebp]
  0014a	83 c2 02	 add	 edx, 2
  0014d	89 55 f0	 mov	 DWORD PTR _nextChar$[ebp], edx

; 963  : 
; 964  :             // If we have a surrogate pair then we need to consume
; 965  :             // a following valid LO surrogate.
; 966  :             //
; 967  :             if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_HIGH_END) 

  00150	81 7d f8 00 d8
	00 00		 cmp	 DWORD PTR _ch$[ebp], 55296 ; 0000d800H
  00157	72 4e		 jb	 SHORT $LN17@antlr3UTF1
  00159	81 7d f8 ff db
	00 00		 cmp	 DWORD PTR _ch$[ebp], 56319 ; 0000dbffH
  00160	77 45		 ja	 SHORT $LN17@antlr3UTF1

; 968  :             {
; 969  :                 // If the 16 bits following the high surrogate are in the source buffer...
; 970  :                 //
; 971  :                 if	((pANTLR3_UINT8)(nextChar) < (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  00162	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  00165	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00168	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  0016b	03 4a 18	 add	 ecx, DWORD PTR [edx+24]
  0016e	39 4d f0	 cmp	 DWORD PTR _nextChar$[ebp], ecx
  00171	73 34		 jae	 SHORT $LN17@antlr3UTF1

; 972  :                 {
; 973  :                     // Next character is in natural machine byte order
; 974  :                     //
; 975  :                     ch2 = *nextChar;

  00173	8b 45 f0	 mov	 eax, DWORD PTR _nextChar$[ebp]
  00176	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00179	89 4d f4	 mov	 DWORD PTR _ch2$[ebp], ecx

; 976  : 
; 977  :                     // If it's a valid low surrogate, consume it
; 978  :                     //
; 979  :                     if (ch2 >= UNI_SUR_LOW_START && ch2 <= UNI_SUR_LOW_END) 

  0017c	81 7d f4 00 dc
	00 00		 cmp	 DWORD PTR _ch2$[ebp], 56320 ; 0000dc00H
  00183	72 22		 jb	 SHORT $LN17@antlr3UTF1
  00185	81 7d f4 ff df
	00 00		 cmp	 DWORD PTR _ch2$[ebp], 57343 ; 0000dfffH
  0018c	77 19		 ja	 SHORT $LN17@antlr3UTF1

; 980  :                     {
; 981  :                         // Construct the UTF32 code point
; 982  :                         //
; 983  :                         ch = ((ch - UNI_SUR_HIGH_START) << halfShift)

  0018e	8b 55 f8	 mov	 edx, DWORD PTR _ch$[ebp]
  00191	81 ea 00 d8 00
	00		 sub	 edx, 55296		; 0000d800H
  00197	c1 e2 0a	 shl	 edx, 10			; 0000000aH
  0019a	8b 45 f4	 mov	 eax, DWORD PTR _ch2$[ebp]
  0019d	8d 8c 02 00 24
	00 00		 lea	 ecx, DWORD PTR [edx+eax+9216]
  001a4	89 4d f8	 mov	 DWORD PTR _ch$[ebp], ecx
$LN17@antlr3UTF1:

; 984  : 			    + (ch2 - UNI_SUR_LOW_START) + halfBase;
; 985  :                     }
; 986  :                     // Note that we ignore a valid hi surrogate that has no lo surrogate to go with
; 987  :                     // it.
; 988  :                     //
; 989  :                 } 
; 990  :                 // Note that we ignore a valid hi surrogate that has no lo surrogate to go with
; 991  :                 // it because the buffer ended
; 992  :                 //
; 993  :             }
; 994  :         }
; 995  :         return ch;

  001a7	8b 45 f8	 mov	 eax, DWORD PTR _ch$[ebp]
$LN1@antlr3UTF1:

; 996  : }

  001aa	8b e5		 mov	 esp, ebp
  001ac	5d		 pop	 ebp
  001ad	c3		 ret	 0
_antlr3UTF16LA ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3inputstream.c
;	COMDAT _antlr3UTF16Consume
_TEXT	SEGMENT
_ch2$ = -12						; size = 4
_ch$ = -8						; size = 4
_input$ = -4						; size = 4
_is$ = 8						; size = 4
_antlr3UTF16Consume PROC				; COMDAT

; 786  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 787  : 	pANTLR3_INPUT_STREAM input;
; 788  :         UTF32   ch;
; 789  :         UTF32   ch2;
; 790  : 
; 791  : 	input   = ((pANTLR3_INPUT_STREAM) (is->super));

  00006	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  00009	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000c	89 4d fc	 mov	 DWORD PTR _input$[ebp], ecx

; 792  : 
; 793  :         // Buffer size is always in bytes
; 794  :         //
; 795  : 	if	((pANTLR3_UINT8)(input->nextChar) < (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  0000f	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  00012	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  00018	03 41 18	 add	 eax, DWORD PTR [ecx+24]
  0001b	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  0001e	39 42 14	 cmp	 DWORD PTR [edx+20], eax
  00021	0f 83 b6 00 00
	00		 jae	 $LN6@antlr3UTF1

; 796  : 	{	
; 797  : 		// Indicate one more character in this line
; 798  : 		//
; 799  : 		input->charPositionInLine++;

  00027	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  0002a	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0002d	83 c1 01	 add	 ecx, 1
  00030	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  00033	89 4a 24	 mov	 DWORD PTR [edx+36], ecx

; 800  : 
; 801  : 		if  ((ANTLR3_UCHAR)(*((pANTLR3_UINT16)input->nextChar)) == input->newlineChar)

  00036	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  00039	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0003c	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  0003f	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  00042	3b 50 70	 cmp	 edx, DWORD PTR [eax+112]
  00045	75 28		 jne	 SHORT $LN3@antlr3UTF1

; 802  : 		{
; 803  : 			// Reset for start of a new line of input
; 804  : 			//
; 805  : 			input->line++;

  00047	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  0004a	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0004d	83 c2 01	 add	 edx, 1
  00050	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  00053	89 50 1c	 mov	 DWORD PTR [eax+28], edx

; 806  : 			input->charPositionInLine	= 0;

  00056	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  00059	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], 0

; 807  : 			input->currentLine		= (void *)(((pANTLR3_UINT16)input->nextChar) + 1);

  00060	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  00063	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00066	83 c0 02	 add	 eax, 2
  00069	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  0006c	89 41 20	 mov	 DWORD PTR [ecx+32], eax
$LN3@antlr3UTF1:

; 808  : 		}
; 809  : 
; 810  : 		// Increment to next character position, accounting for any surrogates
; 811  : 		//
; 812  :                 // Next char in natural machine byte order
; 813  :                 //
; 814  :                 ch  = *((UTF16*)input->nextChar);

  0006f	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  00072	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00075	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00078	89 4d f8	 mov	 DWORD PTR _ch$[ebp], ecx

; 815  : 
; 816  :                 // We consumed one 16 bit character
; 817  :                 //
; 818  : 		input->nextChar = (void *)(((pANTLR3_UINT16)input->nextChar) + 1);

  0007b	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  0007e	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00081	83 c0 02	 add	 eax, 2
  00084	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  00087	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 819  : 
; 820  :                 // If we have a surrogate pair then we need to consume
; 821  :                 // a following valid LO surrogate.
; 822  :                 //
; 823  :                 if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_HIGH_END) {

  0008a	81 7d f8 00 d8
	00 00		 cmp	 DWORD PTR _ch$[ebp], 55296 ; 0000d800H
  00091	72 4a		 jb	 SHORT $LN6@antlr3UTF1
  00093	81 7d f8 ff db
	00 00		 cmp	 DWORD PTR _ch$[ebp], 56319 ; 0000dbffH
  0009a	77 41		 ja	 SHORT $LN6@antlr3UTF1

; 824  : 
; 825  :                     // If the 16 bits following the high surrogate are in the source buffer...
; 826  :                     //
; 827  :                     if	((pANTLR3_UINT8)(input->nextChar) < (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  0009c	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  0009f	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000a2	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  000a5	03 41 18	 add	 eax, DWORD PTR [ecx+24]
  000a8	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  000ab	39 42 14	 cmp	 DWORD PTR [edx+20], eax
  000ae	73 2d		 jae	 SHORT $LN6@antlr3UTF1

; 828  :                     {
; 829  :                         // Next character is in natural machine byte order
; 830  :                         //
; 831  :                         ch2 = *((UTF16*)input->nextChar);

  000b0	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  000b3	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000b6	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  000b9	89 55 f4	 mov	 DWORD PTR _ch2$[ebp], edx

; 832  : 
; 833  :                         // If it's a valid low surrogate, consume it
; 834  :                         //
; 835  :                         if (ch2 >= UNI_SUR_LOW_START && ch2 <= UNI_SUR_LOW_END) 

  000bc	81 7d f4 00 dc
	00 00		 cmp	 DWORD PTR _ch2$[ebp], 56320 ; 0000dc00H
  000c3	72 18		 jb	 SHORT $LN6@antlr3UTF1
  000c5	81 7d f4 ff df
	00 00		 cmp	 DWORD PTR _ch2$[ebp], 57343 ; 0000dfffH
  000cc	77 0f		 ja	 SHORT $LN6@antlr3UTF1

; 836  :                         {
; 837  :                             // We consumed one 16 bit character
; 838  :                             //
; 839  : 		            input->nextChar = (void *)(((pANTLR3_UINT16)input->nextChar) + 1);

  000ce	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  000d1	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000d4	83 c1 02	 add	 ecx, 2
  000d7	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  000da	89 4a 14	 mov	 DWORD PTR [edx+20], ecx
$LN6@antlr3UTF1:

; 840  :                         }
; 841  :                         // Note that we ignore a valid hi surrogate that has no lo surrogate to go with
; 842  :                         // it.
; 843  :                         //
; 844  :                     } 
; 845  :                     // Note that we ignore a valid hi surrogate that has no lo surrogate to go with
; 846  :                     // it because the buffer ended
; 847  :                     //
; 848  :                 } 
; 849  :                 // Note that we did not check for an invalid low surrogate here, or that fact that the
; 850  :                 // lo surrogate was missing. We just picked out one 16 bit character unless the character
; 851  :                 // was a valid hi surrogate, in whcih case we consumed two 16 bit characters.
; 852  :                 //
; 853  : 	}
; 854  : }

  000dd	8b e5		 mov	 esp, ebp
  000df	5d		 pop	 ebp
  000e0	c3		 ret	 0
_antlr3UTF16Consume ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3inputstream.c
;	COMDAT _antlr38BitSetUcaseLA
_TEXT	SEGMENT
_input$ = 8						; size = 4
_flag$ = 12						; size = 1
_antlr38BitSetUcaseLA PROC				; COMDAT

; 240  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 241  : 	if	(flag)

  00003	0f b6 45 0c	 movzx	 eax, BYTE PTR _flag$[ebp]
  00007	85 c0		 test	 eax, eax
  00009	74 0e		 je	 SHORT $LN2@antlr38Bit

; 242  : 	{
; 243  : 		// Return the upper case version of the characters
; 244  : 		//
; 245  : 		input->istream->_LA		    =  antlr38BitLA_ucase;

  0000b	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  0000e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00010	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET _antlr38BitLA_ucase

; 246  : 	}

  00017	eb 0c		 jmp	 SHORT $LN3@antlr38Bit
$LN2@antlr38Bit:

; 247  : 	else
; 248  : 	{
; 249  : 		// Return the raw characters as they are in the buffer
; 250  : 		//
; 251  : 		input->istream->_LA		    =  antlr38BitLA;

  00019	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  0001c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001e	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET _antlr38BitLA
$LN3@antlr38Bit:

; 252  : 	}
; 253  : }

  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
_antlr38BitSetUcaseLA ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3inputstream.c
;	COMDAT _antlr38BitSetNewLineChar
_TEXT	SEGMENT
_input$ = 8						; size = 4
_newlineChar$ = 12					; size = 4
_antlr38BitSetNewLineChar PROC				; COMDAT

; 693  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 694  :     input->newlineChar	= newlineChar;

  00003	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _newlineChar$[ebp]
  00009	89 48 70	 mov	 DWORD PTR [eax+112], ecx

; 695  : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
_antlr38BitSetNewLineChar ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3inputstream.c
;	COMDAT _antlr38BitSetCharPosition
_TEXT	SEGMENT
_input$ = 8						; size = 4
_position$ = 12						; size = 4
_antlr38BitSetCharPosition PROC				; COMDAT

; 677  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 678  :     input->charPositionInLine = position;

  00003	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _position$[ebp]
  00009	89 48 24	 mov	 DWORD PTR [eax+36], ecx

; 679  : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
_antlr38BitSetCharPosition ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3inputstream.c
;	COMDAT _antlr38BitSetLine
_TEXT	SEGMENT
_input$ = 8						; size = 4
_line$ = 12						; size = 4
_antlr38BitSetLine PROC					; COMDAT

; 662  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 663  :     input->line	= line;

  00003	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _line$[ebp]
  00009	89 48 1c	 mov	 DWORD PTR [eax+28], ecx

; 664  : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
_antlr38BitSetLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3inputstream.c
;	COMDAT _antlr38BitGetCharPosition
_TEXT	SEGMENT
_input$ = 8						; size = 4
_antlr38BitGetCharPosition PROC				; COMDAT

; 645  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 646  :     return  input->charPositionInLine;

  00003	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  00006	8b 40 24	 mov	 eax, DWORD PTR [eax+36]

; 647  : }

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
_antlr38BitGetCharPosition ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3inputstream.c
;	COMDAT _antlr38BitGetLineBuf
_TEXT	SEGMENT
_input$ = 8						; size = 4
_antlr38BitGetLineBuf PROC				; COMDAT

; 634  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 635  :     return  input->currentLine;

  00003	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  00006	8b 40 20	 mov	 eax, DWORD PTR [eax+32]

; 636  : }

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
_antlr38BitGetLineBuf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3inputstream.c
;	COMDAT _antlr38BitGetLine
_TEXT	SEGMENT
_input$ = 8						; size = 4
_antlr38BitGetLine PROC					; COMDAT

; 622  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 623  :     return  input->line;

  00003	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  00006	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]

; 624  : }

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
_antlr38BitGetLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3inputstream.c
;	COMDAT _antlr38BitSubstr
_TEXT	SEGMENT
_input$ = 8						; size = 4
_start$ = 12						; size = 4
_stop$ = 16						; size = 4
_antlr38BitSubstr PROC					; COMDAT

; 611  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 612  : 	return  input->strFactory->newPtr(input->strFactory, (pANTLR3_UINT8)start, (ANTLR3_UINT32)(stop - start + 1));

  00004	8b 45 10	 mov	 eax, DWORD PTR _stop$[ebp]
  00007	2b 45 0c	 sub	 eax, DWORD PTR _start$[ebp]
  0000a	83 c0 01	 add	 eax, 1
  0000d	8b f4		 mov	 esi, esp
  0000f	50		 push	 eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR _start$[ebp]
  00013	51		 push	 ecx
  00014	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  00017	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0001a	50		 push	 eax
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  0001e	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00021	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00024	ff d0		 call	 eax
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH
  00029	3b f4		 cmp	 esi, esp
  0002b	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 613  : }

  00030	5e		 pop	 esi
  00031	3b ec		 cmp	 ebp, esp
  00033	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
_antlr38BitSubstr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3inputstream.c
;	COMDAT _antlr38BitSize
_TEXT	SEGMENT
_input$ = 8						; size = 4
_antlr38BitSize PROC					; COMDAT

; 434  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 435  :     return  input->sizeBuf;

  00003	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  00006	8b 40 18	 mov	 eax, DWORD PTR [eax+24]

; 436  : }

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
_antlr38BitSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3inputstream.c
;	COMDAT _antlr38BitLT
_TEXT	SEGMENT
_input$ = 8						; size = 4
_lt$ = 12						; size = 4
_antlr38BitLT PROC					; COMDAT

; 403  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 404  :     /* Casting is horrible but it means no warnings and LT should never be called
; 405  :      * on a character stream anyway I think. If it is then, the void * will need to be 
; 406  :      * cast back in a similar manner. Yuck! But this means that LT for Token streams and
; 407  :      * tree streams is correct.
; 408  :      */
; 409  :     return (ANTLR3_FUNC_PTR(input->istream->_LA(input->istream, lt)));

  00004	8b f4		 mov	 esi, esp
  00006	8b 45 0c	 mov	 eax, DWORD PTR _lt$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	52		 push	 edx
  00010	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  00013	8b 08		 mov	 ecx, DWORD PTR [eax]
  00015	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00018	ff d2		 call	 edx
  0001a	83 c4 08	 add	 esp, 8
  0001d	3b f4		 cmp	 esi, esp
  0001f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 410  : }

  00024	5e		 pop	 esi
  00025	3b ec		 cmp	 ebp, esp
  00027	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
_antlr38BitLT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3inputstream.c
;	COMDAT _antlr38BitReuse
_TEXT	SEGMENT
tv88 = -8						; size = 4
tv76 = -4						; size = 4
_input$ = 8						; size = 4
_inString$ = 12						; size = 4
_size$ = 16						; size = 4
_name$ = 20						; size = 4
_antlr38BitReuse PROC					; COMDAT

; 289  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 290  :     input->isAllocated	= ANTLR3_FALSE;

  00015	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  00018	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 291  :     input->data		= inString;

  0001f	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  00022	8b 55 0c	 mov	 edx, DWORD PTR _inString$[ebp]
  00025	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 292  :     input->sizeBuf	= size;

  00028	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  0002b	8b 4d 10	 mov	 ecx, DWORD PTR _size$[ebp]
  0002e	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 293  :     
; 294  :     // Now we can set up the file name. As we are reusing the stream, there may already
; 295  :     // be a string that we can reuse for holding the filename.
; 296  :     //
; 297  : 	if	(input->istream->streamName == NULL) 

  00031	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  00034	8b 02		 mov	 eax, DWORD PTR [edx]
  00036	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0003a	75 4f		 jne	 SHORT $LN2@antlr38Bit

; 298  : 	{
; 299  : 		input->istream->streamName	= input->strFactory->newStr(input->strFactory, name == NULL ? (pANTLR3_UINT8)"-memory-" : name);

  0003c	83 7d 14 00	 cmp	 DWORD PTR _name$[ebp], 0
  00040	75 09		 jne	 SHORT $LN5@antlr38Bit
  00042	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], OFFSET ??_C@_08ONBMMFLC@?9memory?9@
  00049	eb 06		 jmp	 SHORT $LN6@antlr38Bit
$LN5@antlr38Bit:
  0004b	8b 4d 14	 mov	 ecx, DWORD PTR _name$[ebp]
  0004e	89 4d fc	 mov	 DWORD PTR tv76[ebp], ecx
$LN6@antlr38Bit:
  00051	8b f4		 mov	 esi, esp
  00053	8b 55 fc	 mov	 edx, DWORD PTR tv76[ebp]
  00056	52		 push	 edx
  00057	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  0005a	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0005d	51		 push	 ecx
  0005e	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  00061	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00064	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00067	ff d1		 call	 ecx
  00069	83 c4 08	 add	 esp, 8
  0006c	3b f4		 cmp	 esi, esp
  0006e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00073	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  00076	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00078	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 300  : 		input->fileName		= input->istream->streamName;

  0007b	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  0007e	8b 02		 mov	 eax, DWORD PTR [edx]
  00080	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  00083	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00086	89 51 30	 mov	 DWORD PTR [ecx+48], edx

; 301  : 	}

  00089	eb 3c		 jmp	 SHORT $LN3@antlr38Bit
$LN2@antlr38Bit:

; 302  : 	else
; 303  : 	{
; 304  : 		input->istream->streamName->set(input->istream->streamName,  (name == NULL ? (const char *)"-memory-" : (const char *)name));

  0008b	83 7d 14 00	 cmp	 DWORD PTR _name$[ebp], 0
  0008f	75 09		 jne	 SHORT $LN7@antlr38Bit
  00091	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv88[ebp], OFFSET ??_C@_08ONBMMFLC@?9memory?9@
  00098	eb 06		 jmp	 SHORT $LN8@antlr38Bit
$LN7@antlr38Bit:
  0009a	8b 45 14	 mov	 eax, DWORD PTR _name$[ebp]
  0009d	89 45 f8	 mov	 DWORD PTR tv88[ebp], eax
$LN8@antlr38Bit:
  000a0	8b f4		 mov	 esi, esp
  000a2	8b 4d f8	 mov	 ecx, DWORD PTR tv88[ebp]
  000a5	51		 push	 ecx
  000a6	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  000a9	8b 02		 mov	 eax, DWORD PTR [edx]
  000ab	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ae	51		 push	 ecx
  000af	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  000b2	8b 02		 mov	 eax, DWORD PTR [edx]
  000b4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000b7	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  000ba	ff d2		 call	 edx
  000bc	83 c4 08	 add	 esp, 8
  000bf	3b f4		 cmp	 esi, esp
  000c1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c6	90		 npad	 1
$LN3@antlr38Bit:

; 305  : 	}
; 306  : 
; 307  :     input->reset(input);

  000c7	8b f4		 mov	 esi, esp
  000c9	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  000cc	50		 push	 eax
  000cd	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  000d0	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  000d3	ff d2		 call	 edx
  000d5	83 c4 04	 add	 esp, 4
  000d8	3b f4		 cmp	 esi, esp
  000da	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000df	90		 npad	 1

; 308  : }

  000e0	5e		 pop	 esi
  000e1	83 c4 08	 add	 esp, 8
  000e4	3b ec		 cmp	 ebp, esp
  000e6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000eb	8b e5		 mov	 esp, ebp
  000ed	5d		 pop	 ebp
  000ee	c3		 ret	 0
_antlr38BitReuse ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3inputstream.c
;	COMDAT _antlr3InputReset
_TEXT	SEGMENT
_input$ = 8						; size = 4
_antlr3InputReset PROC					; COMDAT

; 262  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 263  : 
; 264  :     input->nextChar		= input->data;	/* Input at first character */

  00004	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  0000a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0000d	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 265  :     input->line			= 1;		/* starts at line 1	    */

  00010	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  00013	c7 40 1c 01 00
	00 00		 mov	 DWORD PTR [eax+28], 1

; 266  :     input->charPositionInLine	= 0;

  0001a	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  0001d	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], 0

; 267  :     input->currentLine		= input->data;

  00024	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  00027	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  0002a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0002d	89 4a 20	 mov	 DWORD PTR [edx+32], ecx

; 268  :     input->markDepth		= 0;		/* Reset markers	    */

  00030	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  00033	c7 42 28 00 00
	00 00		 mov	 DWORD PTR [edx+40], 0

; 269  :     
; 270  :     /* Clear out up the markers table if it is there
; 271  :      */
; 272  :     if	(input->markers != NULL)

  0003a	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  0003d	83 78 2c 00	 cmp	 DWORD PTR [eax+44], 0
  00041	74 24		 je	 SHORT $LN2@antlr3Inpu

; 273  :     {
; 274  :         input->markers->clear(input->markers);

  00043	8b f4		 mov	 esi, esp
  00045	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  00048	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  0004b	52		 push	 edx
  0004c	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  0004f	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  00052	8b 91 a0 00 00
	00		 mov	 edx, DWORD PTR [ecx+160]
  00058	ff d2		 call	 edx
  0005a	83 c4 04	 add	 esp, 4
  0005d	3b f4		 cmp	 esi, esp
  0005f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00064	90		 npad	 1

; 275  :     }

  00065	eb 10		 jmp	 SHORT $LN3@antlr3Inpu
$LN2@antlr3Inpu:

; 276  :     else
; 277  :     {
; 278  :         /* Install a new markers table
; 279  :          */
; 280  :         input->markers  = antlr3VectorNew(0);

  00067	6a 00		 push	 0
  00069	e8 00 00 00 00	 call	 _antlr3VectorNew
  0006e	83 c4 04	 add	 esp, 4
  00071	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  00074	89 41 2c	 mov	 DWORD PTR [ecx+44], eax
$LN3@antlr3Inpu:

; 281  :     }
; 282  : }

  00077	5e		 pop	 esi
  00078	3b ec		 cmp	 ebp, esp
  0007a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007f	5d		 pop	 ebp
  00080	c3		 ret	 0
_antlr3InputReset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3inputstream.c
;	COMDAT _antlr3InputClose
_TEXT	SEGMENT
_input$ = 8						; size = 4
_antlr3InputClose PROC					; COMDAT

; 204  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 205  :     // Close any markers in the input stream
; 206  :     //
; 207  :     if	(input->markers != NULL)

  00004	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  00007	83 78 2c 00	 cmp	 DWORD PTR [eax+44], 0
  0000b	74 2b		 je	 SHORT $LN2@antlr3Inpu

; 208  :     {
; 209  : 		input->markers->free(input->markers);

  0000d	8b f4		 mov	 esi, esp
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  00012	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00015	52		 push	 edx
  00016	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  00019	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  0001c	8b 91 90 00 00
	00		 mov	 edx, DWORD PTR [ecx+144]
  00022	ff d2		 call	 edx
  00024	83 c4 04	 add	 esp, 4
  00027	3b f4		 cmp	 esi, esp
  00029	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 210  : 		input->markers = NULL;

  0002e	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  00031	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], 0
$LN2@antlr3Inpu:

; 211  :     }
; 212  : 
; 213  :     // Close the string factory
; 214  :     //
; 215  :     if	(input->strFactory != NULL)

  00038	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  0003b	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  0003f	74 1f		 je	 SHORT $LN3@antlr3Inpu

; 216  :     {
; 217  : 		input->strFactory->close(input->strFactory);

  00041	8b f4		 mov	 esi, esp
  00043	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  00046	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00049	50		 push	 eax
  0004a	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  0004d	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00050	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  00053	ff d0		 call	 eax
  00055	83 c4 04	 add	 esp, 4
  00058	3b f4		 cmp	 esi, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005f	90		 npad	 1
$LN3@antlr3Inpu:

; 218  :     }
; 219  : 
; 220  :     // Free the input stream buffer if we allocated it
; 221  :     //
; 222  :     if	(input->isAllocated && input->data != NULL)

  00060	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  00063	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  00067	74 2c		 je	 SHORT $LN4@antlr3Inpu
  00069	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  0006c	83 7a 08 00	 cmp	 DWORD PTR [edx+8], 0
  00070	74 23		 je	 SHORT $LN4@antlr3Inpu

; 223  :     {
; 224  : 		ANTLR3_FREE(input->data);

  00072	8b f4		 mov	 esi, esp
  00074	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  00077	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0007a	51		 push	 ecx
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00081	83 c4 04	 add	 esp, 4
  00084	3b f4		 cmp	 esi, esp
  00086	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 225  : 		input->data = NULL;

  0008b	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  0008e	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0
$LN4@antlr3Inpu:

; 226  :     }
; 227  :     
; 228  :     input->istream->free(input->istream);

  00095	8b f4		 mov	 esi, esp
  00097	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  0009a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009c	51		 push	 ecx
  0009d	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  000a0	8b 02		 mov	 eax, DWORD PTR [edx]
  000a2	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  000a5	ff d1		 call	 ecx
  000a7	83 c4 04	 add	 esp, 4
  000aa	3b f4		 cmp	 esi, esp
  000ac	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 229  : 
; 230  :     // Finally, free the space for the structure itself
; 231  :     //
; 232  :     ANTLR3_FREE(input);

  000b1	8b f4		 mov	 esi, esp
  000b3	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  000b6	52		 push	 edx
  000b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  000bd	83 c4 04	 add	 esp, 4
  000c0	3b f4		 cmp	 esi, esp
  000c2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c7	90		 npad	 1

; 233  : 
; 234  :     // Done
; 235  :     //
; 236  : }

  000c8	5e		 pop	 esi
  000c9	3b ec		 cmp	 ebp, esp
  000cb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d0	5d		 pop	 ebp
  000d1	c3		 ret	 0
_antlr3InputClose ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3inputstream.c
;	COMDAT _antlr38BitGetSourceName
_TEXT	SEGMENT
_is$ = 8						; size = 4
_antlr38BitGetSourceName PROC				; COMDAT

; 194  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 195  : 	return	is->streamName;

  00003	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  00006	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 196  : }

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
_antlr38BitGetSourceName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3inputstream.c
;	COMDAT _antlr38BitSeek
_TEXT	SEGMENT
tv71 = -12						; size = 4
_input$ = -8						; size = 4
_count$ = -4						; size = 4
_is$ = 8						; size = 4
_seekPoint$ = 12					; size = 4
_antlr38BitSeek PROC					; COMDAT

; 578  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000e	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00015	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 579  : 	ANTLR3_INT32   count;
; 580  : 	pANTLR3_INPUT_STREAM input;
; 581  : 
; 582  : 	input   = (pANTLR3_INPUT_STREAM)ANTLR3_FUNC_PTR(((pANTLR3_INPUT_STREAM) is->super));

  0001c	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  0001f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00022	89 4d f8	 mov	 DWORD PTR _input$[ebp], ecx

; 583  : 
; 584  : 	/* If the requested seek point is less than the current
; 585  : 	* input point, then we assume that we are resetting from a mark
; 586  : 	* and do not need to scan, but can just set to there.
; 587  : 	*/
; 588  : 	if	(seekPoint <= (ANTLR3_MARKER)(input->nextChar))

  00025	8b 55 f8	 mov	 edx, DWORD PTR _input$[ebp]
  00028	8b 45 0c	 mov	 eax, DWORD PTR _seekPoint$[ebp]
  0002b	3b 42 14	 cmp	 eax, DWORD PTR [edx+20]
  0002e	7f 0b		 jg	 SHORT $LN4@antlr38Bit

; 589  : 	{
; 590  : 		input->nextChar	= ((pANTLR3_UINT8) seekPoint);

  00030	8b 4d f8	 mov	 ecx, DWORD PTR _input$[ebp]
  00033	8b 55 0c	 mov	 edx, DWORD PTR _seekPoint$[ebp]
  00036	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 591  : 	}

  00039	eb 3c		 jmp	 SHORT $LN3@antlr38Bit
$LN4@antlr38Bit:

; 592  : 	else
; 593  : 	{
; 594  : 		count	= (ANTLR3_UINT32)(seekPoint - (ANTLR3_MARKER)(input->nextChar));

  0003b	8b 45 f8	 mov	 eax, DWORD PTR _input$[ebp]
  0003e	8b 4d 0c	 mov	 ecx, DWORD PTR _seekPoint$[ebp]
  00041	2b 48 14	 sub	 ecx, DWORD PTR [eax+20]
  00044	89 4d fc	 mov	 DWORD PTR _count$[ebp], ecx
$LN2@antlr38Bit:

; 595  : 
; 596  : 		while (count--)

  00047	8b 55 fc	 mov	 edx, DWORD PTR _count$[ebp]
  0004a	89 55 f4	 mov	 DWORD PTR tv71[ebp], edx
  0004d	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00050	83 e8 01	 sub	 eax, 1
  00053	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax
  00056	83 7d f4 00	 cmp	 DWORD PTR tv71[ebp], 0
  0005a	74 1b		 je	 SHORT $LN3@antlr38Bit

; 597  : 		{
; 598  : 			is->consume(is);

  0005c	8b f4		 mov	 esi, esp
  0005e	8b 4d 08	 mov	 ecx, DWORD PTR _is$[ebp]
  00061	51		 push	 ecx
  00062	8b 55 08	 mov	 edx, DWORD PTR _is$[ebp]
  00065	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00068	ff d0		 call	 eax
  0006a	83 c4 04	 add	 esp, 4
  0006d	3b f4		 cmp	 esi, esp
  0006f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00074	90		 npad	 1

; 599  : 		}

  00075	eb d0		 jmp	 SHORT $LN2@antlr38Bit
$LN3@antlr38Bit:

; 600  : 	}
; 601  : }

  00077	5e		 pop	 esi
  00078	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007b	3b ec		 cmp	 ebp, esp
  0007d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
_antlr38BitSeek ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3inputstream.c
;	COMDAT _antlr38BitRelease
_TEXT	SEGMENT
_input$ = -4						; size = 4
_is$ = 8						; size = 4
_mark$ = 12						; size = 4
_antlr38BitRelease PROC					; COMDAT

; 558  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 559  :     pANTLR3_INPUT_STREAM input;
; 560  : 
; 561  :     input   = ((pANTLR3_INPUT_STREAM) (is->super));

  00004	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  00007	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000a	89 4d fc	 mov	 DWORD PTR _input$[ebp], ecx

; 562  : 
; 563  :     /* We don't do much here in fact as we never free any higher marks in
; 564  :      * the hashtable as we just resuse any memory allocated for them.
; 565  :      */
; 566  :     input->markDepth	= (ANTLR3_UINT32)(mark - 1);

  0000d	8b 55 0c	 mov	 edx, DWORD PTR _mark$[ebp]
  00010	83 ea 01	 sub	 edx, 1
  00013	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  00016	89 50 28	 mov	 DWORD PTR [eax+40], edx

; 567  : }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
_antlr38BitRelease ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3inputstream.c
;	COMDAT _antlr38BitRewindLast
_TEXT	SEGMENT
_is$ = 8						; size = 4
_antlr38BitRewindLast PROC				; COMDAT

; 505  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 506  :     is->rewind(is, is->lastMarker);

  00004	8b f4		 mov	 esi, esp
  00006	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  00009	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0000c	51		 push	 ecx
  0000d	8b 55 08	 mov	 edx, DWORD PTR _is$[ebp]
  00010	52		 push	 edx
  00011	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  00014	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00017	ff d1		 call	 ecx
  00019	83 c4 08	 add	 esp, 8
  0001c	3b f4		 cmp	 esi, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	90		 npad	 1

; 507  : }

  00024	5e		 pop	 esi
  00025	3b ec		 cmp	 ebp, esp
  00027	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
_antlr38BitRewindLast ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3inputstream.c
;	COMDAT _antlr38BitRewind
_TEXT	SEGMENT
_input$ = -8						; size = 4
_state$ = -4						; size = 4
_is$ = 8						; size = 4
_mark$ = 12						; size = 4
_antlr38BitRewind PROC					; COMDAT

; 518  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 519  :     pANTLR3_LEX_STATE	state;
; 520  :     pANTLR3_INPUT_STREAM input;
; 521  : 
; 522  :     input   = ((pANTLR3_INPUT_STREAM) is->super);

  00015	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  00018	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0001b	89 4d f8	 mov	 DWORD PTR _input$[ebp], ecx

; 523  : 
; 524  :     /* Perform any clean up of the marks
; 525  :      */
; 526  :     input->istream->release(input->istream, mark);

  0001e	8b f4		 mov	 esi, esp
  00020	8b 55 0c	 mov	 edx, DWORD PTR _mark$[ebp]
  00023	52		 push	 edx
  00024	8b 45 f8	 mov	 eax, DWORD PTR _input$[ebp]
  00027	8b 08		 mov	 ecx, DWORD PTR [eax]
  00029	51		 push	 ecx
  0002a	8b 55 f8	 mov	 edx, DWORD PTR _input$[ebp]
  0002d	8b 02		 mov	 eax, DWORD PTR [edx]
  0002f	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  00032	ff d1		 call	 ecx
  00034	83 c4 08	 add	 esp, 8
  00037	3b f4		 cmp	 esi, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 527  : 
; 528  :     /* Find the supplied mark state 
; 529  :      */
; 530  :     state   = (pANTLR3_LEX_STATE)input->markers->get(input->markers, (ANTLR3_UINT32)(mark - 1));

  0003e	8b 55 0c	 mov	 edx, DWORD PTR _mark$[ebp]
  00041	83 ea 01	 sub	 edx, 1
  00044	8b f4		 mov	 esi, esp
  00046	52		 push	 edx
  00047	8b 45 f8	 mov	 eax, DWORD PTR _input$[ebp]
  0004a	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  0004d	51		 push	 ecx
  0004e	8b 55 f8	 mov	 edx, DWORD PTR _input$[ebp]
  00051	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  00054	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [eax+152]
  0005a	ff d1		 call	 ecx
  0005c	83 c4 08	 add	 esp, 8
  0005f	3b f4		 cmp	 esi, esp
  00061	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00066	89 45 fc	 mov	 DWORD PTR _state$[ebp], eax

; 531  : 	if (state == NULL) { return; }

  00069	83 7d fc 00	 cmp	 DWORD PTR _state$[ebp], 0
  0006d	75 02		 jne	 SHORT $LN2@antlr38Bit
  0006f	eb 41		 jmp	 SHORT $LN1@antlr38Bit
$LN2@antlr38Bit:

; 532  : 
; 533  :     /* Seek input pointer to the requested point (note we supply the void *pointer
; 534  :      * to whatever is implementing the int stream to seek).
; 535  :      */
; 536  :     antlr38BitSeek(is, (ANTLR3_MARKER)(state->nextChar));

  00071	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00074	8b 02		 mov	 eax, DWORD PTR [edx]
  00076	50		 push	 eax
  00077	8b 4d 08	 mov	 ecx, DWORD PTR _is$[ebp]
  0007a	51		 push	 ecx
  0007b	e8 00 00 00 00	 call	 _antlr38BitSeek
  00080	83 c4 08	 add	 esp, 8

; 537  : 
; 538  :     /* Reset to the reset of the information in the mark
; 539  :      */
; 540  :     input->charPositionInLine	= state->charPositionInLine;

  00083	8b 55 f8	 mov	 edx, DWORD PTR _input$[ebp]
  00086	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00089	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0008c	89 4a 24	 mov	 DWORD PTR [edx+36], ecx

; 541  :     input->currentLine		= state->currentLine;

  0008f	8b 55 f8	 mov	 edx, DWORD PTR _input$[ebp]
  00092	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00095	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00098	89 4a 20	 mov	 DWORD PTR [edx+32], ecx

; 542  :     input->line			= state->line;

  0009b	8b 55 f8	 mov	 edx, DWORD PTR _input$[ebp]
  0009e	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  000a1	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000a4	89 4a 1c	 mov	 DWORD PTR [edx+28], ecx

; 543  :     input->nextChar		= state->nextChar;

  000a7	8b 55 f8	 mov	 edx, DWORD PTR _input$[ebp]
  000aa	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  000ad	8b 08		 mov	 ecx, DWORD PTR [eax]
  000af	89 4a 14	 mov	 DWORD PTR [edx+20], ecx
$LN1@antlr38Bit:

; 544  : 
; 545  :     /* And we are done
; 546  :      */
; 547  : }

  000b2	5e		 pop	 esi
  000b3	83 c4 08	 add	 esp, 8
  000b6	3b ec		 cmp	 ebp, esp
  000b8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bd	8b e5		 mov	 esp, ebp
  000bf	5d		 pop	 ebp
  000c0	c3		 ret	 0
_antlr38BitRewind ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3inputstream.c
;	COMDAT _antlr38BitMark
_TEXT	SEGMENT
_input$ = -8						; size = 4
_state$ = -4						; size = 4
_is$ = 8						; size = 4
_antlr38BitMark PROC					; COMDAT

; 446  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 447  :     pANTLR3_LEX_STATE	    state;
; 448  :     pANTLR3_INPUT_STREAM    input;
; 449  : 
; 450  :     input   = ((pANTLR3_INPUT_STREAM) (is->super));

  00015	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  00018	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0001b	89 4d f8	 mov	 DWORD PTR _input$[ebp], ecx

; 451  : 
; 452  :     /* New mark point 
; 453  :      */
; 454  :     ++input->markDepth;

  0001e	8b 55 f8	 mov	 edx, DWORD PTR _input$[ebp]
  00021	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  00024	83 c0 01	 add	 eax, 1
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _input$[ebp]
  0002a	89 41 28	 mov	 DWORD PTR [ecx+40], eax

; 455  : 
; 456  :     /* See if we are revisiting a mark as we can just reuse the vector
; 457  :      * entry if we are, otherwise, we need a new one
; 458  :      */
; 459  :     if	(input->markDepth > input->markers->count)

  0002d	8b 55 f8	 mov	 edx, DWORD PTR _input$[ebp]
  00030	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  00033	8b 4d f8	 mov	 ecx, DWORD PTR _input$[ebp]
  00036	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00039	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  0003c	76 61		 jbe	 SHORT $LN2@antlr38Bit

; 460  :     {	
; 461  : 		state = (pANTLR3_LEX_STATE)ANTLR3_MALLOC(sizeof(ANTLR3_LEX_STATE));

  0003e	8b f4		 mov	 esi, esp
  00040	6a 10		 push	 16			; 00000010H
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00048	83 c4 04	 add	 esp, 4
  0004b	3b f4		 cmp	 esi, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	89 45 fc	 mov	 DWORD PTR _state$[ebp], eax

; 462  : 		if (state == NULL)

  00055	83 7d fc 00	 cmp	 DWORD PTR _state$[ebp], 0
  00059	75 16		 jne	 SHORT $LN4@antlr38Bit

; 463  : 		{
; 464  : 			// malloc failed
; 465  : 			--input->markDepth;

  0005b	8b 45 f8	 mov	 eax, DWORD PTR _input$[ebp]
  0005e	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00061	83 e9 01	 sub	 ecx, 1
  00064	8b 55 f8	 mov	 edx, DWORD PTR _input$[ebp]
  00067	89 4a 28	 mov	 DWORD PTR [edx+40], ecx

; 466  : 			return 0;

  0006a	33 c0		 xor	 eax, eax
  0006c	e9 9d 00 00 00	 jmp	 $LN1@antlr38Bit
$LN4@antlr38Bit:

; 467  : 		}
; 468  : 
; 469  : 		/* Add it to the table
; 470  : 		 */
; 471  : 		input->markers->add(input->markers, state, ANTLR3_FREE_FUNC);	/* No special structure, just free() on delete */

  00071	8b f4		 mov	 esi, esp
  00073	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__free
  00078	50		 push	 eax
  00079	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0007c	51		 push	 ecx
  0007d	8b 55 f8	 mov	 edx, DWORD PTR _input$[ebp]
  00080	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  00083	50		 push	 eax
  00084	8b 4d f8	 mov	 ecx, DWORD PTR _input$[ebp]
  00087	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  0008a	8b 82 a8 00 00
	00		 mov	 eax, DWORD PTR [edx+168]
  00090	ff d0		 call	 eax
  00092	83 c4 0c	 add	 esp, 12			; 0000000cH
  00095	3b f4		 cmp	 esi, esp
  00097	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009c	90		 npad	 1

; 472  :     }

  0009d	eb 2e		 jmp	 SHORT $LN3@antlr38Bit
$LN2@antlr38Bit:

; 473  :     else
; 474  :     {
; 475  : 		state	= (pANTLR3_LEX_STATE)input->markers->get(input->markers, input->markDepth - 1);

  0009f	8b 4d f8	 mov	 ecx, DWORD PTR _input$[ebp]
  000a2	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  000a5	83 ea 01	 sub	 edx, 1
  000a8	8b f4		 mov	 esi, esp
  000aa	52		 push	 edx
  000ab	8b 45 f8	 mov	 eax, DWORD PTR _input$[ebp]
  000ae	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  000b1	51		 push	 ecx
  000b2	8b 55 f8	 mov	 edx, DWORD PTR _input$[ebp]
  000b5	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  000b8	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [eax+152]
  000be	ff d1		 call	 ecx
  000c0	83 c4 08	 add	 esp, 8
  000c3	3b f4		 cmp	 esi, esp
  000c5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ca	89 45 fc	 mov	 DWORD PTR _state$[ebp], eax
$LN3@antlr38Bit:

; 476  : 
; 477  : 		/* Assume no errors for speed, it will just blow up if the table failed
; 478  : 		 * for some reasons, hence lots of unit tests on the tables ;-)
; 479  : 		 */
; 480  :     }
; 481  : 
; 482  :     /* We have created or retrieved the state, so update it with the current
; 483  :      * elements of the lexer state.
; 484  :      */
; 485  :     state->charPositionInLine	= input->charPositionInLine;

  000cd	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  000d0	8b 45 f8	 mov	 eax, DWORD PTR _input$[ebp]
  000d3	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  000d6	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 486  :     state->currentLine		= input->currentLine;

  000d9	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  000dc	8b 45 f8	 mov	 eax, DWORD PTR _input$[ebp]
  000df	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  000e2	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 487  :     state->line			= input->line;

  000e5	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  000e8	8b 45 f8	 mov	 eax, DWORD PTR _input$[ebp]
  000eb	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  000ee	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 488  :     state->nextChar		= input->nextChar;

  000f1	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  000f4	8b 45 f8	 mov	 eax, DWORD PTR _input$[ebp]
  000f7	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000fa	89 0a		 mov	 DWORD PTR [edx], ecx

; 489  : 
; 490  :     is->lastMarker  = input->markDepth;

  000fc	8b 55 08	 mov	 edx, DWORD PTR _is$[ebp]
  000ff	8b 45 f8	 mov	 eax, DWORD PTR _input$[ebp]
  00102	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00105	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 491  : 
; 492  :     /* And that's it
; 493  :      */
; 494  :     return  input->markDepth;

  00108	8b 55 f8	 mov	 edx, DWORD PTR _input$[ebp]
  0010b	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
$LN1@antlr38Bit:

; 495  : }

  0010e	5e		 pop	 esi
  0010f	83 c4 08	 add	 esp, 8
  00112	3b ec		 cmp	 ebp, esp
  00114	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00119	8b e5		 mov	 esp, ebp
  0011b	5d		 pop	 ebp
  0011c	c3		 ret	 0
_antlr38BitMark ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3inputstream.c
;	COMDAT _antlr38BitIndex
_TEXT	SEGMENT
_input$ = -4						; size = 4
_is$ = 8						; size = 4
_antlr38BitIndex PROC					; COMDAT

; 417  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 418  :     pANTLR3_INPUT_STREAM input;
; 419  : 
; 420  :     input   = ((pANTLR3_INPUT_STREAM) (is->super));

  00004	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  00007	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000a	89 4d fc	 mov	 DWORD PTR _input$[ebp], ecx

; 421  : 
; 422  :     return  (ANTLR3_MARKER)(((pANTLR3_UINT8)input->nextChar));

  0000d	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  00010	8b 42 14	 mov	 eax, DWORD PTR [edx+20]

; 423  : }

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
_antlr38BitIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3inputstream.c
;	COMDAT _antlr38BitLA_ucase
_TEXT	SEGMENT
_input$ = -4						; size = 4
_is$ = 8						; size = 4
_la$ = 12						; size = 4
_antlr38BitLA_ucase PROC				; COMDAT

; 378  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 379  :     pANTLR3_INPUT_STREAM input;
; 380  : 	
; 381  :     input   = ((pANTLR3_INPUT_STREAM) (is->super));

  0000c	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  0000f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00012	89 4d fc	 mov	 DWORD PTR _input$[ebp], ecx

; 382  : 
; 383  :     if	(( ((pANTLR3_UINT8)input->nextChar) + la - 1) >= (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  00015	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  00018	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0001b	8b 4d 0c	 mov	 ecx, DWORD PTR _la$[ebp]
  0001e	8d 54 08 ff	 lea	 edx, DWORD PTR [eax+ecx-1]
  00022	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  00025	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00028	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  0002b	03 48 18	 add	 ecx, DWORD PTR [eax+24]
  0002e	3b d1		 cmp	 edx, ecx
  00030	72 07		 jb	 SHORT $LN2@antlr38Bit

; 384  :     {
; 385  : 		return	ANTLR3_CHARSTREAM_EOF;

  00032	83 c8 ff	 or	 eax, -1
  00035	eb 23		 jmp	 SHORT $LN3@antlr38Bit

; 386  :     }

  00037	eb 21		 jmp	 SHORT $LN3@antlr38Bit
$LN2@antlr38Bit:

; 387  :     else
; 388  :     {
; 389  : 		return	(ANTLR3_UCHAR)toupper((*((pANTLR3_UINT8)input->nextChar + la - 1)));

  00039	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  0003c	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0003f	8b 45 0c	 mov	 eax, DWORD PTR _la$[ebp]
  00042	0f b6 4c 02 ff	 movzx	 ecx, BYTE PTR [edx+eax-1]
  00047	8b f4		 mov	 esi, esp
  00049	51		 push	 ecx
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__toupper
  00050	83 c4 04	 add	 esp, 4
  00053	3b f4		 cmp	 esi, esp
  00055	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@antlr38Bit:

; 390  :     }
; 391  : }

  0005a	5e		 pop	 esi
  0005b	83 c4 04	 add	 esp, 4
  0005e	3b ec		 cmp	 ebp, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
_antlr38BitLA_ucase ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3inputstream.c
;	COMDAT _antlr38BitLA
_TEXT	SEGMENT
_input$ = -4						; size = 4
_is$ = 8						; size = 4
_la$ = 12						; size = 4
_antlr38BitLA PROC					; COMDAT

; 351  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 352  :     pANTLR3_INPUT_STREAM input;
; 353  : 	
; 354  :     input   = ((pANTLR3_INPUT_STREAM) (is->super));

  00004	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  00007	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000a	89 4d fc	 mov	 DWORD PTR _input$[ebp], ecx

; 355  : 
; 356  :     if	(( ((pANTLR3_UINT8)input->nextChar) + la - 1) >= (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  0000d	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  00010	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR _la$[ebp]
  00016	8d 54 08 ff	 lea	 edx, DWORD PTR [eax+ecx-1]
  0001a	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  0001d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00020	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  00023	03 48 18	 add	 ecx, DWORD PTR [eax+24]
  00026	3b d1		 cmp	 edx, ecx
  00028	72 07		 jb	 SHORT $LN2@antlr38Bit

; 357  :     {
; 358  : 		return	ANTLR3_CHARSTREAM_EOF;

  0002a	83 c8 ff	 or	 eax, -1
  0002d	eb 10		 jmp	 SHORT $LN3@antlr38Bit

; 359  :     }

  0002f	eb 0e		 jmp	 SHORT $LN3@antlr38Bit
$LN2@antlr38Bit:

; 360  :     else
; 361  :     {
; 362  : 		return	(ANTLR3_UCHAR)(*((pANTLR3_UINT8)input->nextChar + la - 1));

  00031	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  00034	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00037	8b 45 0c	 mov	 eax, DWORD PTR _la$[ebp]
  0003a	0f b6 44 02 ff	 movzx	 eax, BYTE PTR [edx+eax-1]
$LN3@antlr38Bit:

; 363  :     }
; 364  : }

  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
_antlr38BitLA ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3inputstream.c
;	COMDAT _antlr38BitConsume
_TEXT	SEGMENT
_input$ = -4						; size = 4
_is$ = 8						; size = 4
_antlr38BitConsume PROC					; COMDAT

; 316  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 317  :     pANTLR3_INPUT_STREAM input;
; 318  : 
; 319  :     input   = ((pANTLR3_INPUT_STREAM) (is->super));

  00004	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  00007	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000a	89 4d fc	 mov	 DWORD PTR _input$[ebp], ecx

; 320  : 
; 321  :     if	((pANTLR3_UINT8)(input->nextChar) < (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  0000d	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  00010	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  00016	03 41 18	 add	 eax, DWORD PTR [ecx+24]
  00019	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  0001c	39 42 14	 cmp	 DWORD PTR [edx+20], eax
  0001f	73 57		 jae	 SHORT $LN2@antlr38Bit

; 322  :     {	
; 323  : 	/* Indicate one more character in this line
; 324  : 	 */
; 325  : 	input->charPositionInLine++;

  00021	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  00024	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00027	83 c1 01	 add	 ecx, 1
  0002a	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  0002d	89 4a 24	 mov	 DWORD PTR [edx+36], ecx

; 326  : 	
; 327  : 	if  ((ANTLR3_UCHAR)(*((pANTLR3_UINT8)input->nextChar)) == input->newlineChar)

  00030	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  00033	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00036	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00039	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  0003c	3b 50 70	 cmp	 edx, DWORD PTR [eax+112]
  0003f	75 28		 jne	 SHORT $LN3@antlr38Bit

; 328  : 	{
; 329  : 	    /* Reset for start of a new line of input
; 330  : 	     */
; 331  : 	    input->line++;

  00041	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  00044	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00047	83 c2 01	 add	 edx, 1
  0004a	8b 45 fc	 mov	 eax, DWORD PTR _input$[ebp]
  0004d	89 50 1c	 mov	 DWORD PTR [eax+28], edx

; 332  : 	    input->charPositionInLine	= 0;

  00050	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  00053	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], 0

; 333  : 	    input->currentLine		= (void *)(((pANTLR3_UINT8)input->nextChar) + 1);

  0005a	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  0005d	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00060	83 c0 01	 add	 eax, 1
  00063	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  00066	89 41 20	 mov	 DWORD PTR [ecx+32], eax
$LN3@antlr38Bit:

; 334  : 	}
; 335  : 
; 336  : 	/* Increment to next character position
; 337  : 	 */
; 338  : 	input->nextChar = (void *)(((pANTLR3_UINT8)input->nextChar) + 1);

  00069	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  0006c	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0006f	83 c0 01	 add	 eax, 1
  00072	8b 4d fc	 mov	 ecx, DWORD PTR _input$[ebp]
  00075	89 41 14	 mov	 DWORD PTR [ecx+20], eax
$LN2@antlr38Bit:

; 339  :     }
; 340  : }

  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c3		 ret	 0
_antlr38BitConsume ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3inputstream.c
;	COMDAT _antlr3GenericSetupStream
_TEXT	SEGMENT
_input$ = 8						; size = 4
_antlr3GenericSetupStream PROC				; COMDAT

; 137  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 138  :     /* Install function pointers for an 8 bit input
; 139  :      */
; 140  : 
; 141  :     /* Allocate stream interface
; 142  :      */
; 143  :     input->istream		= antlr3IntStreamNew();

  00004	e8 00 00 00 00	 call	 _antlr3IntStreamNew
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  0000c	89 01		 mov	 DWORD PTR [ecx], eax

; 144  :     input->istream->type        = ANTLR3_CHARSTREAM;

  0000e	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  00011	8b 02		 mov	 eax, DWORD PTR [edx]
  00013	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1

; 145  :     input->istream->super       = input;

  00019	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  0001c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001e	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  00021	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 146  : 
; 147  :     /* Intstream API
; 148  :      */
; 149  :     input->istream->consume	    = antlr38BitConsume;	    // Consume the next 8 bit character in the buffer			

  00024	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  00027	8b 11		 mov	 edx, DWORD PTR [ecx]
  00029	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], OFFSET _antlr38BitConsume

; 150  :     input->istream->_LA		    = antlr38BitLA;	            // Return the UTF32 character at offset n (1 based)			

  00030	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  00033	8b 08		 mov	 ecx, DWORD PTR [eax]
  00035	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET _antlr38BitLA

; 151  :     input->istream->index	    = antlr38BitIndex;	            // Current index (offset from first character			    

  0003c	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  0003f	8b 02		 mov	 eax, DWORD PTR [edx]
  00041	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], OFFSET _antlr38BitIndex

; 152  :     input->istream->mark	    = antlr38BitMark;		    // Record the current lex state for later restore			

  00048	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  0004b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004d	c7 42 1c 00 00
	00 00		 mov	 DWORD PTR [edx+28], OFFSET _antlr38BitMark

; 153  :     input->istream->rewind	    = antlr38BitRewind;	            // How to rewind the input									

  00054	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  00057	8b 08		 mov	 ecx, DWORD PTR [eax]
  00059	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], OFFSET _antlr38BitRewind

; 154  :     input->istream->rewindLast	    = antlr38BitRewindLast;	    // How to rewind the input									

  00060	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  00063	8b 02		 mov	 eax, DWORD PTR [edx]
  00065	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [eax+40], OFFSET _antlr38BitRewindLast

; 155  :     input->istream->seek	    = antlr38BitSeek;		    // How to seek to a specific point in the stream		    

  0006c	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  0006f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00071	c7 42 30 00 00
	00 00		 mov	 DWORD PTR [edx+48], OFFSET _antlr38BitSeek

; 156  :     input->istream->release	    = antlr38BitRelease;	    // Reset marks after mark n									

  00078	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  0007b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007d	c7 41 2c 00 00
	00 00		 mov	 DWORD PTR [ecx+44], OFFSET _antlr38BitRelease

; 157  :     input->istream->getSourceName   = antlr38BitGetSourceName;      // Return a string that names the input source

  00084	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  00087	8b 02		 mov	 eax, DWORD PTR [edx]
  00089	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], OFFSET _antlr38BitGetSourceName

; 158  : 
; 159  :     /* Charstream API
; 160  :      */
; 161  :     input->close		    =  antlr3InputClose;	    // Close down the stream completely										

  00090	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  00093	c7 41 38 00 00
	00 00		 mov	 DWORD PTR [ecx+56], OFFSET _antlr3InputClose

; 162  :     input->free			    =  antlr3InputClose;	    // Synonym for free														

  0009a	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  0009d	c7 42 3c 00 00
	00 00		 mov	 DWORD PTR [edx+60], OFFSET _antlr3InputClose

; 163  :     input->reset		    =  antlr3InputReset;	    // Reset input to start	

  000a4	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  000a7	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [eax+64], OFFSET _antlr3InputReset

; 164  :     input->reuse                    =  antlr38BitReuse;             // Install a new input string and reset

  000ae	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  000b1	c7 41 44 00 00
	00 00		 mov	 DWORD PTR [ecx+68], OFFSET _antlr38BitReuse

; 165  :     input->_LT			    =  antlr38BitLT;		    // Same as _LA for 8 bit file										

  000b8	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  000bb	c7 42 4c 00 00
	00 00		 mov	 DWORD PTR [edx+76], OFFSET _antlr38BitLT

; 166  :     input->size			    =  antlr38BitSize;		    // Return the size of the input buffer									

  000c2	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  000c5	c7 40 50 00 00
	00 00		 mov	 DWORD PTR [eax+80], OFFSET _antlr38BitSize

; 167  :     input->substr		    =  antlr38BitSubstr;	    // Return a string from the input stream								

  000cc	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  000cf	c7 41 54 00 00
	00 00		 mov	 DWORD PTR [ecx+84], OFFSET _antlr38BitSubstr

; 168  :     input->getLine		    =  antlr38BitGetLine;	    // Return the current line number in the input stream					

  000d6	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  000d9	c7 42 58 00 00
	00 00		 mov	 DWORD PTR [edx+88], OFFSET _antlr38BitGetLine

; 169  :     input->getLineBuf		    =  antlr38BitGetLineBuf;	    // Return a pointer to the start of the current line being consumed	    

  000e0	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  000e3	c7 40 5c 00 00
	00 00		 mov	 DWORD PTR [eax+92], OFFSET _antlr38BitGetLineBuf

; 170  :     input->getCharPositionInLine    =  antlr38BitGetCharPosition;   // Return the offset into the current line of input						

  000ea	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  000ed	c7 41 60 00 00
	00 00		 mov	 DWORD PTR [ecx+96], OFFSET _antlr38BitGetCharPosition

; 171  :     input->setLine		    =  antlr38BitSetLine;	    // Set the input stream line number (does not set buffer pointers)	    

  000f4	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  000f7	c7 42 64 00 00
	00 00		 mov	 DWORD PTR [edx+100], OFFSET _antlr38BitSetLine

; 172  :     input->setCharPositionInLine    =  antlr38BitSetCharPosition;   // Set the offset in to the current line (does not set any pointers)   

  000fe	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  00101	c7 40 68 00 00
	00 00		 mov	 DWORD PTR [eax+104], OFFSET _antlr38BitSetCharPosition

; 173  :     input->SetNewLineChar	    =  antlr38BitSetNewLineChar;    // Set the value of the newline trigger character						

  00108	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  0010b	c7 41 6c 00 00
	00 00		 mov	 DWORD PTR [ecx+108], OFFSET _antlr38BitSetNewLineChar

; 174  :     input->setUcaseLA		    =  antlr38BitSetUcaseLA;        // Changes the LA function to return upper case always

  00112	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  00115	c7 42 48 00 00
	00 00		 mov	 DWORD PTR [edx+72], OFFSET _antlr38BitSetUcaseLA

; 175  : 
; 176  :     input->charByteSize		    = 1;		// Size in bytes of characters in this stream.

  0011c	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  0011f	c6 40 74 01	 mov	 BYTE PTR [eax+116], 1

; 177  : 
; 178  :     /* Initialize entries for tables etc
; 179  :      */
; 180  :     input->markers  = NULL;

  00123	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  00126	c7 41 2c 00 00
	00 00		 mov	 DWORD PTR [ecx+44], 0

; 181  : 
; 182  :     /* Set up the input stream brand new
; 183  :      */
; 184  :     input->reset(input);

  0012d	8b f4		 mov	 esi, esp
  0012f	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  00132	52		 push	 edx
  00133	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  00136	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  00139	ff d1		 call	 ecx
  0013b	83 c4 04	 add	 esp, 4
  0013e	3b f4		 cmp	 esi, esp
  00140	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 185  :     
; 186  :     /* Install default line separator character (it can be replaced
; 187  :      * by the grammar programmer later)
; 188  :      */
; 189  :     input->SetNewLineChar(input, (ANTLR3_UCHAR)'\n');

  00145	8b f4		 mov	 esi, esp
  00147	6a 0a		 push	 10			; 0000000aH
  00149	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  0014c	52		 push	 edx
  0014d	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  00150	8b 48 6c	 mov	 ecx, DWORD PTR [eax+108]
  00153	ff d1		 call	 ecx
  00155	83 c4 08	 add	 esp, 8
  00158	3b f4		 cmp	 esi, esp
  0015a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0015f	90		 npad	 1

; 190  : }

  00160	5e		 pop	 esi
  00161	3b ec		 cmp	 ebp, esp
  00163	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00168	5d		 pop	 ebp
  00169	c3		 ret	 0
_antlr3GenericSetupStream ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3inputstream.c
;	COMDAT _antlr3EBCDICSetupStream
_TEXT	SEGMENT
_input$ = 8						; size = 4
_antlr3EBCDICSetupStream PROC				; COMDAT

; 2021 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2022 :     // EBCDIC streams can use the standard 8 bit string factory
; 2023 :     //
; 2024 :     input->strFactory	= antlr3StringFactoryNew(input->encoding);

  00003	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  00006	8b 48 78	 mov	 ecx, DWORD PTR [eax+120]
  00009	51		 push	 ecx
  0000a	e8 00 00 00 00	 call	 _antlr3StringFactoryNew
  0000f	83 c4 04	 add	 esp, 4
  00012	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  00015	89 42 10	 mov	 DWORD PTR [edx+16], eax

; 2025 : 
; 2026 :     // Generic API that does not care about endianess.
; 2027 :     //
; 2028 :     input->istream->_LA         = antlr3EBCDICLA;       // Return the UTF32 character at offset n (1 based)    

  00018	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  0001b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001d	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET _antlr3EBCDICLA

; 2029 :     input->charByteSize		= 1;	                // Size in bytes of characters in this stream.

  00024	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  00027	c6 42 74 01	 mov	 BYTE PTR [edx+116], 1

; 2030 : }

  0002b	3b ec		 cmp	 ebp, esp
  0002d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
_antlr3EBCDICSetupStream ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3inputstream.c
;	COMDAT _antlr3UTF8SetupStream
_TEXT	SEGMENT
_input$ = 8						; size = 4
_antlr3UTF8SetupStream PROC				; COMDAT

; 1758 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1759 :     // Build a string factory for this stream. This is a UTF16 string factory which is a standard
; 1760 :     // part of the ANTLR3 string. The string factory is then passed through the whole chain of lexer->parser->tree->treeparser
; 1761 :     // and so on.
; 1762 :     //
; 1763 :     input->strFactory	= antlr3StringFactoryNew(input->encoding);

  00003	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  00006	8b 48 78	 mov	 ecx, DWORD PTR [eax+120]
  00009	51		 push	 ecx
  0000a	e8 00 00 00 00	 call	 _antlr3StringFactoryNew
  0000f	83 c4 04	 add	 esp, 4
  00012	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  00015	89 42 10	 mov	 DWORD PTR [edx+16], eax

; 1764 : 
; 1765 :     // Generic API that does not care about endianess.
; 1766 :     //
; 1767 :     input->istream->consume	= antlr3UTF8Consume;	// Consume the next UTF32 character in the buffer

  00018	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  0001b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001d	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], OFFSET _antlr3UTF8Consume

; 1768 :     input->istream->_LA         = antlr3UTF8LA;         // Return the UTF32 character at offset n (1 based)    

  00024	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  00027	8b 02		 mov	 eax, DWORD PTR [edx]
  00029	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET _antlr3UTF8LA

; 1769 :     input->charByteSize		= 0;	                // Size in bytes of characters in this stream.

  00030	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  00033	c6 41 74 00	 mov	 BYTE PTR [ecx+116], 0

; 1770 : }

  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
_antlr3UTF8SetupStream ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3inputstream.c
;	COMDAT _antlr3UTF32SetupStream
_TEXT	SEGMENT
tv76 = -4						; size = 4
_input$ = 8						; size = 4
_machineBigEndian$ = 12					; size = 1
_inputBigEndian$ = 16					; size = 1
_antlr3UTF32SetupStream PROC				; COMDAT

; 1508 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 1509 :     // Build a string factory for this stream. This is a UTF32 string factory which is a standard
; 1510 :     // part of the ANTLR3 string. The string factory is then passed through the whole chain of lexer->parser->tree->treeparser
; 1511 :     // and so on.
; 1512 :     //
; 1513 :     input->strFactory	= antlr3StringFactoryNew(input->encoding);

  0000b	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  0000e	8b 48 78	 mov	 ecx, DWORD PTR [eax+120]
  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 _antlr3StringFactoryNew
  00017	83 c4 04	 add	 esp, 4
  0001a	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  0001d	89 42 10	 mov	 DWORD PTR [edx+16], eax

; 1514 : 
; 1515 :     // Generic API that does not care about endianess.
; 1516 :     //
; 1517 :     input->istream->index	    =  antlr3UTF32Index;            // Calculate current index in input stream, UTF16 based

  00020	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  00023	8b 08		 mov	 ecx, DWORD PTR [eax]
  00025	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], OFFSET _antlr3UTF32Index

; 1518 :     input->substr		    =  antlr3UTF32Substr;	    // Return a string from the input stream

  0002c	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  0002f	c7 42 54 00 00
	00 00		 mov	 DWORD PTR [edx+84], OFFSET _antlr3UTF32Substr

; 1519 :     input->istream->seek	    =  antlr3UTF32Seek;		    // How to seek to a specific point in the stream

  00036	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  00039	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003b	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], OFFSET _antlr3UTF32Seek

; 1520 :     input->istream->consume	    =  antlr3UTF32Consume;	    // Consume the next UTF32 character in the buffer

  00042	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  00045	8b 02		 mov	 eax, DWORD PTR [edx]
  00047	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], OFFSET _antlr3UTF32Consume

; 1521 : 
; 1522 :     // We must install different UTF32 LA routines according to whether the input
; 1523 :     // is the same endianess as the machine we are executing upon or not. If it is not
; 1524 :     // then we must install methods that can convert the endianess on the fly as they go
; 1525 :     //
; 1526 :     switch (machineBigEndian)

  0004e	8a 4d 0c	 mov	 cl, BYTE PTR _machineBigEndian$[ebp]
  00051	88 4d fc	 mov	 BYTE PTR tv76[ebp], cl
  00054	80 7d fc 00	 cmp	 BYTE PTR tv76[ebp], 0
  00058	74 2d		 je	 SHORT $LN7@antlr3UTF3
  0005a	80 7d fc 01	 cmp	 BYTE PTR tv76[ebp], 1
  0005e	74 02		 je	 SHORT $LN4@antlr3UTF3
  00060	eb 47		 jmp	 SHORT $LN2@antlr3UTF3
$LN4@antlr3UTF3:

; 1527 :     {
; 1528 :         case    ANTLR3_TRUE:
; 1529 : 
; 1530 :             // Machine is Big Endian, if the input is also then install the 
; 1531 :             // methods that do not access input by bytes and reverse them.
; 1532 :             // Otherwise install endian aware methods.
; 1533 :             //
; 1534 :             if  (inputBigEndian == ANTLR3_TRUE) 

  00062	0f b6 55 10	 movzx	 edx, BYTE PTR _inputBigEndian$[ebp]
  00066	83 fa 01	 cmp	 edx, 1
  00069	75 0e		 jne	 SHORT $LN5@antlr3UTF3

; 1535 :             {
; 1536 :                 // Input is machine compatible
; 1537 :                 //
; 1538 :                 input->istream->_LA         =  antlr3UTF32LA;		    // Return the UTF32 character at offset n (1 based)    

  0006b	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  0006e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00070	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET _antlr3UTF32LA

; 1539 :             }

  00077	eb 0c		 jmp	 SHORT $LN6@antlr3UTF3
$LN5@antlr3UTF3:

; 1540 :             else
; 1541 :             {
; 1542 :                 // Need to use methods that know that the input is little endian
; 1543 :                 //
; 1544 :                 input->istream->_LA         =  antlr3UTF32LALE;		    // Return the UTF32 character at offset n (1 based) 

  00079	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  0007c	8b 02		 mov	 eax, DWORD PTR [edx]
  0007e	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET _antlr3UTF32LALE
$LN6@antlr3UTF3:

; 1545 :             }
; 1546 :             break;

  00085	eb 22		 jmp	 SHORT $LN2@antlr3UTF3
$LN7@antlr3UTF3:

; 1547 : 
; 1548 :         case    ANTLR3_FALSE:
; 1549 : 
; 1550 :             // Machine is Little Endian, if the input is also then install the 
; 1551 :             // methods that do not access input by bytes and reverse them.
; 1552 :             // Otherwise install endian aware methods.
; 1553 :             //
; 1554 :             if  (inputBigEndian == ANTLR3_FALSE) 

  00087	0f b6 4d 10	 movzx	 ecx, BYTE PTR _inputBigEndian$[ebp]
  0008b	85 c9		 test	 ecx, ecx
  0008d	75 0e		 jne	 SHORT $LN8@antlr3UTF3

; 1555 :             {
; 1556 :                 // Input is machine compatible
; 1557 :                 //
; 1558 :                 input->istream->_LA         =  antlr3UTF32LA;		    // Return the UTF32 character at offset n (1 based)    

  0008f	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  00092	8b 02		 mov	 eax, DWORD PTR [edx]
  00094	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET _antlr3UTF32LA

; 1559 :             }

  0009b	eb 0c		 jmp	 SHORT $LN9@antlr3UTF3
$LN8@antlr3UTF3:

; 1560 :             else
; 1561 :             {
; 1562 :                 // Need to use methods that know that the input is Big Endian
; 1563 :                 //
; 1564 :                 input->istream->_LA         =  antlr3UTF32LABE;		    // Return the UTF32 character at offset n (1 based) 

  0009d	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  000a0	8b 11		 mov	 edx, DWORD PTR [ecx]
  000a2	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET _antlr3UTF32LABE
$LN9@antlr3UTF3:
$LN2@antlr3UTF3:

; 1565 :             }
; 1566 :             break;
; 1567 :     }
; 1568 : 
; 1569 :     input->charByteSize		    = 4;			    // Size in bytes of characters in this stream.

  000a9	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  000ac	c6 40 74 04	 mov	 BYTE PTR [eax+116], 4

; 1570 : }

  000b0	83 c4 04	 add	 esp, 4
  000b3	3b ec		 cmp	 ebp, esp
  000b5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ba	8b e5		 mov	 esp, ebp
  000bc	5d		 pop	 ebp
  000bd	c3		 ret	 0
_antlr3UTF32SetupStream ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3inputstream.c
;	COMDAT _antlr3UTF16SetupStream
_TEXT	SEGMENT
tv74 = -4						; size = 4
_input$ = 8						; size = 4
_machineBigEndian$ = 12					; size = 1
_inputBigEndian$ = 16					; size = 1
_antlr3UTF16SetupStream PROC				; COMDAT

; 710  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 711  :     // Build a string factory for this stream. This is a UTF16 string factory which is a standard
; 712  :     // part of the ANTLR3 string. The string factory is then passed through the whole chain 
; 713  :     // of lexer->parser->tree->treeparser and so on.
; 714  :     //
; 715  :     input->strFactory	= antlr3StringFactoryNew(input->encoding);

  0000b	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  0000e	8b 48 78	 mov	 ecx, DWORD PTR [eax+120]
  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 _antlr3StringFactoryNew
  00017	83 c4 04	 add	 esp, 4
  0001a	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  0001d	89 42 10	 mov	 DWORD PTR [edx+16], eax

; 716  : 
; 717  :     // Generic API that does not care about endianess.
; 718  :     //
; 719  :     input->istream->index	    =  antlr3UTF16Index;            // Calculate current index in input stream, UTF16 based

  00020	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  00023	8b 08		 mov	 ecx, DWORD PTR [eax]
  00025	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], OFFSET _antlr3UTF16Index

; 720  :     input->substr		    =  antlr3UTF16Substr;	    // Return a string from the input stream

  0002c	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  0002f	c7 42 54 00 00
	00 00		 mov	 DWORD PTR [edx+84], OFFSET _antlr3UTF16Substr

; 721  :     input->istream->seek	    =  antlr3UTF16Seek;		    // How to seek to a specific point in the stream

  00036	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  00039	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003b	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], OFFSET _antlr3UTF16Seek

; 722  : 
; 723  :     // We must install different UTF16 routines according to whether the input
; 724  :     // is the same endianess as the machine we are executing upon or not. If it is not
; 725  :     // then we must install methods that can convert the endianess on the fly as they go
; 726  :     //
; 727  : 
; 728  :     switch (machineBigEndian)

  00042	8a 55 0c	 mov	 dl, BYTE PTR _machineBigEndian$[ebp]
  00045	88 55 fc	 mov	 BYTE PTR tv74[ebp], dl
  00048	80 7d fc 00	 cmp	 BYTE PTR tv74[ebp], 0
  0004c	74 45		 je	 SHORT $LN7@antlr3UTF1
  0004e	80 7d fc 01	 cmp	 BYTE PTR tv74[ebp], 1
  00052	74 02		 je	 SHORT $LN4@antlr3UTF1
  00054	eb 77		 jmp	 SHORT $LN2@antlr3UTF1
$LN4@antlr3UTF1:

; 729  :     {
; 730  :         case    ANTLR3_TRUE:
; 731  : 
; 732  :             // Machine is Big Endian, if the input is also then install the 
; 733  :             // methods that do not access input by bytes and reverse them.
; 734  :             // Otherwise install endian aware methods.
; 735  :             //
; 736  :             if  (inputBigEndian == ANTLR3_TRUE) 

  00056	0f b6 45 10	 movzx	 eax, BYTE PTR _inputBigEndian$[ebp]
  0005a	83 f8 01	 cmp	 eax, 1
  0005d	75 1a		 jne	 SHORT $LN5@antlr3UTF1

; 737  :             {
; 738  :                 // Input is machine compatible
; 739  :                 //
; 740  :                 input->istream->consume	    =  antlr3UTF16Consume;	    // Consume the next UTF16 character in the buffer

  0005f	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  00062	8b 11		 mov	 edx, DWORD PTR [ecx]
  00064	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], OFFSET _antlr3UTF16Consume

; 741  :                 input->istream->_LA         =  antlr3UTF16LA;		    // Return the UTF32 character at offset n (1 based)    

  0006b	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  0006e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00070	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET _antlr3UTF16LA

; 742  :             }

  00077	eb 18		 jmp	 SHORT $LN6@antlr3UTF1
$LN5@antlr3UTF1:

; 743  :             else
; 744  :             {
; 745  :                 // Need to use methods that know that the input is little endian
; 746  :                 //
; 747  :                 input->istream->consume	    =  antlr3UTF16ConsumeLE;	    // Consume the next UTF16 character in the buffer

  00079	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  0007c	8b 02		 mov	 eax, DWORD PTR [edx]
  0007e	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], OFFSET _antlr3UTF16ConsumeLE

; 748  :                 input->istream->_LA         =  antlr3UTF16LALE;		    // Return the UTF32 character at offset n (1 based) 

  00085	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  00088	8b 11		 mov	 edx, DWORD PTR [ecx]
  0008a	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET _antlr3UTF16LALE
$LN6@antlr3UTF1:

; 749  :             }
; 750  :             break;

  00091	eb 3a		 jmp	 SHORT $LN2@antlr3UTF1
$LN7@antlr3UTF1:

; 751  : 
; 752  :         case    ANTLR3_FALSE:
; 753  : 
; 754  :             // Machine is Little Endian, if the input is also then install the 
; 755  :             // methods that do not access input by bytes and reverse them.
; 756  :             // Otherwise install endian aware methods.
; 757  :             //
; 758  :             if  (inputBigEndian == ANTLR3_FALSE) 

  00093	0f b6 45 10	 movzx	 eax, BYTE PTR _inputBigEndian$[ebp]
  00097	85 c0		 test	 eax, eax
  00099	75 1a		 jne	 SHORT $LN8@antlr3UTF1

; 759  :             {
; 760  :                 // Input is machine compatible
; 761  :                 //
; 762  :                 input->istream->consume	    =  antlr3UTF16Consume;	    // Consume the next UTF16 character in the buffer

  0009b	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  0009e	8b 11		 mov	 edx, DWORD PTR [ecx]
  000a0	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], OFFSET _antlr3UTF16Consume

; 763  :                 input->istream->_LA         =  antlr3UTF16LA;		    // Return the UTF32 character at offset n (1 based)    

  000a7	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  000aa	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ac	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET _antlr3UTF16LA

; 764  :             }

  000b3	eb 18		 jmp	 SHORT $LN9@antlr3UTF1
$LN8@antlr3UTF1:

; 765  :             else
; 766  :             {
; 767  :                 // Need to use methods that know that the input is Big Endian
; 768  :                 //
; 769  :                 input->istream->consume	    =  antlr3UTF16ConsumeBE;	    // Consume the next UTF16 character in the buffer

  000b5	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  000b8	8b 02		 mov	 eax, DWORD PTR [edx]
  000ba	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], OFFSET _antlr3UTF16ConsumeBE

; 770  :                 input->istream->_LA         =  antlr3UTF16LABE;		    // Return the UTF32 character at offset n (1 based) 

  000c1	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  000c4	8b 11		 mov	 edx, DWORD PTR [ecx]
  000c6	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET _antlr3UTF16LABE
$LN9@antlr3UTF1:
$LN2@antlr3UTF1:

; 771  :             }
; 772  :             break;
; 773  :     }
; 774  : 
; 775  :         
; 776  :     input->charByteSize		    = 2;			    // Size in bytes of characters in this stream.

  000cd	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  000d0	c6 40 74 02	 mov	 BYTE PTR [eax+116], 2

; 777  : 
; 778  : }

  000d4	83 c4 04	 add	 esp, 4
  000d7	3b ec		 cmp	 ebp, esp
  000d9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000de	8b e5		 mov	 esp, ebp
  000e0	5d		 pop	 ebp
  000e1	c3		 ret	 0
_antlr3UTF16SetupStream ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3inputstream.c
;	COMDAT _antlr38BitSetupStream
_TEXT	SEGMENT
_input$ = 8						; size = 4
_antlr38BitSetupStream PROC				; COMDAT

; 126  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 127  :     // Build a string factory for this stream
; 128  :     //
; 129  :     input->strFactory	= antlr3StringFactoryNew(input->encoding);

  00003	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  00006	8b 48 78	 mov	 ecx, DWORD PTR [eax+120]
  00009	51		 push	 ecx
  0000a	e8 00 00 00 00	 call	 _antlr3StringFactoryNew
  0000f	83 c4 04	 add	 esp, 4
  00012	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  00015	89 42 10	 mov	 DWORD PTR [edx+16], eax

; 130  : 
; 131  :     // Default stream API set up is for 8Bit, so we are done
; 132  :     //
; 133  : }

  00018	3b ec		 cmp	 ebp, esp
  0001a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
_antlr38BitSetupStream ENDP
_TEXT	ENDS
END
