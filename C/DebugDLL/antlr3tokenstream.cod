; Listing generated by Microsoft (R) Optimizing Compiler Version 19.42.34436.0 

	TITLE	C:\SPO_labs\C\DebugDLL\antlr3tokenstream.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_antlr3CommonTokenStreamSourceNew
PUBLIC	_antlr3CommonTokenStreamNew
PUBLIC	_antlr3CommonTokenDebugStreamSourceNew
PUBLIC	_fillBufferExt
PUBLIC	_antlr3TokenStreamNew
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	_antlr3BitsetOf:PROC
EXTRN	_antlr3BitsetList:PROC
EXTRN	_antlr3ListNew:PROC
EXTRN	_antlr3VectorNew:PROC
EXTRN	_antlr3IntStreamNew:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3tokenstream.c
;	COMDAT _consumeInitialHiddenTokens
_TEXT	SEGMENT
_ts$ = -12						; size = 4
_i$ = -8						; size = 4
_first$ = -4						; size = 4
_is$ = 8						; size = 4
_consumeInitialHiddenTokens PROC			; COMDAT

; 417  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000e	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00015	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 418  : 	ANTLR3_MARKER	first;
; 419  : 	ANTLR3_INT32	i;
; 420  : 	pANTLR3_TOKEN_STREAM	ts;
; 421  : 
; 422  : 	ts	    = (pANTLR3_TOKEN_STREAM)	    is->super;

  0001c	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  0001f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00022	89 4d f4	 mov	 DWORD PTR _ts$[ebp], ecx

; 423  : 	first	= is->index(is);

  00025	8b f4		 mov	 esi, esp
  00027	8b 55 08	 mov	 edx, DWORD PTR _is$[ebp]
  0002a	52		 push	 edx
  0002b	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  0002e	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00031	ff d1		 call	 ecx
  00033	83 c4 04	 add	 esp, 4
  00036	3b f4		 cmp	 esi, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	89 45 fc	 mov	 DWORD PTR _first$[ebp], eax

; 424  : 
; 425  : 	for	(i=0; i<first; i++)

  00040	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00047	eb 09		 jmp	 SHORT $LN4@consumeIni
$LN2@consumeIni:
  00049	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  0004c	83 c2 01	 add	 edx, 1
  0004f	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
$LN4@consumeIni:
  00052	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00055	3b 45 fc	 cmp	 eax, DWORD PTR _first$[ebp]
  00058	7d 3e		 jge	 SHORT $LN3@consumeIni

; 426  : 	{
; 427  : 		ts->debugger->consumeHiddenToken(ts->debugger, ts->get(ts, i));

  0005a	8b f4		 mov	 esi, esp
  0005c	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  0005f	51		 push	 ecx
  00060	8b 55 f4	 mov	 edx, DWORD PTR _ts$[ebp]
  00063	52		 push	 edx
  00064	8b 45 f4	 mov	 eax, DWORD PTR _ts$[ebp]
  00067	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0006a	ff d1		 call	 ecx
  0006c	83 c4 08	 add	 esp, 8
  0006f	3b f4		 cmp	 esi, esp
  00071	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00076	8b f4		 mov	 esi, esp
  00078	50		 push	 eax
  00079	8b 55 f4	 mov	 edx, DWORD PTR _ts$[ebp]
  0007c	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0007f	50		 push	 eax
  00080	8b 4d f4	 mov	 ecx, DWORD PTR _ts$[ebp]
  00083	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00086	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  00089	ff d0		 call	 eax
  0008b	83 c4 08	 add	 esp, 8
  0008e	3b f4		 cmp	 esi, esp
  00090	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00095	90		 npad	 1

; 428  : 	}

  00096	eb b1		 jmp	 SHORT $LN2@consumeIni
$LN3@consumeIni:

; 429  : 
; 430  : 	ts->initialStreamState = ANTLR3_FALSE;

  00098	8b 4d f4	 mov	 ecx, DWORD PTR _ts$[ebp]
  0009b	c6 41 10 00	 mov	 BYTE PTR [ecx+16], 0

; 431  : 
; 432  : }

  0009f	5e		 pop	 esi
  000a0	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a3	3b ec		 cmp	 ebp, esp
  000a5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000aa	8b e5		 mov	 esp, ebp
  000ac	5d		 pop	 ebp
  000ad	c3		 ret	 0
_consumeInitialHiddenTokens ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3tokenstream.c
;	COMDAT _antlr3TokenStreamNew
_TEXT	SEGMENT
_stream$ = -4						; size = 4
_antlr3TokenStreamNew PROC				; COMDAT

; 94   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 95   :     pANTLR3_TOKEN_STREAM stream;
; 96   : 
; 97   :     // Memory for the interface structure
; 98   :     //
; 99   :     stream  = (pANTLR3_TOKEN_STREAM) ANTLR3_MALLOC(sizeof(ANTLR3_TOKEN_STREAM));

  0000c	8b f4		 mov	 esi, esp
  0000e	6a 38		 push	 56			; 00000038H
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00016	83 c4 04	 add	 esp, 4
  00019	3b f4		 cmp	 esi, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	89 45 fc	 mov	 DWORD PTR _stream$[ebp], eax

; 100  : 
; 101  :     if	(stream == NULL)

  00023	83 7d fc 00	 cmp	 DWORD PTR _stream$[ebp], 0
  00027	75 04		 jne	 SHORT $LN2@antlr3Toke

; 102  :     {
; 103  : 		return	NULL;

  00029	33 c0		 xor	 eax, eax
  0002b	eb 0d		 jmp	 SHORT $LN1@antlr3Toke
$LN2@antlr3Toke:

; 104  :     }
; 105  : 
; 106  :     // Install basic API 
; 107  :     //
; 108  :     stream->free    =  antlr3TokenStreamFree;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  00030	c7 40 34 00 00
	00 00		 mov	 DWORD PTR [eax+52], OFFSET _antlr3TokenStreamFree

; 109  : 
; 110  :     
; 111  :     return stream;

  00037	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
$LN1@antlr3Toke:

; 112  : }

  0003a	5e		 pop	 esi
  0003b	83 c4 04	 add	 esp, 4
  0003e	3b ec		 cmp	 ebp, esp
  00040	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
_antlr3TokenStreamNew ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3tokenstream.c
;	COMDAT _LB
_TEXT	SEGMENT
_n$ = -8						; size = 4
_i$ = -4						; size = 4
_cts$ = 8						; size = 4
_k$ = 12						; size = 4
_LB	PROC						; COMDAT

; 455  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 456  :     ANTLR3_INT32 i;
; 457  :     ANTLR3_INT32 n;
; 458  : 
; 459  :     if (cts->p == -1)

  00014	8b 45 08	 mov	 eax, DWORD PTR _cts$[ebp]
  00017	83 78 1c ff	 cmp	 DWORD PTR [eax+28], -1
  0001b	75 0c		 jne	 SHORT $LN4@LB

; 460  :     {
; 461  :         fillBuffer(cts);

  0001d	8b 4d 08	 mov	 ecx, DWORD PTR _cts$[ebp]
  00020	51		 push	 ecx
  00021	e8 00 00 00 00	 call	 _fillBuffer
  00026	83 c4 04	 add	 esp, 4
$LN4@LB:

; 462  :     }
; 463  :     if (k == 0)

  00029	83 7d 0c 00	 cmp	 DWORD PTR _k$[ebp], 0
  0002d	75 04		 jne	 SHORT $LN5@LB

; 464  :     {
; 465  :         return NULL;

  0002f	33 c0		 xor	 eax, eax
  00031	eb 60		 jmp	 SHORT $LN1@LB
$LN5@LB:

; 466  :     }
; 467  :     if ((cts->p - k) < 0)

  00033	8b 55 08	 mov	 edx, DWORD PTR _cts$[ebp]
  00036	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00039	2b 45 0c	 sub	 eax, DWORD PTR _k$[ebp]
  0003c	79 04		 jns	 SHORT $LN6@LB

; 468  :     {
; 469  :         return NULL;

  0003e	33 c0		 xor	 eax, eax
  00040	eb 51		 jmp	 SHORT $LN1@LB
$LN6@LB:

; 470  :     }
; 471  : 
; 472  :     i = cts->p;

  00042	8b 4d 08	 mov	 ecx, DWORD PTR _cts$[ebp]
  00045	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00048	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx

; 473  :     n = 1;

  0004b	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _n$[ebp], 1
$LN2@LB:

; 474  : 
; 475  :     /* Need to find k good tokens, going backwards, skipping ones that are off channel
; 476  :      */
; 477  :     while (n <= (ANTLR3_INT32) k)

  00052	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  00055	3b 45 0c	 cmp	 eax, DWORD PTR _k$[ebp]
  00058	7f 21		 jg	 SHORT $LN3@LB

; 478  :     {
; 479  :         /* Skip off-channel tokens
; 480  :          */
; 481  : 
; 482  :         i = skipOffTokenChannelsReverse(cts, i - 1); /* leave p on valid token    */

  0005a	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0005d	83 e9 01	 sub	 ecx, 1
  00060	51		 push	 ecx
  00061	8b 55 08	 mov	 edx, DWORD PTR _cts$[ebp]
  00064	52		 push	 edx
  00065	e8 00 00 00 00	 call	 _skipOffTokenChannelsReverse
  0006a	83 c4 08	 add	 esp, 8
  0006d	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax

; 483  :         n++;

  00070	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  00073	83 c0 01	 add	 eax, 1
  00076	89 45 f8	 mov	 DWORD PTR _n$[ebp], eax

; 484  :     }

  00079	eb d7		 jmp	 SHORT $LN2@LB
$LN3@LB:

; 485  :     if (i < 0)

  0007b	83 7d fc 00	 cmp	 DWORD PTR _i$[ebp], 0
  0007f	7d 04		 jge	 SHORT $LN7@LB

; 486  :     {
; 487  :         return NULL;

  00081	33 c0		 xor	 eax, eax
  00083	eb 0e		 jmp	 SHORT $LN1@LB
$LN7@LB:

; 488  :     }
; 489  : 	// Here the token must be in the input vector. Rather then incut
; 490  : 	// function call penalty, we jsut return the pointer directly
; 491  : 	// from the vector
; 492  : 	//
; 493  : 	return  (pANTLR3_COMMON_TOKEN)cts->tokens->elements[i].element;

  00085	8b 4d 08	 mov	 ecx, DWORD PTR _cts$[ebp]
  00088	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0008b	8b 02		 mov	 eax, DWORD PTR [edx]
  0008d	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00090	8b 04 c8	 mov	 eax, DWORD PTR [eax+ecx*8]
$LN1@LB:

; 494  : }

  00093	83 c4 08	 add	 esp, 8
  00096	3b ec		 cmp	 ebp, esp
  00098	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	c3		 ret	 0
_LB	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3tokenstream.c
;	COMDAT _skipOffTokenChannelsReverse
_TEXT	SEGMENT
_tok$ = -4						; size = 4
_tokenStream$ = 8					; size = 4
_x$ = 12						; size = 4
_skipOffTokenChannelsReverse PROC			; COMDAT

; 1056 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
$LN2@skipOffTok:

; 1057 :     pANTLR3_COMMON_TOKEN tok;
; 1058 : 
; 1059 :     while (x >= 0)

  00004	83 7d 0c 00	 cmp	 DWORD PTR _x$[ebp], 0
  00008	7c 31		 jl	 SHORT $LN3@skipOffTok

; 1060 :     {
; 1061 :         tok =  (pANTLR3_COMMON_TOKEN)tokenStream->tokens->elements[x].element;

  0000a	8b 45 08	 mov	 eax, DWORD PTR _tokenStream$[ebp]
  0000d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00010	8b 11		 mov	 edx, DWORD PTR [ecx]
  00012	8b 45 0c	 mov	 eax, DWORD PTR _x$[ebp]
  00015	8b 0c c2	 mov	 ecx, DWORD PTR [edx+eax*8]
  00018	89 4d fc	 mov	 DWORD PTR _tok$[ebp], ecx

; 1062 :         
; 1063 :         if ((tok->channel != tokenStream->channel))

  0001b	8b 55 fc	 mov	 edx, DWORD PTR _tok$[ebp]
  0001e	8b 45 08	 mov	 eax, DWORD PTR _tokenStream$[ebp]
  00021	8b 4a 18	 mov	 ecx, DWORD PTR [edx+24]
  00024	3b 48 14	 cmp	 ecx, DWORD PTR [eax+20]
  00027	74 0b		 je	 SHORT $LN4@skipOffTok

; 1064 :         {
; 1065 :             x--;

  00029	8b 55 0c	 mov	 edx, DWORD PTR _x$[ebp]
  0002c	83 ea 01	 sub	 edx, 1
  0002f	89 55 0c	 mov	 DWORD PTR _x$[ebp], edx

; 1066 :         }

  00032	eb 05		 jmp	 SHORT $LN5@skipOffTok
$LN4@skipOffTok:

; 1067 :         else
; 1068 :         {
; 1069 :             return x;

  00034	8b 45 0c	 mov	 eax, DWORD PTR _x$[ebp]
  00037	eb 05		 jmp	 SHORT $LN1@skipOffTok
$LN5@skipOffTok:

; 1070 :         }
; 1071 :     }

  00039	eb c9		 jmp	 SHORT $LN2@skipOffTok
$LN3@skipOffTok:

; 1072 :     return x;

  0003b	8b 45 0c	 mov	 eax, DWORD PTR _x$[ebp]
$LN1@skipOffTok:

; 1073 : }

  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
_skipOffTokenChannelsReverse ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3tokenstream.c
;	COMDAT _skipOffTokenChannels
_TEXT	SEGMENT
_tok$ = -8						; size = 4
_n$ = -4						; size = 4
_tokenStream$ = 8					; size = 4
_i$ = 12						; size = 4
_skipOffTokenChannels PROC				; COMDAT

; 1032 : skipOffTokenChannels(pANTLR3_COMMON_TOKEN_STREAM tokenStream, ANTLR3_INT32 i) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1033 :     ANTLR3_INT32 n;
; 1034 :     pANTLR3_COMMON_TOKEN tok;
; 1035 : 
; 1036 :     n = tokenStream->tstream->istream->cachedSize;

  00006	8b 45 08	 mov	 eax, DWORD PTR _tokenStream$[ebp]
  00009	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000b	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0000e	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  00011	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax
$LN2@skipOffTok:

; 1037 : 
; 1038 :     while (i < n)

  00014	8b 4d 0c	 mov	 ecx, DWORD PTR _i$[ebp]
  00017	3b 4d fc	 cmp	 ecx, DWORD PTR _n$[ebp]
  0001a	7d 31		 jge	 SHORT $LN3@skipOffTok

; 1039 :     {
; 1040 :         tok =  (pANTLR3_COMMON_TOKEN)tokenStream->tokens->elements[i].element;

  0001c	8b 55 08	 mov	 edx, DWORD PTR _tokenStream$[ebp]
  0001f	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00022	8b 08		 mov	 ecx, DWORD PTR [eax]
  00024	8b 55 0c	 mov	 edx, DWORD PTR _i$[ebp]
  00027	8b 04 d1	 mov	 eax, DWORD PTR [ecx+edx*8]
  0002a	89 45 f8	 mov	 DWORD PTR _tok$[ebp], eax

; 1041 : 
; 1042 :         if (tok->channel!= tokenStream->channel)

  0002d	8b 4d f8	 mov	 ecx, DWORD PTR _tok$[ebp]
  00030	8b 55 08	 mov	 edx, DWORD PTR _tokenStream$[ebp]
  00033	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00036	3b 42 14	 cmp	 eax, DWORD PTR [edx+20]
  00039	74 0b		 je	 SHORT $LN4@skipOffTok

; 1043 :         {
; 1044 :             i++;

  0003b	8b 4d 0c	 mov	 ecx, DWORD PTR _i$[ebp]
  0003e	83 c1 01	 add	 ecx, 1
  00041	89 4d 0c	 mov	 DWORD PTR _i$[ebp], ecx

; 1045 :         }

  00044	eb 05		 jmp	 SHORT $LN5@skipOffTok
$LN4@skipOffTok:

; 1046 :         else
; 1047 :         {
; 1048 :             return i;

  00046	8b 45 0c	 mov	 eax, DWORD PTR _i$[ebp]
  00049	eb 05		 jmp	 SHORT $LN1@skipOffTok
$LN5@skipOffTok:

; 1049 :         }
; 1050 :     }

  0004b	eb c7		 jmp	 SHORT $LN2@skipOffTok
$LN3@skipOffTok:

; 1051 :     return i;

  0004d	8b 45 0c	 mov	 eax, DWORD PTR _i$[ebp]
$LN1@skipOffTok:

; 1052 : }

  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
_skipOffTokenChannels ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3tokenstream.c
;	COMDAT _fillBuffer
_TEXT	SEGMENT
_channelI$ = -16					; size = 4
_discard$ = -9						; size = 1
_tok$ = -8						; size = 4
_index$ = -4						; size = 4
_tokenStream$ = 8					; size = 4
_fillBuffer PROC					; COMDAT

; 950  : fillBuffer(pANTLR3_COMMON_TOKEN_STREAM tokenStream) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000f	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00012	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00015	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 951  :     ANTLR3_UINT32 index;
; 952  :     pANTLR3_COMMON_TOKEN tok;
; 953  :     ANTLR3_BOOLEAN discard;
; 954  :     void * channelI;
; 955  : 
; 956  :     /* Start at index 0 of course
; 957  :      */
; 958  :     index = 0;

  00018	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _index$[ebp], 0

; 959  : 
; 960  :     /* Pick out the next token from the token source
; 961  :      * Remember we just get a pointer (reference if you like) here
; 962  :      * and so if we store it anywhere, we don't set any pointers to auto free it.
; 963  :      */
; 964  :     tok = tokenStream->tstream->tokenSource->nextToken(tokenStream->tstream->tokenSource);

  0001f	8b 45 08	 mov	 eax, DWORD PTR _tokenStream$[ebp]
  00022	8b 08		 mov	 ecx, DWORD PTR [eax]
  00024	8b f4		 mov	 esi, esp
  00026	8b 11		 mov	 edx, DWORD PTR [ecx]
  00028	52		 push	 edx
  00029	8b 45 08	 mov	 eax, DWORD PTR _tokenStream$[ebp]
  0002c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00030	8b 02		 mov	 eax, DWORD PTR [edx]
  00032	ff d0		 call	 eax
  00034	83 c4 04	 add	 esp, 4
  00037	3b f4		 cmp	 esi, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	89 45 f8	 mov	 DWORD PTR _tok$[ebp], eax
$LN2@fillBuffer:

; 965  : 
; 966  :     while (tok != NULL && tok->type != ANTLR3_TOKEN_EOF)

  00041	83 7d f8 00	 cmp	 DWORD PTR _tok$[ebp], 0
  00045	0f 84 85 01 00
	00		 je	 $LN3@fillBuffer
  0004b	8b 4d f8	 mov	 ecx, DWORD PTR _tok$[ebp]
  0004e	83 39 ff	 cmp	 DWORD PTR [ecx], -1
  00051	0f 84 79 01 00
	00		 je	 $LN3@fillBuffer

; 967  :     {
; 968  :         discard = ANTLR3_FALSE; /* Assume we are not discarding	*/

  00057	c6 45 f7 00	 mov	 BYTE PTR _discard$[ebp], 0

; 969  : 
; 970  :         /* I employ a bit of a trick, or perhaps hack here. Rather than
; 971  :          * store a pointer to a structure in the override map and discard set
; 972  :          * we store the value + 1 cast to a void *. Hence on systems where NULL = (void *)0
; 973  :          * we can distinguish "not being there" from "being channel or type 0"
; 974  :          */
; 975  : 
; 976  :         if (tokenStream->discardSet != NULL
; 977  :             && tokenStream->discardSet->get(tokenStream->discardSet, tok->getType(tok)) != NULL)

  0005b	8b 55 08	 mov	 edx, DWORD PTR _tokenStream$[ebp]
  0005e	83 7a 10 00	 cmp	 DWORD PTR [edx+16], 0
  00062	74 44		 je	 SHORT $LN4@fillBuffer
  00064	8b f4		 mov	 esi, esp
  00066	8b 45 f8	 mov	 eax, DWORD PTR _tok$[ebp]
  00069	50		 push	 eax
  0006a	8b 4d f8	 mov	 ecx, DWORD PTR _tok$[ebp]
  0006d	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  00070	ff d2		 call	 edx
  00072	83 c4 04	 add	 esp, 4
  00075	3b f4		 cmp	 esi, esp
  00077	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007c	8b f4		 mov	 esi, esp
  0007e	50		 push	 eax
  0007f	8b 45 08	 mov	 eax, DWORD PTR _tokenStream$[ebp]
  00082	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00085	51		 push	 ecx
  00086	8b 55 08	 mov	 edx, DWORD PTR _tokenStream$[ebp]
  00089	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0008c	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0008f	ff d1		 call	 ecx
  00091	83 c4 08	 add	 esp, 8
  00094	3b f4		 cmp	 esi, esp
  00096	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009b	85 c0		 test	 eax, eax
  0009d	74 09		 je	 SHORT $LN4@fillBuffer

; 978  :         {
; 979  :             discard = ANTLR3_TRUE;

  0009f	c6 45 f7 01	 mov	 BYTE PTR _discard$[ebp], 1

; 980  :         }

  000a3	e9 9e 00 00 00	 jmp	 $LN9@fillBuffer
$LN4@fillBuffer:

; 981  :         else if (   tokenStream->discardOffChannel == ANTLR3_TRUE
; 982  :                  && tok->getChannel(tok) != tokenStream->channel

  000a8	8b 55 08	 mov	 edx, DWORD PTR _tokenStream$[ebp]
  000ab	0f b6 42 18	 movzx	 eax, BYTE PTR [edx+24]
  000af	83 f8 01	 cmp	 eax, 1
  000b2	75 26		 jne	 SHORT $LN6@fillBuffer
  000b4	8b f4		 mov	 esi, esp
  000b6	8b 4d f8	 mov	 ecx, DWORD PTR _tok$[ebp]
  000b9	51		 push	 ecx
  000ba	8b 55 f8	 mov	 edx, DWORD PTR _tok$[ebp]
  000bd	8b 42 6c	 mov	 eax, DWORD PTR [edx+108]
  000c0	ff d0		 call	 eax
  000c2	83 c4 04	 add	 esp, 4
  000c5	3b f4		 cmp	 esi, esp
  000c7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000cc	8b 4d 08	 mov	 ecx, DWORD PTR _tokenStream$[ebp]
  000cf	3b 41 14	 cmp	 eax, DWORD PTR [ecx+20]
  000d2	74 06		 je	 SHORT $LN6@fillBuffer

; 983  :                  )
; 984  :         {
; 985  :             discard = ANTLR3_TRUE;

  000d4	c6 45 f7 01	 mov	 BYTE PTR _discard$[ebp], 1

; 986  :         }

  000d8	eb 6c		 jmp	 SHORT $LN9@fillBuffer
$LN6@fillBuffer:

; 987  :         else if (tokenStream->channelOverrides != NULL)

  000da	8b 55 08	 mov	 edx, DWORD PTR _tokenStream$[ebp]
  000dd	83 7a 0c 00	 cmp	 DWORD PTR [edx+12], 0
  000e1	74 63		 je	 SHORT $LN9@fillBuffer

; 988  :         {
; 989  :             /* See if this type is in the override map
; 990  :              */
; 991  :             channelI = tokenStream->channelOverrides->get(tokenStream->channelOverrides, tok->getType(tok) + 1);

  000e3	8b f4		 mov	 esi, esp
  000e5	8b 45 f8	 mov	 eax, DWORD PTR _tok$[ebp]
  000e8	50		 push	 eax
  000e9	8b 4d f8	 mov	 ecx, DWORD PTR _tok$[ebp]
  000ec	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  000ef	ff d2		 call	 edx
  000f1	83 c4 04	 add	 esp, 4
  000f4	3b f4		 cmp	 esi, esp
  000f6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000fb	83 c0 01	 add	 eax, 1
  000fe	8b f4		 mov	 esi, esp
  00100	50		 push	 eax
  00101	8b 45 08	 mov	 eax, DWORD PTR _tokenStream$[ebp]
  00104	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00107	51		 push	 ecx
  00108	8b 55 08	 mov	 edx, DWORD PTR _tokenStream$[ebp]
  0010b	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0010e	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00111	ff d1		 call	 ecx
  00113	83 c4 08	 add	 esp, 8
  00116	3b f4		 cmp	 esi, esp
  00118	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0011d	89 45 f0	 mov	 DWORD PTR _channelI$[ebp], eax

; 992  : 
; 993  :             if (channelI != NULL)

  00120	83 7d f0 00	 cmp	 DWORD PTR _channelI$[ebp], 0
  00124	74 20		 je	 SHORT $LN9@fillBuffer

; 994  :             {
; 995  :                 /* Override found
; 996  :                  */
; 997  :                 tok->setChannel(tok, ANTLR3_UINT32_CAST(channelI) - 1);

  00126	8b 55 f0	 mov	 edx, DWORD PTR _channelI$[ebp]
  00129	83 ea 01	 sub	 edx, 1
  0012c	8b f4		 mov	 esi, esp
  0012e	52		 push	 edx
  0012f	8b 45 f8	 mov	 eax, DWORD PTR _tok$[ebp]
  00132	50		 push	 eax
  00133	8b 4d f8	 mov	 ecx, DWORD PTR _tok$[ebp]
  00136	8b 51 70	 mov	 edx, DWORD PTR [ecx+112]
  00139	ff d2		 call	 edx
  0013b	83 c4 08	 add	 esp, 8
  0013e	3b f4		 cmp	 esi, esp
  00140	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00145	90		 npad	 1
$LN9@fillBuffer:

; 998  :             }
; 999  :         }
; 1000 : 
; 1001 :         /* If not discarding it, add it to the list at the current index
; 1002 :          */
; 1003 :         if (discard == ANTLR3_FALSE)

  00146	0f b6 45 f7	 movzx	 eax, BYTE PTR _discard$[ebp]
  0014a	85 c0		 test	 eax, eax
  0014c	75 5b		 jne	 SHORT $LN10@fillBuffer

; 1004 :         {
; 1005 :             /* Add it, indicating that we will delete it and the table should not
; 1006 :              */
; 1007 :             tok->setTokenIndex(tok, index);

  0014e	8b f4		 mov	 esi, esp
  00150	8b 4d fc	 mov	 ecx, DWORD PTR _index$[ebp]
  00153	51		 push	 ecx
  00154	8b 55 f8	 mov	 edx, DWORD PTR _tok$[ebp]
  00157	52		 push	 edx
  00158	8b 45 f8	 mov	 eax, DWORD PTR _tok$[ebp]
  0015b	8b 48 78	 mov	 ecx, DWORD PTR [eax+120]
  0015e	ff d1		 call	 ecx
  00160	83 c4 08	 add	 esp, 8
  00163	3b f4		 cmp	 esi, esp
  00165	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1008 :             tokenStream->p++;

  0016a	8b 55 08	 mov	 edx, DWORD PTR _tokenStream$[ebp]
  0016d	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00170	83 c0 01	 add	 eax, 1
  00173	8b 4d 08	 mov	 ecx, DWORD PTR _tokenStream$[ebp]
  00176	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 1009 :             tokenStream->tokens->add(tokenStream->tokens, (void *) tok, NULL);

  00179	8b f4		 mov	 esi, esp
  0017b	6a 00		 push	 0
  0017d	8b 55 f8	 mov	 edx, DWORD PTR _tok$[ebp]
  00180	52		 push	 edx
  00181	8b 45 08	 mov	 eax, DWORD PTR _tokenStream$[ebp]
  00184	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00187	51		 push	 ecx
  00188	8b 55 08	 mov	 edx, DWORD PTR _tokenStream$[ebp]
  0018b	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0018e	8b 88 a8 00 00
	00		 mov	 ecx, DWORD PTR [eax+168]
  00194	ff d1		 call	 ecx
  00196	83 c4 0c	 add	 esp, 12			; 0000000cH
  00199	3b f4		 cmp	 esi, esp
  0019b	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1010 :             index++;

  001a0	8b 55 fc	 mov	 edx, DWORD PTR _index$[ebp]
  001a3	83 c2 01	 add	 edx, 1
  001a6	89 55 fc	 mov	 DWORD PTR _index$[ebp], edx
$LN10@fillBuffer:

; 1011 :         }
; 1012 : 
; 1013 :         tok = tokenStream->tstream->tokenSource->nextToken(tokenStream->tstream->tokenSource);

  001a9	8b 45 08	 mov	 eax, DWORD PTR _tokenStream$[ebp]
  001ac	8b 08		 mov	 ecx, DWORD PTR [eax]
  001ae	8b f4		 mov	 esi, esp
  001b0	8b 11		 mov	 edx, DWORD PTR [ecx]
  001b2	52		 push	 edx
  001b3	8b 45 08	 mov	 eax, DWORD PTR _tokenStream$[ebp]
  001b6	8b 08		 mov	 ecx, DWORD PTR [eax]
  001b8	8b 11		 mov	 edx, DWORD PTR [ecx]
  001ba	8b 02		 mov	 eax, DWORD PTR [edx]
  001bc	ff d0		 call	 eax
  001be	83 c4 04	 add	 esp, 4
  001c1	3b f4		 cmp	 esi, esp
  001c3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001c8	89 45 f8	 mov	 DWORD PTR _tok$[ebp], eax

; 1014 :     }

  001cb	e9 71 fe ff ff	 jmp	 $LN2@fillBuffer
$LN3@fillBuffer:

; 1015 : 
; 1016 :     /* Cache the size so we don't keep doing indirect method calls. We do this as
; 1017 :      * early as possible so that anything after this may utilize the cached value.
; 1018 :      */
; 1019 :     tokenStream->tstream->istream->cachedSize = tokenStream->tokens->count;

  001d0	8b 4d 08	 mov	 ecx, DWORD PTR _tokenStream$[ebp]
  001d3	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  001d6	8b 45 08	 mov	 eax, DWORD PTR _tokenStream$[ebp]
  001d9	8b 08		 mov	 ecx, DWORD PTR [eax]
  001db	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  001de	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  001e1	89 48 38	 mov	 DWORD PTR [eax+56], ecx

; 1020 : 
; 1021 :     /* Set the consume pointer to the first token that is on our channel
; 1022 :      */
; 1023 :     tokenStream->p = 0;

  001e4	8b 55 08	 mov	 edx, DWORD PTR _tokenStream$[ebp]
  001e7	c7 42 1c 00 00
	00 00		 mov	 DWORD PTR [edx+28], 0

; 1024 :     tokenStream->p = skipOffTokenChannels(tokenStream, tokenStream->p);

  001ee	8b 45 08	 mov	 eax, DWORD PTR _tokenStream$[ebp]
  001f1	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  001f4	51		 push	 ecx
  001f5	8b 55 08	 mov	 edx, DWORD PTR _tokenStream$[ebp]
  001f8	52		 push	 edx
  001f9	e8 00 00 00 00	 call	 _skipOffTokenChannels
  001fe	83 c4 08	 add	 esp, 8
  00201	8b 4d 08	 mov	 ecx, DWORD PTR _tokenStream$[ebp]
  00204	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 1025 : 
; 1026 : }

  00207	5e		 pop	 esi
  00208	83 c4 10	 add	 esp, 16			; 00000010H
  0020b	3b ec		 cmp	 ebp, esp
  0020d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00212	8b e5		 mov	 esp, ebp
  00214	5d		 pop	 ebp
  00215	c3		 ret	 0
_fillBuffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3tokenstream.c
;	COMDAT _antlr3CTSFree
_TEXT	SEGMENT
_stream$ = 8						; size = 4
_antlr3CTSFree PROC					; COMDAT

; 122  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 123  : 	// We only free up our subordinate interfaces if they belong
; 124  : 	// to us, otherwise we let whoever owns them deal with them.
; 125  : 	//
; 126  : 	if	(stream->tstream->super == stream)

  00004	8b 45 08	 mov	 eax, DWORD PTR _stream$[ebp]
  00007	8b 08		 mov	 ecx, DWORD PTR [eax]
  00009	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0000c	3b 55 08	 cmp	 edx, DWORD PTR _stream$[ebp]
  0000f	75 5d		 jne	 SHORT $LN2@antlr3CTSF

; 127  : 	{
; 128  : 		if	(stream->tstream->istream->super == stream->tstream)

  00011	8b 45 08	 mov	 eax, DWORD PTR _stream$[ebp]
  00014	8b 08		 mov	 ecx, DWORD PTR [eax]
  00016	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00019	8b 45 08	 mov	 eax, DWORD PTR _stream$[ebp]
  0001c	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  0001f	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00021	75 2e		 jne	 SHORT $LN3@antlr3CTSF

; 129  : 		{
; 130  : 			stream->tstream->istream->free(stream->tstream->istream);

  00023	8b 55 08	 mov	 edx, DWORD PTR _stream$[ebp]
  00026	8b 02		 mov	 eax, DWORD PTR [edx]
  00028	8b f4		 mov	 esi, esp
  0002a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0002d	51		 push	 ecx
  0002e	8b 55 08	 mov	 edx, DWORD PTR _stream$[ebp]
  00031	8b 02		 mov	 eax, DWORD PTR [edx]
  00033	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00036	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  00039	ff d2		 call	 edx
  0003b	83 c4 04	 add	 esp, 4
  0003e	3b f4		 cmp	 esi, esp
  00040	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 131  : 			stream->tstream->istream = NULL;

  00045	8b 45 08	 mov	 eax, DWORD PTR _stream$[ebp]
  00048	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004a	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
$LN3@antlr3CTSF:

; 132  : 		}
; 133  : 		stream->tstream->free(stream->tstream);

  00051	8b f4		 mov	 esi, esp
  00053	8b 55 08	 mov	 edx, DWORD PTR _stream$[ebp]
  00056	8b 02		 mov	 eax, DWORD PTR [edx]
  00058	50		 push	 eax
  00059	8b 4d 08	 mov	 ecx, DWORD PTR _stream$[ebp]
  0005c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005e	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00061	ff d0		 call	 eax
  00063	83 c4 04	 add	 esp, 4
  00066	3b f4		 cmp	 esi, esp
  00068	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006d	90		 npad	 1
$LN2@antlr3CTSF:

; 134  : 	}
; 135  : 
; 136  : 	// Now we free our own resources
; 137  : 	//
; 138  : 	if	(stream->tokens != NULL)

  0006e	8b 4d 08	 mov	 ecx, DWORD PTR _stream$[ebp]
  00071	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  00075	74 2b		 je	 SHORT $LN4@antlr3CTSF

; 139  : 	{
; 140  : 		stream->tokens->free(stream->tokens);

  00077	8b f4		 mov	 esi, esp
  00079	8b 55 08	 mov	 edx, DWORD PTR _stream$[ebp]
  0007c	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0007f	50		 push	 eax
  00080	8b 4d 08	 mov	 ecx, DWORD PTR _stream$[ebp]
  00083	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00086	8b 82 90 00 00
	00		 mov	 eax, DWORD PTR [edx+144]
  0008c	ff d0		 call	 eax
  0008e	83 c4 04	 add	 esp, 4
  00091	3b f4		 cmp	 esi, esp
  00093	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 141  : 		stream->tokens	= NULL;

  00098	8b 4d 08	 mov	 ecx, DWORD PTR _stream$[ebp]
  0009b	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
$LN4@antlr3CTSF:

; 142  : 	}
; 143  : 	if	(stream->discardSet != NULL)

  000a2	8b 55 08	 mov	 edx, DWORD PTR _stream$[ebp]
  000a5	83 7a 10 00	 cmp	 DWORD PTR [edx+16], 0
  000a9	74 28		 je	 SHORT $LN5@antlr3CTSF

; 144  : 	{
; 145  : 		stream->discardSet->free(stream->discardSet);

  000ab	8b f4		 mov	 esi, esp
  000ad	8b 45 08	 mov	 eax, DWORD PTR _stream$[ebp]
  000b0	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  000b3	51		 push	 ecx
  000b4	8b 55 08	 mov	 edx, DWORD PTR _stream$[ebp]
  000b7	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  000ba	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000bd	ff d1		 call	 ecx
  000bf	83 c4 04	 add	 esp, 4
  000c2	3b f4		 cmp	 esi, esp
  000c4	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 146  : 		stream->discardSet  = NULL;

  000c9	8b 55 08	 mov	 edx, DWORD PTR _stream$[ebp]
  000cc	c7 42 10 00 00
	00 00		 mov	 DWORD PTR [edx+16], 0
$LN5@antlr3CTSF:

; 147  : 	}
; 148  : 	if	(stream->channelOverrides != NULL)

  000d3	8b 45 08	 mov	 eax, DWORD PTR _stream$[ebp]
  000d6	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  000da	74 28		 je	 SHORT $LN6@antlr3CTSF

; 149  : 	{
; 150  : 		stream->channelOverrides->free(stream->channelOverrides);

  000dc	8b f4		 mov	 esi, esp
  000de	8b 4d 08	 mov	 ecx, DWORD PTR _stream$[ebp]
  000e1	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  000e4	52		 push	 edx
  000e5	8b 45 08	 mov	 eax, DWORD PTR _stream$[ebp]
  000e8	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000eb	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000ee	ff d2		 call	 edx
  000f0	83 c4 04	 add	 esp, 4
  000f3	3b f4		 cmp	 esi, esp
  000f5	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 151  : 		stream->channelOverrides = NULL;

  000fa	8b 45 08	 mov	 eax, DWORD PTR _stream$[ebp]
  000fd	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
$LN6@antlr3CTSF:

; 152  : 	}
; 153  : 
; 154  : 	// Free our memory now
; 155  : 	//
; 156  : 	ANTLR3_FREE(stream);

  00104	8b f4		 mov	 esi, esp
  00106	8b 4d 08	 mov	 ecx, DWORD PTR _stream$[ebp]
  00109	51		 push	 ecx
  0010a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00110	83 c4 04	 add	 esp, 4
  00113	3b f4		 cmp	 esi, esp
  00115	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0011a	90		 npad	 1

; 157  : }

  0011b	5e		 pop	 esi
  0011c	3b ec		 cmp	 ebp, esp
  0011e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00123	5d		 pop	 ebp
  00124	c3		 ret	 0
_antlr3CTSFree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3tokenstream.c
;	COMDAT _antlr3TokenStreamFree
_TEXT	SEGMENT
_stream$ = 8						; size = 4
_antlr3TokenStreamFree PROC				; COMDAT

; 116  : {   

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 117  :     ANTLR3_FREE(stream);

  00004	8b f4		 mov	 esi, esp
  00006	8b 45 08	 mov	 eax, DWORD PTR _stream$[ebp]
  00009	50		 push	 eax
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00010	83 c4 04	 add	 esp, 4
  00013	3b f4		 cmp	 esi, esp
  00015	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001a	90		 npad	 1

; 118  : }

  0001b	5e		 pop	 esi
  0001c	3b ec		 cmp	 ebp, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
_antlr3TokenStreamFree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3tokenstream.c
;	COMDAT _getSourceName
_TEXT	SEGMENT
_is$ = 8						; size = 4
_getSourceName PROC					; COMDAT

; 1084 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1085 : 	// Slightly convoluted as we must trace back to the lexer's input source
; 1086 : 	// via the token source. The streamName that is here is not initialized
; 1087 : 	// because this is a token stream, not a file or string stream, which are the
; 1088 : 	// only things that have a context for a source name.
; 1089 : 	//
; 1090 : 	return ((pANTLR3_TOKEN_STREAM)(is->super))->tokenSource->fileName;

  00003	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  00006	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00009	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000b	8b 82 2c 01 00
	00		 mov	 eax, DWORD PTR [edx+300]

; 1091 : }

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
_getSourceName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3tokenstream.c
;	COMDAT _dbgSeek
_TEXT	SEGMENT
_is$ = 8						; size = 4
_index$ = 12						; size = 4
_dbgSeek PROC						; COMDAT

; 939  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 940  : 	// TODO: Implement seek in debugger when Ter adds it to Java
; 941  : 	//
; 942  : 	seek(is, index);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _index$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _is$[ebp]
  0000a	51		 push	 ecx
  0000b	e8 00 00 00 00	 call	 _seek
  00010	83 c4 08	 add	 esp, 8

; 943  : }

  00013	3b ec		 cmp	 ebp, esp
  00015	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
_dbgSeek ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3tokenstream.c
;	COMDAT _seek
_TEXT	SEGMENT
_ts$ = -8						; size = 4
_cts$ = -4						; size = 4
_is$ = 8						; size = 4
_index$ = 12						; size = 4
_seek	PROC						; COMDAT

; 928  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 929  :     pANTLR3_COMMON_TOKEN_STREAM cts;
; 930  :     pANTLR3_TOKEN_STREAM	ts;
; 931  : 
; 932  :     ts	    = (pANTLR3_TOKEN_STREAM)	    is->super;

  00006	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  00009	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000c	89 4d f8	 mov	 DWORD PTR _ts$[ebp], ecx

; 933  :     cts	    = (pANTLR3_COMMON_TOKEN_STREAM) ts->super;

  0000f	8b 55 f8	 mov	 edx, DWORD PTR _ts$[ebp]
  00012	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00015	89 45 fc	 mov	 DWORD PTR _cts$[ebp], eax

; 934  : 
; 935  :     cts->p  = (ANTLR3_UINT32)index;

  00018	8b 4d fc	 mov	 ecx, DWORD PTR _cts$[ebp]
  0001b	8b 55 0c	 mov	 edx, DWORD PTR _index$[ebp]
  0001e	89 51 1c	 mov	 DWORD PTR [ecx+28], edx

; 936  : }

  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
_seek	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3tokenstream.c
;	COMDAT _dbgRewindLast
_TEXT	SEGMENT
_ts$ = -4						; size = 4
_is$ = 8						; size = 4
_dbgRewindLast PROC					; COMDAT

; 895  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 896  : 	pANTLR3_TOKEN_STREAM	ts;
; 897  : 
; 898  :     ts	    = (pANTLR3_TOKEN_STREAM)	    is->super;

  0000c	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  0000f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00012	89 4d fc	 mov	 DWORD PTR _ts$[ebp], ecx

; 899  : 
; 900  : 	ts->debugger->rewindLast(ts->debugger);

  00015	8b f4		 mov	 esi, esp
  00017	8b 55 fc	 mov	 edx, DWORD PTR _ts$[ebp]
  0001a	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0001d	50		 push	 eax
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _ts$[ebp]
  00021	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00024	8b 42 50	 mov	 eax, DWORD PTR [edx+80]
  00027	ff d0		 call	 eax
  00029	83 c4 04	 add	 esp, 4
  0002c	3b f4		 cmp	 esi, esp
  0002e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 901  : 
; 902  :     is->rewind(is, is->lastMarker);

  00033	8b f4		 mov	 esi, esp
  00035	8b 4d 08	 mov	 ecx, DWORD PTR _is$[ebp]
  00038	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0003b	52		 push	 edx
  0003c	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  0003f	50		 push	 eax
  00040	8b 4d 08	 mov	 ecx, DWORD PTR _is$[ebp]
  00043	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00046	ff d2		 call	 edx
  00048	83 c4 08	 add	 esp, 8
  0004b	3b f4		 cmp	 esi, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	90		 npad	 1

; 903  : }

  00053	5e		 pop	 esi
  00054	83 c4 04	 add	 esp, 4
  00057	3b ec		 cmp	 ebp, esp
  00059	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
_dbgRewindLast ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3tokenstream.c
;	COMDAT _rewindLast
_TEXT	SEGMENT
_is$ = 8						; size = 4
_rewindLast PROC					; COMDAT

; 906  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 907  :     is->rewind(is, is->lastMarker);

  00004	8b f4		 mov	 esi, esp
  00006	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  00009	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0000c	51		 push	 ecx
  0000d	8b 55 08	 mov	 edx, DWORD PTR _is$[ebp]
  00010	52		 push	 edx
  00011	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  00014	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00017	ff d1		 call	 ecx
  00019	83 c4 08	 add	 esp, 8
  0001c	3b f4		 cmp	 esi, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	90		 npad	 1

; 908  : }

  00024	5e		 pop	 esi
  00025	3b ec		 cmp	 ebp, esp
  00027	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
_rewindLast ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3tokenstream.c
;	COMDAT _dbgRewindStream
_TEXT	SEGMENT
_ts$ = -4						; size = 4
_is$ = 8						; size = 4
_marker$ = 12						; size = 4
_dbgRewindStream PROC					; COMDAT

; 916  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 917  :     pANTLR3_TOKEN_STREAM	ts;
; 918  : 
; 919  :     ts	    = (pANTLR3_TOKEN_STREAM)	    is->super;

  0000c	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  0000f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00012	89 4d fc	 mov	 DWORD PTR _ts$[ebp], ecx

; 920  : 
; 921  : 	ts->debugger->rewind(ts->debugger, marker);

  00015	8b f4		 mov	 esi, esp
  00017	8b 55 0c	 mov	 edx, DWORD PTR _marker$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _ts$[ebp]
  0001e	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00021	51		 push	 ecx
  00022	8b 55 fc	 mov	 edx, DWORD PTR _ts$[ebp]
  00025	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00028	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  0002b	ff d1		 call	 ecx
  0002d	83 c4 08	 add	 esp, 8
  00030	3b f4		 cmp	 esi, esp
  00032	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 922  : 
; 923  :     is->seek(is, (ANTLR3_UINT32)(marker));

  00037	8b f4		 mov	 esi, esp
  00039	8b 55 0c	 mov	 edx, DWORD PTR _marker$[ebp]
  0003c	52		 push	 edx
  0003d	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  00040	50		 push	 eax
  00041	8b 4d 08	 mov	 ecx, DWORD PTR _is$[ebp]
  00044	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00047	ff d2		 call	 edx
  00049	83 c4 08	 add	 esp, 8
  0004c	3b f4		 cmp	 esi, esp
  0004e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00053	90		 npad	 1

; 924  : }

  00054	5e		 pop	 esi
  00055	83 c4 04	 add	 esp, 4
  00058	3b ec		 cmp	 ebp, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
_dbgRewindStream ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3tokenstream.c
;	COMDAT _rewindStream
_TEXT	SEGMENT
_is$ = 8						; size = 4
_marker$ = 12						; size = 4
_rewindStream PROC					; COMDAT

; 911  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 912  :     is->seek(is, (ANTLR3_UINT32)(marker));

  00004	8b f4		 mov	 esi, esp
  00006	8b 45 0c	 mov	 eax, DWORD PTR _marker$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _is$[ebp]
  0000d	51		 push	 ecx
  0000e	8b 55 08	 mov	 edx, DWORD PTR _is$[ebp]
  00011	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  00014	ff d0		 call	 eax
  00016	83 c4 08	 add	 esp, 8
  00019	3b f4		 cmp	 esi, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	90		 npad	 1

; 913  : }

  00021	5e		 pop	 esi
  00022	3b ec		 cmp	 ebp, esp
  00024	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
_rewindStream ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3tokenstream.c
;	COMDAT _tindex
_TEXT	SEGMENT
_ts$ = -8						; size = 4
_cts$ = -4						; size = 4
_is$ = 8						; size = 4
_tindex	PROC						; COMDAT

; 883  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 884  :     pANTLR3_COMMON_TOKEN_STREAM cts;
; 885  :     pANTLR3_TOKEN_STREAM	ts;
; 886  : 
; 887  :     ts	    = (pANTLR3_TOKEN_STREAM)	    is->super;

  00006	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  00009	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000c	89 4d f8	 mov	 DWORD PTR _ts$[ebp], ecx

; 888  :     cts	    = (pANTLR3_COMMON_TOKEN_STREAM) ts->super;

  0000f	8b 55 f8	 mov	 edx, DWORD PTR _ts$[ebp]
  00012	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00015	89 45 fc	 mov	 DWORD PTR _cts$[ebp], eax

; 889  : 
; 890  :     return  cts->p;

  00018	8b 4d fc	 mov	 ecx, DWORD PTR _cts$[ebp]
  0001b	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]

; 891  : }

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
_tindex	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3tokenstream.c
;	COMDAT _size
_TEXT	SEGMENT
_ts$ = -8						; size = 4
_cts$ = -4						; size = 4
_is$ = 8						; size = 4
_size	PROC						; COMDAT

; 866  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 867  :     pANTLR3_COMMON_TOKEN_STREAM cts;
; 868  :     pANTLR3_TOKEN_STREAM	ts;
; 869  : 
; 870  :     if (is->cachedSize > 0)

  00006	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  00009	83 78 38 00	 cmp	 DWORD PTR [eax+56], 0
  0000d	76 08		 jbe	 SHORT $LN2@size

; 871  :     {
; 872  : 	return  is->cachedSize;

  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _is$[ebp]
  00012	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]
  00015	eb 27		 jmp	 SHORT $LN1@size
$LN2@size:

; 873  :     }
; 874  :     ts	    = (pANTLR3_TOKEN_STREAM)	    is->super;

  00017	8b 55 08	 mov	 edx, DWORD PTR _is$[ebp]
  0001a	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0001d	89 45 f8	 mov	 DWORD PTR _ts$[ebp], eax

; 875  :     cts	    = (pANTLR3_COMMON_TOKEN_STREAM) ts->super;

  00020	8b 4d f8	 mov	 ecx, DWORD PTR _ts$[ebp]
  00023	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00026	89 55 fc	 mov	 DWORD PTR _cts$[ebp], edx

; 876  : 
; 877  :     is->cachedSize =  cts->tokens->count;

  00029	8b 45 fc	 mov	 eax, DWORD PTR _cts$[ebp]
  0002c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0002f	8b 55 08	 mov	 edx, DWORD PTR _is$[ebp]
  00032	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00035	89 42 38	 mov	 DWORD PTR [edx+56], eax

; 878  :     return  is->cachedSize;

  00038	8b 4d 08	 mov	 ecx, DWORD PTR _is$[ebp]
  0003b	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]
$LN1@size:

; 879  : }

  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
_size	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3tokenstream.c
;	COMDAT _release
_TEXT	SEGMENT
_is$ = 8						; size = 4
_mark$ = 12						; size = 4
_release PROC						; COMDAT

; 860  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 861  :     return;
; 862  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
_release ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3tokenstream.c
;	COMDAT _dbgMark
_TEXT	SEGMENT
_ts$ = -4						; size = 4
_is$ = 8						; size = 4
_dbgMark PROC						; COMDAT

; 847  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 848  :     pANTLR3_TOKEN_STREAM    ts;
; 849  :    
; 850  :     ts	    = (pANTLR3_TOKEN_STREAM)	    is->super;

  0000c	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  0000f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00012	89 4d fc	 mov	 DWORD PTR _ts$[ebp], ecx

; 851  : 	
; 852  : 	is->lastMarker = is->index(is);

  00015	8b f4		 mov	 esi, esp
  00017	8b 55 08	 mov	 edx, DWORD PTR _is$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  0001e	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00021	ff d1		 call	 ecx
  00023	83 c4 04	 add	 esp, 4
  00026	3b f4		 cmp	 esi, esp
  00028	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002d	8b 55 08	 mov	 edx, DWORD PTR _is$[ebp]
  00030	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 853  : 	ts->debugger->mark(ts->debugger, is->lastMarker);

  00033	8b f4		 mov	 esi, esp
  00035	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  00038	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0003b	51		 push	 ecx
  0003c	8b 55 fc	 mov	 edx, DWORD PTR _ts$[ebp]
  0003f	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00042	50		 push	 eax
  00043	8b 4d fc	 mov	 ecx, DWORD PTR _ts$[ebp]
  00046	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00049	8b 42 48	 mov	 eax, DWORD PTR [edx+72]
  0004c	ff d0		 call	 eax
  0004e	83 c4 08	 add	 esp, 8
  00051	3b f4		 cmp	 esi, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 854  : 
; 855  :     return  is->lastMarker;

  00058	8b 4d 08	 mov	 ecx, DWORD PTR _is$[ebp]
  0005b	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]

; 856  : }

  0005e	5e		 pop	 esi
  0005f	83 c4 04	 add	 esp, 4
  00062	3b ec		 cmp	 ebp, esp
  00064	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
_dbgMark ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3tokenstream.c
;	COMDAT _mark
_TEXT	SEGMENT
_is$ = 8						; size = 4
_mark	PROC						; COMDAT

; 838  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 839  :     is->lastMarker = is->index(is);

  00004	8b f4		 mov	 esi, esp
  00006	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _is$[ebp]
  0000d	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00010	ff d2		 call	 edx
  00012	83 c4 04	 add	 esp, 4
  00015	3b f4		 cmp	 esi, esp
  00017	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR _is$[ebp]
  0001f	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 840  :     return  is->lastMarker;

  00022	8b 55 08	 mov	 edx, DWORD PTR _is$[ebp]
  00025	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]

; 841  : }

  00028	5e		 pop	 esi
  00029	3b ec		 cmp	 ebp, esp
  0002b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
_mark	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3tokenstream.c
;	COMDAT _dbgLA
_TEXT	SEGMENT
_ts$ = -4						; size = 4
_is$ = 8						; size = 4
_i$ = 12						; size = 4
_dbgLA	PROC						; COMDAT

; 823  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 824  :     pANTLR3_TOKEN_STREAM    ts;
; 825  :    
; 826  :     ts	    = (pANTLR3_TOKEN_STREAM)	    is->super;

  0000c	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  0000f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00012	89 4d fc	 mov	 DWORD PTR _ts$[ebp], ecx

; 827  : 
; 828  : 	if	(ts->initialStreamState == ANTLR3_TRUE)

  00015	8b 55 fc	 mov	 edx, DWORD PTR _ts$[ebp]
  00018	0f b6 42 10	 movzx	 eax, BYTE PTR [edx+16]
  0001c	83 f8 01	 cmp	 eax, 1
  0001f	75 0c		 jne	 SHORT $LN2@dbgLA

; 829  : 	{
; 830  : 		consumeInitialHiddenTokens(is);

  00021	8b 4d 08	 mov	 ecx, DWORD PTR _is$[ebp]
  00024	51		 push	 ecx
  00025	e8 00 00 00 00	 call	 _consumeInitialHiddenTokens
  0002a	83 c4 04	 add	 esp, 4
$LN2@dbgLA:

; 831  : 	}
; 832  : 	ts->debugger->LT(ts->debugger, i, tokLT(ts, i));

  0002d	8b 55 0c	 mov	 edx, DWORD PTR _i$[ebp]
  00030	52		 push	 edx
  00031	8b 45 fc	 mov	 eax, DWORD PTR _ts$[ebp]
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 _tokLT
  0003a	83 c4 08	 add	 esp, 8
  0003d	8b f4		 mov	 esi, esp
  0003f	50		 push	 eax
  00040	8b 4d 0c	 mov	 ecx, DWORD PTR _i$[ebp]
  00043	51		 push	 ecx
  00044	8b 55 fc	 mov	 edx, DWORD PTR _ts$[ebp]
  00047	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0004a	50		 push	 eax
  0004b	8b 4d fc	 mov	 ecx, DWORD PTR _ts$[ebp]
  0004e	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00051	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  00054	ff d0		 call	 eax
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH
  00059	3b f4		 cmp	 esi, esp
  0005b	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 833  : 	return	_LA(is, i);

  00060	8b 4d 0c	 mov	 ecx, DWORD PTR _i$[ebp]
  00063	51		 push	 ecx
  00064	8b 55 08	 mov	 edx, DWORD PTR _is$[ebp]
  00067	52		 push	 edx
  00068	e8 00 00 00 00	 call	 __LA
  0006d	83 c4 08	 add	 esp, 8

; 834  : }

  00070	5e		 pop	 esi
  00071	83 c4 04	 add	 esp, 4
  00074	3b ec		 cmp	 ebp, esp
  00076	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
_dbgLA	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3tokenstream.c
;	COMDAT __LA
_TEXT	SEGMENT
_tok$ = -8						; size = 4
_ts$ = -4						; size = 4
_is$ = 8						; size = 4
_i$ = 12						; size = 4
__LA	PROC						; COMDAT

; 801  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 802  : 	pANTLR3_TOKEN_STREAM    ts;
; 803  : 	pANTLR3_COMMON_TOKEN    tok;
; 804  : 
; 805  : 	ts	    = (pANTLR3_TOKEN_STREAM)	    is->super;

  00015	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  00018	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0001b	89 4d fc	 mov	 DWORD PTR _ts$[ebp], ecx

; 806  : 
; 807  : 	tok	    =  ts->_LT(ts, i);

  0001e	8b f4		 mov	 esi, esp
  00020	8b 55 0c	 mov	 edx, DWORD PTR _i$[ebp]
  00023	52		 push	 edx
  00024	8b 45 fc	 mov	 eax, DWORD PTR _ts$[ebp]
  00027	50		 push	 eax
  00028	8b 4d fc	 mov	 ecx, DWORD PTR _ts$[ebp]
  0002b	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0002e	ff d2		 call	 edx
  00030	83 c4 08	 add	 esp, 8
  00033	3b f4		 cmp	 esi, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	89 45 f8	 mov	 DWORD PTR _tok$[ebp], eax

; 808  : 
; 809  : 	if	(tok != NULL)

  0003d	83 7d f8 00	 cmp	 DWORD PTR _tok$[ebp], 0
  00041	74 1c		 je	 SHORT $LN2@LA

; 810  : 	{
; 811  : 		return	tok->getType(tok);

  00043	8b f4		 mov	 esi, esp
  00045	8b 45 f8	 mov	 eax, DWORD PTR _tok$[ebp]
  00048	50		 push	 eax
  00049	8b 4d f8	 mov	 ecx, DWORD PTR _tok$[ebp]
  0004c	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  0004f	ff d2		 call	 edx
  00051	83 c4 04	 add	 esp, 4
  00054	3b f4		 cmp	 esi, esp
  00056	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005b	eb 04		 jmp	 SHORT $LN3@LA

; 812  : 	}

  0005d	eb 02		 jmp	 SHORT $LN3@LA
$LN2@LA:

; 813  : 	else
; 814  : 	{
; 815  : 		return	ANTLR3_TOKEN_INVALID;

  0005f	33 c0		 xor	 eax, eax
$LN3@LA:

; 816  : 	}
; 817  : }

  00061	5e		 pop	 esi
  00062	83 c4 08	 add	 esp, 8
  00065	3b ec		 cmp	 ebp, esp
  00067	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
__LA	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3tokenstream.c
;	COMDAT _dbgConsume
_TEXT	SEGMENT
_i$1 = -20						; size = 4
_t$ = -16						; size = 4
_b$ = -12						; size = 4
_a$ = -8						; size = 4
_ts$ = -4						; size = 4
_is$ = 8						; size = 4
_dbgConsume PROC					; COMDAT

; 621  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0000f	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00012	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00015	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00018	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 622  : 	pANTLR3_TOKEN_STREAM	ts;
; 623  : 	ANTLR3_MARKER			a;
; 624  : 	ANTLR3_MARKER			b;
; 625  : 	pANTLR3_COMMON_TOKEN	t;
; 626  : 
; 627  : 	ts	    = (pANTLR3_TOKEN_STREAM)	    is->super;

  0001b	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  0001e	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00021	89 4d fc	 mov	 DWORD PTR _ts$[ebp], ecx

; 628  : 
; 629  : 	if	(ts->initialStreamState == ANTLR3_TRUE)

  00024	8b 55 fc	 mov	 edx, DWORD PTR _ts$[ebp]
  00027	0f b6 42 10	 movzx	 eax, BYTE PTR [edx+16]
  0002b	83 f8 01	 cmp	 eax, 1
  0002e	75 0c		 jne	 SHORT $LN5@dbgConsume

; 630  : 	{
; 631  : 		consumeInitialHiddenTokens(is);

  00030	8b 4d 08	 mov	 ecx, DWORD PTR _is$[ebp]
  00033	51		 push	 ecx
  00034	e8 00 00 00 00	 call	 _consumeInitialHiddenTokens
  00039	83 c4 04	 add	 esp, 4
$LN5@dbgConsume:

; 632  : 	}
; 633  : 	
; 634  : 	a = is->index(is);		// Where are we right now?

  0003c	8b f4		 mov	 esi, esp
  0003e	8b 55 08	 mov	 edx, DWORD PTR _is$[ebp]
  00041	52		 push	 edx
  00042	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  00045	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00048	ff d1		 call	 ecx
  0004a	83 c4 04	 add	 esp, 4
  0004d	3b f4		 cmp	 esi, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00054	89 45 f8	 mov	 DWORD PTR _a$[ebp], eax

; 635  : 	t = ts->_LT(ts, 1);		// Current token from stream

  00057	8b f4		 mov	 esi, esp
  00059	6a 01		 push	 1
  0005b	8b 55 fc	 mov	 edx, DWORD PTR _ts$[ebp]
  0005e	52		 push	 edx
  0005f	8b 45 fc	 mov	 eax, DWORD PTR _ts$[ebp]
  00062	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00065	ff d1		 call	 ecx
  00067	83 c4 08	 add	 esp, 8
  0006a	3b f4		 cmp	 esi, esp
  0006c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00071	89 45 f0	 mov	 DWORD PTR _t$[ebp], eax

; 636  : 
; 637  : 	consume(is);			// Standard consumer

  00074	8b 55 08	 mov	 edx, DWORD PTR _is$[ebp]
  00077	52		 push	 edx
  00078	e8 00 00 00 00	 call	 _consume
  0007d	83 c4 04	 add	 esp, 4

; 638  : 
; 639  : 	b = is->index(is);		// Where are we after consuming 1 on channel token?

  00080	8b f4		 mov	 esi, esp
  00082	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  00085	50		 push	 eax
  00086	8b 4d 08	 mov	 ecx, DWORD PTR _is$[ebp]
  00089	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  0008c	ff d2		 call	 edx
  0008e	83 c4 04	 add	 esp, 4
  00091	3b f4		 cmp	 esi, esp
  00093	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00098	89 45 f4	 mov	 DWORD PTR _b$[ebp], eax

; 640  : 
; 641  : 	ts->debugger->consumeToken(ts->debugger, t);	// Tell the debugger that we consumed the first token

  0009b	8b f4		 mov	 esi, esp
  0009d	8b 45 f0	 mov	 eax, DWORD PTR _t$[ebp]
  000a0	50		 push	 eax
  000a1	8b 4d fc	 mov	 ecx, DWORD PTR _ts$[ebp]
  000a4	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  000a7	52		 push	 edx
  000a8	8b 45 fc	 mov	 eax, DWORD PTR _ts$[ebp]
  000ab	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000ae	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  000b1	ff d2		 call	 edx
  000b3	83 c4 08	 add	 esp, 8
  000b6	3b f4		 cmp	 esi, esp
  000b8	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 642  : 
; 643  : 	if	(b>a+1)

  000bd	8b 45 f8	 mov	 eax, DWORD PTR _a$[ebp]
  000c0	83 c0 01	 add	 eax, 1
  000c3	39 45 f4	 cmp	 DWORD PTR _b$[ebp], eax
  000c6	7e 5a		 jle	 SHORT $LN3@dbgConsume

; 644  : 	{
; 645  : 		// The standard consume caused the index to advance by more than 1,
; 646  : 		// which can only happen if it skipped some off-channel tokens.
; 647  : 		// we need to tell the debugger about those tokens.
; 648  : 		//
; 649  : 		ANTLR3_MARKER	i;
; 650  : 
; 651  : 		for	(i = a+1; i<b; i++)

  000c8	8b 4d f8	 mov	 ecx, DWORD PTR _a$[ebp]
  000cb	83 c1 01	 add	 ecx, 1
  000ce	89 4d ec	 mov	 DWORD PTR _i$1[ebp], ecx
  000d1	eb 09		 jmp	 SHORT $LN4@dbgConsume
$LN2@dbgConsume:
  000d3	8b 55 ec	 mov	 edx, DWORD PTR _i$1[ebp]
  000d6	83 c2 01	 add	 edx, 1
  000d9	89 55 ec	 mov	 DWORD PTR _i$1[ebp], edx
$LN4@dbgConsume:
  000dc	8b 45 ec	 mov	 eax, DWORD PTR _i$1[ebp]
  000df	3b 45 f4	 cmp	 eax, DWORD PTR _b$[ebp]
  000e2	7d 3e		 jge	 SHORT $LN3@dbgConsume

; 652  : 		{
; 653  : 			ts->debugger->consumeHiddenToken(ts->debugger, ts->get(ts, (ANTLR3_UINT32)i));

  000e4	8b f4		 mov	 esi, esp
  000e6	8b 4d ec	 mov	 ecx, DWORD PTR _i$1[ebp]
  000e9	51		 push	 ecx
  000ea	8b 55 fc	 mov	 edx, DWORD PTR _ts$[ebp]
  000ed	52		 push	 edx
  000ee	8b 45 fc	 mov	 eax, DWORD PTR _ts$[ebp]
  000f1	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000f4	ff d1		 call	 ecx
  000f6	83 c4 08	 add	 esp, 8
  000f9	3b f4		 cmp	 esi, esp
  000fb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00100	8b f4		 mov	 esi, esp
  00102	50		 push	 eax
  00103	8b 55 fc	 mov	 edx, DWORD PTR _ts$[ebp]
  00106	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00109	50		 push	 eax
  0010a	8b 4d fc	 mov	 ecx, DWORD PTR _ts$[ebp]
  0010d	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00110	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  00113	ff d0		 call	 eax
  00115	83 c4 08	 add	 esp, 8
  00118	3b f4		 cmp	 esi, esp
  0011a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0011f	90		 npad	 1

; 654  : 		}

  00120	eb b1		 jmp	 SHORT $LN2@dbgConsume
$LN3@dbgConsume:

; 655  : 
; 656  : 	}
; 657  : }

  00122	5e		 pop	 esi
  00123	83 c4 14	 add	 esp, 20			; 00000014H
  00126	3b ec		 cmp	 ebp, esp
  00128	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0012d	8b e5		 mov	 esp, ebp
  0012f	5d		 pop	 ebp
  00130	c3		 ret	 0
_dbgConsume ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3tokenstream.c
;	COMDAT _consume
_TEXT	SEGMENT
_ts$ = -8						; size = 4
_cts$ = -4						; size = 4
_is$ = 8						; size = 4
_consume PROC						; COMDAT

; 601  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 602  : 	pANTLR3_COMMON_TOKEN_STREAM cts;
; 603  : 	pANTLR3_TOKEN_STREAM	ts;
; 604  : 
; 605  : 	ts	    = (pANTLR3_TOKEN_STREAM)	    is->super;

  00014	8b 45 08	 mov	 eax, DWORD PTR _is$[ebp]
  00017	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0001a	89 4d f8	 mov	 DWORD PTR _ts$[ebp], ecx

; 606  : 	cts	    = (pANTLR3_COMMON_TOKEN_STREAM) ts->super;

  0001d	8b 55 f8	 mov	 edx, DWORD PTR _ts$[ebp]
  00020	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00023	89 45 fc	 mov	 DWORD PTR _cts$[ebp], eax

; 607  : 
; 608  :         if	((ANTLR3_UINT32)cts->p < cts->tokens->count)

  00026	8b 4d fc	 mov	 ecx, DWORD PTR _cts$[ebp]
  00029	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _cts$[ebp]
  0002f	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00032	3b 4a 04	 cmp	 ecx, DWORD PTR [edx+4]
  00035	73 28		 jae	 SHORT $LN2@consume

; 609  : 	{
; 610  : 		cts->p++;

  00037	8b 55 fc	 mov	 edx, DWORD PTR _cts$[ebp]
  0003a	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  0003d	83 c0 01	 add	 eax, 1
  00040	8b 4d fc	 mov	 ecx, DWORD PTR _cts$[ebp]
  00043	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 611  : 		cts->p	= skipOffTokenChannels(cts, cts->p);

  00046	8b 55 fc	 mov	 edx, DWORD PTR _cts$[ebp]
  00049	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  0004c	50		 push	 eax
  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _cts$[ebp]
  00050	51		 push	 ecx
  00051	e8 00 00 00 00	 call	 _skipOffTokenChannels
  00056	83 c4 08	 add	 esp, 8
  00059	8b 55 fc	 mov	 edx, DWORD PTR _cts$[ebp]
  0005c	89 42 1c	 mov	 DWORD PTR [edx+28], eax
$LN2@consume:

; 612  : 	}
; 613  : }

  0005f	83 c4 08	 add	 esp, 8
  00062	3b ec		 cmp	 ebp, esp
  00064	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
_consume ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3tokenstream.c
;	COMDAT _setDebugListener
_TEXT	SEGMENT
_ts$ = 8						; size = 4
_debugger$ = 12						; size = 4
_setDebugListener PROC					; COMDAT

; 329  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 330  : 		// Install the debugger object
; 331  : 	//
; 332  : 	ts->debugger = debugger;

  00003	8b 45 08	 mov	 eax, DWORD PTR _ts$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _debugger$[ebp]
  00009	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 333  : 
; 334  : 	// Override standard token stream methods with debugging versions
; 335  : 	//
; 336  : 	ts->initialStreamState	= ANTLR3_FALSE;

  0000c	8b 55 08	 mov	 edx, DWORD PTR _ts$[ebp]
  0000f	c6 42 10 00	 mov	 BYTE PTR [edx+16], 0

; 337  : 
; 338  : 	ts->_LT				= dbgTokLT;

  00013	8b 45 08	 mov	 eax, DWORD PTR _ts$[ebp]
  00016	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], OFFSET _dbgTokLT

; 339  : 
; 340  : 	ts->istream->consume		= dbgConsume;

  0001d	8b 4d 08	 mov	 ecx, DWORD PTR _ts$[ebp]
  00020	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00023	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], OFFSET _dbgConsume

; 341  : 	ts->istream->_LA			= dbgLA;

  0002a	8b 45 08	 mov	 eax, DWORD PTR _ts$[ebp]
  0002d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00030	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET _dbgLA

; 342  : 	ts->istream->mark			= dbgMark;

  00037	8b 55 08	 mov	 edx, DWORD PTR _ts$[ebp]
  0003a	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0003d	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], OFFSET _dbgMark

; 343  : 	ts->istream->rewind			= dbgRewindStream;

  00044	8b 4d 08	 mov	 ecx, DWORD PTR _ts$[ebp]
  00047	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0004a	c7 42 24 00 00
	00 00		 mov	 DWORD PTR [edx+36], OFFSET _dbgRewindStream

; 344  : 	ts->istream->rewindLast		= dbgRewindLast;

  00051	8b 45 08	 mov	 eax, DWORD PTR _ts$[ebp]
  00054	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00057	c7 41 28 00 00
	00 00		 mov	 DWORD PTR [ecx+40], OFFSET _dbgRewindLast

; 345  : 	ts->istream->seek			= dbgSeek;

  0005e	8b 55 08	 mov	 edx, DWORD PTR _ts$[ebp]
  00061	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00064	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], OFFSET _dbgSeek

; 346  : }

  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
_setDebugListener ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3tokenstream.c
;	COMDAT _toStringTT
_TEXT	SEGMENT
_ts$ = 8						; size = 4
_start$ = 12						; size = 4
_stop$ = 16						; size = 4
_toStringTT PROC					; COMDAT

; 581  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 582  : 	if	(start != NULL && stop != NULL)

  00005	83 7d 0c 00	 cmp	 DWORD PTR _start$[ebp], 0
  00009	74 54		 je	 SHORT $LN2@toStringTT
  0000b	83 7d 10 00	 cmp	 DWORD PTR _stop$[ebp], 0
  0000f	74 4e		 je	 SHORT $LN2@toStringTT

; 583  : 	{
; 584  : 		return	ts->toStringSS(ts, (ANTLR3_UINT32)start->getTokenIndex(start), (ANTLR3_UINT32)stop->getTokenIndex(stop));

  00011	8b f4		 mov	 esi, esp
  00013	8b 45 10	 mov	 eax, DWORD PTR _stop$[ebp]
  00016	50		 push	 eax
  00017	8b 4d 10	 mov	 ecx, DWORD PTR _stop$[ebp]
  0001a	8b 51 74	 mov	 edx, DWORD PTR [ecx+116]
  0001d	ff d2		 call	 edx
  0001f	83 c4 04	 add	 esp, 4
  00022	3b f4		 cmp	 esi, esp
  00024	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00029	8b f4		 mov	 esi, esp
  0002b	50		 push	 eax
  0002c	8b fc		 mov	 edi, esp
  0002e	8b 45 0c	 mov	 eax, DWORD PTR _start$[ebp]
  00031	50		 push	 eax
  00032	8b 4d 0c	 mov	 ecx, DWORD PTR _start$[ebp]
  00035	8b 51 74	 mov	 edx, DWORD PTR [ecx+116]
  00038	ff d2		 call	 edx
  0003a	83 c4 04	 add	 esp, 4
  0003d	3b fc		 cmp	 edi, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	50		 push	 eax
  00045	8b 45 08	 mov	 eax, DWORD PTR _ts$[ebp]
  00048	50		 push	 eax
  00049	8b 4d 08	 mov	 ecx, DWORD PTR _ts$[ebp]
  0004c	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  0004f	ff d2		 call	 edx
  00051	83 c4 0c	 add	 esp, 12			; 0000000cH
  00054	3b f4		 cmp	 esi, esp
  00056	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005b	eb 04		 jmp	 SHORT $LN3@toStringTT

; 585  : 	}

  0005d	eb 02		 jmp	 SHORT $LN3@toStringTT
$LN2@toStringTT:

; 586  : 	else
; 587  : 	{
; 588  : 		return	NULL;

  0005f	33 c0		 xor	 eax, eax
$LN3@toStringTT:

; 589  : 	}
; 590  : }

  00061	5f		 pop	 edi
  00062	5e		 pop	 esi
  00063	3b ec		 cmp	 ebp, esp
  00065	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
_toStringTT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3tokenstream.c
;	COMDAT _toStringSS
_TEXT	SEGMENT
_cts$ = -20						; size = 4
_i$ = -16						; size = 4
_tok$ = -12						; size = 4
_tsource$ = -8						; size = 4
_string$ = -4						; size = 4
_ts$ = 8						; size = 4
_start$ = 12						; size = 4
_stop$ = 16						; size = 4
_toStringSS PROC					; COMDAT

; 536  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0000f	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00012	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00015	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00018	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 537  :     pANTLR3_STRING string;
; 538  :     pANTLR3_TOKEN_SOURCE tsource;
; 539  :     pANTLR3_COMMON_TOKEN tok;
; 540  :     ANTLR3_UINT32 i;
; 541  :     pANTLR3_COMMON_TOKEN_STREAM cts;
; 542  : 
; 543  :     cts = (pANTLR3_COMMON_TOKEN_STREAM) ts->super;

  0001b	8b 45 08	 mov	 eax, DWORD PTR _ts$[ebp]
  0001e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00021	89 4d ec	 mov	 DWORD PTR _cts$[ebp], ecx

; 544  : 
; 545  :     if (cts->p == -1)

  00024	8b 55 ec	 mov	 edx, DWORD PTR _cts$[ebp]
  00027	83 7a 1c ff	 cmp	 DWORD PTR [edx+28], -1
  0002b	75 0c		 jne	 SHORT $LN5@toStringSS

; 546  :     {
; 547  :         fillBuffer(cts);

  0002d	8b 45 ec	 mov	 eax, DWORD PTR _cts$[ebp]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 _fillBuffer
  00036	83 c4 04	 add	 esp, 4
$LN5@toStringSS:

; 548  :     }
; 549  :     if (stop >= ts->istream->size(ts->istream))

  00039	8b f4		 mov	 esi, esp
  0003b	8b 4d 08	 mov	 ecx, DWORD PTR _ts$[ebp]
  0003e	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00041	52		 push	 edx
  00042	8b 45 08	 mov	 eax, DWORD PTR _ts$[ebp]
  00045	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00048	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  0004b	ff d2		 call	 edx
  0004d	83 c4 04	 add	 esp, 4
  00050	3b f4		 cmp	 esi, esp
  00052	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00057	39 45 10	 cmp	 DWORD PTR _stop$[ebp], eax
  0005a	72 24		 jb	 SHORT $LN6@toStringSS

; 550  :     {
; 551  :         stop = ts->istream->size(ts->istream) - 1;

  0005c	8b f4		 mov	 esi, esp
  0005e	8b 45 08	 mov	 eax, DWORD PTR _ts$[ebp]
  00061	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00064	51		 push	 ecx
  00065	8b 55 08	 mov	 edx, DWORD PTR _ts$[ebp]
  00068	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0006b	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0006e	ff d1		 call	 ecx
  00070	83 c4 04	 add	 esp, 4
  00073	3b f4		 cmp	 esi, esp
  00075	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007a	83 e8 01	 sub	 eax, 1
  0007d	89 45 10	 mov	 DWORD PTR _stop$[ebp], eax
$LN6@toStringSS:

; 552  :     }
; 553  : 
; 554  :     /* Who is giving us these tokens?
; 555  :      */
; 556  :     tsource = ts->getTokenSource(ts);

  00080	8b f4		 mov	 esi, esp
  00082	8b 55 08	 mov	 edx, DWORD PTR _ts$[ebp]
  00085	52		 push	 edx
  00086	8b 45 08	 mov	 eax, DWORD PTR _ts$[ebp]
  00089	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0008c	ff d1		 call	 ecx
  0008e	83 c4 04	 add	 esp, 4
  00091	3b f4		 cmp	 esi, esp
  00093	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00098	89 45 f8	 mov	 DWORD PTR _tsource$[ebp], eax

; 557  : 
; 558  :     if (tsource != NULL && cts->tokens != NULL)

  0009b	83 7d f8 00	 cmp	 DWORD PTR _tsource$[ebp], 0
  0009f	0f 84 a5 00 00
	00		 je	 $LN7@toStringSS
  000a5	8b 55 ec	 mov	 edx, DWORD PTR _cts$[ebp]
  000a8	83 7a 08 00	 cmp	 DWORD PTR [edx+8], 0
  000ac	0f 84 98 00 00
	00		 je	 $LN7@toStringSS

; 559  :     {
; 560  :         /* Finally, let's get a string
; 561  :          */
; 562  :         string = tsource->strFactory->newRaw(tsource->strFactory);

  000b2	8b f4		 mov	 esi, esp
  000b4	8b 45 f8	 mov	 eax, DWORD PTR _tsource$[ebp]
  000b7	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ba	51		 push	 ecx
  000bb	8b 55 f8	 mov	 edx, DWORD PTR _tsource$[ebp]
  000be	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000c1	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000c4	ff d1		 call	 ecx
  000c6	83 c4 04	 add	 esp, 4
  000c9	3b f4		 cmp	 esi, esp
  000cb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d0	89 45 fc	 mov	 DWORD PTR _string$[ebp], eax

; 563  : 
; 564  :         for (i = start; i <= stop; i++)

  000d3	8b 55 0c	 mov	 edx, DWORD PTR _start$[ebp]
  000d6	89 55 f0	 mov	 DWORD PTR _i$[ebp], edx
  000d9	eb 09		 jmp	 SHORT $LN4@toStringSS
$LN2@toStringSS:
  000db	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  000de	83 c0 01	 add	 eax, 1
  000e1	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax
$LN4@toStringSS:
  000e4	8b 4d f0	 mov	 ecx, DWORD PTR _i$[ebp]
  000e7	3b 4d 10	 cmp	 ecx, DWORD PTR _stop$[ebp]
  000ea	77 59		 ja	 SHORT $LN3@toStringSS

; 565  :         {
; 566  :             tok = ts->get(ts, i);

  000ec	8b f4		 mov	 esi, esp
  000ee	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  000f1	52		 push	 edx
  000f2	8b 45 08	 mov	 eax, DWORD PTR _ts$[ebp]
  000f5	50		 push	 eax
  000f6	8b 4d 08	 mov	 ecx, DWORD PTR _ts$[ebp]
  000f9	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  000fc	ff d2		 call	 edx
  000fe	83 c4 08	 add	 esp, 8
  00101	3b f4		 cmp	 esi, esp
  00103	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00108	89 45 f4	 mov	 DWORD PTR _tok$[ebp], eax

; 567  :             if (tok != NULL)

  0010b	83 7d f4 00	 cmp	 DWORD PTR _tok$[ebp], 0
  0010f	74 32		 je	 SHORT $LN8@toStringSS

; 568  :             {
; 569  :                 string->appendS(string, tok->getText(tok));

  00111	8b f4		 mov	 esi, esp
  00113	8b 45 f4	 mov	 eax, DWORD PTR _tok$[ebp]
  00116	50		 push	 eax
  00117	8b 4d f4	 mov	 ecx, DWORD PTR _tok$[ebp]
  0011a	8b 51 48	 mov	 edx, DWORD PTR [ecx+72]
  0011d	ff d2		 call	 edx
  0011f	83 c4 04	 add	 esp, 4
  00122	3b f4		 cmp	 esi, esp
  00124	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00129	8b f4		 mov	 esi, esp
  0012b	50		 push	 eax
  0012c	8b 45 fc	 mov	 eax, DWORD PTR _string$[ebp]
  0012f	50		 push	 eax
  00130	8b 4d fc	 mov	 ecx, DWORD PTR _string$[ebp]
  00133	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00136	ff d2		 call	 edx
  00138	83 c4 08	 add	 esp, 8
  0013b	3b f4		 cmp	 esi, esp
  0013d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00142	90		 npad	 1
$LN8@toStringSS:

; 570  :             }
; 571  :         }

  00143	eb 96		 jmp	 SHORT $LN2@toStringSS
$LN3@toStringSS:

; 572  : 
; 573  :         return string;

  00145	8b 45 fc	 mov	 eax, DWORD PTR _string$[ebp]
  00148	eb 02		 jmp	 SHORT $LN1@toStringSS
$LN7@toStringSS:

; 574  :     }
; 575  :     return NULL;

  0014a	33 c0		 xor	 eax, eax
$LN1@toStringSS:

; 576  : 
; 577  : }

  0014c	5e		 pop	 esi
  0014d	83 c4 14	 add	 esp, 20			; 00000014H
  00150	3b ec		 cmp	 ebp, esp
  00152	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00157	8b e5		 mov	 esp, ebp
  00159	5d		 pop	 ebp
  0015a	c3		 ret	 0
_toStringSS ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3tokenstream.c
;	COMDAT _toString
_TEXT	SEGMENT
_cts$ = -4						; size = 4
_ts$ = 8						; size = 4
_toString PROC						; COMDAT

; 521  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 522  :     pANTLR3_COMMON_TOKEN_STREAM cts;
; 523  : 
; 524  :     cts	    = (pANTLR3_COMMON_TOKEN_STREAM)ts->super;

  0000c	8b 45 08	 mov	 eax, DWORD PTR _ts$[ebp]
  0000f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00012	89 4d fc	 mov	 DWORD PTR _cts$[ebp], ecx

; 525  : 
; 526  :     if	(cts->p == -1)

  00015	8b 55 fc	 mov	 edx, DWORD PTR _cts$[ebp]
  00018	83 7a 1c ff	 cmp	 DWORD PTR [edx+28], -1
  0001c	75 0c		 jne	 SHORT $LN2@toString

; 527  :     {
; 528  : 	fillBuffer(cts);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _cts$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 _fillBuffer
  00027	83 c4 04	 add	 esp, 4
$LN2@toString:

; 529  :     }
; 530  : 
; 531  :     return  ts->toStringSS(ts, 0, ts->istream->size(ts->istream));

  0002a	8b f4		 mov	 esi, esp
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _ts$[ebp]
  0002f	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00032	52		 push	 edx
  00033	8b 45 08	 mov	 eax, DWORD PTR _ts$[ebp]
  00036	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00039	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  0003c	ff d2		 call	 edx
  0003e	83 c4 04	 add	 esp, 4
  00041	3b f4		 cmp	 esi, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b f4		 mov	 esi, esp
  0004a	50		 push	 eax
  0004b	6a 00		 push	 0
  0004d	8b 45 08	 mov	 eax, DWORD PTR _ts$[ebp]
  00050	50		 push	 eax
  00051	8b 4d 08	 mov	 ecx, DWORD PTR _ts$[ebp]
  00054	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00057	ff d2		 call	 edx
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005c	3b f4		 cmp	 esi, esp
  0005e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 532  : }

  00063	5e		 pop	 esi
  00064	83 c4 04	 add	 esp, 4
  00067	3b ec		 cmp	 ebp, esp
  00069	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c3		 ret	 0
_toString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3tokenstream.c
;	COMDAT _setTokenSource
_TEXT	SEGMENT
_ts$ = 8						; size = 4
_tokenSource$ = 12					; size = 4
_setTokenSource PROC					; COMDAT

; 515  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 516  :     ts->tokenSource	= tokenSource;

  00003	8b 45 08	 mov	 eax, DWORD PTR _ts$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _tokenSource$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 517  : }

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
_setTokenSource ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3tokenstream.c
;	COMDAT _getTokenSource
_TEXT	SEGMENT
_ts$ = 8						; size = 4
_getTokenSource PROC					; COMDAT

; 508  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 509  :     return  ts->tokenSource;

  00003	8b 45 08	 mov	 eax, DWORD PTR _ts$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]

; 510  : }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
_getTokenSource ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3tokenstream.c
;	COMDAT _get
_TEXT	SEGMENT
_cts$ = -4						; size = 4
_ts$ = 8						; size = 4
_i$ = 12						; size = 4
_get	PROC						; COMDAT

; 498  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 499  :     pANTLR3_COMMON_TOKEN_STREAM cts;
; 500  : 
; 501  :     cts	    = (pANTLR3_COMMON_TOKEN_STREAM)ts->super;

  0000c	8b 45 08	 mov	 eax, DWORD PTR _ts$[ebp]
  0000f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00012	89 4d fc	 mov	 DWORD PTR _cts$[ebp], ecx

; 502  : 
; 503  :     return  (pANTLR3_COMMON_TOKEN)(cts->tokens->get(cts->tokens, i));  /* Token index is zero based but vectors are 1 based */

  00015	8b f4		 mov	 esi, esp
  00017	8b 55 0c	 mov	 edx, DWORD PTR _i$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _cts$[ebp]
  0001e	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00021	51		 push	 ecx
  00022	8b 55 fc	 mov	 edx, DWORD PTR _cts$[ebp]
  00025	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00028	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [eax+152]
  0002e	ff d1		 call	 ecx
  00030	83 c4 08	 add	 esp, 8
  00033	3b f4		 cmp	 esi, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 504  : }

  0003a	5e		 pop	 esi
  0003b	83 c4 04	 add	 esp, 4
  0003e	3b ec		 cmp	 ebp, esp
  00040	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
_get	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3tokenstream.c
;	COMDAT _dbgTokLT
_TEXT	SEGMENT
_ts$ = 8						; size = 4
_k$ = 12						; size = 4
_dbgTokLT PROC						; COMDAT

; 438  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 439  : 	if	(ts->initialStreamState == ANTLR3_TRUE)

  00003	8b 45 08	 mov	 eax, DWORD PTR _ts$[ebp]
  00006	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  0000a	83 f9 01	 cmp	 ecx, 1
  0000d	75 0f		 jne	 SHORT $LN2@dbgTokLT

; 440  : 	{
; 441  : 		consumeInitialHiddenTokens(ts->istream);

  0000f	8b 55 08	 mov	 edx, DWORD PTR _ts$[ebp]
  00012	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 _consumeInitialHiddenTokens
  0001b	83 c4 04	 add	 esp, 4
$LN2@dbgTokLT:

; 442  : 	}
; 443  : 	return tokLT(ts, k);

  0001e	8b 4d 0c	 mov	 ecx, DWORD PTR _k$[ebp]
  00021	51		 push	 ecx
  00022	8b 55 08	 mov	 edx, DWORD PTR _ts$[ebp]
  00025	52		 push	 edx
  00026	e8 00 00 00 00	 call	 _tokLT
  0002b	83 c4 08	 add	 esp, 8

; 444  : }

  0002e	3b ec		 cmp	 ebp, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
_dbgTokLT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3tokenstream.c
;	COMDAT _tokLT
_TEXT	SEGMENT
_teof$1 = -20						; size = 4
_teof$2 = -16						; size = 4
_cts$ = -12						; size = 4
_n$ = -8						; size = 4
_i$ = -4						; size = 4
_ts$ = 8						; size = 4
_k$ = 12						; size = 4
_tokLT	PROC						; COMDAT

; 353  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0000f	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00012	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00015	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00018	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 354  : 	ANTLR3_INT32    i;
; 355  : 	ANTLR3_INT32    n;
; 356  : 	pANTLR3_COMMON_TOKEN_STREAM cts;
; 357  : 
; 358  : 	cts	    = (pANTLR3_COMMON_TOKEN_STREAM)ts->super;

  0001b	8b 45 08	 mov	 eax, DWORD PTR _ts$[ebp]
  0001e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00021	89 4d f4	 mov	 DWORD PTR _cts$[ebp], ecx

; 359  : 
; 360  :         if	(k < 0)

  00024	83 7d 0c 00	 cmp	 DWORD PTR _k$[ebp], 0
  00028	7d 17		 jge	 SHORT $LN4@tokLT

; 361  : 	{
; 362  : 		return LB(cts, -k);

  0002a	8b 55 0c	 mov	 edx, DWORD PTR _k$[ebp]
  0002d	f7 da		 neg	 edx
  0002f	52		 push	 edx
  00030	8b 45 f4	 mov	 eax, DWORD PTR _cts$[ebp]
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 _LB
  00039	83 c4 08	 add	 esp, 8
  0003c	e9 95 01 00 00	 jmp	 $LN1@tokLT
$LN4@tokLT:

; 363  : 	}
; 364  : 
; 365  : 	if	(cts->p == -1)

  00041	8b 4d f4	 mov	 ecx, DWORD PTR _cts$[ebp]
  00044	83 79 1c ff	 cmp	 DWORD PTR [ecx+28], -1
  00048	75 0c		 jne	 SHORT $LN5@tokLT

; 366  : 	{
; 367  : 		fillBuffer(cts);

  0004a	8b 55 f4	 mov	 edx, DWORD PTR _cts$[ebp]
  0004d	52		 push	 edx
  0004e	e8 00 00 00 00	 call	 _fillBuffer
  00053	83 c4 04	 add	 esp, 4
$LN5@tokLT:

; 368  : 	}
; 369  : 
; 370  :         // Here we used to check for k == 0 and return 0, but this seems
; 371  :         // a superfluous check to me. LT(k=0) is therefore just undefined
; 372  :         // and we won't waste the clock cycles on the check
; 373  :         //
; 374  : 
; 375  : 	if	((cts->p + k - 1) >= (ANTLR3_INT32)ts->istream->cachedSize)

  00056	8b 45 f4	 mov	 eax, DWORD PTR _cts$[ebp]
  00059	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0005c	8b 55 0c	 mov	 edx, DWORD PTR _k$[ebp]
  0005f	8d 44 11 ff	 lea	 eax, DWORD PTR [ecx+edx-1]
  00063	8b 4d 08	 mov	 ecx, DWORD PTR _ts$[ebp]
  00066	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00069	3b 42 38	 cmp	 eax, DWORD PTR [edx+56]
  0006c	0f 8c 87 00 00
	00		 jl	 $LN6@tokLT

; 376  : 	{
; 377  : 		pANTLR3_COMMON_TOKEN    teof = &(ts->tokenSource->eofToken);

  00072	8b 45 08	 mov	 eax, DWORD PTR _ts$[ebp]
  00075	8b 08		 mov	 ecx, DWORD PTR [eax]
  00077	83 c1 08	 add	 ecx, 8
  0007a	89 4d f0	 mov	 DWORD PTR _teof$2[ebp], ecx

; 378  : 
; 379  : 		teof->setStartIndex (teof, ts->istream->index	    (ts->istream));

  0007d	8b f4		 mov	 esi, esp
  0007f	8b 55 08	 mov	 edx, DWORD PTR _ts$[ebp]
  00082	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00085	50		 push	 eax
  00086	8b 4d 08	 mov	 ecx, DWORD PTR _ts$[ebp]
  00089	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0008c	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0008f	ff d0		 call	 eax
  00091	83 c4 04	 add	 esp, 4
  00094	3b f4		 cmp	 esi, esp
  00096	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009b	8b f4		 mov	 esi, esp
  0009d	50		 push	 eax
  0009e	8b 4d f0	 mov	 ecx, DWORD PTR _teof$2[ebp]
  000a1	51		 push	 ecx
  000a2	8b 55 f0	 mov	 edx, DWORD PTR _teof$2[ebp]
  000a5	8b 82 80 00 00
	00		 mov	 eax, DWORD PTR [edx+128]
  000ab	ff d0		 call	 eax
  000ad	83 c4 08	 add	 esp, 8
  000b0	3b f4		 cmp	 esi, esp
  000b2	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 380  : 		teof->setStopIndex  (teof, ts->istream->index	    (ts->istream));

  000b7	8b f4		 mov	 esi, esp
  000b9	8b 4d 08	 mov	 ecx, DWORD PTR _ts$[ebp]
  000bc	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000bf	52		 push	 edx
  000c0	8b 45 08	 mov	 eax, DWORD PTR _ts$[ebp]
  000c3	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000c6	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  000c9	ff d2		 call	 edx
  000cb	83 c4 04	 add	 esp, 4
  000ce	3b f4		 cmp	 esi, esp
  000d0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d5	8b f4		 mov	 esi, esp
  000d7	50		 push	 eax
  000d8	8b 45 f0	 mov	 eax, DWORD PTR _teof$2[ebp]
  000db	50		 push	 eax
  000dc	8b 4d f0	 mov	 ecx, DWORD PTR _teof$2[ebp]
  000df	8b 91 88 00 00
	00		 mov	 edx, DWORD PTR [ecx+136]
  000e5	ff d2		 call	 edx
  000e7	83 c4 08	 add	 esp, 8
  000ea	3b f4		 cmp	 esi, esp
  000ec	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 381  : 		return  teof;

  000f1	8b 45 f0	 mov	 eax, DWORD PTR _teof$2[ebp]
  000f4	e9 dd 00 00 00	 jmp	 $LN1@tokLT
$LN6@tokLT:

; 382  : 	}
; 383  : 
; 384  : 	i	= cts->p;

  000f9	8b 45 f4	 mov	 eax, DWORD PTR _cts$[ebp]
  000fc	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  000ff	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx

; 385  : 	n	= 1;

  00102	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _n$[ebp], 1
$LN2@tokLT:

; 386  : 
; 387  : 	/* Need to find k good tokens, skipping ones that are off channel
; 388  : 	*/
; 389  : 	while   ( n < k)

  00109	8b 55 f8	 mov	 edx, DWORD PTR _n$[ebp]
  0010c	3b 55 0c	 cmp	 edx, DWORD PTR _k$[ebp]
  0010f	7d 21		 jge	 SHORT $LN3@tokLT

; 390  : 	{
; 391  : 		/* Skip off-channel tokens */
; 392  : 		i = skipOffTokenChannels(cts, i+1); /* leave p on valid token    */

  00111	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00114	83 c0 01	 add	 eax, 1
  00117	50		 push	 eax
  00118	8b 4d f4	 mov	 ecx, DWORD PTR _cts$[ebp]
  0011b	51		 push	 ecx
  0011c	e8 00 00 00 00	 call	 _skipOffTokenChannels
  00121	83 c4 08	 add	 esp, 8
  00124	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax

; 393  : 		n++;

  00127	8b 55 f8	 mov	 edx, DWORD PTR _n$[ebp]
  0012a	83 c2 01	 add	 edx, 1
  0012d	89 55 f8	 mov	 DWORD PTR _n$[ebp], edx

; 394  : 	}

  00130	eb d7		 jmp	 SHORT $LN2@tokLT
$LN3@tokLT:

; 395  : 	if	( (ANTLR3_UINT32) i >= ts->istream->cachedSize)

  00132	8b 45 08	 mov	 eax, DWORD PTR _ts$[ebp]
  00135	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00138	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0013b	3b 51 38	 cmp	 edx, DWORD PTR [ecx+56]
  0013e	0f 82 84 00 00
	00		 jb	 $LN7@tokLT

; 396  : 	{
; 397  : 		pANTLR3_COMMON_TOKEN    teof = &(ts->tokenSource->eofToken);

  00144	8b 45 08	 mov	 eax, DWORD PTR _ts$[ebp]
  00147	8b 08		 mov	 ecx, DWORD PTR [eax]
  00149	83 c1 08	 add	 ecx, 8
  0014c	89 4d ec	 mov	 DWORD PTR _teof$1[ebp], ecx

; 398  : 
; 399  : 		teof->setStartIndex (teof, ts->istream->index(ts->istream));

  0014f	8b f4		 mov	 esi, esp
  00151	8b 55 08	 mov	 edx, DWORD PTR _ts$[ebp]
  00154	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00157	50		 push	 eax
  00158	8b 4d 08	 mov	 ecx, DWORD PTR _ts$[ebp]
  0015b	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0015e	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00161	ff d0		 call	 eax
  00163	83 c4 04	 add	 esp, 4
  00166	3b f4		 cmp	 esi, esp
  00168	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0016d	8b f4		 mov	 esi, esp
  0016f	50		 push	 eax
  00170	8b 4d ec	 mov	 ecx, DWORD PTR _teof$1[ebp]
  00173	51		 push	 ecx
  00174	8b 55 ec	 mov	 edx, DWORD PTR _teof$1[ebp]
  00177	8b 82 80 00 00
	00		 mov	 eax, DWORD PTR [edx+128]
  0017d	ff d0		 call	 eax
  0017f	83 c4 08	 add	 esp, 8
  00182	3b f4		 cmp	 esi, esp
  00184	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 400  : 		teof->setStopIndex  (teof, ts->istream->index(ts->istream));

  00189	8b f4		 mov	 esi, esp
  0018b	8b 4d 08	 mov	 ecx, DWORD PTR _ts$[ebp]
  0018e	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00191	52		 push	 edx
  00192	8b 45 08	 mov	 eax, DWORD PTR _ts$[ebp]
  00195	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00198	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  0019b	ff d2		 call	 edx
  0019d	83 c4 04	 add	 esp, 4
  001a0	3b f4		 cmp	 esi, esp
  001a2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001a7	8b f4		 mov	 esi, esp
  001a9	50		 push	 eax
  001aa	8b 45 ec	 mov	 eax, DWORD PTR _teof$1[ebp]
  001ad	50		 push	 eax
  001ae	8b 4d ec	 mov	 ecx, DWORD PTR _teof$1[ebp]
  001b1	8b 91 88 00 00
	00		 mov	 edx, DWORD PTR [ecx+136]
  001b7	ff d2		 call	 edx
  001b9	83 c4 08	 add	 esp, 8
  001bc	3b f4		 cmp	 esi, esp
  001be	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 401  : 		return  teof;

  001c3	8b 45 ec	 mov	 eax, DWORD PTR _teof$1[ebp]
  001c6	eb 0e		 jmp	 SHORT $LN1@tokLT
$LN7@tokLT:

; 402  : 	}
; 403  : 
; 404  : 	// Here the token must be in the input vector. Rather then incur
; 405  : 	// function call penalty, we just return the pointer directly
; 406  : 	// from the vector
; 407  : 	//
; 408  : 	return  (pANTLR3_COMMON_TOKEN)cts->tokens->elements[i].element;

  001c8	8b 45 f4	 mov	 eax, DWORD PTR _cts$[ebp]
  001cb	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001ce	8b 11		 mov	 edx, DWORD PTR [ecx]
  001d0	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  001d3	8b 04 c2	 mov	 eax, DWORD PTR [edx+eax*8]
$LN1@tokLT:

; 409  : 	//return  (pANTLR3_COMMON_TOKEN)cts->tokens->get(cts->tokens, i);
; 410  : }

  001d6	5e		 pop	 esi
  001d7	83 c4 14	 add	 esp, 20			; 00000014H
  001da	3b ec		 cmp	 ebp, esp
  001dc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001e1	8b e5		 mov	 esp, ebp
  001e3	5d		 pop	 ebp
  001e4	c3		 ret	 0
_tokLT	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3tokenstream.c
;	COMDAT _reset
_TEXT	SEGMENT
_cts$ = 8						; size = 4
_reset	PROC						; COMDAT

; 164  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 165  : 
; 166  :     // Free any resources that ar most like specifc to the
; 167  :     // run we just did.
; 168  :     //
; 169  :     if	(cts->discardSet != NULL)

  00004	8b 45 08	 mov	 eax, DWORD PTR _cts$[ebp]
  00007	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  0000b	74 28		 je	 SHORT $LN2@reset

; 170  :     {
; 171  :         cts->discardSet->free(cts->discardSet);

  0000d	8b f4		 mov	 esi, esp
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _cts$[ebp]
  00012	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00015	52		 push	 edx
  00016	8b 45 08	 mov	 eax, DWORD PTR _cts$[ebp]
  00019	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0001c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001f	ff d2		 call	 edx
  00021	83 c4 04	 add	 esp, 4
  00024	3b f4		 cmp	 esi, esp
  00026	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 172  :         cts->discardSet  = NULL;

  0002b	8b 45 08	 mov	 eax, DWORD PTR _cts$[ebp]
  0002e	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
$LN2@reset:

; 173  :     }
; 174  :     if	(cts->channelOverrides != NULL)

  00035	8b 4d 08	 mov	 ecx, DWORD PTR _cts$[ebp]
  00038	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  0003c	74 28		 je	 SHORT $LN3@reset

; 175  :     {
; 176  :         cts->channelOverrides->free(cts->channelOverrides);

  0003e	8b f4		 mov	 esi, esp
  00040	8b 55 08	 mov	 edx, DWORD PTR _cts$[ebp]
  00043	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00046	50		 push	 eax
  00047	8b 4d 08	 mov	 ecx, DWORD PTR _cts$[ebp]
  0004a	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0004d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00050	ff d0		 call	 eax
  00052	83 c4 04	 add	 esp, 4
  00055	3b f4		 cmp	 esi, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 177  :         cts->channelOverrides = NULL;

  0005c	8b 4d 08	 mov	 ecx, DWORD PTR _cts$[ebp]
  0005f	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
$LN3@reset:

; 178  :     }
; 179  : 
; 180  :     // Now, if there were any existing tokens in the stream,
; 181  :     // then we just reset the vector count so that it starts
; 182  :     // again. We must traverse the entries unfortunately as
; 183  :     // there may be free pointers for custom token types and
; 184  :     // so on. However that is just a quick NULL check on the
; 185  :     // vector entries.
; 186  :     //
; 187  :     if	(cts->tokens != NULL)

  00066	8b 55 08	 mov	 edx, DWORD PTR _cts$[ebp]
  00069	83 7a 08 00	 cmp	 DWORD PTR [edx+8], 0
  0006d	74 24		 je	 SHORT $LN4@reset

; 188  :     {
; 189  :         cts->tokens->clear(cts->tokens);

  0006f	8b f4		 mov	 esi, esp
  00071	8b 45 08	 mov	 eax, DWORD PTR _cts$[ebp]
  00074	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00077	51		 push	 ecx
  00078	8b 55 08	 mov	 edx, DWORD PTR _cts$[ebp]
  0007b	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0007e	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [eax+160]
  00084	ff d1		 call	 ecx
  00086	83 c4 04	 add	 esp, 4
  00089	3b f4		 cmp	 esi, esp
  0008b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00090	90		 npad	 1

; 190  :     }

  00091	eb 10		 jmp	 SHORT $LN5@reset
$LN4@reset:

; 191  :     else
; 192  :     {
; 193  :         /* Install the token tracking tables
; 194  :          */
; 195  :         cts->tokens  = antlr3VectorNew(0);

  00093	6a 00		 push	 0
  00095	e8 00 00 00 00	 call	 _antlr3VectorNew
  0009a	83 c4 04	 add	 esp, 4
  0009d	8b 55 08	 mov	 edx, DWORD PTR _cts$[ebp]
  000a0	89 42 08	 mov	 DWORD PTR [edx+8], eax
$LN5@reset:

; 196  :     }
; 197  : 
; 198  :     // Reset to defaults
; 199  :     //
; 200  :     cts->discardOffChannel  = ANTLR3_FALSE;

  000a3	8b 45 08	 mov	 eax, DWORD PTR _cts$[ebp]
  000a6	c6 40 18 00	 mov	 BYTE PTR [eax+24], 0

; 201  :     cts->channel            = ANTLR3_TOKEN_DEFAULT_CHANNEL;

  000aa	8b 4d 08	 mov	 ecx, DWORD PTR _cts$[ebp]
  000ad	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 202  :     cts->p	            = -1;

  000b4	8b 55 08	 mov	 edx, DWORD PTR _cts$[ebp]
  000b7	c7 42 1c ff ff
	ff ff		 mov	 DWORD PTR [edx+28], -1

; 203  : }

  000be	5e		 pop	 esi
  000bf	3b ec		 cmp	 ebp, esp
  000c1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c6	5d		 pop	 ebp
  000c7	c3		 ret	 0
_reset	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3tokenstream.c
;	COMDAT _getTokensType
_TEXT	SEGMENT
_newlist$ = -8						; size = 4
_bitSet$ = -4						; size = 4
_tokenStream$ = 8					; size = 4
_start$ = 12						; size = 4
_stop$ = 16						; size = 4
_type$ = 20						; size = 4
_getTokensType PROC					; COMDAT

; 787  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 788  :     pANTLR3_BITSET  bitSet;
; 789  :     pANTLR3_LIST    newlist;
; 790  : 
; 791  :     bitSet  = antlr3BitsetOf(type, -1);

  00015	6a ff		 push	 -1
  00017	8b 45 14	 mov	 eax, DWORD PTR _type$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 _antlr3BitsetOf
  00020	83 c4 08	 add	 esp, 8
  00023	89 45 fc	 mov	 DWORD PTR _bitSet$[ebp], eax

; 792  :     newlist = tokenStream->getTokensSet(tokenStream, start, stop, bitSet);

  00026	8b f4		 mov	 esi, esp
  00028	8b 4d fc	 mov	 ecx, DWORD PTR _bitSet$[ebp]
  0002b	51		 push	 ecx
  0002c	8b 55 10	 mov	 edx, DWORD PTR _stop$[ebp]
  0002f	52		 push	 edx
  00030	8b 45 0c	 mov	 eax, DWORD PTR _start$[ebp]
  00033	50		 push	 eax
  00034	8b 4d 08	 mov	 ecx, DWORD PTR _tokenStream$[ebp]
  00037	51		 push	 ecx
  00038	8b 55 08	 mov	 edx, DWORD PTR _tokenStream$[ebp]
  0003b	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  0003e	ff d0		 call	 eax
  00040	83 c4 10	 add	 esp, 16			; 00000010H
  00043	3b f4		 cmp	 esi, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	89 45 f8	 mov	 DWORD PTR _newlist$[ebp], eax

; 793  : 
; 794  :     bitSet->free(bitSet);

  0004d	8b f4		 mov	 esi, esp
  0004f	8b 4d fc	 mov	 ecx, DWORD PTR _bitSet$[ebp]
  00052	51		 push	 ecx
  00053	8b 55 fc	 mov	 edx, DWORD PTR _bitSet$[ebp]
  00056	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  00059	ff d0		 call	 eax
  0005b	83 c4 04	 add	 esp, 4
  0005e	3b f4		 cmp	 esi, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 795  : 
; 796  :     return  newlist;

  00065	8b 45 f8	 mov	 eax, DWORD PTR _newlist$[ebp]

; 797  : }

  00068	5e		 pop	 esi
  00069	83 c4 08	 add	 esp, 8
  0006c	3b ec		 cmp	 ebp, esp
  0006e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
_getTokensType ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3tokenstream.c
;	COMDAT _getTokensList
_TEXT	SEGMENT
_newlist$ = -8						; size = 4
_bitSet$ = -4						; size = 4
_tokenStream$ = 8					; size = 4
_start$ = 12						; size = 4
_stop$ = 16						; size = 4
_list$ = 20						; size = 4
_getTokensList PROC					; COMDAT

; 771  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 772  :     pANTLR3_BITSET  bitSet;
; 773  :     pANTLR3_LIST    newlist;
; 774  : 
; 775  :     bitSet  = antlr3BitsetList(list->table);

  00015	8b 45 14	 mov	 eax, DWORD PTR _list$[ebp]
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 _antlr3BitsetList
  00020	83 c4 04	 add	 esp, 4
  00023	89 45 fc	 mov	 DWORD PTR _bitSet$[ebp], eax

; 776  : 
; 777  :     newlist    = tokenStream->getTokensSet(tokenStream, start, stop, bitSet);

  00026	8b f4		 mov	 esi, esp
  00028	8b 55 fc	 mov	 edx, DWORD PTR _bitSet$[ebp]
  0002b	52		 push	 edx
  0002c	8b 45 10	 mov	 eax, DWORD PTR _stop$[ebp]
  0002f	50		 push	 eax
  00030	8b 4d 0c	 mov	 ecx, DWORD PTR _start$[ebp]
  00033	51		 push	 ecx
  00034	8b 55 08	 mov	 edx, DWORD PTR _tokenStream$[ebp]
  00037	52		 push	 edx
  00038	8b 45 08	 mov	 eax, DWORD PTR _tokenStream$[ebp]
  0003b	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0003e	ff d1		 call	 ecx
  00040	83 c4 10	 add	 esp, 16			; 00000010H
  00043	3b f4		 cmp	 esi, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	89 45 f8	 mov	 DWORD PTR _newlist$[ebp], eax

; 778  : 
; 779  :     bitSet->free(bitSet);

  0004d	8b f4		 mov	 esi, esp
  0004f	8b 55 fc	 mov	 edx, DWORD PTR _bitSet$[ebp]
  00052	52		 push	 edx
  00053	8b 45 fc	 mov	 eax, DWORD PTR _bitSet$[ebp]
  00056	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00059	ff d1		 call	 ecx
  0005b	83 c4 04	 add	 esp, 4
  0005e	3b f4		 cmp	 esi, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 780  : 
; 781  :     return  newlist;

  00065	8b 45 f8	 mov	 eax, DWORD PTR _newlist$[ebp]

; 782  : 
; 783  : }

  00068	5e		 pop	 esi
  00069	83 c4 08	 add	 esp, 8
  0006c	3b ec		 cmp	 ebp, esp
  0006e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
_getTokensList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3tokenstream.c
;	COMDAT _getTokensSet
_TEXT	SEGMENT
tv149 = -24						; size = 4
tv139 = -20						; size = 4
_tok$ = -16						; size = 4
_n$ = -12						; size = 4
_i$ = -8						; size = 4
_filteredList$ = -4					; size = 4
_tokenStream$ = 8					; size = 4
_start$ = 12						; size = 4
_stop$ = 16						; size = 4
_types$ = 20						; size = 4
_getTokensSet PROC					; COMDAT

; 721  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  0000f	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00012	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00015	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00018	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001b	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 722  :     pANTLR3_LIST	    filteredList;
; 723  :     ANTLR3_UINT32	    i;
; 724  :     ANTLR3_UINT32	    n;
; 725  :     pANTLR3_COMMON_TOKEN    tok;
; 726  : 
; 727  :     if	(tokenStream->p == -1)

  0001e	8b 45 08	 mov	 eax, DWORD PTR _tokenStream$[ebp]
  00021	83 78 1c ff	 cmp	 DWORD PTR [eax+28], -1
  00025	75 0c		 jne	 SHORT $LN5@getTokensS

; 728  :     {
; 729  : 	fillBuffer(tokenStream);

  00027	8b 4d 08	 mov	 ecx, DWORD PTR _tokenStream$[ebp]
  0002a	51		 push	 ecx
  0002b	e8 00 00 00 00	 call	 _fillBuffer
  00030	83 c4 04	 add	 esp, 4
$LN5@getTokensS:

; 730  :     }
; 731  :     if	(stop > tokenStream->tstream->istream->size(tokenStream->tstream->istream))

  00033	8b 55 08	 mov	 edx, DWORD PTR _tokenStream$[ebp]
  00036	8b 02		 mov	 eax, DWORD PTR [edx]
  00038	8b f4		 mov	 esi, esp
  0003a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0003d	51		 push	 ecx
  0003e	8b 55 08	 mov	 edx, DWORD PTR _tokenStream$[ebp]
  00041	8b 02		 mov	 eax, DWORD PTR [edx]
  00043	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00046	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00049	ff d2		 call	 edx
  0004b	83 c4 04	 add	 esp, 4
  0004e	3b f4		 cmp	 esi, esp
  00050	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00055	39 45 10	 cmp	 DWORD PTR _stop$[ebp], eax
  00058	76 25		 jbe	 SHORT $LN6@getTokensS

; 732  :     {
; 733  : 	stop = tokenStream->tstream->istream->size(tokenStream->tstream->istream);

  0005a	8b 45 08	 mov	 eax, DWORD PTR _tokenStream$[ebp]
  0005d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005f	8b f4		 mov	 esi, esp
  00061	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00064	52		 push	 edx
  00065	8b 45 08	 mov	 eax, DWORD PTR _tokenStream$[ebp]
  00068	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0006d	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00070	ff d0		 call	 eax
  00072	83 c4 04	 add	 esp, 4
  00075	3b f4		 cmp	 esi, esp
  00077	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007c	89 45 10	 mov	 DWORD PTR _stop$[ebp], eax
$LN6@getTokensS:

; 734  :     }
; 735  :     if	(start > stop)

  0007f	8b 4d 0c	 mov	 ecx, DWORD PTR _start$[ebp]
  00082	3b 4d 10	 cmp	 ecx, DWORD PTR _stop$[ebp]
  00085	76 07		 jbe	 SHORT $LN7@getTokensS

; 736  :     {
; 737  : 	return NULL;

  00087	33 c0		 xor	 eax, eax
  00089	e9 40 01 00 00	 jmp	 $LN1@getTokensS
$LN7@getTokensS:

; 738  :     }
; 739  : 
; 740  :     /* We have the range set, now we need to iterate through the
; 741  :      * installed tokens and create a new list with just the ones we want
; 742  :      * in it. We are just moving pointers about really.
; 743  :      */
; 744  :     filteredList    = antlr3ListNew((ANTLR3_UINT32)tokenStream->tstream->istream->size(tokenStream->tstream->istream));

  0008e	8b 55 08	 mov	 edx, DWORD PTR _tokenStream$[ebp]
  00091	8b 02		 mov	 eax, DWORD PTR [edx]
  00093	8b f4		 mov	 esi, esp
  00095	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00098	51		 push	 ecx
  00099	8b 55 08	 mov	 edx, DWORD PTR _tokenStream$[ebp]
  0009c	8b 02		 mov	 eax, DWORD PTR [edx]
  0009e	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000a1	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  000a4	ff d2		 call	 edx
  000a6	83 c4 04	 add	 esp, 4
  000a9	3b f4		 cmp	 esi, esp
  000ab	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b0	50		 push	 eax
  000b1	e8 00 00 00 00	 call	 _antlr3ListNew
  000b6	83 c4 04	 add	 esp, 4
  000b9	89 45 fc	 mov	 DWORD PTR _filteredList$[ebp], eax

; 745  : 
; 746  :     for	(i = start, n = 0; i<= stop; i++)

  000bc	8b 45 0c	 mov	 eax, DWORD PTR _start$[ebp]
  000bf	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  000c2	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  000c9	eb 09		 jmp	 SHORT $LN4@getTokensS
$LN2@getTokensS:
  000cb	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  000ce	83 c1 01	 add	 ecx, 1
  000d1	89 4d f8	 mov	 DWORD PTR _i$[ebp], ecx
$LN4@getTokensS:
  000d4	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  000d7	3b 55 10	 cmp	 edx, DWORD PTR _stop$[ebp]
  000da	0f 87 b0 00 00
	00		 ja	 $LN3@getTokensS

; 747  :     {
; 748  : 	tok = tokenStream->tstream->get(tokenStream->tstream, i);

  000e0	8b f4		 mov	 esi, esp
  000e2	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000e5	50		 push	 eax
  000e6	8b 4d 08	 mov	 ecx, DWORD PTR _tokenStream$[ebp]
  000e9	8b 11		 mov	 edx, DWORD PTR [ecx]
  000eb	52		 push	 edx
  000ec	8b 45 08	 mov	 eax, DWORD PTR _tokenStream$[ebp]
  000ef	8b 08		 mov	 ecx, DWORD PTR [eax]
  000f1	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  000f4	ff d2		 call	 edx
  000f6	83 c4 08	 add	 esp, 8
  000f9	3b f4		 cmp	 esi, esp
  000fb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00100	89 45 f0	 mov	 DWORD PTR _tok$[ebp], eax

; 749  : 
; 750  : 	if  (	   types == NULL
; 751  : 		|| types->isMember(types, tok->getType(tok) == ANTLR3_TRUE)

  00103	83 7d 14 00	 cmp	 DWORD PTR _types$[ebp], 0
  00107	74 50		 je	 SHORT $LN9@getTokensS
  00109	8b f4		 mov	 esi, esp
  0010b	8b 45 f0	 mov	 eax, DWORD PTR _tok$[ebp]
  0010e	50		 push	 eax
  0010f	8b 4d f0	 mov	 ecx, DWORD PTR _tok$[ebp]
  00112	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  00115	ff d2		 call	 edx
  00117	83 c4 04	 add	 esp, 4
  0011a	3b f4		 cmp	 esi, esp
  0011c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00121	83 f8 01	 cmp	 eax, 1
  00124	75 09		 jne	 SHORT $LN12@getTokensS
  00126	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv139[ebp], 1
  0012d	eb 07		 jmp	 SHORT $LN13@getTokensS
$LN12@getTokensS:
  0012f	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv139[ebp], 0
$LN13@getTokensS:
  00136	8b f4		 mov	 esi, esp
  00138	8b 45 ec	 mov	 eax, DWORD PTR tv139[ebp]
  0013b	50		 push	 eax
  0013c	8b 4d 14	 mov	 ecx, DWORD PTR _types$[ebp]
  0013f	51		 push	 ecx
  00140	8b 55 14	 mov	 edx, DWORD PTR _types$[ebp]
  00143	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00146	ff d0		 call	 eax
  00148	83 c4 08	 add	 esp, 8
  0014b	3b f4		 cmp	 esi, esp
  0014d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00152	0f b6 c8	 movzx	 ecx, al
  00155	85 c9		 test	 ecx, ecx
  00157	74 32		 je	 SHORT $LN8@getTokensS
$LN9@getTokensS:

; 752  : 	    )
; 753  : 	{
; 754  : 	    filteredList->put(filteredList, n++, (void *)tok, NULL);

  00159	8b 55 f4	 mov	 edx, DWORD PTR _n$[ebp]
  0015c	89 55 e8	 mov	 DWORD PTR tv149[ebp], edx
  0015f	8b 45 f4	 mov	 eax, DWORD PTR _n$[ebp]
  00162	83 c0 01	 add	 eax, 1
  00165	89 45 f4	 mov	 DWORD PTR _n$[ebp], eax
  00168	8b f4		 mov	 esi, esp
  0016a	6a 00		 push	 0
  0016c	8b 4d f0	 mov	 ecx, DWORD PTR _tok$[ebp]
  0016f	51		 push	 ecx
  00170	8b 55 e8	 mov	 edx, DWORD PTR tv149[ebp]
  00173	52		 push	 edx
  00174	8b 45 fc	 mov	 eax, DWORD PTR _filteredList$[ebp]
  00177	50		 push	 eax
  00178	8b 4d fc	 mov	 ecx, DWORD PTR _filteredList$[ebp]
  0017b	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0017e	ff d2		 call	 edx
  00180	83 c4 10	 add	 esp, 16			; 00000010H
  00183	3b f4		 cmp	 esi, esp
  00185	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0018a	90		 npad	 1
$LN8@getTokensS:

; 755  : 	}
; 756  :     }

  0018b	e9 3b ff ff ff	 jmp	 $LN2@getTokensS
$LN3@getTokensS:

; 757  :     
; 758  :     /* Did we get any then?
; 759  :      */
; 760  :     if	(filteredList->size(filteredList) == 0)

  00190	8b f4		 mov	 esi, esp
  00192	8b 45 fc	 mov	 eax, DWORD PTR _filteredList$[ebp]
  00195	50		 push	 eax
  00196	8b 4d fc	 mov	 ecx, DWORD PTR _filteredList$[ebp]
  00199	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0019c	ff d2		 call	 edx
  0019e	83 c4 04	 add	 esp, 4
  001a1	3b f4		 cmp	 esi, esp
  001a3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001a8	85 c0		 test	 eax, eax
  001aa	75 1f		 jne	 SHORT $LN10@getTokensS

; 761  :     {
; 762  : 	filteredList->free(filteredList);

  001ac	8b f4		 mov	 esi, esp
  001ae	8b 45 fc	 mov	 eax, DWORD PTR _filteredList$[ebp]
  001b1	50		 push	 eax
  001b2	8b 4d fc	 mov	 ecx, DWORD PTR _filteredList$[ebp]
  001b5	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  001b8	ff d2		 call	 edx
  001ba	83 c4 04	 add	 esp, 4
  001bd	3b f4		 cmp	 esi, esp
  001bf	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 763  : 	filteredList	= NULL;

  001c4	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _filteredList$[ebp], 0
$LN10@getTokensS:

; 764  :     }
; 765  : 
; 766  :     return  filteredList;

  001cb	8b 45 fc	 mov	 eax, DWORD PTR _filteredList$[ebp]
$LN1@getTokensS:

; 767  : }

  001ce	5e		 pop	 esi
  001cf	83 c4 18	 add	 esp, 24			; 00000018H
  001d2	3b ec		 cmp	 ebp, esp
  001d4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001d9	8b e5		 mov	 esp, ebp
  001db	5d		 pop	 ebp
  001dc	c3		 ret	 0
_getTokensSet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3tokenstream.c
;	COMDAT _getTokenRange
_TEXT	SEGMENT
_tokenStream$ = 8					; size = 4
_start$ = 12						; size = 4
_stop$ = 16						; size = 4
_getTokenRange PROC					; COMDAT

; 712  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 713  :     return tokenStream->getTokensSet(tokenStream, start, stop, NULL);

  00004	8b f4		 mov	 esi, esp
  00006	6a 00		 push	 0
  00008	8b 45 10	 mov	 eax, DWORD PTR _stop$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR _start$[ebp]
  0000f	51		 push	 ecx
  00010	8b 55 08	 mov	 edx, DWORD PTR _tokenStream$[ebp]
  00013	52		 push	 edx
  00014	8b 45 08	 mov	 eax, DWORD PTR _tokenStream$[ebp]
  00017	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0001a	ff d1		 call	 ecx
  0001c	83 c4 10	 add	 esp, 16			; 00000010H
  0001f	3b f4		 cmp	 esi, esp
  00021	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 714  : }                                                   

  00026	5e		 pop	 esi
  00027	3b ec		 cmp	 ebp, esp
  00029	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
_getTokenRange ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3tokenstream.c
;	COMDAT _getTokens
_TEXT	SEGMENT
_tokenStream$ = 8					; size = 4
_getTokens PROC						; COMDAT

; 701  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 702  :     if	(tokenStream->p == -1)

  00003	8b 45 08	 mov	 eax, DWORD PTR _tokenStream$[ebp]
  00006	83 78 1c ff	 cmp	 DWORD PTR [eax+28], -1
  0000a	75 0c		 jne	 SHORT $LN2@getTokens

; 703  :     {
; 704  : 	fillBuffer(tokenStream);

  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _tokenStream$[ebp]
  0000f	51		 push	 ecx
  00010	e8 00 00 00 00	 call	 _fillBuffer
  00015	83 c4 04	 add	 esp, 4
$LN2@getTokens:

; 705  :     }
; 706  : 
; 707  :     return  tokenStream->tokens;

  00018	8b 55 08	 mov	 edx, DWORD PTR _tokenStream$[ebp]
  0001b	8b 42 08	 mov	 eax, DWORD PTR [edx+8]

; 708  : }

  0001e	3b ec		 cmp	 ebp, esp
  00020	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
_getTokens ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3tokenstream.c
;	COMDAT _discardOffChannel
_TEXT	SEGMENT
_tokenStream$ = 8					; size = 4
_discard$ = 12						; size = 1
_discardOffChannel PROC					; COMDAT

; 695  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 696  :     tokenStream->discardOffChannel  = discard;

  00003	8b 45 08	 mov	 eax, DWORD PTR _tokenStream$[ebp]
  00006	8a 4d 0c	 mov	 cl, BYTE PTR _discard$[ebp]
  00009	88 48 18	 mov	 BYTE PTR [eax+24], cl

; 697  : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
_discardOffChannel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3tokenstream.c
;	COMDAT _discardTokenType
_TEXT	SEGMENT
_tokenStream$ = 8					; size = 4
_ttype$ = 12						; size = 4
_discardTokenType PROC					; COMDAT

; 681  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 682  :     if	(tokenStream->discardSet == NULL)

  00004	8b 45 08	 mov	 eax, DWORD PTR _tokenStream$[ebp]
  00007	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  0000b	75 10		 jne	 SHORT $LN2@discardTok

; 683  :     {
; 684  : 	tokenStream->discardSet	= antlr3ListNew(31);

  0000d	6a 1f		 push	 31			; 0000001fH
  0000f	e8 00 00 00 00	 call	 _antlr3ListNew
  00014	83 c4 04	 add	 esp, 4
  00017	8b 4d 08	 mov	 ecx, DWORD PTR _tokenStream$[ebp]
  0001a	89 41 10	 mov	 DWORD PTR [ecx+16], eax
$LN2@discardTok:

; 685  :     }
; 686  : 
; 687  :     /* We add one to the channel so we can distinguish NULL as being no entry in the
; 688  :      * table for a particular token type. We could use bitsets for this I suppose too.
; 689  :      */
; 690  :     tokenStream->discardSet->put(tokenStream->discardSet, ttype, ANTLR3_FUNC_PTR((ANTLR3_UINT32)ttype + 1), NULL);

  0001d	8b f4		 mov	 esi, esp
  0001f	6a 00		 push	 0
  00021	8b 55 0c	 mov	 edx, DWORD PTR _ttype$[ebp]
  00024	83 c2 01	 add	 edx, 1
  00027	52		 push	 edx
  00028	8b 45 0c	 mov	 eax, DWORD PTR _ttype$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _tokenStream$[ebp]
  0002f	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00032	52		 push	 edx
  00033	8b 45 08	 mov	 eax, DWORD PTR _tokenStream$[ebp]
  00036	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00039	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0003c	ff d2		 call	 edx
  0003e	83 c4 10	 add	 esp, 16			; 00000010H
  00041	3b f4		 cmp	 esi, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	90		 npad	 1

; 691  : }

  00049	5e		 pop	 esi
  0004a	3b ec		 cmp	 ebp, esp
  0004c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
_discardTokenType ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3tokenstream.c
;	COMDAT _setTokenTypeChannel
_TEXT	SEGMENT
_tokenStream$ = 8					; size = 4
_ttype$ = 12						; size = 4
_channel$ = 16						; size = 4
_setTokenTypeChannel PROC				; COMDAT

; 667  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 668  :     if	(tokenStream->channelOverrides == NULL)

  00004	8b 45 08	 mov	 eax, DWORD PTR _tokenStream$[ebp]
  00007	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  0000b	75 10		 jne	 SHORT $LN2@setTokenTy

; 669  :     {
; 670  : 	tokenStream->channelOverrides	= antlr3ListNew(10);

  0000d	6a 0a		 push	 10			; 0000000aH
  0000f	e8 00 00 00 00	 call	 _antlr3ListNew
  00014	83 c4 04	 add	 esp, 4
  00017	8b 4d 08	 mov	 ecx, DWORD PTR _tokenStream$[ebp]
  0001a	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
$LN2@setTokenTy:

; 671  :     }
; 672  : 
; 673  :     /* We add one to the channel so we can distinguish NULL as being no entry in the
; 674  :      * table for a particular token type.
; 675  :      */
; 676  :     tokenStream->channelOverrides->put(tokenStream->channelOverrides, ttype, ANTLR3_FUNC_PTR((ANTLR3_UINT32)channel + 1), NULL);

  0001d	8b f4		 mov	 esi, esp
  0001f	6a 00		 push	 0
  00021	8b 55 10	 mov	 edx, DWORD PTR _channel$[ebp]
  00024	83 c2 01	 add	 edx, 1
  00027	52		 push	 edx
  00028	8b 45 0c	 mov	 eax, DWORD PTR _ttype$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _tokenStream$[ebp]
  0002f	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00032	52		 push	 edx
  00033	8b 45 08	 mov	 eax, DWORD PTR _tokenStream$[ebp]
  00036	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00039	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0003c	ff d2		 call	 edx
  0003e	83 c4 10	 add	 esp, 16			; 00000010H
  00041	3b f4		 cmp	 esi, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	90		 npad	 1

; 677  : }

  00049	5e		 pop	 esi
  0004a	3b ec		 cmp	 ebp, esp
  0004c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
_setTokenTypeChannel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3tokenstream.c
;	COMDAT _fillBufferExt
_TEXT	SEGMENT
_tokenStream$ = 8					; size = 4
_fillBufferExt PROC					; COMDAT

; 946  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 947  :     fillBuffer(tokenStream);

  00003	8b 45 08	 mov	 eax, DWORD PTR _tokenStream$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 _fillBuffer
  0000c	83 c4 04	 add	 esp, 4

; 948  : }

  0000f	3b ec		 cmp	 ebp, esp
  00011	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
_fillBufferExt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3tokenstream.c
;	COMDAT _antlr3CommonTokenDebugStreamSourceNew
_TEXT	SEGMENT
_stream$ = -4						; size = 4
_hint$ = 8						; size = 4
_source$ = 12						; size = 4
_debugger$ = 16						; size = 4
_antlr3CommonTokenDebugStreamSourceNew PROC		; COMDAT

; 207  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 208  :     pANTLR3_COMMON_TOKEN_STREAM	stream;
; 209  : 
; 210  : 	// Create a standard token stream
; 211  : 	//
; 212  : 	stream = antlr3CommonTokenStreamSourceNew(hint, source);

  0000b	8b 45 0c	 mov	 eax, DWORD PTR _source$[ebp]
  0000e	50		 push	 eax
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _hint$[ebp]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 _antlr3CommonTokenStreamSourceNew
  00018	83 c4 08	 add	 esp, 8
  0001b	89 45 fc	 mov	 DWORD PTR _stream$[ebp], eax

; 213  : 
; 214  : 	// Install the debugger object
; 215  : 	//
; 216  : 	stream->tstream->debugger = debugger;

  0001e	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  00021	8b 02		 mov	 eax, DWORD PTR [edx]
  00023	8b 4d 10	 mov	 ecx, DWORD PTR _debugger$[ebp]
  00026	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 217  : 
; 218  : 	// Override standard token stream methods with debugging versions
; 219  : 	//
; 220  : 	stream->tstream->initialStreamState	= ANTLR3_FALSE;

  00029	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  0002c	8b 02		 mov	 eax, DWORD PTR [edx]
  0002e	c6 40 10 00	 mov	 BYTE PTR [eax+16], 0

; 221  : 
; 222  : 	stream->tstream->_LT				= dbgTokLT;

  00032	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  00035	8b 11		 mov	 edx, DWORD PTR [ecx]
  00037	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], OFFSET _dbgTokLT

; 223  : 
; 224  : 	stream->tstream->istream->consume		= dbgConsume;

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  00041	8b 08		 mov	 ecx, DWORD PTR [eax]
  00043	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00046	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], OFFSET _dbgConsume

; 225  : 	stream->tstream->istream->_LA			= dbgLA;

  0004d	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  00050	8b 08		 mov	 ecx, DWORD PTR [eax]
  00052	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00055	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET _dbgLA

; 226  : 	stream->tstream->istream->mark			= dbgMark;

  0005c	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  0005f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00061	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00064	c7 42 1c 00 00
	00 00		 mov	 DWORD PTR [edx+28], OFFSET _dbgMark

; 227  : 	stream->tstream->istream->rewind		= dbgRewindStream;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  0006e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00070	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00073	c7 42 24 00 00
	00 00		 mov	 DWORD PTR [edx+36], OFFSET _dbgRewindStream

; 228  : 	stream->tstream->istream->rewindLast	= dbgRewindLast;

  0007a	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  0007d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007f	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00082	c7 42 28 00 00
	00 00		 mov	 DWORD PTR [edx+40], OFFSET _dbgRewindLast

; 229  : 	stream->tstream->istream->seek			= dbgSeek;

  00089	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  0008c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0008e	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00091	c7 42 30 00 00
	00 00		 mov	 DWORD PTR [edx+48], OFFSET _dbgSeek

; 230  : 
; 231  : 	return stream;

  00098	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]

; 232  : }

  0009b	83 c4 04	 add	 esp, 4
  0009e	3b ec		 cmp	 ebp, esp
  000a0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a5	8b e5		 mov	 esp, ebp
  000a7	5d		 pop	 ebp
  000a8	c3		 ret	 0
_antlr3CommonTokenDebugStreamSourceNew ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3tokenstream.c
;	COMDAT _antlr3CommonTokenStreamNew
_TEXT	SEGMENT
_stream$ = -4						; size = 4
_hint$ = 8						; size = 4
_antlr3CommonTokenStreamNew PROC			; COMDAT

; 255  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 256  :     pANTLR3_COMMON_TOKEN_STREAM stream;
; 257  : 
; 258  :     /* Memory for the interface structure
; 259  :      */
; 260  :     stream  = (pANTLR3_COMMON_TOKEN_STREAM) ANTLR3_MALLOC(sizeof(ANTLR3_COMMON_TOKEN_STREAM));

  0000c	8b f4		 mov	 esi, esp
  0000e	6a 48		 push	 72			; 00000048H
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00016	83 c4 04	 add	 esp, 4
  00019	3b f4		 cmp	 esi, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	89 45 fc	 mov	 DWORD PTR _stream$[ebp], eax

; 261  : 
; 262  :     if	(stream == NULL)

  00023	83 7d fc 00	 cmp	 DWORD PTR _stream$[ebp], 0
  00027	75 07		 jne	 SHORT $LN2@antlr3Comm

; 263  :     {
; 264  : 	return	NULL;

  00029	33 c0		 xor	 eax, eax
  0002b	e9 ad 01 00 00	 jmp	 $LN1@antlr3Comm
$LN2@antlr3Comm:

; 265  :     }
; 266  : 
; 267  :     /* Create space for the token stream interface
; 268  :      */
; 269  :     stream->tstream	    = antlr3TokenStreamNew();

  00030	e8 00 00 00 00	 call	 _antlr3TokenStreamNew
  00035	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  00038	89 01		 mov	 DWORD PTR [ecx], eax

; 270  :     stream->tstream->super  =  stream;

  0003a	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  0003d	8b 02		 mov	 eax, DWORD PTR [edx]
  0003f	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  00042	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 271  : 
; 272  :     /* Create space for the INT_STREAM interfacce
; 273  :      */
; 274  :     stream->tstream->istream		    =  antlr3IntStreamNew();

  00045	e8 00 00 00 00	 call	 _antlr3IntStreamNew
  0004a	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  0004d	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0004f	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 275  :     stream->tstream->istream->super	    =  (stream->tstream);

  00052	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  00055	8b 02		 mov	 eax, DWORD PTR [edx]
  00057	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0005a	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  0005d	8b 02		 mov	 eax, DWORD PTR [edx]
  0005f	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 276  :     stream->tstream->istream->type	    = ANTLR3_TOKENSTREAM;

  00062	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  00065	8b 11		 mov	 edx, DWORD PTR [ecx]
  00067	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0006a	c7 00 02 00 00
	00		 mov	 DWORD PTR [eax], 2

; 277  : 
; 278  :     /* Install the token tracking tables
; 279  :      */
; 280  :     stream->tokens  = antlr3VectorNew(0);

  00070	6a 00		 push	 0
  00072	e8 00 00 00 00	 call	 _antlr3VectorNew
  00077	83 c4 04	 add	 esp, 4
  0007a	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  0007d	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 281  : 
; 282  :     /* Defaults
; 283  :      */
; 284  :     stream->p	    = -1;

  00080	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  00083	c7 42 1c ff ff
	ff ff		 mov	 DWORD PTR [edx+28], -1

; 285  : 
; 286  :     /* Install the common token stream API
; 287  :      */
; 288  :     stream->setTokenTypeChannel	    = setTokenTypeChannel;

  0008a	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  0008d	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], OFFSET _setTokenTypeChannel

; 289  :     stream->discardTokenType	    = discardTokenType;

  00094	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  00097	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], OFFSET _discardTokenType

; 290  :     stream->discardOffChannelToks   = discardOffChannel;

  0009e	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  000a1	c7 42 28 00 00
	00 00		 mov	 DWORD PTR [edx+40], OFFSET _discardOffChannel

; 291  :     stream->getTokens		    = getTokens;

  000a8	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  000ab	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], OFFSET _getTokens

; 292  :     stream->getTokenRange	    = getTokenRange;

  000b2	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  000b5	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], OFFSET _getTokenRange

; 293  :     stream->getTokensSet	    = getTokensSet;

  000bc	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  000bf	c7 42 34 00 00
	00 00		 mov	 DWORD PTR [edx+52], OFFSET _getTokensSet

; 294  :     stream->getTokensList	    = getTokensList;

  000c6	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  000c9	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [eax+56], OFFSET _getTokensList

; 295  :     stream->getTokensType	    = getTokensType;

  000d0	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  000d3	c7 41 3c 00 00
	00 00		 mov	 DWORD PTR [ecx+60], OFFSET _getTokensType

; 296  :     stream->reset                   = reset;

  000da	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  000dd	c7 42 40 00 00
	00 00		 mov	 DWORD PTR [edx+64], OFFSET _reset

; 297  : 
; 298  :     /* Install the token stream API
; 299  :      */
; 300  :     stream->tstream->_LT			=  tokLT;

  000e4	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  000e7	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e9	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], OFFSET _tokLT

; 301  :     stream->tstream->get			=  get;

  000f0	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  000f3	8b 02		 mov	 eax, DWORD PTR [edx]
  000f5	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET _get

; 302  :     stream->tstream->getTokenSource	        =  getTokenSource;

  000fc	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  000ff	8b 11		 mov	 edx, DWORD PTR [ecx]
  00101	c7 42 1c 00 00
	00 00		 mov	 DWORD PTR [edx+28], OFFSET _getTokenSource

; 303  :     stream->tstream->setTokenSource	        =  setTokenSource;

  00108	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  0010b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0010d	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], OFFSET _setTokenSource

; 304  :     stream->tstream->toString		        =  toString;

  00114	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  00117	8b 02		 mov	 eax, DWORD PTR [edx]
  00119	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], OFFSET _toString

; 305  :     stream->tstream->toStringSS		        =  toStringSS;

  00120	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  00123	8b 11		 mov	 edx, DWORD PTR [ecx]
  00125	c7 42 28 00 00
	00 00		 mov	 DWORD PTR [edx+40], OFFSET _toStringSS

; 306  :     stream->tstream->toStringTT		        =  toStringTT;

  0012c	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  0012f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00131	c7 41 2c 00 00
	00 00		 mov	 DWORD PTR [ecx+44], OFFSET _toStringTT

; 307  :     stream->tstream->setDebugListener           =  setDebugListener;

  00138	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  0013b	8b 02		 mov	 eax, DWORD PTR [edx]
  0013d	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], OFFSET _setDebugListener

; 308  : 
; 309  :     /* Install INT_STREAM interface
; 310  :      */
; 311  :     stream->tstream->istream->_LA	=  _LA;

  00144	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  00147	8b 11		 mov	 edx, DWORD PTR [ecx]
  00149	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0014c	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET __LA

; 312  :     stream->tstream->istream->mark	=  mark;

  00153	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  00156	8b 11		 mov	 edx, DWORD PTR [ecx]
  00158	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0015b	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], OFFSET _mark

; 313  :     stream->tstream->istream->release	=  release;

  00162	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  00165	8b 11		 mov	 edx, DWORD PTR [ecx]
  00167	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0016a	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], OFFSET _release

; 314  :     stream->tstream->istream->size	=  size;

  00171	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  00174	8b 11		 mov	 edx, DWORD PTR [ecx]
  00176	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00179	c7 40 34 00 00
	00 00		 mov	 DWORD PTR [eax+52], OFFSET _size

; 315  :     stream->tstream->istream->index	=  tindex;

  00180	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  00183	8b 11		 mov	 edx, DWORD PTR [ecx]
  00185	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00188	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], OFFSET _tindex

; 316  :     stream->tstream->istream->rewind	=  rewindStream;

  0018f	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  00192	8b 11		 mov	 edx, DWORD PTR [ecx]
  00194	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00197	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], OFFSET _rewindStream

; 317  :     stream->tstream->istream->rewindLast=  rewindLast;

  0019e	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  001a1	8b 11		 mov	 edx, DWORD PTR [ecx]
  001a3	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  001a6	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [eax+40], OFFSET _rewindLast

; 318  :     stream->tstream->istream->seek	=  seek;

  001ad	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  001b0	8b 11		 mov	 edx, DWORD PTR [ecx]
  001b2	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  001b5	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], OFFSET _seek

; 319  :     stream->tstream->istream->consume	=  consume;

  001bc	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  001bf	8b 11		 mov	 edx, DWORD PTR [ecx]
  001c1	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  001c4	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], OFFSET _consume

; 320  :     stream->tstream->istream->getSourceName = getSourceName;

  001cb	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  001ce	8b 11		 mov	 edx, DWORD PTR [ecx]
  001d0	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  001d3	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], OFFSET _getSourceName

; 321  : 
; 322  :     return  stream;

  001da	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
$LN1@antlr3Comm:

; 323  : }

  001dd	5e		 pop	 esi
  001de	83 c4 04	 add	 esp, 4
  001e1	3b ec		 cmp	 ebp, esp
  001e3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001e8	8b e5		 mov	 esp, ebp
  001ea	5d		 pop	 ebp
  001eb	c3		 ret	 0
_antlr3CommonTokenStreamNew ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3tokenstream.c
;	COMDAT _antlr3CommonTokenStreamSourceNew
_TEXT	SEGMENT
_stream$ = -4						; size = 4
_hint$ = 8						; size = 4
_source$ = 12						; size = 4
_antlr3CommonTokenStreamSourceNew PROC			; COMDAT

; 236  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 237  :     pANTLR3_COMMON_TOKEN_STREAM	stream;
; 238  : 
; 239  :     stream = antlr3CommonTokenStreamNew(hint);

  0000c	8b 45 08	 mov	 eax, DWORD PTR _hint$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 _antlr3CommonTokenStreamNew
  00015	83 c4 04	 add	 esp, 4
  00018	89 45 fc	 mov	 DWORD PTR _stream$[ebp], eax

; 240  : 
; 241  :     stream->channel = ANTLR3_TOKEN_DEFAULT_CHANNEL;

  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  0001e	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 242  :     
; 243  :     stream->channelOverrides	= NULL;

  00025	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  00028	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0

; 244  :     stream->discardSet		= NULL;

  0002f	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  00032	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 245  :     stream->discardOffChannel	= ANTLR3_FALSE;

  00039	8b 4d fc	 mov	 ecx, DWORD PTR _stream$[ebp]
  0003c	c6 41 18 00	 mov	 BYTE PTR [ecx+24], 0

; 246  : 
; 247  :     stream->tstream->setTokenSource(stream->tstream, source);

  00040	8b f4		 mov	 esi, esp
  00042	8b 55 0c	 mov	 edx, DWORD PTR _source$[ebp]
  00045	52		 push	 edx
  00046	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]
  00049	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004b	51		 push	 ecx
  0004c	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  0004f	8b 02		 mov	 eax, DWORD PTR [edx]
  00051	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00054	ff d1		 call	 ecx
  00056	83 c4 08	 add	 esp, 8
  00059	3b f4		 cmp	 esi, esp
  0005b	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 248  : 
; 249  :     stream->free		=  antlr3CTSFree;

  00060	8b 55 fc	 mov	 edx, DWORD PTR _stream$[ebp]
  00063	c7 42 44 00 00
	00 00		 mov	 DWORD PTR [edx+68], OFFSET _antlr3CTSFree

; 250  :     return  stream;

  0006a	8b 45 fc	 mov	 eax, DWORD PTR _stream$[ebp]

; 251  : }

  0006d	5e		 pop	 esi
  0006e	83 c4 04	 add	 esp, 4
  00071	3b ec		 cmp	 ebp, esp
  00073	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c3		 ret	 0
_antlr3CommonTokenStreamSourceNew ENDP
_TEXT	ENDS
END
