; Listing generated by Microsoft (R) Optimizing Compiler Version 19.42.34436.0 

	TITLE	C:\SPO_labs\C\DebugDLL\antlr3lexer.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	___local_stdio_printf_options
PUBLIC	__vfprintf_l
PUBLIC	_fprintf
PUBLIC	_antlr3LexerNewStream
PUBLIC	_antlr3LexerNew
PUBLIC	??_C@_0EG@JALJLDIL@lexer?9?$DOmTokens?$CI?$CJ?3?5Error?3?5No?5lex@ ; `string'
PUBLIC	??_C@_0BC@NHAPJBAE@?9unknown?5source?9?$CI@	; `string'
PUBLIC	??_C@_03ECLNAHEM@?$CFs?$CI@			; `string'
PUBLIC	??_C@_04CGKAJBAP@?$CFd?$CJ?5@			; `string'
PUBLIC	??_C@_0CG@CKJILOKO@?3?5lexer?5error?5?$CFd?5?3?6?7?$CFs?5at?5offse@ ; `string'
PUBLIC	??_C@_0N@LFOODOBD@near?5?8?$CFc?8?5?3?6@	; `string'
PUBLIC	??_C@_0BE@GGCOLI@near?5char?$CI?$CF?$CD02X?$CJ?5?3?6@ ; `string'
PUBLIC	??_C@_06LNEMBBGL@?7?$CF?4?$CKs?6@		; `string'
PUBLIC	??_C@_0HE@ELHLADFJ@?$CIend?5of?5input?$CJ?4?6?7?5This?5indicate@ ; `string'
PUBLIC	??_C@_0DL@OFNCJFPJ@?7?5The?5lexer?5was?5matching?5from?5l@ ; `string'
PUBLIC	??_C@_0BJ@MNCIDMAD@looks?5like?5this?3?6?7?7?$CF?4?$CKs?6@ ; `string'
PUBLIC	??_C@_0EB@JKDHCAGB@is?5also?5the?5end?5of?5the?5line?0?5so@ ; `string'
EXTRN	__imp__isprint:PROC
EXTRN	__imp__calloc:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	_antlr3BaseRecognizerNew:PROC
EXTRN	_antlr3RecognitionExceptionNew:PROC
EXTRN	_antlr3StackNew:PROC
EXTRN	_antlr3TokenFactoryNew:PROC
EXTRN	_antlr3SetTokenAPI:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0EB@JKDHCAGB@is?5also?5the?5end?5of?5the?5line?0?5so@
CONST	SEGMENT
??_C@_0EB@JKDHCAGB@is?5also?5the?5end?5of?5the?5line?0?5so@ DB 'is also t'
	DB	'he end of the line, so you must check your lexer rules', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@MNCIDMAD@looks?5like?5this?3?6?7?7?$CF?4?$CKs?6@
CONST	SEGMENT
??_C@_0BJ@MNCIDMAD@looks?5like?5this?3?6?7?7?$CF?4?$CKs?6@ DB 'looks like'
	DB	' this:', 0aH, 09H, 09H, '%.*s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@OFNCJFPJ@?7?5The?5lexer?5was?5matching?5from?5l@
CONST	SEGMENT
??_C@_0DL@OFNCJFPJ@?7?5The?5lexer?5was?5matching?5from?5l@ DB 09H, ' The '
	DB	'lexer was matching from line %d, offset %d, which', 0aH, 09H, ' '
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0HE@ELHLADFJ@?$CIend?5of?5input?$CJ?4?6?7?5This?5indicate@
CONST	SEGMENT
??_C@_0HE@ELHLADFJ@?$CIend?5of?5input?$CJ?4?6?7?5This?5indicate@ DB '(end'
	DB	' of input).', 0aH, 09H, ' This indicates a poorly specified l'
	DB	'exer RULE', 0aH, 09H, ' or unterminated input element such as'
	DB	': "STRING["]', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06LNEMBBGL@?7?$CF?4?$CKs?6@
CONST	SEGMENT
??_C@_06LNEMBBGL@?7?$CF?4?$CKs?6@ DB 09H, '%.*s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GGCOLI@near?5char?$CI?$CF?$CD02X?$CJ?5?3?6@
CONST	SEGMENT
??_C@_0BE@GGCOLI@near?5char?$CI?$CF?$CD02X?$CJ?5?3?6@ DB 'near char(%#02X'
	DB	') :', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LFOODOBD@near?5?8?$CFc?8?5?3?6@
CONST	SEGMENT
??_C@_0N@LFOODOBD@near?5?8?$CFc?8?5?3?6@ DB 'near ''%c'' :', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@CKJILOKO@?3?5lexer?5error?5?$CFd?5?3?6?7?$CFs?5at?5offse@
CONST	SEGMENT
??_C@_0CG@CKJILOKO@?3?5lexer?5error?5?$CFd?5?3?6?7?$CFs?5at?5offse@ DB ':'
	DB	' lexer error %d :', 0aH, 09H, '%s at offset %d, ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04CGKAJBAP@?$CFd?$CJ?5@
CONST	SEGMENT
??_C@_04CGKAJBAP@?$CFd?$CJ?5@ DB '%d) ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03ECLNAHEM@?$CFs?$CI@
CONST	SEGMENT
??_C@_03ECLNAHEM@?$CFs?$CI@ DB '%s(', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NHAPJBAE@?9unknown?5source?9?$CI@
CONST	SEGMENT
??_C@_0BC@NHAPJBAE@?9unknown?5source?9?$CI@ DB '-unknown source-(', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@JALJLDIL@lexer?9?$DOmTokens?$CI?$CJ?3?5Error?3?5No?5lex@
CONST	SEGMENT
??_C@_0EG@JALJLDIL@lexer?9?$DOmTokens?$CI?$CJ?3?5Error?3?5No?5lex@ DB 'le'
	DB	'xer->mTokens(): Error: No lexer rules were added to the lexer'
	DB	' yet!', 0aH, 00H				; `string'
CONST	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3lexer.c
;	COMDAT _nextTokenStr
_TEXT	SEGMENT
_teof$1 = -20						; size = 4
_istream$ = -16						; size = 4
_input$ = -12						; size = 4
_state$ = -8						; size = 4
_lexer$ = -4						; size = 4
_toksource$ = 8						; size = 4
_nextTokenStr PROC					; COMDAT

; 218  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0000f	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00012	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00015	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00018	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 219  :     pANTLR3_LEXER                   lexer;
; 220  :     pANTLR3_RECOGNIZER_SHARED_STATE state;
; 221  :     pANTLR3_INPUT_STREAM            input;
; 222  :     pANTLR3_INT_STREAM              istream;
; 223  : 
; 224  :     lexer   = (pANTLR3_LEXER)(toksource->super);

  0001b	8b 45 08	 mov	 eax, DWORD PTR _toksource$[ebp]
  0001e	8b 88 28 01 00
	00		 mov	 ecx, DWORD PTR [eax+296]
  00024	89 4d fc	 mov	 DWORD PTR _lexer$[ebp], ecx

; 225  :     state   = lexer->rec->state;

  00027	8b 55 fc	 mov	 edx, DWORD PTR _lexer$[ebp]
  0002a	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0002d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00030	89 4d f8	 mov	 DWORD PTR _state$[ebp], ecx

; 226  :     input   = lexer->input;

  00033	8b 55 fc	 mov	 edx, DWORD PTR _lexer$[ebp]
  00036	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00039	89 45 f4	 mov	 DWORD PTR _input$[ebp], eax

; 227  :     istream = input->istream;

  0003c	8b 4d f4	 mov	 ecx, DWORD PTR _input$[ebp]
  0003f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00041	89 55 f0	 mov	 DWORD PTR _istream$[ebp], edx
$LN2@nextTokenS:

; 228  : 
; 229  :     /// Loop until we get a non skipped token or EOF
; 230  :     ///
; 231  :     for	(;;)
; 232  :     {
; 233  :         // Get rid of any previous token (token factory takes care of
; 234  :         // any de-allocation when this token is finally used up.
; 235  :         //
; 236  :         state->token		    = NULL;

  00044	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  00047	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], 0

; 237  :         state->error		    = ANTLR3_FALSE;	    // Start out without an exception

  0004e	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  00051	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 238  :         state->failed		    = ANTLR3_FALSE;

  00054	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  00057	c6 42 18 00	 mov	 BYTE PTR [edx+24], 0
$LN5@nextTokenS:

; 239  : 
; 240  :         // Now call the matching rules and see if we can generate a new token
; 241  :         //
; 242  :         for	(;;)
; 243  :         {
; 244  :             // Record the start of the token in our input stream.
; 245  :             //
; 246  :             state->channel			    = ANTLR3_TOKEN_DEFAULT_CHANNEL;

  0005b	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  0005e	c7 40 3c 00 00
	00 00		 mov	 DWORD PTR [eax+60], 0

; 247  :             state->tokenStartCharIndex	            = (ANTLR3_MARKER)(((pANTLR3_UINT8)input->nextChar));

  00065	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  00068	8b 55 f4	 mov	 edx, DWORD PTR _input$[ebp]
  0006b	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0006e	89 41 4c	 mov	 DWORD PTR [ecx+76], eax

; 248  :             state->tokenStartCharPositionInLine     = input->charPositionInLine;

  00071	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  00074	8b 55 f4	 mov	 edx, DWORD PTR _input$[ebp]
  00077	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  0007a	89 41 48	 mov	 DWORD PTR [ecx+72], eax

; 249  :             state->tokenStartLine		    = input->line;

  0007d	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  00080	8b 55 f4	 mov	 edx, DWORD PTR _input$[ebp]
  00083	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00086	89 41 44	 mov	 DWORD PTR [ecx+68], eax

; 250  :             state->text			            = NULL;

  00089	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  0008c	c7 41 50 00 00
	00 00		 mov	 DWORD PTR [ecx+80], 0

; 251  :             state->custom                           = NULL;

  00093	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  00096	c7 42 60 00 00
	00 00		 mov	 DWORD PTR [edx+96], 0

; 252  :             state->user1                            = 0;

  0009d	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  000a0	c7 40 54 00 00
	00 00		 mov	 DWORD PTR [eax+84], 0

; 253  :             state->user2                            = 0;

  000a7	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  000aa	c7 41 58 00 00
	00 00		 mov	 DWORD PTR [ecx+88], 0

; 254  :             state->user3                            = 0;

  000b1	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  000b4	c7 42 5c 00 00
	00 00		 mov	 DWORD PTR [edx+92], 0

; 255  : 
; 256  :             if  (istream->_LA(istream, 1) == ANTLR3_CHARSTREAM_EOF)

  000bb	8b f4		 mov	 esi, esp
  000bd	6a 01		 push	 1
  000bf	8b 45 f0	 mov	 eax, DWORD PTR _istream$[ebp]
  000c2	50		 push	 eax
  000c3	8b 4d f0	 mov	 ecx, DWORD PTR _istream$[ebp]
  000c6	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  000c9	ff d2		 call	 edx
  000cb	83 c4 08	 add	 esp, 8
  000ce	3b f4		 cmp	 esi, esp
  000d0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d5	83 f8 ff	 cmp	 eax, -1
  000d8	0f 85 b1 00 00
	00		 jne	 $LN8@nextTokenS

; 257  :             {
; 258  :                 // Reached the end of the current stream, nothing more to do if this is
; 259  :                 // the last in the stack.
; 260  :                 //
; 261  :                 pANTLR3_COMMON_TOKEN    teof = &(toksource->eofToken);

  000de	8b 45 08	 mov	 eax, DWORD PTR _toksource$[ebp]
  000e1	83 c0 08	 add	 eax, 8
  000e4	89 45 ec	 mov	 DWORD PTR _teof$1[ebp], eax

; 262  : 
; 263  :                 teof->setStartIndex (teof, lexer->getCharIndex(lexer));

  000e7	8b f4		 mov	 esi, esp
  000e9	8b 4d fc	 mov	 ecx, DWORD PTR _lexer$[ebp]
  000ec	51		 push	 ecx
  000ed	8b 55 fc	 mov	 edx, DWORD PTR _lexer$[ebp]
  000f0	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  000f3	ff d0		 call	 eax
  000f5	83 c4 04	 add	 esp, 4
  000f8	3b f4		 cmp	 esi, esp
  000fa	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ff	8b f4		 mov	 esi, esp
  00101	50		 push	 eax
  00102	8b 4d ec	 mov	 ecx, DWORD PTR _teof$1[ebp]
  00105	51		 push	 ecx
  00106	8b 55 ec	 mov	 edx, DWORD PTR _teof$1[ebp]
  00109	8b 82 80 00 00
	00		 mov	 eax, DWORD PTR [edx+128]
  0010f	ff d0		 call	 eax
  00111	83 c4 08	 add	 esp, 8
  00114	3b f4		 cmp	 esi, esp
  00116	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 264  :                 teof->setStopIndex  (teof, lexer->getCharIndex(lexer));

  0011b	8b f4		 mov	 esi, esp
  0011d	8b 4d fc	 mov	 ecx, DWORD PTR _lexer$[ebp]
  00120	51		 push	 ecx
  00121	8b 55 fc	 mov	 edx, DWORD PTR _lexer$[ebp]
  00124	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  00127	ff d0		 call	 eax
  00129	83 c4 04	 add	 esp, 4
  0012c	3b f4		 cmp	 esi, esp
  0012e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00133	8b f4		 mov	 esi, esp
  00135	50		 push	 eax
  00136	8b 4d ec	 mov	 ecx, DWORD PTR _teof$1[ebp]
  00139	51		 push	 ecx
  0013a	8b 55 ec	 mov	 edx, DWORD PTR _teof$1[ebp]
  0013d	8b 82 88 00 00
	00		 mov	 eax, DWORD PTR [edx+136]
  00143	ff d0		 call	 eax
  00145	83 c4 08	 add	 esp, 8
  00148	3b f4		 cmp	 esi, esp
  0014a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 265  :                 teof->setLine	    (teof, lexer->getLine(lexer));

  0014f	8b f4		 mov	 esi, esp
  00151	8b 4d fc	 mov	 ecx, DWORD PTR _lexer$[ebp]
  00154	51		 push	 ecx
  00155	8b 55 fc	 mov	 edx, DWORD PTR _lexer$[ebp]
  00158	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  0015b	ff d0		 call	 eax
  0015d	83 c4 04	 add	 esp, 4
  00160	3b f4		 cmp	 esi, esp
  00162	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00167	8b f4		 mov	 esi, esp
  00169	50		 push	 eax
  0016a	8b 4d ec	 mov	 ecx, DWORD PTR _teof$1[ebp]
  0016d	51		 push	 ecx
  0016e	8b 55 ec	 mov	 edx, DWORD PTR _teof$1[ebp]
  00171	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  00174	ff d0		 call	 eax
  00176	83 c4 08	 add	 esp, 8
  00179	3b f4		 cmp	 esi, esp
  0017b	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 266  :                 teof->factoryMade = ANTLR3_TRUE;	// This isn't really manufactured but it stops things from trying to free it

  00180	8b 4d ec	 mov	 ecx, DWORD PTR _teof$1[ebp]
  00183	c6 41 04 01	 mov	 BYTE PTR [ecx+4], 1

; 267  :                 return  teof;

  00187	8b 45 ec	 mov	 eax, DWORD PTR _teof$1[ebp]
  0018a	e9 bc 00 00 00	 jmp	 $LN3@nextTokenS
$LN8@nextTokenS:

; 268  :             }
; 269  : 
; 270  :             state->token		= NULL;

  0018f	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  00192	c7 42 30 00 00
	00 00		 mov	 DWORD PTR [edx+48], 0

; 271  :             state->error		= ANTLR3_FALSE;	    // Start out without an exception

  00199	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  0019c	c6 00 00	 mov	 BYTE PTR [eax], 0

; 272  :             state->failed		= ANTLR3_FALSE;

  0019f	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  001a2	c6 41 18 00	 mov	 BYTE PTR [ecx+24], 0

; 273  : 
; 274  :             // Call the generated lexer, see if it can get a new token together.
; 275  :             //
; 276  :             lexer->mTokens(lexer->ctx);

  001a6	8b f4		 mov	 esi, esp
  001a8	8b 55 fc	 mov	 edx, DWORD PTR _lexer$[ebp]
  001ab	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  001ae	50		 push	 eax
  001af	8b 4d fc	 mov	 ecx, DWORD PTR _lexer$[ebp]
  001b2	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  001b5	ff d2		 call	 edx
  001b7	83 c4 04	 add	 esp, 4
  001ba	3b f4		 cmp	 esi, esp
  001bc	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 277  : 
; 278  :             if  (state->error  == ANTLR3_TRUE)

  001c1	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  001c4	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  001c7	83 f9 01	 cmp	 ecx, 1
  001ca	75 40		 jne	 SHORT $LN9@nextTokenS

; 279  :             {
; 280  :                 // Recognition exception, report it and try to recover.
; 281  :                 //
; 282  :                 state->failed	    = ANTLR3_TRUE;

  001cc	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  001cf	c6 42 18 01	 mov	 BYTE PTR [edx+24], 1

; 283  :                 lexer->rec->reportError(lexer->rec);

  001d3	8b f4		 mov	 esi, esp
  001d5	8b 45 fc	 mov	 eax, DWORD PTR _lexer$[ebp]
  001d8	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  001db	51		 push	 ecx
  001dc	8b 55 fc	 mov	 edx, DWORD PTR _lexer$[ebp]
  001df	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  001e2	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  001e5	ff d1		 call	 ecx
  001e7	83 c4 04	 add	 esp, 4
  001ea	3b f4		 cmp	 esi, esp
  001ec	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 284  :                 lexer->recover(lexer); 

  001f1	8b f4		 mov	 esi, esp
  001f3	8b 55 fc	 mov	 edx, DWORD PTR _lexer$[ebp]
  001f6	52		 push	 edx
  001f7	8b 45 fc	 mov	 eax, DWORD PTR _lexer$[ebp]
  001fa	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  001fd	ff d1		 call	 ecx
  001ff	83 c4 04	 add	 esp, 4
  00202	3b f4		 cmp	 esi, esp
  00204	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00209	90		 npad	 1

; 285  :             }

  0020a	eb 35		 jmp	 SHORT $LN10@nextTokenS
$LN9@nextTokenS:

; 286  :             else
; 287  :             {
; 288  :                 if (state->token == NULL)

  0020c	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  0020f	83 7a 30 00	 cmp	 DWORD PTR [edx+48], 0
  00213	75 0e		 jne	 SHORT $LN11@nextTokenS

; 289  :                 {
; 290  :                     // Emit the real token, which adds it in to the token stream basically
; 291  :                     //
; 292  :                     emit(lexer);

  00215	8b 45 fc	 mov	 eax, DWORD PTR _lexer$[ebp]
  00218	50		 push	 eax
  00219	e8 00 00 00 00	 call	 _emit
  0021e	83 c4 04	 add	 esp, 4

; 293  :                 }

  00221	eb 16		 jmp	 SHORT $LN13@nextTokenS
$LN11@nextTokenS:

; 294  :                 else if	(state->token ==  &(toksource->skipToken))

  00223	8b 4d 08	 mov	 ecx, DWORD PTR _toksource$[ebp]
  00226	81 c1 98 00 00
	00		 add	 ecx, 152		; 00000098H
  0022c	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  0022f	39 4a 30	 cmp	 DWORD PTR [edx+48], ecx
  00232	75 05		 jne	 SHORT $LN13@nextTokenS

; 295  :                 {
; 296  :                     // A real token could have been generated, but "Computer say's naaaaah" and it
; 297  :                     // it is just something we need to skip altogether.
; 298  :                     //
; 299  :                     continue;

  00234	e9 22 fe ff ff	 jmp	 $LN5@nextTokenS
$LN13@nextTokenS:

; 300  :                 }
; 301  : 
; 302  :                 // Good token, not skipped, not EOF token
; 303  :                 //
; 304  :                 return  state->token;

  00239	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  0023c	8b 40 30	 mov	 eax, DWORD PTR [eax+48]
  0023f	eb 0a		 jmp	 SHORT $LN3@nextTokenS
$LN10@nextTokenS:

; 305  :             }
; 306  :         }

  00241	e9 15 fe ff ff	 jmp	 $LN5@nextTokenS

; 307  :     }

  00246	e9 f9 fd ff ff	 jmp	 $LN2@nextTokenS
$LN3@nextTokenS:

; 308  : }

  0024b	5e		 pop	 esi
  0024c	83 c4 14	 add	 esp, 20			; 00000014H
  0024f	3b ec		 cmp	 ebp, esp
  00251	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00256	8b e5		 mov	 esp, ebp
  00258	5d		 pop	 ebp
  00259	c3		 ret	 0
_nextTokenStr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3lexer.c
;	COMDAT _freeLexer
_TEXT	SEGMENT
_lexer$ = 8						; size = 4
_freeLexer PROC						; COMDAT

; 690  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 691  : 	// This may have ben a delegate or delegator lexer, in which case the
; 692  : 	// state may already have been freed (and set to NULL therefore)
; 693  : 	// so we ignore the state if we don't have it.
; 694  : 	//
; 695  : 	if	(lexer->rec->state != NULL)

  00004	8b 45 08	 mov	 eax, DWORD PTR _lexer$[ebp]
  00007	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0000a	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  0000e	0f 84 c4 00 00
	00		 je	 $LN5@freeLexer

; 696  : 	{
; 697  : 		if	(lexer->rec->state->streams != NULL)

  00014	8b 55 08	 mov	 edx, DWORD PTR _lexer$[ebp]
  00017	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0001a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0001d	83 79 64 00	 cmp	 DWORD PTR [ecx+100], 0
  00021	74 2b		 je	 SHORT $LN3@freeLexer

; 698  : 		{
; 699  : 			lexer->rec->state->streams->free(lexer->rec->state->streams);

  00023	8b 55 08	 mov	 edx, DWORD PTR _lexer$[ebp]
  00026	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00029	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0002c	8b f4		 mov	 esi, esp
  0002e	8b 51 64	 mov	 edx, DWORD PTR [ecx+100]
  00031	52		 push	 edx
  00032	8b 45 08	 mov	 eax, DWORD PTR _lexer$[ebp]
  00035	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00038	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0003b	8b 42 64	 mov	 eax, DWORD PTR [edx+100]
  0003e	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00041	ff d1		 call	 ecx
  00043	83 c4 04	 add	 esp, 4
  00046	3b f4		 cmp	 esi, esp
  00048	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004d	90		 npad	 1
$LN3@freeLexer:

; 700  : 		}
; 701  : 		if	(lexer->rec->state->tokFactory != NULL)

  0004e	8b 55 08	 mov	 edx, DWORD PTR _lexer$[ebp]
  00051	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00054	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00057	83 79 34 00	 cmp	 DWORD PTR [ecx+52], 0
  0005b	74 3d		 je	 SHORT $LN4@freeLexer

; 702  : 		{
; 703  : 			lexer->rec->state->tokFactory->close(lexer->rec->state->tokFactory);

  0005d	8b 55 08	 mov	 edx, DWORD PTR _lexer$[ebp]
  00060	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00063	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00066	8b f4		 mov	 esi, esp
  00068	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  0006b	52		 push	 edx
  0006c	8b 45 08	 mov	 eax, DWORD PTR _lexer$[ebp]
  0006f	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00072	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00075	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00078	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  0007e	ff d1		 call	 ecx
  00080	83 c4 04	 add	 esp, 4
  00083	3b f4		 cmp	 esi, esp
  00085	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 704  : 			lexer->rec->state->tokFactory = NULL;

  0008a	8b 55 08	 mov	 edx, DWORD PTR _lexer$[ebp]
  0008d	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00090	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00093	c7 41 34 00 00
	00 00		 mov	 DWORD PTR [ecx+52], 0
$LN4@freeLexer:

; 705  : 		}
; 706  : 		if	(lexer->rec->state->tokSource != NULL)

  0009a	8b 55 08	 mov	 edx, DWORD PTR _lexer$[ebp]
  0009d	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  000a0	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000a3	83 79 38 00	 cmp	 DWORD PTR [ecx+56], 0
  000a7	74 2f		 je	 SHORT $LN5@freeLexer

; 707  : 		{
; 708  : 			ANTLR3_FREE(lexer->rec->state->tokSource);

  000a9	8b 55 08	 mov	 edx, DWORD PTR _lexer$[ebp]
  000ac	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  000af	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000b2	8b f4		 mov	 esi, esp
  000b4	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  000b7	52		 push	 edx
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  000be	83 c4 04	 add	 esp, 4
  000c1	3b f4		 cmp	 esi, esp
  000c3	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 709  : 			lexer->rec->state->tokSource = NULL;

  000c8	8b 45 08	 mov	 eax, DWORD PTR _lexer$[ebp]
  000cb	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000ce	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000d1	c7 42 38 00 00
	00 00		 mov	 DWORD PTR [edx+56], 0
$LN5@freeLexer:

; 710  : 		}
; 711  : 	}
; 712  : 	if	(lexer->rec != NULL)

  000d8	8b 45 08	 mov	 eax, DWORD PTR _lexer$[ebp]
  000db	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  000df	74 2b		 je	 SHORT $LN6@freeLexer

; 713  : 	{
; 714  : 		lexer->rec->free(lexer->rec);

  000e1	8b f4		 mov	 esi, esp
  000e3	8b 4d 08	 mov	 ecx, DWORD PTR _lexer$[ebp]
  000e6	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  000e9	52		 push	 edx
  000ea	8b 45 08	 mov	 eax, DWORD PTR _lexer$[ebp]
  000ed	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000f0	8b 91 90 00 00
	00		 mov	 edx, DWORD PTR [ecx+144]
  000f6	ff d2		 call	 edx
  000f8	83 c4 04	 add	 esp, 4
  000fb	3b f4		 cmp	 esi, esp
  000fd	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 715  : 		lexer->rec = NULL;

  00102	8b 45 08	 mov	 eax, DWORD PTR _lexer$[ebp]
  00105	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
$LN6@freeLexer:

; 716  : 	}
; 717  : 	ANTLR3_FREE(lexer);

  0010c	8b f4		 mov	 esi, esp
  0010e	8b 4d 08	 mov	 ecx, DWORD PTR _lexer$[ebp]
  00111	51		 push	 ecx
  00112	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00118	83 c4 04	 add	 esp, 4
  0011b	3b f4		 cmp	 esi, esp
  0011d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00122	90		 npad	 1

; 718  : }

  00123	5e		 pop	 esi
  00124	3b ec		 cmp	 ebp, esp
  00126	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0012b	5d		 pop	 ebp
  0012c	c3		 ret	 0
_freeLexer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3lexer.c
;	COMDAT _reset
_TEXT	SEGMENT
_lexer$ = -4						; size = 4
_rec$ = 8						; size = 4
_reset	PROC						; COMDAT

; 176  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 177  :     pANTLR3_LEXER   lexer;
; 178  : 
; 179  :     lexer   = (pANTLR3_LEXER)rec->super;

  0000c	8b 45 08	 mov	 eax, DWORD PTR _rec$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	89 4d fc	 mov	 DWORD PTR _lexer$[ebp], ecx

; 180  : 
; 181  :     lexer->rec->state->token			    = NULL;

  00014	8b 55 fc	 mov	 edx, DWORD PTR _lexer$[ebp]
  00017	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0001a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0001d	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], 0

; 182  :     lexer->rec->state->type			    = ANTLR3_TOKEN_INVALID;

  00024	8b 55 fc	 mov	 edx, DWORD PTR _lexer$[ebp]
  00027	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0002a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0002d	c7 41 40 00 00
	00 00		 mov	 DWORD PTR [ecx+64], 0

; 183  :     lexer->rec->state->channel			    = ANTLR3_TOKEN_DEFAULT_CHANNEL;

  00034	8b 55 fc	 mov	 edx, DWORD PTR _lexer$[ebp]
  00037	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0003a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0003d	c7 41 3c 00 00
	00 00		 mov	 DWORD PTR [ecx+60], 0

; 184  :     lexer->rec->state->tokenStartCharIndex	    = -1;

  00044	8b 55 fc	 mov	 edx, DWORD PTR _lexer$[ebp]
  00047	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0004a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0004d	c7 41 4c ff ff
	ff ff		 mov	 DWORD PTR [ecx+76], -1

; 185  :     lexer->rec->state->tokenStartCharPositionInLine = -1;

  00054	8b 55 fc	 mov	 edx, DWORD PTR _lexer$[ebp]
  00057	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0005a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0005d	c7 41 48 ff ff
	ff ff		 mov	 DWORD PTR [ecx+72], -1

; 186  :     lexer->rec->state->tokenStartLine		    = -1;

  00064	8b 55 fc	 mov	 edx, DWORD PTR _lexer$[ebp]
  00067	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0006a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0006d	c7 41 44 ff ff
	ff ff		 mov	 DWORD PTR [ecx+68], -1

; 187  : 
; 188  :     lexer->rec->state->text	                    = NULL;

  00074	8b 55 fc	 mov	 edx, DWORD PTR _lexer$[ebp]
  00077	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0007a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0007d	c7 41 50 00 00
	00 00		 mov	 DWORD PTR [ecx+80], 0

; 189  : 
; 190  :     // OK - that's all hunky dory, but we may well have had
; 191  :     // a token factory that needs a reset. Do that here
; 192  :     //
; 193  :     if  (lexer->rec->state->tokFactory != NULL)

  00084	8b 55 fc	 mov	 edx, DWORD PTR _lexer$[ebp]
  00087	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0008a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0008d	83 79 34 00	 cmp	 DWORD PTR [ecx+52], 0
  00091	74 2e		 je	 SHORT $LN2@reset

; 194  :     {
; 195  :         lexer->rec->state->tokFactory->reset(lexer->rec->state->tokFactory);

  00093	8b 55 fc	 mov	 edx, DWORD PTR _lexer$[ebp]
  00096	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00099	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0009c	8b f4		 mov	 esi, esp
  0009e	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  000a1	52		 push	 edx
  000a2	8b 45 fc	 mov	 eax, DWORD PTR _lexer$[ebp]
  000a5	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000a8	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000ab	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  000ae	8b 88 a8 00 00
	00		 mov	 ecx, DWORD PTR [eax+168]
  000b4	ff d1		 call	 ecx
  000b6	83 c4 04	 add	 esp, 4
  000b9	3b f4		 cmp	 esi, esp
  000bb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c0	90		 npad	 1
$LN2@reset:

; 196  :     }
; 197  : }

  000c1	5e		 pop	 esi
  000c2	83 c4 04	 add	 esp, 4
  000c5	3b ec		 cmp	 ebp, esp
  000c7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000cc	8b e5		 mov	 esp, ebp
  000ce	5d		 pop	 ebp
  000cf	c3		 ret	 0
_reset	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3lexer.c
;	COMDAT _getMissingSymbol
_TEXT	SEGMENT
_recognizer$ = 8					; size = 4
_istream$ = 12						; size = 4
_e$ = 16						; size = 4
_expectedTokenType$ = 20				; size = 4
_follow$ = 24						; size = 4
_getMissingSymbol PROC					; COMDAT

; 903  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 904  : 	return NULL;

  00003	33 c0		 xor	 eax, eax

; 905  : }

  00005	5d		 pop	 ebp
  00006	c3		 ret	 0
_getMissingSymbol ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3lexer.c
;	COMDAT _getCurrentInputSymbol
_TEXT	SEGMENT
_recognizer$ = 8					; size = 4
_istream$ = 12						; size = 4
_getCurrentInputSymbol PROC				; COMDAT

; 896  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 897  : 	return NULL;

  00003	33 c0		 xor	 eax, eax

; 898  : }

  00005	5d		 pop	 ebp
  00006	c3		 ret	 0
_getCurrentInputSymbol ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3lexer.c
;	COMDAT _reportError
_TEXT	SEGMENT
_rec$ = 8						; size = 4
_reportError PROC					; COMDAT

; 412  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 413  :     // Indicate this recognizer had an error while processing.
; 414  : 	//
; 415  : 	rec->state->errorCount++;

  00004	8b 45 08	 mov	 eax, DWORD PTR _rec$[ebp]
  00007	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000a	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0000d	83 c2 01	 add	 edx, 1
  00010	8b 45 08	 mov	 eax, DWORD PTR _rec$[ebp]
  00013	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00016	89 51 1c	 mov	 DWORD PTR [ecx+28], edx

; 416  : 
; 417  :     rec->displayRecognitionError(rec, rec->state->tokenNames);

  00019	8b 55 08	 mov	 edx, DWORD PTR _rec$[ebp]
  0001c	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0001f	8b f4		 mov	 esi, esp
  00021	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00024	51		 push	 ecx
  00025	8b 55 08	 mov	 edx, DWORD PTR _rec$[ebp]
  00028	52		 push	 edx
  00029	8b 45 08	 mov	 eax, DWORD PTR _rec$[ebp]
  0002c	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  0002f	ff d1		 call	 ecx
  00031	83 c4 08	 add	 esp, 8
  00034	3b f4		 cmp	 esi, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	90		 npad	 1

; 418  : }

  0003c	5e		 pop	 esi
  0003d	3b ec		 cmp	 ebp, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
_reportError ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3lexer.c
;	COMDAT _displayRecognitionError
_TEXT	SEGMENT
tv208 = -24						; size = 4
tv168 = -20						; size = 4
_width$1 = -16						; size = 4
_ftext$ = -12						; size = 4
_ex$ = -8						; size = 4
_lexer$ = -4						; size = 4
_recognizer$ = 8					; size = 4
_tokenNames$ = 12					; size = 4
_displayRecognitionError PROC				; COMDAT

; 428  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000d	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00010	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00013	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00016	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00019	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001c	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 429  :     pANTLR3_LEXER			lexer;
; 430  : 	pANTLR3_EXCEPTION	    ex;
; 431  : 	pANTLR3_STRING			ftext;
; 432  : 
; 433  :     lexer   = (pANTLR3_LEXER)(recognizer->super);

  0001f	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  00022	8b 08		 mov	 ecx, DWORD PTR [eax]
  00024	89 4d fc	 mov	 DWORD PTR _lexer$[ebp], ecx

; 434  : 	ex		= lexer->rec->state->exception;

  00027	8b 55 fc	 mov	 edx, DWORD PTR _lexer$[ebp]
  0002a	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0002d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00030	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00033	89 55 f8	 mov	 DWORD PTR _ex$[ebp], edx

; 435  : 
; 436  : 	// See if there is a 'filename' we can use
; 437  :     //
; 438  :     if	(ex->name == NULL)

  00036	8b 45 f8	 mov	 eax, DWORD PTR _ex$[ebp]
  00039	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0003d	75 24		 jne	 SHORT $LN2@displayRec

; 439  :     {
; 440  : 		ANTLR3_FPRINTF(stderr, "-unknown source-(");

  0003f	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@NHAPJBAE@?9unknown?5source?9?$CI@
  00044	8b f4		 mov	 esi, esp
  00046	6a 02		 push	 2
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  0004e	83 c4 04	 add	 esp, 4
  00051	3b f4		 cmp	 esi, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 _fprintf
  0005e	83 c4 08	 add	 esp, 8

; 441  :     }

  00061	eb 4a		 jmp	 SHORT $LN3@displayRec
$LN2@displayRec:

; 442  :     else
; 443  :     {
; 444  : 		ftext = ex->streamName->to8(ex->streamName);

  00063	8b f4		 mov	 esi, esp
  00065	8b 4d f8	 mov	 ecx, DWORD PTR _ex$[ebp]
  00068	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0006b	52		 push	 edx
  0006c	8b 45 f8	 mov	 eax, DWORD PTR _ex$[ebp]
  0006f	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00072	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  00075	ff d2		 call	 edx
  00077	83 c4 04	 add	 esp, 4
  0007a	3b f4		 cmp	 esi, esp
  0007c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00081	89 45 f4	 mov	 DWORD PTR _ftext$[ebp], eax

; 445  : 		ANTLR3_FPRINTF(stderr, "%s(", ftext->chars);

  00084	8b 45 f4	 mov	 eax, DWORD PTR _ftext$[ebp]
  00087	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0008a	51		 push	 ecx
  0008b	68 00 00 00 00	 push	 OFFSET ??_C@_03ECLNAHEM@?$CFs?$CI@
  00090	8b f4		 mov	 esi, esp
  00092	6a 02		 push	 2
  00094	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  0009a	83 c4 04	 add	 esp, 4
  0009d	3b f4		 cmp	 esi, esp
  0009f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a4	50		 push	 eax
  000a5	e8 00 00 00 00	 call	 _fprintf
  000aa	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@displayRec:

; 446  :     }
; 447  : 
; 448  :     ANTLR3_FPRINTF(stderr, "%d) ", recognizer->state->exception->line);

  000ad	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  000b0	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000b3	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000b6	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  000b9	52		 push	 edx
  000ba	68 00 00 00 00	 push	 OFFSET ??_C@_04CGKAJBAP@?$CFd?$CJ?5@
  000bf	8b f4		 mov	 esi, esp
  000c1	6a 02		 push	 2
  000c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  000c9	83 c4 04	 add	 esp, 4
  000cc	3b f4		 cmp	 esi, esp
  000ce	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d3	50		 push	 eax
  000d4	e8 00 00 00 00	 call	 _fprintf
  000d9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 449  :     ANTLR3_FPRINTF(stderr, ": lexer error %d :\n\t%s at offset %d, ", 

  000dc	8b 45 f8	 mov	 eax, DWORD PTR _ex$[ebp]
  000df	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  000e2	83 c1 01	 add	 ecx, 1
  000e5	51		 push	 ecx
  000e6	8b 55 f8	 mov	 edx, DWORD PTR _ex$[ebp]
  000e9	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000ec	50		 push	 eax
  000ed	8b 4d f8	 mov	 ecx, DWORD PTR _ex$[ebp]
  000f0	8b 11		 mov	 edx, DWORD PTR [ecx]
  000f2	52		 push	 edx
  000f3	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@CKJILOKO@?3?5lexer?5error?5?$CFd?5?3?6?7?$CFs?5at?5offse@
  000f8	8b f4		 mov	 esi, esp
  000fa	6a 02		 push	 2
  000fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  00102	83 c4 04	 add	 esp, 4
  00105	3b f4		 cmp	 esi, esp
  00107	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0010c	50		 push	 eax
  0010d	e8 00 00 00 00	 call	 _fprintf
  00112	83 c4 14	 add	 esp, 20			; 00000014H

; 450  : 						ex->type,
; 451  : 						(pANTLR3_UINT8)	   (ex->message),
; 452  : 					    ex->charPositionInLine+1
; 453  : 		    );
; 454  : 	{
; 455  : 		ANTLR3_INT32	width;
; 456  : 
; 457  : 		width	= ANTLR3_UINT32_CAST(( (pANTLR3_UINT8)(lexer->input->data) + (lexer->input->size(lexer->input) )) - (pANTLR3_UINT8)(ex->index));

  00115	8b 45 fc	 mov	 eax, DWORD PTR _lexer$[ebp]
  00118	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  0011b	8b fc		 mov	 edi, esp
  0011d	8b 4d fc	 mov	 ecx, DWORD PTR _lexer$[ebp]
  00120	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00123	52		 push	 edx
  00124	8b 45 fc	 mov	 eax, DWORD PTR _lexer$[ebp]
  00127	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0012a	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  0012d	ff d2		 call	 edx
  0012f	83 c4 04	 add	 esp, 4
  00132	3b fc		 cmp	 edi, esp
  00134	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00139	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0013c	03 c8		 add	 ecx, eax
  0013e	8b 55 f8	 mov	 edx, DWORD PTR _ex$[ebp]
  00141	2b 4a 14	 sub	 ecx, DWORD PTR [edx+20]
  00144	89 4d f0	 mov	 DWORD PTR _width$1[ebp], ecx

; 458  : 
; 459  : 		if	(width >= 1)

  00147	83 7d f0 01	 cmp	 DWORD PTR _width$1[ebp], 1
  0014b	0f 8c b9 00 00
	00		 jl	 $LN4@displayRec

; 460  : 		{			
; 461  : 			if	(isprint(ex->c))

  00151	8b f4		 mov	 esi, esp
  00153	8b 45 f8	 mov	 eax, DWORD PTR _ex$[ebp]
  00156	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00159	51		 push	 ecx
  0015a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__isprint
  00160	83 c4 04	 add	 esp, 4
  00163	3b f4		 cmp	 esi, esp
  00165	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0016a	85 c0		 test	 eax, eax
  0016c	74 2b		 je	 SHORT $LN6@displayRec

; 462  : 			{
; 463  : 				ANTLR3_FPRINTF(stderr, "near '%c' :\n", ex->c);

  0016e	8b 55 f8	 mov	 edx, DWORD PTR _ex$[ebp]
  00171	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  00174	50		 push	 eax
  00175	68 00 00 00 00	 push	 OFFSET ??_C@_0N@LFOODOBD@near?5?8?$CFc?8?5?3?6@
  0017a	8b f4		 mov	 esi, esp
  0017c	6a 02		 push	 2
  0017e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  00184	83 c4 04	 add	 esp, 4
  00187	3b f4		 cmp	 esi, esp
  00189	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0018e	50		 push	 eax
  0018f	e8 00 00 00 00	 call	 _fprintf
  00194	83 c4 0c	 add	 esp, 12			; 0000000cH

; 464  : 			}

  00197	eb 2a		 jmp	 SHORT $LN7@displayRec
$LN6@displayRec:

; 465  : 			else
; 466  : 			{
; 467  : 				ANTLR3_FPRINTF(stderr, "near char(%#02X) :\n", (ANTLR3_UINT8)(ex->c));

  00199	8b 4d f8	 mov	 ecx, DWORD PTR _ex$[ebp]
  0019c	0f b6 51 28	 movzx	 edx, BYTE PTR [ecx+40]
  001a0	52		 push	 edx
  001a1	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@GGCOLI@near?5char?$CI?$CF?$CD02X?$CJ?5?3?6@
  001a6	8b f4		 mov	 esi, esp
  001a8	6a 02		 push	 2
  001aa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  001b0	83 c4 04	 add	 esp, 4
  001b3	3b f4		 cmp	 esi, esp
  001b5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001ba	50		 push	 eax
  001bb	e8 00 00 00 00	 call	 _fprintf
  001c0	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@displayRec:

; 468  : 			}
; 469  : 			ANTLR3_FPRINTF(stderr, "\t%.*s\n", width > 20 ? 20 : width ,((pANTLR3_UINT8)ex->index));

  001c3	83 7d f0 14	 cmp	 DWORD PTR _width$1[ebp], 20 ; 00000014H
  001c7	7e 09		 jle	 SHORT $LN11@displayRec
  001c9	c7 45 ec 14 00
	00 00		 mov	 DWORD PTR tv168[ebp], 20 ; 00000014H
  001d0	eb 06		 jmp	 SHORT $LN12@displayRec
$LN11@displayRec:
  001d2	8b 45 f0	 mov	 eax, DWORD PTR _width$1[ebp]
  001d5	89 45 ec	 mov	 DWORD PTR tv168[ebp], eax
$LN12@displayRec:
  001d8	8b 4d f8	 mov	 ecx, DWORD PTR _ex$[ebp]
  001db	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  001de	52		 push	 edx
  001df	8b 45 ec	 mov	 eax, DWORD PTR tv168[ebp]
  001e2	50		 push	 eax
  001e3	68 00 00 00 00	 push	 OFFSET ??_C@_06LNEMBBGL@?7?$CF?4?$CKs?6@
  001e8	8b f4		 mov	 esi, esp
  001ea	6a 02		 push	 2
  001ec	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  001f2	83 c4 04	 add	 esp, 4
  001f5	3b f4		 cmp	 esi, esp
  001f7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001fc	50		 push	 eax
  001fd	e8 00 00 00 00	 call	 _fprintf
  00202	83 c4 10	 add	 esp, 16			; 00000010H

; 470  : 		}

  00205	e9 08 01 00 00	 jmp	 $LN9@displayRec
$LN4@displayRec:

; 471  : 		else
; 472  : 		{
; 473  : 			ANTLR3_FPRINTF(stderr, "(end of input).\n\t This indicates a poorly specified lexer RULE\n\t or unterminated input element such as: \"STRING[\"]\n");

  0020a	68 00 00 00 00	 push	 OFFSET ??_C@_0HE@ELHLADFJ@?$CIend?5of?5input?$CJ?4?6?7?5This?5indicate@
  0020f	8b f4		 mov	 esi, esp
  00211	6a 02		 push	 2
  00213	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  00219	83 c4 04	 add	 esp, 4
  0021c	3b f4		 cmp	 esi, esp
  0021e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00223	50		 push	 eax
  00224	e8 00 00 00 00	 call	 _fprintf
  00229	83 c4 08	 add	 esp, 8

; 474  : 			ANTLR3_FPRINTF(stderr, "\t The lexer was matching from line %d, offset %d, which\n\t ", 

  0022c	8b 4d fc	 mov	 ecx, DWORD PTR _lexer$[ebp]
  0022f	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00232	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00235	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  00238	51		 push	 ecx
  00239	8b 55 fc	 mov	 edx, DWORD PTR _lexer$[ebp]
  0023c	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0023f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00242	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  00245	52		 push	 edx
  00246	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@OFNCJFPJ@?7?5The?5lexer?5was?5matching?5from?5l@
  0024b	8b f4		 mov	 esi, esp
  0024d	6a 02		 push	 2
  0024f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  00255	83 c4 04	 add	 esp, 4
  00258	3b f4		 cmp	 esi, esp
  0025a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0025f	50		 push	 eax
  00260	e8 00 00 00 00	 call	 _fprintf
  00265	83 c4 10	 add	 esp, 16			; 00000010H

; 475  : 								(ANTLR3_UINT32)(lexer->rec->state->tokenStartLine),
; 476  : 								(ANTLR3_UINT32)(lexer->rec->state->tokenStartCharPositionInLine)
; 477  : 								);
; 478  : 			width = ANTLR3_UINT32_CAST(((pANTLR3_UINT8)(lexer->input->data)+(lexer->input->size(lexer->input))) - (pANTLR3_UINT8)(lexer->rec->state->tokenStartCharIndex));

  00268	8b 45 fc	 mov	 eax, DWORD PTR _lexer$[ebp]
  0026b	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  0026e	8b fc		 mov	 edi, esp
  00270	8b 4d fc	 mov	 ecx, DWORD PTR _lexer$[ebp]
  00273	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00276	52		 push	 edx
  00277	8b 45 fc	 mov	 eax, DWORD PTR _lexer$[ebp]
  0027a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0027d	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  00280	ff d2		 call	 edx
  00282	83 c4 04	 add	 esp, 4
  00285	3b fc		 cmp	 edi, esp
  00287	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0028c	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0028f	03 c8		 add	 ecx, eax
  00291	8b 55 fc	 mov	 edx, DWORD PTR _lexer$[ebp]
  00294	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00297	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0029a	2b 4a 4c	 sub	 ecx, DWORD PTR [edx+76]
  0029d	89 4d f0	 mov	 DWORD PTR _width$1[ebp], ecx

; 479  : 
; 480  : 			if	(width >= 1)

  002a0	83 7d f0 01	 cmp	 DWORD PTR _width$1[ebp], 1
  002a4	7c 4a		 jl	 SHORT $LN8@displayRec

; 481  : 			{
; 482  : 				ANTLR3_FPRINTF(stderr, "looks like this:\n\t\t%.*s\n", width > 20 ? 20 : width ,(pANTLR3_UINT8)(lexer->rec->state->tokenStartCharIndex));

  002a6	83 7d f0 14	 cmp	 DWORD PTR _width$1[ebp], 20 ; 00000014H
  002aa	7e 09		 jle	 SHORT $LN13@displayRec
  002ac	c7 45 e8 14 00
	00 00		 mov	 DWORD PTR tv208[ebp], 20 ; 00000014H
  002b3	eb 06		 jmp	 SHORT $LN14@displayRec
$LN13@displayRec:
  002b5	8b 45 f0	 mov	 eax, DWORD PTR _width$1[ebp]
  002b8	89 45 e8	 mov	 DWORD PTR tv208[ebp], eax
$LN14@displayRec:
  002bb	8b 4d fc	 mov	 ecx, DWORD PTR _lexer$[ebp]
  002be	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  002c1	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  002c4	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  002c7	51		 push	 ecx
  002c8	8b 55 e8	 mov	 edx, DWORD PTR tv208[ebp]
  002cb	52		 push	 edx
  002cc	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@MNCIDMAD@looks?5like?5this?3?6?7?7?$CF?4?$CKs?6@
  002d1	8b f4		 mov	 esi, esp
  002d3	6a 02		 push	 2
  002d5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  002db	83 c4 04	 add	 esp, 4
  002de	3b f4		 cmp	 esi, esp
  002e0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002e5	50		 push	 eax
  002e6	e8 00 00 00 00	 call	 _fprintf
  002eb	83 c4 10	 add	 esp, 16			; 00000010H

; 483  : 			}

  002ee	eb 22		 jmp	 SHORT $LN9@displayRec
$LN8@displayRec:

; 484  : 			else
; 485  : 			{
; 486  : 				ANTLR3_FPRINTF(stderr, "is also the end of the line, so you must check your lexer rules\n");

  002f0	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@JKDHCAGB@is?5also?5the?5end?5of?5the?5line?0?5so@
  002f5	8b f4		 mov	 esi, esp
  002f7	6a 02		 push	 2
  002f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  002ff	83 c4 04	 add	 esp, 4
  00302	3b f4		 cmp	 esi, esp
  00304	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00309	50		 push	 eax
  0030a	e8 00 00 00 00	 call	 _fprintf
  0030f	83 c4 08	 add	 esp, 8
$LN9@displayRec:

; 487  : 			}
; 488  : 		}
; 489  : 	}
; 490  : }

  00312	5f		 pop	 edi
  00313	5e		 pop	 esi
  00314	83 c4 18	 add	 esp, 24			; 00000018H
  00317	3b ec		 cmp	 ebp, esp
  00319	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0031e	8b e5		 mov	 esp, ebp
  00320	5d		 pop	 ebp
  00321	c3		 ret	 0
_displayRecognitionError ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3lexer.c
;	COMDAT _nextToken
_TEXT	SEGMENT
_lexer$1 = -8						; size = 4
_tok$ = -4						; size = 4
_toksource$ = 8						; size = 4
_nextToken PROC						; COMDAT

; 331  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 332  : 	pANTLR3_COMMON_TOKEN tok;
; 333  : 
; 334  : 	// Find the next token in the current stream
; 335  : 	//
; 336  : 	tok = nextTokenStr(toksource);

  00015	8b 45 08	 mov	 eax, DWORD PTR _toksource$[ebp]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 _nextTokenStr
  0001e	83 c4 04	 add	 esp, 4
  00021	89 45 fc	 mov	 DWORD PTR _tok$[ebp], eax
$LN2@nextToken:

; 337  : 
; 338  : 	// If we got to the EOF token then switch to the previous
; 339  : 	// input stream if there were any and just return the
; 340  : 	// EOF if there are none. We must check the next token
; 341  : 	// in any outstanding input stream we pop into the active
; 342  : 	// role to see if it was sitting at EOF after PUSHing the
; 343  : 	// stream we just consumed, otherwise we will return EOF
; 344  : 	// on the reinstalled input stream, when in actual fact
; 345  : 	// there might be more input streams to POP before the
; 346  : 	// real EOF of the whole logical input stream. Hence we
; 347  : 	// use a while loop here until we find something in the stream
; 348  : 	// that isn't EOF or we reach the actual end of the last input
; 349  : 	// stream on the stack.
; 350  : 	//
; 351  : 	while	((tok != NULL) && (tok->type == ANTLR3_TOKEN_EOF))

  00024	83 7d fc 00	 cmp	 DWORD PTR _tok$[ebp], 0
  00028	0f 84 81 00 00
	00		 je	 $LN3@nextToken
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _tok$[ebp]
  00031	83 39 ff	 cmp	 DWORD PTR [ecx], -1
  00034	75 79		 jne	 SHORT $LN3@nextToken

; 352  : 	{
; 353  : 		pANTLR3_LEXER   lexer;
; 354  : 
; 355  : 		lexer   = (pANTLR3_LEXER)(toksource->super);

  00036	8b 55 08	 mov	 edx, DWORD PTR _toksource$[ebp]
  00039	8b 82 28 01 00
	00		 mov	 eax, DWORD PTR [edx+296]
  0003f	89 45 f8	 mov	 DWORD PTR _lexer$1[ebp], eax

; 356  : 
; 357  : 		if  (lexer->rec->state->streams != NULL && lexer->rec->state->streams->size(lexer->rec->state->streams) > 0)

  00042	8b 4d f8	 mov	 ecx, DWORD PTR _lexer$1[ebp]
  00045	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00048	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0004b	83 78 64 00	 cmp	 DWORD PTR [eax+100], 0
  0004f	74 57		 je	 SHORT $LN4@nextToken
  00051	8b 4d f8	 mov	 ecx, DWORD PTR _lexer$1[ebp]
  00054	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00057	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0005a	8b f4		 mov	 esi, esp
  0005c	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  0005f	51		 push	 ecx
  00060	8b 55 f8	 mov	 edx, DWORD PTR _lexer$1[ebp]
  00063	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00066	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00069	8b 51 64	 mov	 edx, DWORD PTR [ecx+100]
  0006c	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0006f	ff d0		 call	 eax
  00071	83 c4 04	 add	 esp, 4
  00074	3b f4		 cmp	 esi, esp
  00076	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007b	85 c0		 test	 eax, eax
  0007d	76 29		 jbe	 SHORT $LN4@nextToken

; 358  : 		{
; 359  : 			// We have another input stream in the stack so we
; 360  : 			// need to revert to it, then resume the loop to check
; 361  : 			// it wasn't sitting at EOF itself.
; 362  : 			//
; 363  : 			lexer->popCharStream(lexer);

  0007f	8b f4		 mov	 esi, esp
  00081	8b 4d f8	 mov	 ecx, DWORD PTR _lexer$1[ebp]
  00084	51		 push	 ecx
  00085	8b 55 f8	 mov	 edx, DWORD PTR _lexer$1[ebp]
  00088	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0008b	ff d0		 call	 eax
  0008d	83 c4 04	 add	 esp, 4
  00090	3b f4		 cmp	 esi, esp
  00092	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 364  : 			tok = nextTokenStr(toksource);

  00097	8b 4d 08	 mov	 ecx, DWORD PTR _toksource$[ebp]
  0009a	51		 push	 ecx
  0009b	e8 00 00 00 00	 call	 _nextTokenStr
  000a0	83 c4 04	 add	 esp, 4
  000a3	89 45 fc	 mov	 DWORD PTR _tok$[ebp], eax

; 365  : 		}

  000a6	eb 02		 jmp	 SHORT $LN5@nextToken
$LN4@nextToken:

; 366  : 		else
; 367  : 		{
; 368  : 			// There were no more streams on the input stack
; 369  : 			// so this EOF is the 'real' logical EOF for
; 370  : 			// the input stream. So we just exit the loop and 
; 371  : 			// return the EOF we have found.
; 372  : 			//
; 373  : 			break;

  000a8	eb 05		 jmp	 SHORT $LN3@nextToken
$LN5@nextToken:

; 374  : 		}
; 375  : 		
; 376  : 	}

  000aa	e9 75 ff ff ff	 jmp	 $LN2@nextToken
$LN3@nextToken:

; 377  : 
; 378  : 	// return whatever token we have, which may be EOF
; 379  : 	//
; 380  : 	return  tok;

  000af	8b 45 fc	 mov	 eax, DWORD PTR _tok$[ebp]

; 381  : }

  000b2	5e		 pop	 esi
  000b3	83 c4 08	 add	 esp, 8
  000b6	3b ec		 cmp	 ebp, esp
  000b8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bd	8b e5		 mov	 esp, ebp
  000bf	5d		 pop	 ebp
  000c0	c3		 ret	 0
_nextToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3lexer.c
;	COMDAT _getText
_TEXT	SEGMENT
_lexer$ = 8						; size = 4
_getText PROC						; COMDAT

; 880  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 881  : 	if (lexer->rec->state->text)

  00004	8b 45 08	 mov	 eax, DWORD PTR _lexer$[ebp]
  00007	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0000a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0000d	83 7a 50 00	 cmp	 DWORD PTR [edx+80], 0
  00011	74 0e		 je	 SHORT $LN2@getText

; 882  : 	{
; 883  : 		return	lexer->rec->state->text;

  00013	8b 45 08	 mov	 eax, DWORD PTR _lexer$[ebp]
  00016	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00019	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0001c	8b 42 50	 mov	 eax, DWORD PTR [edx+80]
  0001f	eb 50		 jmp	 SHORT $LN1@getText
$LN2@getText:

; 884  : 
; 885  : 	}
; 886  : 	return  lexer->input->substr(

  00021	8b f4		 mov	 esi, esp
  00023	8b 45 08	 mov	 eax, DWORD PTR _lexer$[ebp]
  00026	50		 push	 eax
  00027	8b 4d 08	 mov	 ecx, DWORD PTR _lexer$[ebp]
  0002a	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  0002d	ff d2		 call	 edx
  0002f	83 c4 04	 add	 esp, 4
  00032	3b f4		 cmp	 esi, esp
  00034	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00039	8b 4d 08	 mov	 ecx, DWORD PTR _lexer$[ebp]
  0003c	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0003f	0f b6 4a 74	 movzx	 ecx, BYTE PTR [edx+116]
  00043	2b c1		 sub	 eax, ecx
  00045	8b f4		 mov	 esi, esp
  00047	50		 push	 eax
  00048	8b 55 08	 mov	 edx, DWORD PTR _lexer$[ebp]
  0004b	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0004e	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00051	8b 51 4c	 mov	 edx, DWORD PTR [ecx+76]
  00054	52		 push	 edx
  00055	8b 45 08	 mov	 eax, DWORD PTR _lexer$[ebp]
  00058	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0005b	51		 push	 ecx
  0005c	8b 55 08	 mov	 edx, DWORD PTR _lexer$[ebp]
  0005f	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00062	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  00065	ff d1		 call	 ecx
  00067	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006a	3b f4		 cmp	 esi, esp
  0006c	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@getText:

; 887  : 									lexer->input, 
; 888  : 									lexer->rec->state->tokenStartCharIndex,
; 889  : 									lexer->getCharIndex(lexer) - lexer->input->charByteSize
; 890  : 							);
; 891  : 
; 892  : }

  00071	5e		 pop	 esi
  00072	3b ec		 cmp	 ebp, esp
  00074	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
_getText ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3lexer.c
;	COMDAT _getCharPositionInLine
_TEXT	SEGMENT
_lexer$ = 8						; size = 4
_getCharPositionInLine PROC				; COMDAT

; 869  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 870  :     return  lexer->input->charPositionInLine;

  00003	8b 45 08	 mov	 eax, DWORD PTR _lexer$[ebp]
  00006	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00009	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]

; 871  : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
_getCharPositionInLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3lexer.c
;	COMDAT _getCharIndex
_TEXT	SEGMENT
_lexer$ = 8						; size = 4
_getCharIndex PROC					; COMDAT

; 874  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 875  :     return lexer->input->istream->index(lexer->input->istream);

  00004	8b 45 08	 mov	 eax, DWORD PTR _lexer$[ebp]
  00007	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000a	8b f4		 mov	 esi, esp
  0000c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000e	52		 push	 edx
  0000f	8b 45 08	 mov	 eax, DWORD PTR _lexer$[ebp]
  00012	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00015	8b 11		 mov	 edx, DWORD PTR [ecx]
  00017	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0001a	ff d0		 call	 eax
  0001c	83 c4 04	 add	 esp, 4
  0001f	3b f4		 cmp	 esi, esp
  00021	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 876  : }

  00026	5e		 pop	 esi
  00027	3b ec		 cmp	 ebp, esp
  00029	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
_getCharIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3lexer.c
;	COMDAT _getLine
_TEXT	SEGMENT
_lexer$ = 8						; size = 4
_getLine PROC						; COMDAT

; 863  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 864  :     return  lexer->input->getLine(lexer->input);

  00004	8b f4		 mov	 esi, esp
  00006	8b 45 08	 mov	 eax, DWORD PTR _lexer$[ebp]
  00009	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000c	51		 push	 ecx
  0000d	8b 55 08	 mov	 edx, DWORD PTR _lexer$[ebp]
  00010	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00013	8b 48 58	 mov	 ecx, DWORD PTR [eax+88]
  00016	ff d1		 call	 ecx
  00018	83 c4 04	 add	 esp, 4
  0001b	3b f4		 cmp	 esi, esp
  0001d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 865  : }

  00022	5e		 pop	 esi
  00023	3b ec		 cmp	 ebp, esp
  00025	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
_getLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3lexer.c
;	COMDAT _recover
_TEXT	SEGMENT
_lexer$ = 8						; size = 4
_recover PROC						; COMDAT

; 857  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 858  :     lexer->input->istream->consume(lexer->input->istream);

  00004	8b 45 08	 mov	 eax, DWORD PTR _lexer$[ebp]
  00007	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000a	8b f4		 mov	 esi, esp
  0000c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000e	52		 push	 edx
  0000f	8b 45 08	 mov	 eax, DWORD PTR _lexer$[ebp]
  00012	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00015	8b 11		 mov	 edx, DWORD PTR [ecx]
  00017	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0001a	ff d0		 call	 eax
  0001c	83 c4 04	 add	 esp, 4
  0001f	3b f4		 cmp	 esi, esp
  00021	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00026	90		 npad	 1

; 859  : }

  00027	5e		 pop	 esi
  00028	3b ec		 cmp	 ebp, esp
  0002a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
_recover ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3lexer.c
;	COMDAT _matchAny
_TEXT	SEGMENT
_lexer$ = 8						; size = 4
_matchAny PROC						; COMDAT

; 851  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 852  :     lexer->input->istream->consume(lexer->input->istream);

  00004	8b 45 08	 mov	 eax, DWORD PTR _lexer$[ebp]
  00007	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000a	8b f4		 mov	 esi, esp
  0000c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000e	52		 push	 edx
  0000f	8b 45 08	 mov	 eax, DWORD PTR _lexer$[ebp]
  00012	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00015	8b 11		 mov	 edx, DWORD PTR [ecx]
  00017	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0001a	ff d0		 call	 eax
  0001c	83 c4 04	 add	 esp, 4
  0001f	3b f4		 cmp	 esi, esp
  00021	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00026	90		 npad	 1

; 853  : }

  00027	5e		 pop	 esi
  00028	3b ec		 cmp	 ebp, esp
  0002a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
_matchAny ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3lexer.c
;	COMDAT _matchRange
_TEXT	SEGMENT
_c$ = -4						; size = 4
_lexer$ = 8						; size = 4
_low$ = 12						; size = 4
_high$ = 16						; size = 4
_matchRange PROC					; COMDAT

; 812  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 813  :     ANTLR3_UCHAR    c;
; 814  : 
; 815  :     /* What is in the stream at the moment?
; 816  :      */
; 817  :     c	= lexer->input->istream->_LA(lexer->input->istream, 1);

  0000c	8b f4		 mov	 esi, esp
  0000e	6a 01		 push	 1
  00010	8b 45 08	 mov	 eax, DWORD PTR _lexer$[ebp]
  00013	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00016	8b 11		 mov	 edx, DWORD PTR [ecx]
  00018	52		 push	 edx
  00019	8b 45 08	 mov	 eax, DWORD PTR _lexer$[ebp]
  0001c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0001f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00021	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00024	ff d0		 call	 eax
  00026	83 c4 08	 add	 esp, 8
  00029	3b f4		 cmp	 esi, esp
  0002b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00030	89 45 fc	 mov	 DWORD PTR _c$[ebp], eax

; 818  :     if	( c >= low && c <= high)

  00033	8b 4d fc	 mov	 ecx, DWORD PTR _c$[ebp]
  00036	3b 4d 0c	 cmp	 ecx, DWORD PTR _low$[ebp]
  00039	72 3b		 jb	 SHORT $LN2@matchRange
  0003b	8b 55 fc	 mov	 edx, DWORD PTR _c$[ebp]
  0003e	3b 55 10	 cmp	 edx, DWORD PTR _high$[ebp]
  00041	77 33		 ja	 SHORT $LN2@matchRange

; 819  :     {
; 820  : 	/* Matched correctly, consume it
; 821  : 	 */
; 822  : 	lexer->input->istream->consume(lexer->input->istream);

  00043	8b 45 08	 mov	 eax, DWORD PTR _lexer$[ebp]
  00046	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00049	8b f4		 mov	 esi, esp
  0004b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004d	52		 push	 edx
  0004e	8b 45 08	 mov	 eax, DWORD PTR _lexer$[ebp]
  00051	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00054	8b 11		 mov	 edx, DWORD PTR [ecx]
  00056	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00059	ff d0		 call	 eax
  0005b	83 c4 04	 add	 esp, 4
  0005e	3b f4		 cmp	 esi, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 823  : 
; 824  : 	/* Reset any failed indicator
; 825  : 	 */
; 826  : 	lexer->rec->state->failed = ANTLR3_FALSE;

  00065	8b 4d 08	 mov	 ecx, DWORD PTR _lexer$[ebp]
  00068	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0006b	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0006e	c6 40 18 00	 mov	 BYTE PTR [eax+24], 0

; 827  : 
; 828  : 	return	ANTLR3_TRUE;

  00072	b0 01		 mov	 al, 1
  00074	eb 5b		 jmp	 SHORT $LN1@matchRange
$LN2@matchRange:

; 829  :     }
; 830  :     
; 831  :     /* Failed to match, execption and recovery time.
; 832  :      */
; 833  : 
; 834  :     if	(lexer->rec->state->backtracking > 0)

  00076	8b 4d 08	 mov	 ecx, DWORD PTR _lexer$[ebp]
  00079	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0007c	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0007f	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  00083	7e 11		 jle	 SHORT $LN3@matchRange

; 835  :     {
; 836  : 	lexer->rec->state->failed  = ANTLR3_TRUE;

  00085	8b 4d 08	 mov	 ecx, DWORD PTR _lexer$[ebp]
  00088	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0008b	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0008e	c6 40 18 01	 mov	 BYTE PTR [eax+24], 1

; 837  : 	return	ANTLR3_FALSE;

  00092	32 c0		 xor	 al, al
  00094	eb 3b		 jmp	 SHORT $LN1@matchRange
$LN3@matchRange:

; 838  :     }
; 839  : 
; 840  :     lexer->rec->exConstruct(lexer->rec);

  00096	8b f4		 mov	 esi, esp
  00098	8b 4d 08	 mov	 ecx, DWORD PTR _lexer$[ebp]
  0009b	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0009e	52		 push	 edx
  0009f	8b 45 08	 mov	 eax, DWORD PTR _lexer$[ebp]
  000a2	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000a5	8b 91 88 00 00
	00		 mov	 edx, DWORD PTR [ecx+136]
  000ab	ff d2		 call	 edx
  000ad	83 c4 04	 add	 esp, 4
  000b0	3b f4		 cmp	 esi, esp
  000b2	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 841  : 
; 842  :     /* TODO: Implement exception creation more fully
; 843  :      */
; 844  :     lexer->recover(lexer);

  000b7	8b f4		 mov	 esi, esp
  000b9	8b 45 08	 mov	 eax, DWORD PTR _lexer$[ebp]
  000bc	50		 push	 eax
  000bd	8b 4d 08	 mov	 ecx, DWORD PTR _lexer$[ebp]
  000c0	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  000c3	ff d2		 call	 edx
  000c5	83 c4 04	 add	 esp, 4
  000c8	3b f4		 cmp	 esi, esp
  000ca	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 845  : 
; 846  :     return  ANTLR3_FALSE;

  000cf	32 c0		 xor	 al, al
$LN1@matchRange:

; 847  : }

  000d1	5e		 pop	 esi
  000d2	83 c4 04	 add	 esp, 4
  000d5	3b ec		 cmp	 ebp, esp
  000d7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000dc	8b e5		 mov	 esp, ebp
  000de	5d		 pop	 ebp
  000df	c3		 ret	 0
_matchRange ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3lexer.c
;	COMDAT _matchc
_TEXT	SEGMENT
_lexer$ = 8						; size = 4
_c$ = 12						; size = 4
_matchc	PROC						; COMDAT

; 772  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 773  : 	if	(lexer->input->istream->_LA(lexer->input->istream, 1) == c)

  00004	8b f4		 mov	 esi, esp
  00006	6a 01		 push	 1
  00008	8b 45 08	 mov	 eax, DWORD PTR _lexer$[ebp]
  0000b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00010	52		 push	 edx
  00011	8b 45 08	 mov	 eax, DWORD PTR _lexer$[ebp]
  00014	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00017	8b 11		 mov	 edx, DWORD PTR [ecx]
  00019	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0001c	ff d0		 call	 eax
  0001e	83 c4 08	 add	 esp, 8
  00021	3b f4		 cmp	 esi, esp
  00023	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00028	3b 45 0c	 cmp	 eax, DWORD PTR _c$[ebp]
  0002b	75 33		 jne	 SHORT $LN2@matchc

; 774  : 	{
; 775  : 		/* Matched correctly, do consume it
; 776  : 		 */
; 777  : 		lexer->input->istream->consume(lexer->input->istream);

  0002d	8b 4d 08	 mov	 ecx, DWORD PTR _lexer$[ebp]
  00030	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00033	8b f4		 mov	 esi, esp
  00035	8b 02		 mov	 eax, DWORD PTR [edx]
  00037	50		 push	 eax
  00038	8b 4d 08	 mov	 ecx, DWORD PTR _lexer$[ebp]
  0003b	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0003e	8b 02		 mov	 eax, DWORD PTR [edx]
  00040	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00043	ff d1		 call	 ecx
  00045	83 c4 04	 add	 esp, 4
  00048	3b f4		 cmp	 esi, esp
  0004a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 778  : 
; 779  : 		/* Reset any failed indicator
; 780  : 		 */
; 781  : 		lexer->rec->state->failed = ANTLR3_FALSE;

  0004f	8b 55 08	 mov	 edx, DWORD PTR _lexer$[ebp]
  00052	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00055	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00058	c6 41 18 00	 mov	 BYTE PTR [ecx+24], 0

; 782  : 
; 783  : 		return	ANTLR3_TRUE;

  0005c	b0 01		 mov	 al, 1
  0005e	eb 5b		 jmp	 SHORT $LN1@matchc
$LN2@matchc:

; 784  : 	}
; 785  : 
; 786  : 	/* Failed to match, exception and recovery time.
; 787  : 	 */
; 788  : 	if	(lexer->rec->state->backtracking > 0)

  00060	8b 55 08	 mov	 edx, DWORD PTR _lexer$[ebp]
  00063	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00066	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00069	83 79 20 00	 cmp	 DWORD PTR [ecx+32], 0
  0006d	7e 11		 jle	 SHORT $LN3@matchc

; 789  : 	{
; 790  : 		lexer->rec->state->failed  = ANTLR3_TRUE;

  0006f	8b 55 08	 mov	 edx, DWORD PTR _lexer$[ebp]
  00072	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00075	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00078	c6 41 18 01	 mov	 BYTE PTR [ecx+24], 1

; 791  : 		return	ANTLR3_FALSE;

  0007c	32 c0		 xor	 al, al
  0007e	eb 3b		 jmp	 SHORT $LN1@matchc
$LN3@matchc:

; 792  : 	}
; 793  : 
; 794  : 	lexer->rec->exConstruct(lexer->rec);

  00080	8b f4		 mov	 esi, esp
  00082	8b 55 08	 mov	 edx, DWORD PTR _lexer$[ebp]
  00085	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00088	50		 push	 eax
  00089	8b 4d 08	 mov	 ecx, DWORD PTR _lexer$[ebp]
  0008c	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0008f	8b 82 88 00 00
	00		 mov	 eax, DWORD PTR [edx+136]
  00095	ff d0		 call	 eax
  00097	83 c4 04	 add	 esp, 4
  0009a	3b f4		 cmp	 esi, esp
  0009c	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 795  : 
; 796  : 	/* TODO: Implement exception creation more fully perhaps
; 797  : 	 */
; 798  : 	lexer->recover(lexer);

  000a1	8b f4		 mov	 esi, esp
  000a3	8b 4d 08	 mov	 ecx, DWORD PTR _lexer$[ebp]
  000a6	51		 push	 ecx
  000a7	8b 55 08	 mov	 edx, DWORD PTR _lexer$[ebp]
  000aa	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  000ad	ff d0		 call	 eax
  000af	83 c4 04	 add	 esp, 4
  000b2	3b f4		 cmp	 esi, esp
  000b4	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 799  : 
; 800  : 	return  ANTLR3_FALSE;

  000b9	32 c0		 xor	 al, al
$LN1@matchc:

; 801  : }

  000bb	5e		 pop	 esi
  000bc	3b ec		 cmp	 ebp, esp
  000be	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c3	5d		 pop	 ebp
  000c4	c3		 ret	 0
_matchc	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3lexer.c
;	COMDAT _matchs
_TEXT	SEGMENT
_lexer$ = 8						; size = 4
_string$ = 12						; size = 4
_matchs	PROC						; COMDAT

; 729  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
$LN2@matchs:

; 730  : 	while   (*string != ANTLR3_STRING_TERMINATOR)

  00004	8b 45 0c	 mov	 eax, DWORD PTR _string$[ebp]
  00007	83 38 ff	 cmp	 DWORD PTR [eax], -1
  0000a	0f 84 d5 00 00
	00		 je	 $LN3@matchs

; 731  : 	{
; 732  : 		if  (lexer->input->istream->_LA(lexer->input->istream, 1) != (*string))

  00010	8b f4		 mov	 esi, esp
  00012	6a 01		 push	 1
  00014	8b 4d 08	 mov	 ecx, DWORD PTR _lexer$[ebp]
  00017	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0001a	8b 02		 mov	 eax, DWORD PTR [edx]
  0001c	50		 push	 eax
  0001d	8b 4d 08	 mov	 ecx, DWORD PTR _lexer$[ebp]
  00020	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00023	8b 02		 mov	 eax, DWORD PTR [edx]
  00025	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00028	ff d1		 call	 ecx
  0002a	83 c4 08	 add	 esp, 8
  0002d	3b f4		 cmp	 esi, esp
  0002f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00034	8b 55 0c	 mov	 edx, DWORD PTR _string$[ebp]
  00037	3b 02		 cmp	 eax, DWORD PTR [edx]
  00039	74 6d		 je	 SHORT $LN4@matchs

; 733  : 		{
; 734  : 			if	(lexer->rec->state->backtracking > 0)

  0003b	8b 45 08	 mov	 eax, DWORD PTR _lexer$[ebp]
  0003e	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00041	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00044	83 7a 20 00	 cmp	 DWORD PTR [edx+32], 0
  00048	7e 14		 jle	 SHORT $LN5@matchs

; 735  : 			{
; 736  : 				lexer->rec->state->failed = ANTLR3_TRUE;

  0004a	8b 45 08	 mov	 eax, DWORD PTR _lexer$[ebp]
  0004d	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00050	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00053	c6 42 18 01	 mov	 BYTE PTR [edx+24], 1

; 737  : 				return ANTLR3_FALSE;

  00057	32 c0		 xor	 al, al
  00059	e9 89 00 00 00	 jmp	 $LN1@matchs
$LN5@matchs:

; 738  : 			}
; 739  : 
; 740  : 			lexer->rec->exConstruct(lexer->rec);

  0005e	8b f4		 mov	 esi, esp
  00060	8b 45 08	 mov	 eax, DWORD PTR _lexer$[ebp]
  00063	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00066	51		 push	 ecx
  00067	8b 55 08	 mov	 edx, DWORD PTR _lexer$[ebp]
  0006a	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0006d	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  00073	ff d1		 call	 ecx
  00075	83 c4 04	 add	 esp, 4
  00078	3b f4		 cmp	 esi, esp
  0007a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 741  : 			lexer->rec->state->failed	 = ANTLR3_TRUE;

  0007f	8b 55 08	 mov	 edx, DWORD PTR _lexer$[ebp]
  00082	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00085	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00088	c6 41 18 01	 mov	 BYTE PTR [ecx+24], 1

; 742  : 
; 743  : 			/* TODO: Implement exception creation more fully perhaps
; 744  : 			 */
; 745  : 			lexer->recover(lexer);

  0008c	8b f4		 mov	 esi, esp
  0008e	8b 55 08	 mov	 edx, DWORD PTR _lexer$[ebp]
  00091	52		 push	 edx
  00092	8b 45 08	 mov	 eax, DWORD PTR _lexer$[ebp]
  00095	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00098	ff d1		 call	 ecx
  0009a	83 c4 04	 add	 esp, 4
  0009d	3b f4		 cmp	 esi, esp
  0009f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 746  : 			return  ANTLR3_FALSE;

  000a4	32 c0		 xor	 al, al
  000a6	eb 3f		 jmp	 SHORT $LN1@matchs
$LN4@matchs:

; 747  : 		}
; 748  : 
; 749  : 		/* Matched correctly, do consume it
; 750  : 		 */
; 751  : 		lexer->input->istream->consume(lexer->input->istream);

  000a8	8b 55 08	 mov	 edx, DWORD PTR _lexer$[ebp]
  000ab	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000ae	8b f4		 mov	 esi, esp
  000b0	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b2	51		 push	 ecx
  000b3	8b 55 08	 mov	 edx, DWORD PTR _lexer$[ebp]
  000b6	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000b9	8b 08		 mov	 ecx, DWORD PTR [eax]
  000bb	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  000be	ff d2		 call	 edx
  000c0	83 c4 04	 add	 esp, 4
  000c3	3b f4		 cmp	 esi, esp
  000c5	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 752  : 		string++;

  000ca	8b 45 0c	 mov	 eax, DWORD PTR _string$[ebp]
  000cd	83 c0 04	 add	 eax, 4
  000d0	89 45 0c	 mov	 DWORD PTR _string$[ebp], eax

; 753  : 
; 754  : 		/* Reset any failed indicator
; 755  : 		 */
; 756  : 		lexer->rec->state->failed = ANTLR3_FALSE;

  000d3	8b 4d 08	 mov	 ecx, DWORD PTR _lexer$[ebp]
  000d6	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  000d9	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000dc	c6 40 18 00	 mov	 BYTE PTR [eax+24], 0

; 757  : 	}

  000e0	e9 1f ff ff ff	 jmp	 $LN2@matchs
$LN3@matchs:

; 758  : 
; 759  : 
; 760  : 	return  ANTLR3_TRUE;

  000e5	b0 01		 mov	 al, 1
$LN1@matchs:

; 761  : }

  000e7	5e		 pop	 esi
  000e8	3b ec		 cmp	 ebp, esp
  000ea	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ef	5d		 pop	 ebp
  000f0	c3		 ret	 0
_matchs	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3lexer.c
;	COMDAT _emit
_TEXT	SEGMENT
_token$ = -4						; size = 4
_lexer$ = 8						; size = 4
_emit	PROC						; COMDAT

; 643  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 644  :     pANTLR3_COMMON_TOKEN	token;
; 645  : 
; 646  :     /* We could check pointers to token factories and so on, but
; 647  :     * we are in code that we want to run as fast as possible
; 648  :     * so we are not checking any errors. So make sure you have installed an input stream before
; 649  :     * trying to emit a new token.
; 650  :     */
; 651  :     token   = lexer->rec->state->tokFactory->newToken(lexer->rec->state->tokFactory);

  0000c	8b 45 08	 mov	 eax, DWORD PTR _lexer$[ebp]
  0000f	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00012	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00015	8b f4		 mov	 esi, esp
  00017	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  0001a	50		 push	 eax
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR _lexer$[ebp]
  0001e	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00021	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00024	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00027	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  0002d	ff d2		 call	 edx
  0002f	83 c4 04	 add	 esp, 4
  00032	3b f4		 cmp	 esi, esp
  00034	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00039	89 45 fc	 mov	 DWORD PTR _token$[ebp], eax

; 652  : 	if (token == NULL) { return NULL; }

  0003c	83 7d fc 00	 cmp	 DWORD PTR _token$[ebp], 0
  00040	75 07		 jne	 SHORT $LN2@emit
  00042	33 c0		 xor	 eax, eax
  00044	e9 1a 01 00 00	 jmp	 $LN1@emit
$LN2@emit:

; 653  : 
; 654  :     /* Install the supplied information, and some other bits we already know
; 655  :     * get added automatically, such as the input stream it is associated with
; 656  :     * (though it can all be overridden of course)
; 657  :     */
; 658  :     token->type		    = lexer->rec->state->type;

  00049	8b 45 08	 mov	 eax, DWORD PTR _lexer$[ebp]
  0004c	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0004f	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00052	8b 45 fc	 mov	 eax, DWORD PTR _token$[ebp]
  00055	8b 4a 40	 mov	 ecx, DWORD PTR [edx+64]
  00058	89 08		 mov	 DWORD PTR [eax], ecx

; 659  :     token->channel	    = lexer->rec->state->channel;

  0005a	8b 55 08	 mov	 edx, DWORD PTR _lexer$[ebp]
  0005d	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00060	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00063	8b 55 fc	 mov	 edx, DWORD PTR _token$[ebp]
  00066	8b 41 3c	 mov	 eax, DWORD PTR [ecx+60]
  00069	89 42 18	 mov	 DWORD PTR [edx+24], eax

; 660  :     token->start	    = lexer->rec->state->tokenStartCharIndex;

  0006c	8b 4d 08	 mov	 ecx, DWORD PTR _lexer$[ebp]
  0006f	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00072	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00075	8b 4d fc	 mov	 ecx, DWORD PTR _token$[ebp]
  00078	8b 50 4c	 mov	 edx, DWORD PTR [eax+76]
  0007b	89 51 24	 mov	 DWORD PTR [ecx+36], edx

; 661  :     token->stop		    = lexer->getCharIndex(lexer) - 1;

  0007e	8b f4		 mov	 esi, esp
  00080	8b 45 08	 mov	 eax, DWORD PTR _lexer$[ebp]
  00083	50		 push	 eax
  00084	8b 4d 08	 mov	 ecx, DWORD PTR _lexer$[ebp]
  00087	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  0008a	ff d2		 call	 edx
  0008c	83 c4 04	 add	 esp, 4
  0008f	3b f4		 cmp	 esi, esp
  00091	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00096	83 e8 01	 sub	 eax, 1
  00099	8b 4d fc	 mov	 ecx, DWORD PTR _token$[ebp]
  0009c	89 41 28	 mov	 DWORD PTR [ecx+40], eax

; 662  :     token->line		    = lexer->rec->state->tokenStartLine;

  0009f	8b 55 08	 mov	 edx, DWORD PTR _lexer$[ebp]
  000a2	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  000a5	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000a8	8b 55 fc	 mov	 edx, DWORD PTR _token$[ebp]
  000ab	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]
  000ae	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 663  :     token->charPosition	= lexer->rec->state->tokenStartCharPositionInLine;

  000b1	8b 4d 08	 mov	 ecx, DWORD PTR _lexer$[ebp]
  000b4	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  000b7	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000ba	8b 4d fc	 mov	 ecx, DWORD PTR _token$[ebp]
  000bd	8b 50 48	 mov	 edx, DWORD PTR [eax+72]
  000c0	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 664  : 
; 665  :     if	(lexer->rec->state->text != NULL)

  000c3	8b 45 08	 mov	 eax, DWORD PTR _lexer$[ebp]
  000c6	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000c9	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000cc	83 7a 50 00	 cmp	 DWORD PTR [edx+80], 0
  000d0	74 1e		 je	 SHORT $LN3@emit

; 666  :     {
; 667  :         token->textState	    = ANTLR3_TEXT_STRING;

  000d2	8b 45 fc	 mov	 eax, DWORD PTR _token$[ebp]
  000d5	c7 40 2c 02 00
	00 00		 mov	 DWORD PTR [eax+44], 2

; 668  :         token->tokText.text	    = lexer->rec->state->text;

  000dc	8b 4d 08	 mov	 ecx, DWORD PTR _lexer$[ebp]
  000df	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  000e2	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000e5	8b 4d fc	 mov	 ecx, DWORD PTR _token$[ebp]
  000e8	8b 50 50	 mov	 edx, DWORD PTR [eax+80]
  000eb	89 51 30	 mov	 DWORD PTR [ecx+48], edx

; 669  :     }

  000ee	eb 0a		 jmp	 SHORT $LN4@emit
$LN3@emit:

; 670  :     else
; 671  :     {
; 672  :         token->textState	= ANTLR3_TEXT_NONE;

  000f0	8b 45 fc	 mov	 eax, DWORD PTR _token$[ebp]
  000f3	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], 0
$LN4@emit:

; 673  :     }
; 674  :     token->lineStart	= lexer->input->currentLine;

  000fa	8b 4d 08	 mov	 ecx, DWORD PTR _lexer$[ebp]
  000fd	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00100	8b 45 fc	 mov	 eax, DWORD PTR _token$[ebp]
  00103	8b 4a 20	 mov	 ecx, DWORD PTR [edx+32]
  00106	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 675  :     token->user1	= lexer->rec->state->user1;

  00109	8b 55 08	 mov	 edx, DWORD PTR _lexer$[ebp]
  0010c	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0010f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00112	8b 55 fc	 mov	 edx, DWORD PTR _token$[ebp]
  00115	8b 41 54	 mov	 eax, DWORD PTR [ecx+84]
  00118	89 42 34	 mov	 DWORD PTR [edx+52], eax

; 676  :     token->user2	= lexer->rec->state->user2;

  0011b	8b 4d 08	 mov	 ecx, DWORD PTR _lexer$[ebp]
  0011e	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00121	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00124	8b 4d fc	 mov	 ecx, DWORD PTR _token$[ebp]
  00127	8b 50 58	 mov	 edx, DWORD PTR [eax+88]
  0012a	89 51 38	 mov	 DWORD PTR [ecx+56], edx

; 677  :     token->user3	= lexer->rec->state->user3;

  0012d	8b 45 08	 mov	 eax, DWORD PTR _lexer$[ebp]
  00130	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00133	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00136	8b 45 fc	 mov	 eax, DWORD PTR _token$[ebp]
  00139	8b 4a 5c	 mov	 ecx, DWORD PTR [edx+92]
  0013c	89 48 3c	 mov	 DWORD PTR [eax+60], ecx

; 678  :     token->custom	= lexer->rec->state->custom;

  0013f	8b 55 08	 mov	 edx, DWORD PTR _lexer$[ebp]
  00142	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00145	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00148	8b 55 fc	 mov	 edx, DWORD PTR _token$[ebp]
  0014b	8b 41 60	 mov	 eax, DWORD PTR [ecx+96]
  0014e	89 42 40	 mov	 DWORD PTR [edx+64], eax

; 679  : 
; 680  :     lexer->rec->state->token	    = token;

  00151	8b 4d 08	 mov	 ecx, DWORD PTR _lexer$[ebp]
  00154	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00157	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0015a	8b 4d fc	 mov	 ecx, DWORD PTR _token$[ebp]
  0015d	89 48 30	 mov	 DWORD PTR [eax+48], ecx

; 681  : 
; 682  :     return  token;

  00160	8b 45 fc	 mov	 eax, DWORD PTR _token$[ebp]
$LN1@emit:

; 683  : }

  00163	5e		 pop	 esi
  00164	83 c4 04	 add	 esp, 4
  00167	3b ec		 cmp	 ebp, esp
  00169	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0016e	8b e5		 mov	 esp, ebp
  00170	5d		 pop	 ebp
  00171	c3		 ret	 0
_emit	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3lexer.c
;	COMDAT _emitNew
_TEXT	SEGMENT
_lexer$ = 8						; size = 4
_token$ = 12						; size = 4
_emitNew PROC						; COMDAT

; 637  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 638  :     lexer->rec->state->token    = token;	/* Voila!   */

  00003	8b 45 08	 mov	 eax, DWORD PTR _lexer$[ebp]
  00006	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00009	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0000c	8b 45 0c	 mov	 eax, DWORD PTR _token$[ebp]
  0000f	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 639  : }

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
_emitNew ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3lexer.c
;	COMDAT _popCharStream
_TEXT	SEGMENT
_input$ = -4						; size = 4
_lexer$ = 8						; size = 4
_popCharStream PROC					; COMDAT

; 611  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 612  :     pANTLR3_INPUT_STREAM input;
; 613  : 
; 614  :     // If we do not have a stream stack or we are already at the
; 615  :     // stack bottom, then do nothing.
; 616  :     //
; 617  :     if	(lexer->rec->state->streams != NULL && lexer->rec->state->streams->size(lexer->rec->state->streams) > 0)

  0000c	8b 45 08	 mov	 eax, DWORD PTR _lexer$[ebp]
  0000f	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00012	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00015	83 7a 64 00	 cmp	 DWORD PTR [edx+100], 0
  00019	0f 84 a9 00 00
	00		 je	 $LN2@popCharStr
  0001f	8b 45 08	 mov	 eax, DWORD PTR _lexer$[ebp]
  00022	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00025	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00028	8b f4		 mov	 esi, esp
  0002a	8b 42 64	 mov	 eax, DWORD PTR [edx+100]
  0002d	50		 push	 eax
  0002e	8b 4d 08	 mov	 ecx, DWORD PTR _lexer$[ebp]
  00031	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00034	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00037	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  0003a	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0003d	ff d2		 call	 edx
  0003f	83 c4 04	 add	 esp, 4
  00042	3b f4		 cmp	 esi, esp
  00044	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00049	85 c0		 test	 eax, eax
  0004b	76 7b		 jbe	 SHORT $LN2@popCharStr

; 618  :     {
; 619  : 	// We just leave the current stream to its fate, we do not close
; 620  : 	// it or anything as we do not know what the programmer intended
; 621  : 	// for it. This method can always be overridden of course.
; 622  : 	// So just find out what was currently saved on the stack and use
; 623  : 	// that now, then pop it from the stack.
; 624  : 	//
; 625  : 	input	= (pANTLR3_INPUT_STREAM)(lexer->rec->state->streams->top);

  0004d	8b 45 08	 mov	 eax, DWORD PTR _lexer$[ebp]
  00050	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00053	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00056	8b 42 64	 mov	 eax, DWORD PTR [edx+100]
  00059	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005c	89 4d fc	 mov	 DWORD PTR _input$[ebp], ecx

; 626  : 	lexer->rec->state->streams->pop(lexer->rec->state->streams);

  0005f	8b 55 08	 mov	 edx, DWORD PTR _lexer$[ebp]
  00062	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00065	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00068	8b f4		 mov	 esi, esp
  0006a	8b 51 64	 mov	 edx, DWORD PTR [ecx+100]
  0006d	52		 push	 edx
  0006e	8b 45 08	 mov	 eax, DWORD PTR _lexer$[ebp]
  00071	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00074	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00077	8b 42 64	 mov	 eax, DWORD PTR [edx+100]
  0007a	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0007d	ff d1		 call	 ecx
  0007f	83 c4 04	 add	 esp, 4
  00082	3b f4		 cmp	 esi, esp
  00084	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 627  : 
; 628  : 	// Now install the stream as the current one.
; 629  : 	//
; 630  : 	lexer->setCharStream(lexer, input);

  00089	8b f4		 mov	 esi, esp
  0008b	8b 55 fc	 mov	 edx, DWORD PTR _input$[ebp]
  0008e	52		 push	 edx
  0008f	8b 45 08	 mov	 eax, DWORD PTR _lexer$[ebp]
  00092	50		 push	 eax
  00093	8b 4d 08	 mov	 ecx, DWORD PTR _lexer$[ebp]
  00096	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00099	ff d2		 call	 edx
  0009b	83 c4 08	 add	 esp, 8
  0009e	3b f4		 cmp	 esi, esp
  000a0	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 631  : 	lexer->input->istream->rewindLast(lexer->input->istream);

  000a5	8b 45 08	 mov	 eax, DWORD PTR _lexer$[ebp]
  000a8	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000ab	8b f4		 mov	 esi, esp
  000ad	8b 11		 mov	 edx, DWORD PTR [ecx]
  000af	52		 push	 edx
  000b0	8b 45 08	 mov	 eax, DWORD PTR _lexer$[ebp]
  000b3	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000b6	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b8	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  000bb	ff d0		 call	 eax
  000bd	83 c4 04	 add	 esp, 4
  000c0	3b f4		 cmp	 esi, esp
  000c2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c7	90		 npad	 1
$LN2@popCharStr:

; 632  :     }
; 633  :     return;
; 634  : }

  000c8	5e		 pop	 esi
  000c9	83 c4 04	 add	 esp, 4
  000cc	3b ec		 cmp	 ebp, esp
  000ce	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d3	8b e5		 mov	 esp, ebp
  000d5	5d		 pop	 ebp
  000d6	c3		 ret	 0
_popCharStream ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3lexer.c
;	COMDAT _pushCharStream
_TEXT	SEGMENT
_lexer$ = 8						; size = 4
_input$ = 12						; size = 4
_pushCharStream PROC					; COMDAT

; 565  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 566  : 	// Do we need a new input stream stack?
; 567  : 	//
; 568  : 	if	(lexer->rec->state->streams == NULL)

  00004	8b 45 08	 mov	 eax, DWORD PTR _lexer$[ebp]
  00007	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0000a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0000d	83 7a 64 00	 cmp	 DWORD PTR [edx+100], 0
  00011	75 27		 jne	 SHORT $LN3@pushCharSt

; 569  : 	{
; 570  : 		// This is the first call to stack a new
; 571  : 		// stream and so we must create the stack first.
; 572  : 		//
; 573  : 		lexer->rec->state->streams = antlr3StackNew(0);

  00013	6a 00		 push	 0
  00015	e8 00 00 00 00	 call	 _antlr3StackNew
  0001a	83 c4 04	 add	 esp, 4
  0001d	8b 4d 08	 mov	 ecx, DWORD PTR _lexer$[ebp]
  00020	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00023	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  00026	89 41 64	 mov	 DWORD PTR [ecx+100], eax

; 574  : 
; 575  : 		if  (lexer->rec->state->streams == NULL)

  00029	8b 55 08	 mov	 edx, DWORD PTR _lexer$[ebp]
  0002c	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0002f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00032	83 79 64 00	 cmp	 DWORD PTR [ecx+100], 0
  00036	75 02		 jne	 SHORT $LN3@pushCharSt

; 576  : 		{
; 577  : 			// Could not do this, we just fail to push it.
; 578  : 			// TODO: Consider if this is what we want to do, but then
; 579  : 			//       any programmer can override this method to do something else.
; 580  : 			return;

  00038	eb 72		 jmp	 SHORT $LN1@pushCharSt
$LN3@pushCharSt:

; 581  : 		}
; 582  : 	}
; 583  : 
; 584  : 	// We have a stack, so we can save the current input stream
; 585  : 	// into it.
; 586  : 	//
; 587  : 	lexer->input->istream->mark(lexer->input->istream);

  0003a	8b 55 08	 mov	 edx, DWORD PTR _lexer$[ebp]
  0003d	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00040	8b f4		 mov	 esi, esp
  00042	8b 08		 mov	 ecx, DWORD PTR [eax]
  00044	51		 push	 ecx
  00045	8b 55 08	 mov	 edx, DWORD PTR _lexer$[ebp]
  00048	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0004b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004d	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00050	ff d2		 call	 edx
  00052	83 c4 04	 add	 esp, 4
  00055	3b f4		 cmp	 esi, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 588  : 	lexer->rec->state->streams->push(lexer->rec->state->streams, lexer->input, NULL);

  0005c	8b f4		 mov	 esi, esp
  0005e	6a 00		 push	 0
  00060	8b 45 08	 mov	 eax, DWORD PTR _lexer$[ebp]
  00063	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00066	51		 push	 ecx
  00067	8b 55 08	 mov	 edx, DWORD PTR _lexer$[ebp]
  0006a	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0006d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00070	8b 51 64	 mov	 edx, DWORD PTR [ecx+100]
  00073	52		 push	 edx
  00074	8b 45 08	 mov	 eax, DWORD PTR _lexer$[ebp]
  00077	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0007a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0007d	8b 42 64	 mov	 eax, DWORD PTR [edx+100]
  00080	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00083	ff d1		 call	 ecx
  00085	83 c4 0c	 add	 esp, 12			; 0000000cH
  00088	3b f4		 cmp	 esi, esp
  0008a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 589  : 
; 590  : 	// And now we can install this new one
; 591  : 	//
; 592  : 	lexer->setCharStream(lexer, input);

  0008f	8b f4		 mov	 esi, esp
  00091	8b 55 0c	 mov	 edx, DWORD PTR _input$[ebp]
  00094	52		 push	 edx
  00095	8b 45 08	 mov	 eax, DWORD PTR _lexer$[ebp]
  00098	50		 push	 eax
  00099	8b 4d 08	 mov	 ecx, DWORD PTR _lexer$[ebp]
  0009c	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0009f	ff d2		 call	 edx
  000a1	83 c4 08	 add	 esp, 8
  000a4	3b f4		 cmp	 esi, esp
  000a6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ab	90		 npad	 1
$LN1@pushCharSt:

; 593  : }

  000ac	5e		 pop	 esi
  000ad	3b ec		 cmp	 ebp, esp
  000af	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b4	5d		 pop	 ebp
  000b5	c3		 ret	 0
_pushCharStream ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3lexer.c
;	COMDAT _setCharStream
_TEXT	SEGMENT
_lexer$ = 8						; size = 4
_input$ = 12						; size = 4
_setCharStream PROC					; COMDAT

; 493  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 494  :     /* Install the input interface
; 495  :      */
; 496  :     lexer->input	= input;

  00004	8b 45 08	 mov	 eax, DWORD PTR _lexer$[ebp]
  00007	8b 4d 0c	 mov	 ecx, DWORD PTR _input$[ebp]
  0000a	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 497  : 
; 498  :     /* We may need a token factory for the lexer; we don't destroy any existing factory
; 499  :      * until the lexer is destroyed, as people may still be using the tokens it produced.
; 500  :      * TODO: Later I will provide a dup() method for a token so that it can extract itself
; 501  :      * out of the factory. 
; 502  :      */
; 503  :     if	(lexer->rec->state->tokFactory == NULL)

  0000d	8b 55 08	 mov	 edx, DWORD PTR _lexer$[ebp]
  00010	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00013	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00016	83 79 34 00	 cmp	 DWORD PTR [ecx+52], 0
  0001a	75 1a		 jne	 SHORT $LN2@setCharStr

; 504  :     {
; 505  : 	lexer->rec->state->tokFactory	= antlr3TokenFactoryNew(input);

  0001c	8b 55 0c	 mov	 edx, DWORD PTR _input$[ebp]
  0001f	52		 push	 edx
  00020	e8 00 00 00 00	 call	 _antlr3TokenFactoryNew
  00025	83 c4 04	 add	 esp, 4
  00028	8b 4d 08	 mov	 ecx, DWORD PTR _lexer$[ebp]
  0002b	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0002e	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  00031	89 41 34	 mov	 DWORD PTR [ecx+52], eax

; 506  :     }

  00034	eb 32		 jmp	 SHORT $LN3@setCharStr
$LN2@setCharStr:

; 507  :     else
; 508  :     {
; 509  : 	/* When the input stream is being changed on the fly, rather than
; 510  : 	 * at the start of a new lexer, then we must tell the tokenFactory
; 511  : 	 * which input stream to adorn the tokens with so that when they
; 512  : 	 * are asked to provide their original input strings they can
; 513  : 	 * do so from the correct text stream.
; 514  : 	 */
; 515  : 	lexer->rec->state->tokFactory->setInputStream(lexer->rec->state->tokFactory, input);

  00036	8b f4		 mov	 esi, esp
  00038	8b 55 0c	 mov	 edx, DWORD PTR _input$[ebp]
  0003b	52		 push	 edx
  0003c	8b 45 08	 mov	 eax, DWORD PTR _lexer$[ebp]
  0003f	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00042	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00045	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00048	50		 push	 eax
  00049	8b 4d 08	 mov	 ecx, DWORD PTR _lexer$[ebp]
  0004c	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0004f	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00052	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00055	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR [ecx+172]
  0005b	ff d2		 call	 edx
  0005d	83 c4 08	 add	 esp, 8
  00060	3b f4		 cmp	 esi, esp
  00062	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00067	90		 npad	 1
$LN3@setCharStr:

; 516  :     }
; 517  : 
; 518  :     /* Propagate the string factory so that we preserve the encoding form from
; 519  :      * the input stream.
; 520  :      */
; 521  :     if	(lexer->rec->state->tokSource->strFactory == NULL)

  00068	8b 45 08	 mov	 eax, DWORD PTR _lexer$[ebp]
  0006b	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0006e	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00071	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  00074	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00078	75 3c		 jne	 SHORT $LN5@setCharStr

; 522  :     {
; 523  :         lexer->rec->state->tokSource->strFactory	= input->strFactory;

  0007a	8b 4d 08	 mov	 ecx, DWORD PTR _lexer$[ebp]
  0007d	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00080	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00083	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00086	8b 55 0c	 mov	 edx, DWORD PTR _input$[ebp]
  00089	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0008c	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 524  : 
; 525  :         // Set the newly acquired string factory up for our pre-made tokens
; 526  :         // for EOF.
; 527  :         //
; 528  :         if (lexer->rec->state->tokSource->eofToken.strFactory == NULL)

  0008f	8b 4d 08	 mov	 ecx, DWORD PTR _lexer$[ebp]
  00092	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00095	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00098	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  0009b	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  0009f	75 15		 jne	 SHORT $LN5@setCharStr

; 529  :         {
; 530  :             lexer->rec->state->tokSource->eofToken.strFactory = input->strFactory;

  000a1	8b 55 08	 mov	 edx, DWORD PTR _lexer$[ebp]
  000a4	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  000a7	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000aa	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  000ad	8b 45 0c	 mov	 eax, DWORD PTR _input$[ebp]
  000b0	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  000b3	89 4a 10	 mov	 DWORD PTR [edx+16], ecx
$LN5@setCharStr:

; 531  :         }
; 532  :     }
; 533  : 
; 534  :     /* This is a lexer, install the appropriate exception creator
; 535  :      */
; 536  :     lexer->rec->exConstruct = antlr3RecognitionExceptionNew;

  000b6	8b 55 08	 mov	 edx, DWORD PTR _lexer$[ebp]
  000b9	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  000bc	c7 80 88 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+136], OFFSET _antlr3RecognitionExceptionNew

; 537  : 
; 538  :     /* Set the current token to nothing
; 539  :      */
; 540  :     lexer->rec->state->token		= NULL;

  000c6	8b 4d 08	 mov	 ecx, DWORD PTR _lexer$[ebp]
  000c9	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  000cc	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000cf	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], 0

; 541  :     lexer->rec->state->text			= NULL;

  000d6	8b 4d 08	 mov	 ecx, DWORD PTR _lexer$[ebp]
  000d9	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  000dc	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000df	c7 40 50 00 00
	00 00		 mov	 DWORD PTR [eax+80], 0

; 542  :     lexer->rec->state->tokenStartCharIndex	= -1;

  000e6	8b 4d 08	 mov	 ecx, DWORD PTR _lexer$[ebp]
  000e9	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  000ec	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000ef	c7 40 4c ff ff
	ff ff		 mov	 DWORD PTR [eax+76], -1

; 543  : 
; 544  :     /* Copy the name of the char stream to the token source
; 545  :      */
; 546  :     lexer->rec->state->tokSource->fileName = input->fileName;

  000f6	8b 4d 08	 mov	 ecx, DWORD PTR _lexer$[ebp]
  000f9	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  000fc	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000ff	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00102	8b 55 0c	 mov	 edx, DWORD PTR _input$[ebp]
  00105	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  00108	89 81 2c 01 00
	00		 mov	 DWORD PTR [ecx+300], eax

; 547  : }

  0010e	5e		 pop	 esi
  0010f	3b ec		 cmp	 ebp, esp
  00111	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00116	5d		 pop	 ebp
  00117	c3		 ret	 0
_setCharStream ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3lexer.c
;	COMDAT _mTokens
_TEXT	SEGMENT
_lexer$ = 8						; size = 4
_mTokens PROC						; COMDAT

; 403  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 404  :     if	(lexer)	    // Fool compiler, avoid pragmas

  00004	83 7d 08 00	 cmp	 DWORD PTR _lexer$[ebp], 0
  00008	74 22		 je	 SHORT $LN2@mTokens

; 405  :     {
; 406  : 		ANTLR3_FPRINTF(stderr, "lexer->mTokens(): Error: No lexer rules were added to the lexer yet!\n");

  0000a	68 00 00 00 00	 push	 OFFSET ??_C@_0EG@JALJLDIL@lexer?9?$DOmTokens?$CI?$CJ?3?5Error?3?5No?5lex@
  0000f	8b f4		 mov	 esi, esp
  00011	6a 02		 push	 2
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  00019	83 c4 04	 add	 esp, 4
  0001c	3b f4		 cmp	 esi, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 _fprintf
  00029	83 c4 08	 add	 esp, 8
$LN2@mTokens:

; 407  :     }
; 408  : }

  0002c	5e		 pop	 esi
  0002d	3b ec		 cmp	 ebp, esp
  0002f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
_mTokens ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3lexer.c
;	COMDAT _antlr3LexerNew
_TEXT	SEGMENT
_specialT$ = -8						; size = 4
_lexer$ = -4						; size = 4
_sizeHint$ = 8						; size = 4
_state$ = 12						; size = 4
_antlr3LexerNew PROC					; COMDAT

; 73   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 74   :     pANTLR3_LEXER   lexer;
; 75   :     pANTLR3_COMMON_TOKEN	specialT;
; 76   : 
; 77   : 	/* Allocate memory
; 78   : 	*/
; 79   : 	lexer   = (pANTLR3_LEXER) ANTLR3_MALLOC(sizeof(ANTLR3_LEXER));

  00015	8b f4		 mov	 esi, esp
  00017	6a 50		 push	 80			; 00000050H
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0001f	83 c4 04	 add	 esp, 4
  00022	3b f4		 cmp	 esi, esp
  00024	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00029	89 45 fc	 mov	 DWORD PTR _lexer$[ebp], eax

; 80   : 
; 81   : 	if	(lexer == NULL)

  0002c	83 7d fc 00	 cmp	 DWORD PTR _lexer$[ebp], 0
  00030	75 07		 jne	 SHORT $LN2@antlr3Lexe

; 82   : 	{
; 83   : 		return	NULL;

  00032	33 c0		 xor	 eax, eax
  00034	e9 ff 02 00 00	 jmp	 $LN1@antlr3Lexe
$LN2@antlr3Lexe:

; 84   : 	}
; 85   : 
; 86   : 	/* Now we need to create the base recognizer
; 87   : 	*/
; 88   : 	lexer->rec	    =  antlr3BaseRecognizerNew(ANTLR3_TYPE_LEXER, sizeHint, state);

  00039	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  0003c	50		 push	 eax
  0003d	8b 4d 08	 mov	 ecx, DWORD PTR _sizeHint$[ebp]
  00040	51		 push	 ecx
  00041	6a 01		 push	 1
  00043	e8 00 00 00 00	 call	 _antlr3BaseRecognizerNew
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004b	8b 55 fc	 mov	 edx, DWORD PTR _lexer$[ebp]
  0004e	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 89   : 
; 90   : 	if	(lexer->rec == NULL)

  00051	8b 45 fc	 mov	 eax, DWORD PTR _lexer$[ebp]
  00054	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00058	75 1f		 jne	 SHORT $LN3@antlr3Lexe

; 91   : 	{
; 92   : 		lexer->free(lexer);

  0005a	8b f4		 mov	 esi, esp
  0005c	8b 4d fc	 mov	 ecx, DWORD PTR _lexer$[ebp]
  0005f	51		 push	 ecx
  00060	8b 55 fc	 mov	 edx, DWORD PTR _lexer$[ebp]
  00063	8b 42 4c	 mov	 eax, DWORD PTR [edx+76]
  00066	ff d0		 call	 eax
  00068	83 c4 04	 add	 esp, 4
  0006b	3b f4		 cmp	 esi, esp
  0006d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 93   : 		return	NULL;

  00072	33 c0		 xor	 eax, eax
  00074	e9 bf 02 00 00	 jmp	 $LN1@antlr3Lexe
$LN3@antlr3Lexe:

; 94   : 	}
; 95   : 	lexer->rec->super  =  lexer;

  00079	8b 4d fc	 mov	 ecx, DWORD PTR _lexer$[ebp]
  0007c	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0007f	8b 45 fc	 mov	 eax, DWORD PTR _lexer$[ebp]
  00082	89 02		 mov	 DWORD PTR [edx], eax

; 96   : 
; 97   : 	lexer->rec->displayRecognitionError	    = displayRecognitionError;

  00084	8b 4d fc	 mov	 ecx, DWORD PTR _lexer$[ebp]
  00087	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0008a	c7 42 28 00 00
	00 00		 mov	 DWORD PTR [edx+40], OFFSET _displayRecognitionError

; 98   : 	lexer->rec->reportError					= reportError;

  00091	8b 45 fc	 mov	 eax, DWORD PTR _lexer$[ebp]
  00094	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00097	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], OFFSET _reportError

; 99   : 	lexer->rec->reset						= reset;

  0009e	8b 55 fc	 mov	 edx, DWORD PTR _lexer$[ebp]
  000a1	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  000a4	c7 80 8c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+140], OFFSET _reset

; 100  : 	lexer->rec->getCurrentInputSymbol		= getCurrentInputSymbol;

  000ae	8b 4d fc	 mov	 ecx, DWORD PTR _lexer$[ebp]
  000b1	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  000b4	c7 42 7c 00 00
	00 00		 mov	 DWORD PTR [edx+124], OFFSET _getCurrentInputSymbol

; 101  : 	lexer->rec->getMissingSymbol			= getMissingSymbol;

  000bb	8b 45 fc	 mov	 eax, DWORD PTR _lexer$[ebp]
  000be	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000c1	c7 81 80 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+128], OFFSET _getMissingSymbol

; 102  : 
; 103  : 	/* Now install the token source interface
; 104  : 	*/
; 105  : 	if	(lexer->rec->state->tokSource == NULL) 

  000cb	8b 55 fc	 mov	 edx, DWORD PTR _lexer$[ebp]
  000ce	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  000d1	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000d4	83 79 38 00	 cmp	 DWORD PTR [ecx+56], 0
  000d8	0f 85 be 00 00
	00		 jne	 $LN4@antlr3Lexe

; 106  : 	{
; 107  : 		lexer->rec->state->tokSource	= (pANTLR3_TOKEN_SOURCE)ANTLR3_CALLOC(1, sizeof(ANTLR3_TOKEN_SOURCE));

  000de	8b f4		 mov	 esi, esp
  000e0	68 30 01 00 00	 push	 304			; 00000130H
  000e5	6a 01		 push	 1
  000e7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__calloc
  000ed	83 c4 08	 add	 esp, 8
  000f0	3b f4		 cmp	 esi, esp
  000f2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f7	8b 55 fc	 mov	 edx, DWORD PTR _lexer$[ebp]
  000fa	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  000fd	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00100	89 42 38	 mov	 DWORD PTR [edx+56], eax

; 108  : 
; 109  : 		if	(lexer->rec->state->tokSource == NULL) 

  00103	8b 45 fc	 mov	 eax, DWORD PTR _lexer$[ebp]
  00106	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00109	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0010c	83 7a 38 00	 cmp	 DWORD PTR [edx+56], 0
  00110	75 40		 jne	 SHORT $LN5@antlr3Lexe

; 110  : 		{
; 111  : 			lexer->rec->free(lexer->rec);

  00112	8b f4		 mov	 esi, esp
  00114	8b 45 fc	 mov	 eax, DWORD PTR _lexer$[ebp]
  00117	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0011a	51		 push	 ecx
  0011b	8b 55 fc	 mov	 edx, DWORD PTR _lexer$[ebp]
  0011e	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00121	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  00127	ff d1		 call	 ecx
  00129	83 c4 04	 add	 esp, 4
  0012c	3b f4		 cmp	 esi, esp
  0012e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 112  : 			lexer->free(lexer);

  00133	8b f4		 mov	 esi, esp
  00135	8b 55 fc	 mov	 edx, DWORD PTR _lexer$[ebp]
  00138	52		 push	 edx
  00139	8b 45 fc	 mov	 eax, DWORD PTR _lexer$[ebp]
  0013c	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  0013f	ff d1		 call	 ecx
  00141	83 c4 04	 add	 esp, 4
  00144	3b f4		 cmp	 esi, esp
  00146	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 113  : 
; 114  : 			return	NULL;

  0014b	33 c0		 xor	 eax, eax
  0014d	e9 e6 01 00 00	 jmp	 $LN1@antlr3Lexe
$LN5@antlr3Lexe:

; 115  : 		}
; 116  : 		lexer->rec->state->tokSource->super    =  lexer;

  00152	8b 55 fc	 mov	 edx, DWORD PTR _lexer$[ebp]
  00155	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00158	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0015b	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  0015e	8b 45 fc	 mov	 eax, DWORD PTR _lexer$[ebp]
  00161	89 82 28 01 00
	00		 mov	 DWORD PTR [edx+296], eax

; 117  : 
; 118  : 		/* Install the default nextToken() method, which may be overridden
; 119  : 		 * by generated code, or by anything else in fact.
; 120  : 		 */
; 121  : 		lexer->rec->state->tokSource->nextToken	    =  nextToken;

  00167	8b 4d fc	 mov	 ecx, DWORD PTR _lexer$[ebp]
  0016a	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0016d	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00170	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00173	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET _nextToken

; 122  : 		lexer->rec->state->tokSource->strFactory    = NULL;

  00179	8b 55 fc	 mov	 edx, DWORD PTR _lexer$[ebp]
  0017c	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0017f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00182	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  00185	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 123  : 
; 124  : 		lexer->rec->state->tokFactory				= NULL;

  0018c	8b 45 fc	 mov	 eax, DWORD PTR _lexer$[ebp]
  0018f	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00192	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00195	c7 42 34 00 00
	00 00		 mov	 DWORD PTR [edx+52], 0
$LN4@antlr3Lexe:

; 125  : 	}
; 126  : 
; 127  :     /* Install the lexer API
; 128  :      */
; 129  :     lexer->setCharStream			=  setCharStream;

  0019c	8b 45 fc	 mov	 eax, DWORD PTR _lexer$[ebp]
  0019f	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], OFFSET _setCharStream

; 130  :     lexer->mTokens					= (void (*)(void *))(mTokens);

  001a6	8b 4d fc	 mov	 ecx, DWORD PTR _lexer$[ebp]
  001a9	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], OFFSET _mTokens

; 131  :     lexer->setCharStream			=  setCharStream;

  001b0	8b 55 fc	 mov	 edx, DWORD PTR _lexer$[ebp]
  001b3	c7 42 10 00 00
	00 00		 mov	 DWORD PTR [edx+16], OFFSET _setCharStream

; 132  :     lexer->pushCharStream			=  pushCharStream;

  001ba	8b 45 fc	 mov	 eax, DWORD PTR _lexer$[ebp]
  001bd	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], OFFSET _pushCharStream

; 133  :     lexer->popCharStream			=  popCharStream;

  001c4	8b 4d fc	 mov	 ecx, DWORD PTR _lexer$[ebp]
  001c7	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET _popCharStream

; 134  :     lexer->emit						=  emit;

  001ce	8b 55 fc	 mov	 edx, DWORD PTR _lexer$[ebp]
  001d1	c7 42 20 00 00
	00 00		 mov	 DWORD PTR [edx+32], OFFSET _emit

; 135  :     lexer->emitNew					=  emitNew;

  001d8	8b 45 fc	 mov	 eax, DWORD PTR _lexer$[ebp]
  001db	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], OFFSET _emitNew

; 136  :     lexer->matchs					=  matchs;

  001e2	8b 4d fc	 mov	 ecx, DWORD PTR _lexer$[ebp]
  001e5	c7 41 28 00 00
	00 00		 mov	 DWORD PTR [ecx+40], OFFSET _matchs

; 137  :     lexer->matchc					=  matchc;

  001ec	8b 55 fc	 mov	 edx, DWORD PTR _lexer$[ebp]
  001ef	c7 42 2c 00 00
	00 00		 mov	 DWORD PTR [edx+44], OFFSET _matchc

; 138  :     lexer->matchRange				=  matchRange;

  001f6	8b 45 fc	 mov	 eax, DWORD PTR _lexer$[ebp]
  001f9	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], OFFSET _matchRange

; 139  :     lexer->matchAny					=  matchAny;

  00200	8b 4d fc	 mov	 ecx, DWORD PTR _lexer$[ebp]
  00203	c7 41 34 00 00
	00 00		 mov	 DWORD PTR [ecx+52], OFFSET _matchAny

; 140  :     lexer->recover					=  recover;

  0020a	8b 55 fc	 mov	 edx, DWORD PTR _lexer$[ebp]
  0020d	c7 42 38 00 00
	00 00		 mov	 DWORD PTR [edx+56], OFFSET _recover

; 141  :     lexer->getLine					=  getLine;

  00214	8b 45 fc	 mov	 eax, DWORD PTR _lexer$[ebp]
  00217	c7 40 3c 00 00
	00 00		 mov	 DWORD PTR [eax+60], OFFSET _getLine

; 142  :     lexer->getCharIndex				=  getCharIndex;

  0021e	8b 4d fc	 mov	 ecx, DWORD PTR _lexer$[ebp]
  00221	c7 41 40 00 00
	00 00		 mov	 DWORD PTR [ecx+64], OFFSET _getCharIndex

; 143  :     lexer->getCharPositionInLine    =  getCharPositionInLine;

  00228	8b 55 fc	 mov	 edx, DWORD PTR _lexer$[ebp]
  0022b	c7 42 44 00 00
	00 00		 mov	 DWORD PTR [edx+68], OFFSET _getCharPositionInLine

; 144  :     lexer->getText					=  getText;

  00232	8b 45 fc	 mov	 eax, DWORD PTR _lexer$[ebp]
  00235	c7 40 48 00 00
	00 00		 mov	 DWORD PTR [eax+72], OFFSET _getText

; 145  :     lexer->free						=  freeLexer;

  0023c	8b 4d fc	 mov	 ecx, DWORD PTR _lexer$[ebp]
  0023f	c7 41 4c 00 00
	00 00		 mov	 DWORD PTR [ecx+76], OFFSET _freeLexer

; 146  :     
; 147  :     /* Initialise the eof token
; 148  :      */
; 149  :     specialT					= &(lexer->rec->state->tokSource->eofToken);

  00246	8b 55 fc	 mov	 edx, DWORD PTR _lexer$[ebp]
  00249	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0024c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0024f	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  00252	83 c2 08	 add	 edx, 8
  00255	89 55 f8	 mov	 DWORD PTR _specialT$[ebp], edx

; 150  :     antlr3SetTokenAPI	  (specialT);

  00258	8b 45 f8	 mov	 eax, DWORD PTR _specialT$[ebp]
  0025b	50		 push	 eax
  0025c	e8 00 00 00 00	 call	 _antlr3SetTokenAPI
  00261	83 c4 04	 add	 esp, 4

; 151  :     specialT->setType	  (specialT, ANTLR3_TOKEN_EOF);

  00264	8b f4		 mov	 esi, esp
  00266	6a ff		 push	 -1
  00268	8b 4d f8	 mov	 ecx, DWORD PTR _specialT$[ebp]
  0026b	51		 push	 ecx
  0026c	8b 55 f8	 mov	 edx, DWORD PTR _specialT$[ebp]
  0026f	8b 42 58	 mov	 eax, DWORD PTR [edx+88]
  00272	ff d0		 call	 eax
  00274	83 c4 08	 add	 esp, 8
  00277	3b f4		 cmp	 esi, esp
  00279	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 152  :     specialT->factoryMade		= ANTLR3_TRUE;					// Prevent things trying to free() it

  0027e	8b 4d f8	 mov	 ecx, DWORD PTR _specialT$[ebp]
  00281	c6 41 04 01	 mov	 BYTE PTR [ecx+4], 1

; 153  :     specialT->strFactory        = NULL;

  00285	8b 55 f8	 mov	 edx, DWORD PTR _specialT$[ebp]
  00288	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 154  : 	specialT->textState			= ANTLR3_TEXT_NONE;

  0028f	8b 45 f8	 mov	 eax, DWORD PTR _specialT$[ebp]
  00292	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], 0

; 155  : 	specialT->custom			= NULL;

  00299	8b 4d f8	 mov	 ecx, DWORD PTR _specialT$[ebp]
  0029c	c7 41 40 00 00
	00 00		 mov	 DWORD PTR [ecx+64], 0

; 156  : 	specialT->user1				= 0;

  002a3	8b 55 f8	 mov	 edx, DWORD PTR _specialT$[ebp]
  002a6	c7 42 34 00 00
	00 00		 mov	 DWORD PTR [edx+52], 0

; 157  : 	specialT->user2				= 0;

  002ad	8b 45 f8	 mov	 eax, DWORD PTR _specialT$[ebp]
  002b0	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [eax+56], 0

; 158  : 	specialT->user3				= 0;

  002b7	8b 4d f8	 mov	 ecx, DWORD PTR _specialT$[ebp]
  002ba	c7 41 3c 00 00
	00 00		 mov	 DWORD PTR [ecx+60], 0

; 159  : 
; 160  : 	// Initialize the skip token.
; 161  : 	//
; 162  :     specialT					= &(lexer->rec->state->tokSource->skipToken);

  002c1	8b 55 fc	 mov	 edx, DWORD PTR _lexer$[ebp]
  002c4	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  002c7	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  002ca	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  002cd	81 c2 98 00 00
	00		 add	 edx, 152		; 00000098H
  002d3	89 55 f8	 mov	 DWORD PTR _specialT$[ebp], edx

; 163  :     antlr3SetTokenAPI	  (specialT);

  002d6	8b 45 f8	 mov	 eax, DWORD PTR _specialT$[ebp]
  002d9	50		 push	 eax
  002da	e8 00 00 00 00	 call	 _antlr3SetTokenAPI
  002df	83 c4 04	 add	 esp, 4

; 164  :     specialT->setType	  (specialT, ANTLR3_TOKEN_INVALID);

  002e2	8b f4		 mov	 esi, esp
  002e4	6a 00		 push	 0
  002e6	8b 4d f8	 mov	 ecx, DWORD PTR _specialT$[ebp]
  002e9	51		 push	 ecx
  002ea	8b 55 f8	 mov	 edx, DWORD PTR _specialT$[ebp]
  002ed	8b 42 58	 mov	 eax, DWORD PTR [edx+88]
  002f0	ff d0		 call	 eax
  002f2	83 c4 08	 add	 esp, 8
  002f5	3b f4		 cmp	 esi, esp
  002f7	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 165  :     specialT->factoryMade		= ANTLR3_TRUE;					// Prevent things trying to free() it

  002fc	8b 4d f8	 mov	 ecx, DWORD PTR _specialT$[ebp]
  002ff	c6 41 04 01	 mov	 BYTE PTR [ecx+4], 1

; 166  :     specialT->strFactory        = NULL;

  00303	8b 55 f8	 mov	 edx, DWORD PTR _specialT$[ebp]
  00306	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 167  : 	specialT->custom			= NULL;

  0030d	8b 45 f8	 mov	 eax, DWORD PTR _specialT$[ebp]
  00310	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [eax+64], 0

; 168  : 	specialT->user1				= 0;

  00317	8b 4d f8	 mov	 ecx, DWORD PTR _specialT$[ebp]
  0031a	c7 41 34 00 00
	00 00		 mov	 DWORD PTR [ecx+52], 0

; 169  : 	specialT->user2				= 0;

  00321	8b 55 f8	 mov	 edx, DWORD PTR _specialT$[ebp]
  00324	c7 42 38 00 00
	00 00		 mov	 DWORD PTR [edx+56], 0

; 170  : 	specialT->user3				= 0;

  0032b	8b 45 f8	 mov	 eax, DWORD PTR _specialT$[ebp]
  0032e	c7 40 3c 00 00
	00 00		 mov	 DWORD PTR [eax+60], 0

; 171  :     return  lexer;

  00335	8b 45 fc	 mov	 eax, DWORD PTR _lexer$[ebp]
$LN1@antlr3Lexe:

; 172  : }

  00338	5e		 pop	 esi
  00339	83 c4 08	 add	 esp, 8
  0033c	3b ec		 cmp	 ebp, esp
  0033e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00343	8b e5		 mov	 esp, ebp
  00345	5d		 pop	 ebp
  00346	c3		 ret	 0
_antlr3LexerNew ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3lexer.c
;	COMDAT _antlr3LexerNewStream
_TEXT	SEGMENT
_lexer$ = -4						; size = 4
_sizeHint$ = 8						; size = 4
_input$ = 12						; size = 4
_state$ = 16						; size = 4
_antlr3LexerNewStream PROC				; COMDAT

; 385  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 386  :     pANTLR3_LEXER   lexer;
; 387  : 
; 388  :     // Create a basic lexer first
; 389  :     //
; 390  :     lexer   = antlr3LexerNew(sizeHint, state);

  0000b	8b 45 10	 mov	 eax, DWORD PTR _state$[ebp]
  0000e	50		 push	 eax
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _sizeHint$[ebp]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 _antlr3LexerNew
  00018	83 c4 08	 add	 esp, 8
  0001b	89 45 fc	 mov	 DWORD PTR _lexer$[ebp], eax

; 391  : 
; 392  :     if	(lexer != NULL) 

  0001e	83 7d fc 00	 cmp	 DWORD PTR _lexer$[ebp], 0
  00022	74 10		 je	 SHORT $LN2@antlr3Lexe

; 393  :     {
; 394  : 		// Install the input stream and reset the lexer
; 395  : 		//
; 396  : 		setCharStream(lexer, input);

  00024	8b 55 0c	 mov	 edx, DWORD PTR _input$[ebp]
  00027	52		 push	 edx
  00028	8b 45 fc	 mov	 eax, DWORD PTR _lexer$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 _setCharStream
  00031	83 c4 08	 add	 esp, 8
$LN2@antlr3Lexe:

; 397  :     }
; 398  : 
; 399  :     return  lexer;

  00034	8b 45 fc	 mov	 eax, DWORD PTR _lexer$[ebp]

; 400  : }

  00037	83 c4 04	 add	 esp, 4
  0003a	3b ec		 cmp	 ebp, esp
  0003c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
_antlr3LexerNewStream ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 837  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 838  :         int _Result;
; 839  :         va_list _ArgList;
; 840  :         __crt_va_start(_ArgList, _Format);

  00014	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00017	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 841  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

  0001a	8b 4d f8	 mov	 ecx, DWORD PTR __ArgList$[ebp]
  0001d	51		 push	 ecx
  0001e	6a 00		 push	 0
  00020	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00023	52		 push	 edx
  00024	8b 45 08	 mov	 eax, DWORD PTR __Stream$[ebp]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 __vfprintf_l
  0002d	83 c4 10	 add	 esp, 16			; 00000010H
  00030	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 842  :         __crt_va_end(_ArgList);

  00033	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 843  :         return _Result;

  0003a	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 844  :     }

  0003d	83 c4 08	 add	 esp, 8
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 644  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00004	8b f4		 mov	 esi, esp
  00006	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  0000d	51		 push	 ecx
  0000e	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00011	52		 push	 edx
  00012	8b 45 08	 mov	 eax, DWORD PTR __Stream$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  0001b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001e	51		 push	 ecx
  0001f	8b 10		 mov	 edx, DWORD PTR [eax]
  00021	52		 push	 edx
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vfprintf
  00028	83 c4 18	 add	 esp, 24			; 00000018H
  0002b	3b f4		 cmp	 esi, esp
  0002d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 646  :     }

  00032	5e		 pop	 esi
  00033	3b ec		 cmp	 ebp, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 90   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00003	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
