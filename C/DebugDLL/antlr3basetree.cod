; Listing generated by Microsoft (R) Optimizing Compiler Version 19.42.34436.0 

	TITLE	C:\SPO_labs\C\DebugDLL\antlr3basetree.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	___local_stdio_printf_options
PUBLIC	__vfprintf_l
PUBLIC	_fprintf
PUBLIC	_antlr3BaseTreeNew
PUBLIC	??_C@_0DM@LGLGCGOD@ANTLR3?3?5An?5attempt?5was?5made?5to?5@ ; `string'
PUBLIC	??_C@_01ODHLEDKK@?$CI@				; `string'
PUBLIC	??_C@_01CLKCMJKC@?5@				; `string'
PUBLIC	??_C@_01PKGAHCOL@?$CJ@				; `string'
PUBLIC	??_C@_0EG@NBNMEDOE@replaceChildren?5call?3?5Indexes?5a@ ; `string'
PUBLIC	??_C@_0CB@IIIEFFAH@replaceChildren?3?5out?5of?5memory?$CB@ ; `string'
EXTRN	__imp__free:PROC
EXTRN	__imp__exit:PROC
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	_antlr3VectorNew:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0CB@IIIEFFAH@replaceChildren?3?5out?5of?5memory?$CB@
CONST	SEGMENT
??_C@_0CB@IIIEFFAH@replaceChildren?3?5out?5of?5memory?$CB@ DB 'replaceChi'
	DB	'ldren: out of memory!!', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@NBNMEDOE@replaceChildren?5call?3?5Indexes?5a@
CONST	SEGMENT
??_C@_0EG@NBNMEDOE@replaceChildren?5call?3?5Indexes?5a@ DB 'replaceChildr'
	DB	'en call: Indexes are invalid; no children in list for %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01PKGAHCOL@?$CJ@
CONST	SEGMENT
??_C@_01PKGAHCOL@?$CJ@ DB ')', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01ODHLEDKK@?$CI@
CONST	SEGMENT
??_C@_01ODHLEDKK@?$CI@ DB '(', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@LGLGCGOD@ANTLR3?3?5An?5attempt?5was?5made?5to?5@
CONST	SEGMENT
??_C@_0DM@LGLGCGOD@ANTLR3?3?5An?5attempt?5was?5made?5to?5@ DB 'ANTLR3: An'
	DB	' attempt was made to add a child list to itself!', 0aH, 00H ; `string'
CONST	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3basetree.c
;	COMDAT _toStringTree
_TEXT	SEGMENT
_t$ = -16						; size = 4
_n$ = -12						; size = 4
_i$ = -8						; size = 4
_string$ = -4						; size = 4
_tree$ = 8						; size = 4
_toStringTree PROC					; COMDAT

; 293  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000f	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00012	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00015	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 294  : 	pANTLR3_STRING  string;
; 295  : 	ANTLR3_UINT32   i;
; 296  : 	ANTLR3_UINT32   n;
; 297  : 	pANTLR3_BASE_TREE   t;
; 298  : 
; 299  : 	if	(tree->children == NULL || tree->children->size(tree->children) == 0)

  00018	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  0001b	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0001f	74 25		 je	 SHORT $LN6@toStringTr
  00021	8b f4		 mov	 esi, esp
  00023	8b 4d 08	 mov	 ecx, DWORD PTR _tree$[ebp]
  00026	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00029	52		 push	 edx
  0002a	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  0002d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00030	8b 91 b0 00 00
	00		 mov	 edx, DWORD PTR [ecx+176]
  00036	ff d2		 call	 edx
  00038	83 c4 04	 add	 esp, 4
  0003b	3b f4		 cmp	 esi, esp
  0003d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00042	85 c0		 test	 eax, eax
  00044	75 1d		 jne	 SHORT $LN5@toStringTr
$LN6@toStringTr:

; 300  : 	{
; 301  : 		return	tree->toString(tree);

  00046	8b f4		 mov	 esi, esp
  00048	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  0004b	50		 push	 eax
  0004c	8b 4d 08	 mov	 ecx, DWORD PTR _tree$[ebp]
  0004f	8b 51 6c	 mov	 edx, DWORD PTR [ecx+108]
  00052	ff d2		 call	 edx
  00054	83 c4 04	 add	 esp, 4
  00057	3b f4		 cmp	 esi, esp
  00059	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005e	e9 be 01 00 00	 jmp	 $LN1@toStringTr
$LN5@toStringTr:

; 302  : 	}
; 303  : 
; 304  : 	/* Need a new string with nothing at all in it.
; 305  : 	*/
; 306  : 	string	= tree->strFactory->newRaw(tree->strFactory);

  00063	8b f4		 mov	 esi, esp
  00065	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  00068	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0006b	51		 push	 ecx
  0006c	8b 55 08	 mov	 edx, DWORD PTR _tree$[ebp]
  0006f	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00072	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00075	ff d1		 call	 ecx
  00077	83 c4 04	 add	 esp, 4
  0007a	3b f4		 cmp	 esi, esp
  0007c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00081	89 45 fc	 mov	 DWORD PTR _string$[ebp], eax

; 307  : 
; 308  : 	if	(tree->isNilNode(tree) == ANTLR3_FALSE)

  00084	8b f4		 mov	 esi, esp
  00086	8b 55 08	 mov	 edx, DWORD PTR _tree$[ebp]
  00089	52		 push	 edx
  0008a	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  0008d	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00090	ff d1		 call	 ecx
  00092	83 c4 04	 add	 esp, 4
  00095	3b f4		 cmp	 esi, esp
  00097	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009c	0f b6 d0	 movzx	 edx, al
  0009f	85 d2		 test	 edx, edx
  000a1	75 6c		 jne	 SHORT $LN7@toStringTr

; 309  : 	{
; 310  : 		string->append8	(string, "(");

  000a3	8b f4		 mov	 esi, esp
  000a5	68 00 00 00 00	 push	 OFFSET ??_C@_01ODHLEDKK@?$CI@
  000aa	8b 45 fc	 mov	 eax, DWORD PTR _string$[ebp]
  000ad	50		 push	 eax
  000ae	8b 4d fc	 mov	 ecx, DWORD PTR _string$[ebp]
  000b1	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  000b4	ff d2		 call	 edx
  000b6	83 c4 08	 add	 esp, 8
  000b9	3b f4		 cmp	 esi, esp
  000bb	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 311  : 		string->appendS	(string, tree->toString(tree));

  000c0	8b f4		 mov	 esi, esp
  000c2	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  000c5	50		 push	 eax
  000c6	8b 4d 08	 mov	 ecx, DWORD PTR _tree$[ebp]
  000c9	8b 51 6c	 mov	 edx, DWORD PTR [ecx+108]
  000cc	ff d2		 call	 edx
  000ce	83 c4 04	 add	 esp, 4
  000d1	3b f4		 cmp	 esi, esp
  000d3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d8	8b f4		 mov	 esi, esp
  000da	50		 push	 eax
  000db	8b 45 fc	 mov	 eax, DWORD PTR _string$[ebp]
  000de	50		 push	 eax
  000df	8b 4d fc	 mov	 ecx, DWORD PTR _string$[ebp]
  000e2	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  000e5	ff d2		 call	 edx
  000e7	83 c4 08	 add	 esp, 8
  000ea	3b f4		 cmp	 esi, esp
  000ec	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 312  : 		string->append8	(string, " ");

  000f1	8b f4		 mov	 esi, esp
  000f3	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5@
  000f8	8b 45 fc	 mov	 eax, DWORD PTR _string$[ebp]
  000fb	50		 push	 eax
  000fc	8b 4d fc	 mov	 ecx, DWORD PTR _string$[ebp]
  000ff	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00102	ff d2		 call	 edx
  00104	83 c4 08	 add	 esp, 8
  00107	3b f4		 cmp	 esi, esp
  00109	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0010e	90		 npad	 1
$LN7@toStringTr:

; 313  : 	}
; 314  : 	if	(tree->children != NULL)

  0010f	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  00112	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00116	0f 84 c5 00 00
	00		 je	 $LN3@toStringTr

; 315  : 	{
; 316  : 		n = tree->children->size(tree->children);

  0011c	8b f4		 mov	 esi, esp
  0011e	8b 4d 08	 mov	 ecx, DWORD PTR _tree$[ebp]
  00121	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00124	52		 push	 edx
  00125	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  00128	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0012b	8b 91 b0 00 00
	00		 mov	 edx, DWORD PTR [ecx+176]
  00131	ff d2		 call	 edx
  00133	83 c4 04	 add	 esp, 4
  00136	3b f4		 cmp	 esi, esp
  00138	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0013d	89 45 f4	 mov	 DWORD PTR _n$[ebp], eax

; 317  : 
; 318  : 		for	(i = 0; i < n; i++)

  00140	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00147	eb 09		 jmp	 SHORT $LN4@toStringTr
$LN2@toStringTr:
  00149	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0014c	83 c0 01	 add	 eax, 1
  0014f	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@toStringTr:
  00152	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00155	3b 4d f4	 cmp	 ecx, DWORD PTR _n$[ebp]
  00158	0f 83 83 00 00
	00		 jae	 $LN3@toStringTr

; 319  : 		{   
; 320  : 			t   = (pANTLR3_BASE_TREE) tree->children->get(tree->children, i);

  0015e	8b f4		 mov	 esi, esp
  00160	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00163	52		 push	 edx
  00164	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  00167	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0016a	51		 push	 ecx
  0016b	8b 55 08	 mov	 edx, DWORD PTR _tree$[ebp]
  0016e	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00171	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [eax+152]
  00177	ff d1		 call	 ecx
  00179	83 c4 08	 add	 esp, 8
  0017c	3b f4		 cmp	 esi, esp
  0017e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00183	89 45 f0	 mov	 DWORD PTR _t$[ebp], eax

; 321  : 
; 322  : 			if  (i > 0)

  00186	83 7d f8 00	 cmp	 DWORD PTR _i$[ebp], 0
  0018a	76 1e		 jbe	 SHORT $LN9@toStringTr

; 323  : 			{
; 324  : 				string->append8(string, " ");

  0018c	8b f4		 mov	 esi, esp
  0018e	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5@
  00193	8b 55 fc	 mov	 edx, DWORD PTR _string$[ebp]
  00196	52		 push	 edx
  00197	8b 45 fc	 mov	 eax, DWORD PTR _string$[ebp]
  0019a	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0019d	ff d1		 call	 ecx
  0019f	83 c4 08	 add	 esp, 8
  001a2	3b f4		 cmp	 esi, esp
  001a4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001a9	90		 npad	 1
$LN9@toStringTr:

; 325  : 			}
; 326  : 			string->appendS(string, t->toStringTree(t));

  001aa	8b f4		 mov	 esi, esp
  001ac	8b 55 f0	 mov	 edx, DWORD PTR _t$[ebp]
  001af	52		 push	 edx
  001b0	8b 45 f0	 mov	 eax, DWORD PTR _t$[ebp]
  001b3	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  001b6	ff d1		 call	 ecx
  001b8	83 c4 04	 add	 esp, 4
  001bb	3b f4		 cmp	 esi, esp
  001bd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001c2	8b f4		 mov	 esi, esp
  001c4	50		 push	 eax
  001c5	8b 55 fc	 mov	 edx, DWORD PTR _string$[ebp]
  001c8	52		 push	 edx
  001c9	8b 45 fc	 mov	 eax, DWORD PTR _string$[ebp]
  001cc	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  001cf	ff d1		 call	 ecx
  001d1	83 c4 08	 add	 esp, 8
  001d4	3b f4		 cmp	 esi, esp
  001d6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001db	90		 npad	 1

; 327  : 		}

  001dc	e9 68 ff ff ff	 jmp	 $LN2@toStringTr
$LN3@toStringTr:

; 328  : 	}
; 329  : 	if	(tree->isNilNode(tree) == ANTLR3_FALSE)

  001e1	8b f4		 mov	 esi, esp
  001e3	8b 55 08	 mov	 edx, DWORD PTR _tree$[ebp]
  001e6	52		 push	 edx
  001e7	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  001ea	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  001ed	ff d1		 call	 ecx
  001ef	83 c4 04	 add	 esp, 4
  001f2	3b f4		 cmp	 esi, esp
  001f4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001f9	0f b6 d0	 movzx	 edx, al
  001fc	85 d2		 test	 edx, edx
  001fe	75 1e		 jne	 SHORT $LN10@toStringTr

; 330  : 	{
; 331  : 		string->append8(string,")");

  00200	8b f4		 mov	 esi, esp
  00202	68 00 00 00 00	 push	 OFFSET ??_C@_01PKGAHCOL@?$CJ@
  00207	8b 45 fc	 mov	 eax, DWORD PTR _string$[ebp]
  0020a	50		 push	 eax
  0020b	8b 4d fc	 mov	 ecx, DWORD PTR _string$[ebp]
  0020e	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00211	ff d2		 call	 edx
  00213	83 c4 08	 add	 esp, 8
  00216	3b f4		 cmp	 esi, esp
  00218	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0021d	90		 npad	 1
$LN10@toStringTr:

; 332  : 	}
; 333  : 
; 334  : 	return  string;

  0021e	8b 45 fc	 mov	 eax, DWORD PTR _string$[ebp]
$LN1@toStringTr:

; 335  : }

  00221	5e		 pop	 esi
  00222	83 c4 10	 add	 esp, 16			; 00000010H
  00225	3b ec		 cmp	 ebp, esp
  00227	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0022c	8b e5		 mov	 esp, ebp
  0022e	5d		 pop	 ebp
  0022f	c3		 ret	 0
_toStringTree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3basetree.c
;	COMDAT _dupTree
_TEXT	SEGMENT
_newNode$1 = -20					; size = 4
_t$2 = -16						; size = 4
_s$ = -12						; size = 4
_i$ = -8						; size = 4
_newTree$ = -4						; size = 4
_tree$ = 8						; size = 4
_dupTree PROC						; COMDAT

; 262  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0000f	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00012	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00015	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00018	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 263  : 	pANTLR3_BASE_TREE	newTree;
; 264  : 	ANTLR3_UINT32	i;
; 265  : 	ANTLR3_UINT32	s;
; 266  : 
; 267  : 	newTree = (pANTLR3_BASE_TREE)tree->dupNode	    (tree);

  0001b	8b f4		 mov	 esi, esp
  0001d	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  00020	50		 push	 eax
  00021	8b 4d 08	 mov	 ecx, DWORD PTR _tree$[ebp]
  00024	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00027	ff d2		 call	 edx
  00029	83 c4 04	 add	 esp, 4
  0002c	3b f4		 cmp	 esi, esp
  0002e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00033	89 45 fc	 mov	 DWORD PTR _newTree$[ebp], eax

; 268  : 
; 269  : 	if	(tree->children != NULL)

  00036	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  00039	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0003d	0f 84 a6 00 00
	00		 je	 $LN3@dupTree

; 270  : 	{
; 271  : 		s	    = tree->children->size  (tree->children);

  00043	8b f4		 mov	 esi, esp
  00045	8b 4d 08	 mov	 ecx, DWORD PTR _tree$[ebp]
  00048	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0004b	52		 push	 edx
  0004c	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  0004f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00052	8b 91 b0 00 00
	00		 mov	 edx, DWORD PTR [ecx+176]
  00058	ff d2		 call	 edx
  0005a	83 c4 04	 add	 esp, 4
  0005d	3b f4		 cmp	 esi, esp
  0005f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00064	89 45 f4	 mov	 DWORD PTR _s$[ebp], eax

; 272  : 
; 273  : 		for	(i = 0; i < s; i++)

  00067	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0006e	eb 09		 jmp	 SHORT $LN4@dupTree
$LN2@dupTree:
  00070	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00073	83 c0 01	 add	 eax, 1
  00076	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@dupTree:
  00079	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  0007c	3b 4d f4	 cmp	 ecx, DWORD PTR _s$[ebp]
  0007f	73 68		 jae	 SHORT $LN3@dupTree

; 274  : 		{
; 275  : 			pANTLR3_BASE_TREE    t;
; 276  : 			pANTLR3_BASE_TREE    newNode;
; 277  : 
; 278  : 			t   = (pANTLR3_BASE_TREE) tree->children->get(tree->children, i);

  00081	8b f4		 mov	 esi, esp
  00083	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00086	52		 push	 edx
  00087	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  0008a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0008d	51		 push	 ecx
  0008e	8b 55 08	 mov	 edx, DWORD PTR _tree$[ebp]
  00091	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00094	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [eax+152]
  0009a	ff d1		 call	 ecx
  0009c	83 c4 08	 add	 esp, 8
  0009f	3b f4		 cmp	 esi, esp
  000a1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a6	89 45 f0	 mov	 DWORD PTR _t$2[ebp], eax

; 279  : 
; 280  : 			if  (t!= NULL)

  000a9	83 7d f0 00	 cmp	 DWORD PTR _t$2[ebp], 0
  000ad	74 38		 je	 SHORT $LN6@dupTree

; 281  : 			{
; 282  : 				newNode	    = (pANTLR3_BASE_TREE)t->dupTree(t);

  000af	8b f4		 mov	 esi, esp
  000b1	8b 55 f0	 mov	 edx, DWORD PTR _t$2[ebp]
  000b4	52		 push	 edx
  000b5	8b 45 f0	 mov	 eax, DWORD PTR _t$2[ebp]
  000b8	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  000bb	ff d1		 call	 ecx
  000bd	83 c4 04	 add	 esp, 4
  000c0	3b f4		 cmp	 esi, esp
  000c2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c7	89 45 ec	 mov	 DWORD PTR _newNode$1[ebp], eax

; 283  : 				newTree->addChild(newTree, newNode);

  000ca	8b f4		 mov	 esi, esp
  000cc	8b 55 ec	 mov	 edx, DWORD PTR _newNode$1[ebp]
  000cf	52		 push	 edx
  000d0	8b 45 fc	 mov	 eax, DWORD PTR _newTree$[ebp]
  000d3	50		 push	 eax
  000d4	8b 4d fc	 mov	 ecx, DWORD PTR _newTree$[ebp]
  000d7	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  000da	ff d2		 call	 edx
  000dc	83 c4 08	 add	 esp, 8
  000df	3b f4		 cmp	 esi, esp
  000e1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e6	90		 npad	 1
$LN6@dupTree:

; 284  : 			}
; 285  : 		}

  000e7	eb 87		 jmp	 SHORT $LN2@dupTree
$LN3@dupTree:

; 286  : 	}
; 287  : 
; 288  : 	return newTree;

  000e9	8b 45 fc	 mov	 eax, DWORD PTR _newTree$[ebp]

; 289  : }

  000ec	5e		 pop	 esi
  000ed	83 c4 14	 add	 esp, 20			; 00000014H
  000f0	3b ec		 cmp	 ebp, esp
  000f2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f7	8b e5		 mov	 esp, ebp
  000f9	5d		 pop	 ebp
  000fa	c3		 ret	 0
_dupTree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3basetree.c
;	COMDAT _deleteChild
_TEXT	SEGMENT
_tree$ = 8						; size = 4
_i$ = 12						; size = 4
_deleteChild PROC					; COMDAT

; 251  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 252  : 	if	( tree->children == NULL)

  00004	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  00007	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0000b	75 04		 jne	 SHORT $LN2@deleteChil

; 253  : 	{
; 254  : 		return	NULL;

  0000d	33 c0		 xor	 eax, eax
  0000f	eb 25		 jmp	 SHORT $LN1@deleteChil
$LN2@deleteChil:

; 255  : 	}
; 256  : 
; 257  : 	return  tree->children->remove(tree->children, i);

  00011	8b f4		 mov	 esi, esp
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR _i$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 08	 mov	 edx, DWORD PTR _tree$[ebp]
  0001a	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0001d	50		 push	 eax
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR _tree$[ebp]
  00021	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00024	8b 82 9c 00 00
	00		 mov	 eax, DWORD PTR [edx+156]
  0002a	ff d0		 call	 eax
  0002c	83 c4 08	 add	 esp, 8
  0002f	3b f4		 cmp	 esi, esp
  00031	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@deleteChil:

; 258  : }

  00036	5e		 pop	 esi
  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
_deleteChild ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3basetree.c
;	COMDAT _setChild
_TEXT	SEGMENT
_tree$ = 8						; size = 4
_i$ = 12						; size = 4
_child$ = 16						; size = 4
_setChild PROC						; COMDAT

; 241  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 242  : 	if	(tree->children == NULL)

  00004	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  00007	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0000b	75 19		 jne	 SHORT $LN2@setChild

; 243  : 	{
; 244  : 		tree->createChildrenList(tree);

  0000d	8b f4		 mov	 esi, esp
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _tree$[ebp]
  00012	51		 push	 ecx
  00013	8b 55 08	 mov	 edx, DWORD PTR _tree$[ebp]
  00016	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00019	ff d0		 call	 eax
  0001b	83 c4 04	 add	 esp, 4
  0001e	3b f4		 cmp	 esi, esp
  00020	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00025	90		 npad	 1
$LN2@setChild:

; 245  : 	}
; 246  : 	tree->children->set(tree->children, i, child, NULL, ANTLR3_FALSE);

  00026	8b f4		 mov	 esi, esp
  00028	6a 00		 push	 0
  0002a	6a 00		 push	 0
  0002c	8b 4d 10	 mov	 ecx, DWORD PTR _child$[ebp]
  0002f	51		 push	 ecx
  00030	8b 55 0c	 mov	 edx, DWORD PTR _i$[ebp]
  00033	52		 push	 edx
  00034	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  00037	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0003a	51		 push	 ecx
  0003b	8b 55 08	 mov	 edx, DWORD PTR _tree$[ebp]
  0003e	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00041	8b 88 ac 00 00
	00		 mov	 ecx, DWORD PTR [eax+172]
  00047	ff d1		 call	 ecx
  00049	83 c4 14	 add	 esp, 20			; 00000014H
  0004c	3b f4		 cmp	 esi, esp
  0004e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00053	90		 npad	 1

; 247  : }

  00054	5e		 pop	 esi
  00055	3b ec		 cmp	 ebp, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
_setChild ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3basetree.c
;	COMDAT _freshenPACIndexes
_TEXT	SEGMENT
_child$1 = -12						; size = 4
_c$ = -8						; size = 4
_count$ = -4						; size = 4
_tree$ = 8						; size = 4
_offset$ = 12						; size = 4
_freshenPACIndexes PROC					; COMDAT

; 475  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000e	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00015	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 476  : 	ANTLR3_UINT32	count;
; 477  : 	ANTLR3_UINT32	c;
; 478  : 
; 479  : 	count	= tree->getChildCount(tree);		// How many children do we have 

  0001c	8b f4		 mov	 esi, esp
  0001e	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 08	 mov	 ecx, DWORD PTR _tree$[ebp]
  00025	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  00028	ff d2		 call	 edx
  0002a	83 c4 04	 add	 esp, 4
  0002d	3b f4		 cmp	 esi, esp
  0002f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00034	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax

; 480  : 
; 481  : 	// Loop from the supplied index and set the indexes and parent
; 482  : 	//
; 483  : 	for	(c = offset; c < count; c++)

  00037	8b 45 0c	 mov	 eax, DWORD PTR _offset$[ebp]
  0003a	89 45 f8	 mov	 DWORD PTR _c$[ebp], eax
  0003d	eb 09		 jmp	 SHORT $LN4@freshenPAC
$LN2@freshenPAC:
  0003f	8b 4d f8	 mov	 ecx, DWORD PTR _c$[ebp]
  00042	83 c1 01	 add	 ecx, 1
  00045	89 4d f8	 mov	 DWORD PTR _c$[ebp], ecx
$LN4@freshenPAC:
  00048	8b 55 f8	 mov	 edx, DWORD PTR _c$[ebp]
  0004b	3b 55 fc	 cmp	 edx, DWORD PTR _count$[ebp]
  0004e	73 5a		 jae	 SHORT $LN3@freshenPAC

; 484  : 	{
; 485  : 		pANTLR3_BASE_TREE	child;
; 486  : 
; 487  : 		child = (pANTLR3_BASE_TREE)tree->getChild(tree, c);

  00050	8b f4		 mov	 esi, esp
  00052	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  00055	50		 push	 eax
  00056	8b 4d 08	 mov	 ecx, DWORD PTR _tree$[ebp]
  00059	51		 push	 ecx
  0005a	8b 55 08	 mov	 edx, DWORD PTR _tree$[ebp]
  0005d	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  00060	ff d0		 call	 eax
  00062	83 c4 08	 add	 esp, 8
  00065	3b f4		 cmp	 esi, esp
  00067	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006c	89 45 f4	 mov	 DWORD PTR _child$1[ebp], eax

; 488  : 
; 489  : 		child->setChildIndex(child, c);

  0006f	8b f4		 mov	 esi, esp
  00071	8b 4d f8	 mov	 ecx, DWORD PTR _c$[ebp]
  00074	51		 push	 ecx
  00075	8b 55 f4	 mov	 edx, DWORD PTR _child$1[ebp]
  00078	52		 push	 edx
  00079	8b 45 f4	 mov	 eax, DWORD PTR _child$1[ebp]
  0007c	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  0007f	ff d1		 call	 ecx
  00081	83 c4 08	 add	 esp, 8
  00084	3b f4		 cmp	 esi, esp
  00086	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 490  : 		child->setParent(child, tree);

  0008b	8b f4		 mov	 esi, esp
  0008d	8b 55 08	 mov	 edx, DWORD PTR _tree$[ebp]
  00090	52		 push	 edx
  00091	8b 45 f4	 mov	 eax, DWORD PTR _child$1[ebp]
  00094	50		 push	 eax
  00095	8b 4d f4	 mov	 ecx, DWORD PTR _child$1[ebp]
  00098	8b 51 4c	 mov	 edx, DWORD PTR [ecx+76]
  0009b	ff d2		 call	 edx
  0009d	83 c4 08	 add	 esp, 8
  000a0	3b f4		 cmp	 esi, esp
  000a2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a7	90		 npad	 1

; 491  : 	}

  000a8	eb 95		 jmp	 SHORT $LN2@freshenPAC
$LN3@freshenPAC:

; 492  : }

  000aa	5e		 pop	 esi
  000ab	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ae	3b ec		 cmp	 ebp, esp
  000b0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b5	8b e5		 mov	 esp, ebp
  000b7	5d		 pop	 ebp
  000b8	c3		 ret	 0
_freshenPACIndexes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3basetree.c
;	COMDAT _freshenPACIndexesAll
_TEXT	SEGMENT
_tree$ = 8						; size = 4
_freshenPACIndexesAll PROC				; COMDAT

; 466  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 467  : 	tree->freshenPACIndexes(tree, 0);

  00004	8b f4		 mov	 esi, esp
  00006	6a 00		 push	 0
  00008	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _tree$[ebp]
  0000f	8b 51 74	 mov	 edx, DWORD PTR [ecx+116]
  00012	ff d2		 call	 edx
  00014	83 c4 08	 add	 esp, 8
  00017	3b f4		 cmp	 esi, esp
  00019	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001e	90		 npad	 1

; 468  : }

  0001f	5e		 pop	 esi
  00020	3b ec		 cmp	 ebp, esp
  00022	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
_freshenPACIndexesAll ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3basetree.c
;	COMDAT _replaceChildren
_TEXT	SEGMENT
_numToInsert$1 = -44					; size = 4
_indexToDelete$2 = -40					; size = 4
_child$3 = -36						; size = 4
_freeNewChildren$ = -29					; size = 1
_newChildren$ = -28					; size = 4
_j$ = -24						; size = 4
_i$ = -20						; size = 4
_delta$ = -16						; size = 4
_numNewChildren$ = -12					; size = 4
_replacingWithHowMany$ = -8				; size = 4
_replacingHowMany$ = -4					; size = 4
_parent$ = 8						; size = 4
_startChildIndex$ = 12					; size = 4
_stopChildIndex$ = 16					; size = 4
_newTree$ = 20						; size = 4
_replaceChildren PROC					; COMDAT

; 344  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8d 7d d4	 lea	 edi, DWORD PTR [ebp-44]
  0000b	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd

; 345  : 	ANTLR3_INT32	replacingHowMany;		// How many nodes will go away
; 346  : 	ANTLR3_INT32	replacingWithHowMany;	// How many nodes will replace them
; 347  : 	ANTLR3_INT32	numNewChildren;			// Tracking variable
; 348  : 	ANTLR3_INT32	delta;					// Difference in new vs existing count
; 349  : 
; 350  : 	ANTLR3_INT32	i;
; 351  : 	ANTLR3_INT32	j;
; 352  : 
; 353  : 	pANTLR3_VECTOR	newChildren;			// Iterator for whatever we are going to add in
; 354  : 	ANTLR3_BOOLEAN	freeNewChildren;		// Whether we created the iterator locally or reused it
; 355  : 
; 356  : 	if	(parent->children == NULL)

  00017	8b 45 08	 mov	 eax, DWORD PTR _parent$[ebp]
  0001a	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0001e	75 43		 jne	 SHORT $LN17@replaceChi

; 357  : 	{
; 358  : 		ANTLR3_FPRINTF(stderr, "replaceChildren call: Indexes are invalid; no children in list for %s", parent->getText(parent)->chars);

  00020	8b f4		 mov	 esi, esp
  00022	8b 4d 08	 mov	 ecx, DWORD PTR _parent$[ebp]
  00025	51		 push	 ecx
  00026	8b 55 08	 mov	 edx, DWORD PTR _parent$[ebp]
  00029	8b 42 5c	 mov	 eax, DWORD PTR [edx+92]
  0002c	ff d0		 call	 eax
  0002e	83 c4 04	 add	 esp, 4
  00031	3b f4		 cmp	 esi, esp
  00033	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00038	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003b	51		 push	 ecx
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_0EG@NBNMEDOE@replaceChildren?5call?3?5Indexes?5a@
  00041	8b f4		 mov	 esi, esp
  00043	6a 02		 push	 2
  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  0004b	83 c4 04	 add	 esp, 4
  0004e	3b f4		 cmp	 esi, esp
  00050	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00055	50		 push	 eax
  00056	e8 00 00 00 00	 call	 _fprintf
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 359  : 		return;

  0005e	e9 c6 03 00 00	 jmp	 $LN25@replaceChi
$LN17@replaceChi:

; 360  : 	}
; 361  : 
; 362  : 	// Either use the existing list of children in the supplied nil node, or build a vector of the
; 363  : 	// tree we were given if it is not a nil node, then we treat both situations exactly the same
; 364  : 	//
; 365  : 	if	(newTree->isNilNode(newTree))

  00063	8b f4		 mov	 esi, esp
  00065	8b 55 14	 mov	 edx, DWORD PTR _newTree$[ebp]
  00068	52		 push	 edx
  00069	8b 45 14	 mov	 eax, DWORD PTR _newTree$[ebp]
  0006c	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  0006f	ff d1		 call	 ecx
  00071	83 c4 04	 add	 esp, 4
  00074	3b f4		 cmp	 esi, esp
  00076	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007b	0f b6 d0	 movzx	 edx, al
  0007e	85 d2		 test	 edx, edx
  00080	74 0f		 je	 SHORT $LN18@replaceChi

; 366  : 	{
; 367  : 		newChildren = newTree->children;

  00082	8b 45 14	 mov	 eax, DWORD PTR _newTree$[ebp]
  00085	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00088	89 4d e4	 mov	 DWORD PTR _newChildren$[ebp], ecx

; 368  : 		freeNewChildren = ANTLR3_FALSE;		// We must NO free this memory

  0008b	c6 45 e3 00	 mov	 BYTE PTR _freeNewChildren$[ebp], 0

; 369  : 	}

  0008f	eb 6c		 jmp	 SHORT $LN19@replaceChi
$LN18@replaceChi:

; 370  : 	else
; 371  : 	{
; 372  : 		newChildren = antlr3VectorNew(1);

  00091	6a 01		 push	 1
  00093	e8 00 00 00 00	 call	 _antlr3VectorNew
  00098	83 c4 04	 add	 esp, 4
  0009b	89 45 e4	 mov	 DWORD PTR _newChildren$[ebp], eax

; 373  : 		if	(newChildren == NULL)

  0009e	83 7d e4 00	 cmp	 DWORD PTR _newChildren$[ebp], 0
  000a2	75 34		 jne	 SHORT $LN20@replaceChi

; 374  : 		{
; 375  : 			ANTLR3_FPRINTF(stderr, "replaceChildren: out of memory!!");

  000a4	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@IIIEFFAH@replaceChildren?3?5out?5of?5memory?$CB@
  000a9	8b f4		 mov	 esi, esp
  000ab	6a 02		 push	 2
  000ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  000b3	83 c4 04	 add	 esp, 4
  000b6	3b f4		 cmp	 esi, esp
  000b8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bd	50		 push	 eax
  000be	e8 00 00 00 00	 call	 _fprintf
  000c3	83 c4 08	 add	 esp, 8

; 376  : 			exit(1);

  000c6	8b f4		 mov	 esi, esp
  000c8	6a 01		 push	 1
  000ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
  000d0	3b f4		 cmp	 esi, esp
  000d2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d7	90		 npad	 1
$LN20@replaceChi:

; 377  : 		}
; 378  : 		newChildren->add(newChildren, (void *)newTree, NULL);

  000d8	8b f4		 mov	 esi, esp
  000da	6a 00		 push	 0
  000dc	8b 55 14	 mov	 edx, DWORD PTR _newTree$[ebp]
  000df	52		 push	 edx
  000e0	8b 45 e4	 mov	 eax, DWORD PTR _newChildren$[ebp]
  000e3	50		 push	 eax
  000e4	8b 4d e4	 mov	 ecx, DWORD PTR _newChildren$[ebp]
  000e7	8b 91 a8 00 00
	00		 mov	 edx, DWORD PTR [ecx+168]
  000ed	ff d2		 call	 edx
  000ef	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f2	3b f4		 cmp	 esi, esp
  000f4	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 379  : 
; 380  : 		freeNewChildren = ANTLR3_TRUE;		// We must free this memory

  000f9	c6 45 e3 01	 mov	 BYTE PTR _freeNewChildren$[ebp], 1
$LN19@replaceChi:

; 381  : 	}
; 382  : 
; 383  : 	// Initialize
; 384  : 	//
; 385  : 	replacingHowMany		= stopChildIndex - startChildIndex + 1;

  000fd	8b 45 10	 mov	 eax, DWORD PTR _stopChildIndex$[ebp]
  00100	2b 45 0c	 sub	 eax, DWORD PTR _startChildIndex$[ebp]
  00103	83 c0 01	 add	 eax, 1
  00106	89 45 fc	 mov	 DWORD PTR _replacingHowMany$[ebp], eax

; 386  : 	replacingWithHowMany	= newChildren->size(newChildren);

  00109	8b f4		 mov	 esi, esp
  0010b	8b 4d e4	 mov	 ecx, DWORD PTR _newChildren$[ebp]
  0010e	51		 push	 ecx
  0010f	8b 55 e4	 mov	 edx, DWORD PTR _newChildren$[ebp]
  00112	8b 82 b0 00 00
	00		 mov	 eax, DWORD PTR [edx+176]
  00118	ff d0		 call	 eax
  0011a	83 c4 04	 add	 esp, 4
  0011d	3b f4		 cmp	 esi, esp
  0011f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00124	89 45 f8	 mov	 DWORD PTR _replacingWithHowMany$[ebp], eax

; 387  : 	delta					= replacingHowMany - replacingWithHowMany;

  00127	8b 4d fc	 mov	 ecx, DWORD PTR _replacingHowMany$[ebp]
  0012a	2b 4d f8	 sub	 ecx, DWORD PTR _replacingWithHowMany$[ebp]
  0012d	89 4d f0	 mov	 DWORD PTR _delta$[ebp], ecx

; 388  : 	numNewChildren			= newChildren->size(newChildren);

  00130	8b f4		 mov	 esi, esp
  00132	8b 55 e4	 mov	 edx, DWORD PTR _newChildren$[ebp]
  00135	52		 push	 edx
  00136	8b 45 e4	 mov	 eax, DWORD PTR _newChildren$[ebp]
  00139	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  0013f	ff d1		 call	 ecx
  00141	83 c4 04	 add	 esp, 4
  00144	3b f4		 cmp	 esi, esp
  00146	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0014b	89 45 f4	 mov	 DWORD PTR _numNewChildren$[ebp], eax

; 389  : 
; 390  : 	// If it is the same number of nodes, then do a direct replacement
; 391  : 	//
; 392  : 	if	(delta == 0)

  0014e	83 7d f0 00	 cmp	 DWORD PTR _delta$[ebp], 0
  00152	0f 85 b6 00 00
	00		 jne	 $LN21@replaceChi

; 393  : 	{
; 394  : 		pANTLR3_BASE_TREE	child;
; 395  : 
; 396  : 		// Same number of nodes
; 397  : 		//
; 398  : 		j	= 0;

  00158	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0

; 399  : 		for	(i = startChildIndex; i <= stopChildIndex; i++)

  0015f	8b 55 0c	 mov	 edx, DWORD PTR _startChildIndex$[ebp]
  00162	89 55 ec	 mov	 DWORD PTR _i$[ebp], edx
  00165	eb 09		 jmp	 SHORT $LN4@replaceChi
$LN2@replaceChi:
  00167	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  0016a	83 c0 01	 add	 eax, 1
  0016d	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax
$LN4@replaceChi:
  00170	8b 4d ec	 mov	 ecx, DWORD PTR _i$[ebp]
  00173	3b 4d 10	 cmp	 ecx, DWORD PTR _stopChildIndex$[ebp]
  00176	0f 8f 8d 00 00
	00		 jg	 $LN3@replaceChi

; 400  : 		{
; 401  : 			child = (pANTLR3_BASE_TREE) newChildren->get(newChildren, j);

  0017c	8b f4		 mov	 esi, esp
  0017e	8b 55 e8	 mov	 edx, DWORD PTR _j$[ebp]
  00181	52		 push	 edx
  00182	8b 45 e4	 mov	 eax, DWORD PTR _newChildren$[ebp]
  00185	50		 push	 eax
  00186	8b 4d e4	 mov	 ecx, DWORD PTR _newChildren$[ebp]
  00189	8b 91 98 00 00
	00		 mov	 edx, DWORD PTR [ecx+152]
  0018f	ff d2		 call	 edx
  00191	83 c4 08	 add	 esp, 8
  00194	3b f4		 cmp	 esi, esp
  00196	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0019b	89 45 dc	 mov	 DWORD PTR _child$3[ebp], eax

; 402  : 			parent->children->set(parent->children, i, child, NULL, ANTLR3_FALSE);

  0019e	8b f4		 mov	 esi, esp
  001a0	6a 00		 push	 0
  001a2	6a 00		 push	 0
  001a4	8b 45 dc	 mov	 eax, DWORD PTR _child$3[ebp]
  001a7	50		 push	 eax
  001a8	8b 4d ec	 mov	 ecx, DWORD PTR _i$[ebp]
  001ab	51		 push	 ecx
  001ac	8b 55 08	 mov	 edx, DWORD PTR _parent$[ebp]
  001af	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  001b2	50		 push	 eax
  001b3	8b 4d 08	 mov	 ecx, DWORD PTR _parent$[ebp]
  001b6	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  001b9	8b 82 ac 00 00
	00		 mov	 eax, DWORD PTR [edx+172]
  001bf	ff d0		 call	 eax
  001c1	83 c4 14	 add	 esp, 20			; 00000014H
  001c4	3b f4		 cmp	 esi, esp
  001c6	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 403  : 			child->setParent(child, parent);

  001cb	8b f4		 mov	 esi, esp
  001cd	8b 4d 08	 mov	 ecx, DWORD PTR _parent$[ebp]
  001d0	51		 push	 ecx
  001d1	8b 55 dc	 mov	 edx, DWORD PTR _child$3[ebp]
  001d4	52		 push	 edx
  001d5	8b 45 dc	 mov	 eax, DWORD PTR _child$3[ebp]
  001d8	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  001db	ff d1		 call	 ecx
  001dd	83 c4 08	 add	 esp, 8
  001e0	3b f4		 cmp	 esi, esp
  001e2	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 404  : 			child->setChildIndex(child, i);

  001e7	8b f4		 mov	 esi, esp
  001e9	8b 55 ec	 mov	 edx, DWORD PTR _i$[ebp]
  001ec	52		 push	 edx
  001ed	8b 45 dc	 mov	 eax, DWORD PTR _child$3[ebp]
  001f0	50		 push	 eax
  001f1	8b 4d dc	 mov	 ecx, DWORD PTR _child$3[ebp]
  001f4	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  001f7	ff d2		 call	 edx
  001f9	83 c4 08	 add	 esp, 8
  001fc	3b f4		 cmp	 esi, esp
  001fe	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00203	90		 npad	 1

; 405  : 		}

  00204	e9 5e ff ff ff	 jmp	 $LN2@replaceChi
$LN3@replaceChi:

; 406  : 	}

  00209	e9 cd 01 00 00	 jmp	 $LN24@replaceChi
$LN21@replaceChi:

; 407  : 	else if (delta > 0)

  0020e	83 7d f0 00	 cmp	 DWORD PTR _delta$[ebp], 0
  00212	0f 8e d5 00 00
	00		 jle	 $LN23@replaceChi

; 408  : 	{
; 409  : 		ANTLR3_UINT32	indexToDelete;
; 410  : 
; 411  : 		// Less nodes than there were before
; 412  : 		// reuse what we have then delete the rest
; 413  : 		//
; 414  : 		for	(j = 0; j < numNewChildren; j++)

  00218	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  0021f	eb 09		 jmp	 SHORT $LN7@replaceChi
$LN5@replaceChi:
  00221	8b 45 e8	 mov	 eax, DWORD PTR _j$[ebp]
  00224	83 c0 01	 add	 eax, 1
  00227	89 45 e8	 mov	 DWORD PTR _j$[ebp], eax
$LN7@replaceChi:
  0022a	8b 4d e8	 mov	 ecx, DWORD PTR _j$[ebp]
  0022d	3b 4d f4	 cmp	 ecx, DWORD PTR _numNewChildren$[ebp]
  00230	7d 4f		 jge	 SHORT $LN6@replaceChi

; 415  : 		{
; 416  : 			parent->children->set(parent->children, startChildIndex + j, newChildren->get(newChildren, j), NULL, ANTLR3_FALSE);

  00232	8b f4		 mov	 esi, esp
  00234	6a 00		 push	 0
  00236	6a 00		 push	 0
  00238	8b fc		 mov	 edi, esp
  0023a	8b 55 e8	 mov	 edx, DWORD PTR _j$[ebp]
  0023d	52		 push	 edx
  0023e	8b 45 e4	 mov	 eax, DWORD PTR _newChildren$[ebp]
  00241	50		 push	 eax
  00242	8b 4d e4	 mov	 ecx, DWORD PTR _newChildren$[ebp]
  00245	8b 91 98 00 00
	00		 mov	 edx, DWORD PTR [ecx+152]
  0024b	ff d2		 call	 edx
  0024d	83 c4 08	 add	 esp, 8
  00250	3b fc		 cmp	 edi, esp
  00252	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00257	50		 push	 eax
  00258	8b 45 0c	 mov	 eax, DWORD PTR _startChildIndex$[ebp]
  0025b	03 45 e8	 add	 eax, DWORD PTR _j$[ebp]
  0025e	50		 push	 eax
  0025f	8b 4d 08	 mov	 ecx, DWORD PTR _parent$[ebp]
  00262	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00265	52		 push	 edx
  00266	8b 45 08	 mov	 eax, DWORD PTR _parent$[ebp]
  00269	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0026c	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR [ecx+172]
  00272	ff d2		 call	 edx
  00274	83 c4 14	 add	 esp, 20			; 00000014H
  00277	3b f4		 cmp	 esi, esp
  00279	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0027e	90		 npad	 1

; 417  : 		}

  0027f	eb a0		 jmp	 SHORT $LN5@replaceChi
$LN6@replaceChi:

; 418  : 
; 419  : 		// We just delete the same index position until done
; 420  : 		//
; 421  : 		indexToDelete = startChildIndex + numNewChildren;

  00281	8b 45 0c	 mov	 eax, DWORD PTR _startChildIndex$[ebp]
  00284	03 45 f4	 add	 eax, DWORD PTR _numNewChildren$[ebp]
  00287	89 45 d8	 mov	 DWORD PTR _indexToDelete$2[ebp], eax

; 422  : 
; 423  : 		for	(j = indexToDelete; j <= (ANTLR3_INT32)stopChildIndex; j++)

  0028a	8b 4d d8	 mov	 ecx, DWORD PTR _indexToDelete$2[ebp]
  0028d	89 4d e8	 mov	 DWORD PTR _j$[ebp], ecx
  00290	eb 09		 jmp	 SHORT $LN10@replaceChi
$LN8@replaceChi:
  00292	8b 55 e8	 mov	 edx, DWORD PTR _j$[ebp]
  00295	83 c2 01	 add	 edx, 1
  00298	89 55 e8	 mov	 DWORD PTR _j$[ebp], edx
$LN10@replaceChi:
  0029b	8b 45 e8	 mov	 eax, DWORD PTR _j$[ebp]
  0029e	3b 45 10	 cmp	 eax, DWORD PTR _stopChildIndex$[ebp]
  002a1	7f 28		 jg	 SHORT $LN9@replaceChi

; 424  : 		{
; 425  : 			parent->children->remove(parent->children, indexToDelete);

  002a3	8b f4		 mov	 esi, esp
  002a5	8b 4d d8	 mov	 ecx, DWORD PTR _indexToDelete$2[ebp]
  002a8	51		 push	 ecx
  002a9	8b 55 08	 mov	 edx, DWORD PTR _parent$[ebp]
  002ac	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  002af	50		 push	 eax
  002b0	8b 4d 08	 mov	 ecx, DWORD PTR _parent$[ebp]
  002b3	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  002b6	8b 82 9c 00 00
	00		 mov	 eax, DWORD PTR [edx+156]
  002bc	ff d0		 call	 eax
  002be	83 c4 08	 add	 esp, 8
  002c1	3b f4		 cmp	 esi, esp
  002c3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002c8	90		 npad	 1

; 426  : 		}

  002c9	eb c7		 jmp	 SHORT $LN8@replaceChi
$LN9@replaceChi:

; 427  : 
; 428  : 		parent->freshenPACIndexes(parent, startChildIndex);

  002cb	8b f4		 mov	 esi, esp
  002cd	8b 4d 0c	 mov	 ecx, DWORD PTR _startChildIndex$[ebp]
  002d0	51		 push	 ecx
  002d1	8b 55 08	 mov	 edx, DWORD PTR _parent$[ebp]
  002d4	52		 push	 edx
  002d5	8b 45 08	 mov	 eax, DWORD PTR _parent$[ebp]
  002d8	8b 48 74	 mov	 ecx, DWORD PTR [eax+116]
  002db	ff d1		 call	 ecx
  002dd	83 c4 08	 add	 esp, 8
  002e0	3b f4		 cmp	 esi, esp
  002e2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002e7	90		 npad	 1

; 429  : 	}

  002e8	e9 ee 00 00 00	 jmp	 $LN24@replaceChi
$LN23@replaceChi:

; 430  : 	else
; 431  : 	{
; 432  : 		ANTLR3_UINT32 numToInsert;
; 433  : 
; 434  : 		// More nodes than there were before
; 435  : 		// Use what we can, then start adding
; 436  : 		//
; 437  : 		for	(j = 0; j < replacingHowMany; j++)

  002ed	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  002f4	eb 09		 jmp	 SHORT $LN13@replaceChi
$LN11@replaceChi:
  002f6	8b 55 e8	 mov	 edx, DWORD PTR _j$[ebp]
  002f9	83 c2 01	 add	 edx, 1
  002fc	89 55 e8	 mov	 DWORD PTR _j$[ebp], edx
$LN13@replaceChi:
  002ff	8b 45 e8	 mov	 eax, DWORD PTR _j$[ebp]
  00302	3b 45 fc	 cmp	 eax, DWORD PTR _replacingHowMany$[ebp]
  00305	7d 4f		 jge	 SHORT $LN12@replaceChi

; 438  : 		{
; 439  : 			parent->children->set(parent->children, startChildIndex + j, newChildren->get(newChildren, j), NULL, ANTLR3_FALSE);

  00307	8b f4		 mov	 esi, esp
  00309	6a 00		 push	 0
  0030b	6a 00		 push	 0
  0030d	8b fc		 mov	 edi, esp
  0030f	8b 4d e8	 mov	 ecx, DWORD PTR _j$[ebp]
  00312	51		 push	 ecx
  00313	8b 55 e4	 mov	 edx, DWORD PTR _newChildren$[ebp]
  00316	52		 push	 edx
  00317	8b 45 e4	 mov	 eax, DWORD PTR _newChildren$[ebp]
  0031a	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [eax+152]
  00320	ff d1		 call	 ecx
  00322	83 c4 08	 add	 esp, 8
  00325	3b fc		 cmp	 edi, esp
  00327	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0032c	50		 push	 eax
  0032d	8b 55 0c	 mov	 edx, DWORD PTR _startChildIndex$[ebp]
  00330	03 55 e8	 add	 edx, DWORD PTR _j$[ebp]
  00333	52		 push	 edx
  00334	8b 45 08	 mov	 eax, DWORD PTR _parent$[ebp]
  00337	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0033a	51		 push	 ecx
  0033b	8b 55 08	 mov	 edx, DWORD PTR _parent$[ebp]
  0033e	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00341	8b 88 ac 00 00
	00		 mov	 ecx, DWORD PTR [eax+172]
  00347	ff d1		 call	 ecx
  00349	83 c4 14	 add	 esp, 20			; 00000014H
  0034c	3b f4		 cmp	 esi, esp
  0034e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00353	90		 npad	 1

; 440  : 		}

  00354	eb a0		 jmp	 SHORT $LN11@replaceChi
$LN12@replaceChi:

; 441  : 
; 442  : 		numToInsert = replacingWithHowMany - replacingHowMany;

  00356	8b 55 f8	 mov	 edx, DWORD PTR _replacingWithHowMany$[ebp]
  00359	2b 55 fc	 sub	 edx, DWORD PTR _replacingHowMany$[ebp]
  0035c	89 55 d4	 mov	 DWORD PTR _numToInsert$1[ebp], edx

; 443  : 
; 444  : 		for	(j = replacingHowMany; j < replacingWithHowMany; j++)

  0035f	8b 45 fc	 mov	 eax, DWORD PTR _replacingHowMany$[ebp]
  00362	89 45 e8	 mov	 DWORD PTR _j$[ebp], eax
  00365	eb 09		 jmp	 SHORT $LN16@replaceChi
$LN14@replaceChi:
  00367	8b 4d e8	 mov	 ecx, DWORD PTR _j$[ebp]
  0036a	83 c1 01	 add	 ecx, 1
  0036d	89 4d e8	 mov	 DWORD PTR _j$[ebp], ecx
$LN16@replaceChi:
  00370	8b 55 e8	 mov	 edx, DWORD PTR _j$[ebp]
  00373	3b 55 f8	 cmp	 edx, DWORD PTR _replacingWithHowMany$[ebp]
  00376	7d 46		 jge	 SHORT $LN15@replaceChi

; 445  : 		{
; 446  : 			parent->children->add(parent->children, newChildren->get(newChildren, j), NULL);

  00378	8b f4		 mov	 esi, esp
  0037a	6a 00		 push	 0
  0037c	8b fc		 mov	 edi, esp
  0037e	8b 45 e8	 mov	 eax, DWORD PTR _j$[ebp]
  00381	50		 push	 eax
  00382	8b 4d e4	 mov	 ecx, DWORD PTR _newChildren$[ebp]
  00385	51		 push	 ecx
  00386	8b 55 e4	 mov	 edx, DWORD PTR _newChildren$[ebp]
  00389	8b 82 98 00 00
	00		 mov	 eax, DWORD PTR [edx+152]
  0038f	ff d0		 call	 eax
  00391	83 c4 08	 add	 esp, 8
  00394	3b fc		 cmp	 edi, esp
  00396	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0039b	50		 push	 eax
  0039c	8b 4d 08	 mov	 ecx, DWORD PTR _parent$[ebp]
  0039f	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  003a2	52		 push	 edx
  003a3	8b 45 08	 mov	 eax, DWORD PTR _parent$[ebp]
  003a6	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  003a9	8b 91 a8 00 00
	00		 mov	 edx, DWORD PTR [ecx+168]
  003af	ff d2		 call	 edx
  003b1	83 c4 0c	 add	 esp, 12			; 0000000cH
  003b4	3b f4		 cmp	 esi, esp
  003b6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003bb	90		 npad	 1

; 447  : 		}

  003bc	eb a9		 jmp	 SHORT $LN14@replaceChi
$LN15@replaceChi:

; 448  : 
; 449  : 		parent->freshenPACIndexes(parent, startChildIndex);

  003be	8b f4		 mov	 esi, esp
  003c0	8b 45 0c	 mov	 eax, DWORD PTR _startChildIndex$[ebp]
  003c3	50		 push	 eax
  003c4	8b 4d 08	 mov	 ecx, DWORD PTR _parent$[ebp]
  003c7	51		 push	 ecx
  003c8	8b 55 08	 mov	 edx, DWORD PTR _parent$[ebp]
  003cb	8b 42 74	 mov	 eax, DWORD PTR [edx+116]
  003ce	ff d0		 call	 eax
  003d0	83 c4 08	 add	 esp, 8
  003d3	3b f4		 cmp	 esi, esp
  003d5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003da	90		 npad	 1
$LN24@replaceChi:

; 450  : 	}
; 451  : 
; 452  : 	if	(freeNewChildren == ANTLR3_TRUE)

  003db	0f b6 4d e3	 movzx	 ecx, BYTE PTR _freeNewChildren$[ebp]
  003df	83 f9 01	 cmp	 ecx, 1
  003e2	75 45		 jne	 SHORT $LN25@replaceChi

; 453  : 	{
; 454  : 		ANTLR3_FREE(newChildren->elements);

  003e4	8b f4		 mov	 esi, esp
  003e6	8b 55 e4	 mov	 edx, DWORD PTR _newChildren$[ebp]
  003e9	8b 02		 mov	 eax, DWORD PTR [edx]
  003eb	50		 push	 eax
  003ec	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  003f2	83 c4 04	 add	 esp, 4
  003f5	3b f4		 cmp	 esi, esp
  003f7	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 455  : 		newChildren->elements = NULL;

  003fc	8b 4d e4	 mov	 ecx, DWORD PTR _newChildren$[ebp]
  003ff	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 456  : 		newChildren->size = 0;

  00405	8b 55 e4	 mov	 edx, DWORD PTR _newChildren$[ebp]
  00408	c7 82 b0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+176], 0

; 457  : 		ANTLR3_FREE(newChildren);		// Will not free the nodes

  00412	8b f4		 mov	 esi, esp
  00414	8b 45 e4	 mov	 eax, DWORD PTR _newChildren$[ebp]
  00417	50		 push	 eax
  00418	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0041e	83 c4 04	 add	 esp, 4
  00421	3b f4		 cmp	 esi, esp
  00423	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00428	90		 npad	 1
$LN25@replaceChi:

; 458  : 	}
; 459  : }

  00429	5f		 pop	 edi
  0042a	5e		 pop	 esi
  0042b	83 c4 2c	 add	 esp, 44			; 0000002cH
  0042e	3b ec		 cmp	 ebp, esp
  00430	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00435	8b e5		 mov	 esp, ebp
  00437	5d		 pop	 ebp
  00438	c3		 ret	 0
_replaceChildren ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3basetree.c
;	COMDAT _addChildren
_TEXT	SEGMENT
_s$ = -8						; size = 4
_i$ = -4						; size = 4
_tree$ = 8						; size = 4
_kids$ = 12						; size = 4
_addChildren PROC					; COMDAT

; 227  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 228  : 	ANTLR3_UINT32    i;
; 229  : 	ANTLR3_UINT32    s;
; 230  : 
; 231  : 	s = kids->size(kids);

  00015	8b f4		 mov	 esi, esp
  00017	8b 45 0c	 mov	 eax, DWORD PTR _kids$[ebp]
  0001a	50		 push	 eax
  0001b	8b 4d 0c	 mov	 ecx, DWORD PTR _kids$[ebp]
  0001e	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00021	ff d2		 call	 edx
  00023	83 c4 04	 add	 esp, 4
  00026	3b f4		 cmp	 esi, esp
  00028	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002d	89 45 f8	 mov	 DWORD PTR _s$[ebp], eax

; 232  : 	for	(i = 0; i<s; i++)

  00030	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00037	eb 09		 jmp	 SHORT $LN4@addChildre
$LN2@addChildre:
  00039	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0003c	83 c0 01	 add	 eax, 1
  0003f	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@addChildre:
  00042	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00045	3b 4d f8	 cmp	 ecx, DWORD PTR _s$[ebp]
  00048	73 3b		 jae	 SHORT $LN3@addChildre

; 233  : 	{
; 234  : 		tree->addChild(tree, (pANTLR3_BASE_TREE)(kids->get(kids, i+1)));

  0004a	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0004d	83 c2 01	 add	 edx, 1
  00050	8b f4		 mov	 esi, esp
  00052	52		 push	 edx
  00053	8b 45 0c	 mov	 eax, DWORD PTR _kids$[ebp]
  00056	50		 push	 eax
  00057	8b 4d 0c	 mov	 ecx, DWORD PTR _kids$[ebp]
  0005a	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0005d	ff d2		 call	 edx
  0005f	83 c4 08	 add	 esp, 8
  00062	3b f4		 cmp	 esi, esp
  00064	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00069	8b f4		 mov	 esi, esp
  0006b	50		 push	 eax
  0006c	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  0006f	50		 push	 eax
  00070	8b 4d 08	 mov	 ecx, DWORD PTR _tree$[ebp]
  00073	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00076	ff d2		 call	 edx
  00078	83 c4 08	 add	 esp, 8
  0007b	3b f4		 cmp	 esi, esp
  0007d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00082	90		 npad	 1

; 235  : 	}

  00083	eb b4		 jmp	 SHORT $LN2@addChildre
$LN3@addChildre:

; 236  : }

  00085	5e		 pop	 esi
  00086	83 c4 08	 add	 esp, 8
  00089	3b ec		 cmp	 ebp, esp
  0008b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c3		 ret	 0
_addChildren ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3basetree.c
;	COMDAT _addChild
_TEXT	SEGMENT
_count$1 = -20						; size = 4
_count$2 = -16						; size = 4
_entry$3 = -12						; size = 4
_i$ = -8						; size = 4
_n$ = -4						; size = 4
_tree$ = 8						; size = 4
_child$ = 12						; size = 4
_addChild PROC						; COMDAT

; 145  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0000f	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00012	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00015	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00018	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 146  : 	ANTLR3_UINT32   n;
; 147  : 	ANTLR3_UINT32   i;
; 148  : 
; 149  : 	if	(child == NULL)

  0001b	83 7d 0c 00	 cmp	 DWORD PTR _child$[ebp], 0
  0001f	75 05		 jne	 SHORT $LN5@addChild

; 150  : 	{
; 151  : 		return;

  00021	e9 11 02 00 00	 jmp	 $LN7@addChild
$LN5@addChild:

; 152  : 	}
; 153  : 
; 154  : 	if	(child->isNilNode(child) == ANTLR3_TRUE)

  00026	8b f4		 mov	 esi, esp
  00028	8b 45 0c	 mov	 eax, DWORD PTR _child$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 0c	 mov	 ecx, DWORD PTR _child$[ebp]
  0002f	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  00032	ff d2		 call	 edx
  00034	83 c4 04	 add	 esp, 4
  00037	3b f4		 cmp	 esi, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	0f b6 c0	 movzx	 eax, al
  00041	83 f8 01	 cmp	 eax, 1
  00044	0f 85 60 01 00
	00		 jne	 $LN6@addChild

; 155  : 	{
; 156  : 		if  (child->children != NULL && child->children == tree->children)

  0004a	8b 4d 0c	 mov	 ecx, DWORD PTR _child$[ebp]
  0004d	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  00051	74 35		 je	 SHORT $LN8@addChild
  00053	8b 55 0c	 mov	 edx, DWORD PTR _child$[ebp]
  00056	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  00059	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  0005c	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  0005f	75 27		 jne	 SHORT $LN8@addChild

; 157  : 		{
; 158  : 			// TODO: Change to exception rather than ANTLR3_FPRINTF?
; 159  : 			//
; 160  : 			ANTLR3_FPRINTF(stderr, "ANTLR3: An attempt was made to add a child list to itself!\n");

  00061	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@LGLGCGOD@ANTLR3?3?5An?5attempt?5was?5made?5to?5@
  00066	8b f4		 mov	 esi, esp
  00068	6a 02		 push	 2
  0006a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  00070	83 c4 04	 add	 esp, 4
  00073	3b f4		 cmp	 esi, esp
  00075	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007a	50		 push	 eax
  0007b	e8 00 00 00 00	 call	 _fprintf
  00080	83 c4 08	 add	 esp, 8

; 161  : 			return;

  00083	e9 af 01 00 00	 jmp	 $LN7@addChild
$LN8@addChild:

; 162  : 		}
; 163  : 
; 164  :         // Add all of the children's children to this list
; 165  :         //
; 166  :         if (child->children != NULL)

  00088	8b 55 0c	 mov	 edx, DWORD PTR _child$[ebp]
  0008b	83 7a 08 00	 cmp	 DWORD PTR [edx+8], 0
  0008f	0f 84 10 01 00
	00		 je	 $LN3@addChild

; 167  :         {
; 168  :             if (tree->children == NULL)

  00095	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  00098	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0009c	75 27		 jne	 SHORT $LN10@addChild

; 169  :             {
; 170  :                 // We are build ing the tree structure here, so we need not
; 171  :                 // worry about duplication of pointers as the tree node
; 172  :                 // factory will only clean up each node once. So we just
; 173  :                 // copy in the child's children pointer as the child is
; 174  :                 // a nil node (has not root itself).
; 175  :                 //
; 176  :                 tree->children = child->children;

  0009e	8b 4d 08	 mov	 ecx, DWORD PTR _tree$[ebp]
  000a1	8b 55 0c	 mov	 edx, DWORD PTR _child$[ebp]
  000a4	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000a7	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 177  :                 child->children = NULL;

  000aa	8b 4d 0c	 mov	 ecx, DWORD PTR _child$[ebp]
  000ad	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 178  :                 freshenPACIndexesAll(tree);

  000b4	8b 55 08	 mov	 edx, DWORD PTR _tree$[ebp]
  000b7	52		 push	 edx
  000b8	e8 00 00 00 00	 call	 _freshenPACIndexesAll
  000bd	83 c4 04	 add	 esp, 4

; 179  :                 
; 180  :             }

  000c0	e9 e0 00 00 00	 jmp	 $LN3@addChild
$LN10@addChild:

; 181  :             else
; 182  :             {
; 183  :                 // Need to copy the children
; 184  :                 //
; 185  :                 n = child->children->size(child->children);

  000c5	8b f4		 mov	 esi, esp
  000c7	8b 45 0c	 mov	 eax, DWORD PTR _child$[ebp]
  000ca	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000cd	51		 push	 ecx
  000ce	8b 55 0c	 mov	 edx, DWORD PTR _child$[ebp]
  000d1	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000d4	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  000da	ff d1		 call	 ecx
  000dc	83 c4 04	 add	 esp, 4
  000df	3b f4		 cmp	 esi, esp
  000e1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e6	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax

; 186  : 
; 187  :                 for (i = 0; i < n; i++)

  000e9	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000f0	eb 09		 jmp	 SHORT $LN4@addChild
$LN2@addChild:
  000f2	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  000f5	83 c2 01	 add	 edx, 1
  000f8	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
$LN4@addChild:
  000fb	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000fe	3b 45 fc	 cmp	 eax, DWORD PTR _n$[ebp]
  00101	0f 83 9e 00 00
	00		 jae	 $LN3@addChild

; 188  :                 {
; 189  :                     pANTLR3_BASE_TREE entry;
; 190  :                     entry = (pANTLR3_BASE_TREE)child->children->get(child->children, i);

  00107	8b f4		 mov	 esi, esp
  00109	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  0010c	51		 push	 ecx
  0010d	8b 55 0c	 mov	 edx, DWORD PTR _child$[ebp]
  00110	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00113	50		 push	 eax
  00114	8b 4d 0c	 mov	 ecx, DWORD PTR _child$[ebp]
  00117	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0011a	8b 82 98 00 00
	00		 mov	 eax, DWORD PTR [edx+152]
  00120	ff d0		 call	 eax
  00122	83 c4 08	 add	 esp, 8
  00125	3b f4		 cmp	 esi, esp
  00127	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0012c	89 45 f4	 mov	 DWORD PTR _entry$3[ebp], eax

; 191  : 
; 192  :                     // ANTLR3 lists can be sparse, unlike Array Lists
; 193  :                     //
; 194  :                     if (entry != NULL)

  0012f	83 7d f4 00	 cmp	 DWORD PTR _entry$3[ebp], 0
  00133	74 6b		 je	 SHORT $LN12@addChild

; 195  :                     {
; 196  :                         ANTLR3_UINT32 count = tree->children->add(tree->children, entry, (void (ANTLR3_CDECL *) (void *))child->free);

  00135	8b f4		 mov	 esi, esp
  00137	8b 4d 0c	 mov	 ecx, DWORD PTR _child$[ebp]
  0013a	8b 51 7c	 mov	 edx, DWORD PTR [ecx+124]
  0013d	52		 push	 edx
  0013e	8b 45 f4	 mov	 eax, DWORD PTR _entry$3[ebp]
  00141	50		 push	 eax
  00142	8b 4d 08	 mov	 ecx, DWORD PTR _tree$[ebp]
  00145	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00148	52		 push	 edx
  00149	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  0014c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0014f	8b 91 a8 00 00
	00		 mov	 edx, DWORD PTR [ecx+168]
  00155	ff d2		 call	 edx
  00157	83 c4 0c	 add	 esp, 12			; 0000000cH
  0015a	3b f4		 cmp	 esi, esp
  0015c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00161	89 45 f0	 mov	 DWORD PTR _count$2[ebp], eax

; 197  : 
; 198  :                         entry->setChildIndex(entry, count - 1);

  00164	8b 45 f0	 mov	 eax, DWORD PTR _count$2[ebp]
  00167	83 e8 01	 sub	 eax, 1
  0016a	8b f4		 mov	 esi, esp
  0016c	50		 push	 eax
  0016d	8b 4d f4	 mov	 ecx, DWORD PTR _entry$3[ebp]
  00170	51		 push	 ecx
  00171	8b 55 f4	 mov	 edx, DWORD PTR _entry$3[ebp]
  00174	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  00177	ff d0		 call	 eax
  00179	83 c4 08	 add	 esp, 8
  0017c	3b f4		 cmp	 esi, esp
  0017e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 199  :                         entry->setParent(entry, tree);

  00183	8b f4		 mov	 esi, esp
  00185	8b 4d 08	 mov	 ecx, DWORD PTR _tree$[ebp]
  00188	51		 push	 ecx
  00189	8b 55 f4	 mov	 edx, DWORD PTR _entry$3[ebp]
  0018c	52		 push	 edx
  0018d	8b 45 f4	 mov	 eax, DWORD PTR _entry$3[ebp]
  00190	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  00193	ff d1		 call	 ecx
  00195	83 c4 08	 add	 esp, 8
  00198	3b f4		 cmp	 esi, esp
  0019a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0019f	90		 npad	 1
$LN12@addChild:

; 200  :                     }
; 201  :                 }

  001a0	e9 4d ff ff ff	 jmp	 $LN2@addChild
$LN3@addChild:

; 202  :             }
; 203  : 		}
; 204  : 	}

  001a5	e9 8d 00 00 00	 jmp	 $LN7@addChild
$LN6@addChild:

; 205  : 	else
; 206  : 	{
; 207  : 		// Tree we are adding is not a Nil and might have children to copy
; 208  : 		//
; 209  : 		if  (tree->children == NULL)

  001aa	8b 55 08	 mov	 edx, DWORD PTR _tree$[ebp]
  001ad	83 7a 08 00	 cmp	 DWORD PTR [edx+8], 0
  001b1	75 19		 jne	 SHORT $LN13@addChild

; 210  : 		{
; 211  : 			// No children in the tree we are adding to, so create a new list on
; 212  : 			// the fly to hold them.
; 213  : 			//
; 214  : 			tree->createChildrenList(tree);

  001b3	8b f4		 mov	 esi, esp
  001b5	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  001b8	50		 push	 eax
  001b9	8b 4d 08	 mov	 ecx, DWORD PTR _tree$[ebp]
  001bc	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  001bf	ff d2		 call	 edx
  001c1	83 c4 04	 add	 esp, 4
  001c4	3b f4		 cmp	 esi, esp
  001c6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001cb	90		 npad	 1
$LN13@addChild:

; 215  : 		}
; 216  : 
; 217  : 		ANTLR3_UINT32 count = tree->children->add(tree->children, child, (void (ANTLR3_CDECL *)(void *))child->free);

  001cc	8b f4		 mov	 esi, esp
  001ce	8b 45 0c	 mov	 eax, DWORD PTR _child$[ebp]
  001d1	8b 48 7c	 mov	 ecx, DWORD PTR [eax+124]
  001d4	51		 push	 ecx
  001d5	8b 55 0c	 mov	 edx, DWORD PTR _child$[ebp]
  001d8	52		 push	 edx
  001d9	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  001dc	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001df	51		 push	 ecx
  001e0	8b 55 08	 mov	 edx, DWORD PTR _tree$[ebp]
  001e3	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  001e6	8b 88 a8 00 00
	00		 mov	 ecx, DWORD PTR [eax+168]
  001ec	ff d1		 call	 ecx
  001ee	83 c4 0c	 add	 esp, 12			; 0000000cH
  001f1	3b f4		 cmp	 esi, esp
  001f3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001f8	89 45 ec	 mov	 DWORD PTR _count$1[ebp], eax

; 218  : 		child->setChildIndex(child, count - 1);

  001fb	8b 55 ec	 mov	 edx, DWORD PTR _count$1[ebp]
  001fe	83 ea 01	 sub	 edx, 1
  00201	8b f4		 mov	 esi, esp
  00203	52		 push	 edx
  00204	8b 45 0c	 mov	 eax, DWORD PTR _child$[ebp]
  00207	50		 push	 eax
  00208	8b 4d 0c	 mov	 ecx, DWORD PTR _child$[ebp]
  0020b	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  0020e	ff d2		 call	 edx
  00210	83 c4 08	 add	 esp, 8
  00213	3b f4		 cmp	 esi, esp
  00215	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 219  : 		child->setParent(child, tree);

  0021a	8b f4		 mov	 esi, esp
  0021c	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  0021f	50		 push	 eax
  00220	8b 4d 0c	 mov	 ecx, DWORD PTR _child$[ebp]
  00223	51		 push	 ecx
  00224	8b 55 0c	 mov	 edx, DWORD PTR _child$[ebp]
  00227	8b 42 4c	 mov	 eax, DWORD PTR [edx+76]
  0022a	ff d0		 call	 eax
  0022c	83 c4 08	 add	 esp, 8
  0022f	3b f4		 cmp	 esi, esp
  00231	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00236	90		 npad	 1
$LN7@addChild:

; 220  : 	}
; 221  : }

  00237	5e		 pop	 esi
  00238	83 c4 14	 add	 esp, 20			; 00000014H
  0023b	3b ec		 cmp	 ebp, esp
  0023d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00242	8b e5		 mov	 esp, ebp
  00244	5d		 pop	 ebp
  00245	c3		 ret	 0
_addChild ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3basetree.c
;	COMDAT _getFirstChildWithType
_TEXT	SEGMENT
_t$ = -12						; size = 4
_cs$ = -8						; size = 4
_i$ = -4						; size = 4
_tree$ = 8						; size = 4
_type$ = 12						; size = 4
_getFirstChildWithType PROC				; COMDAT

; 96   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000e	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00015	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 97   : 	ANTLR3_UINT32   i;
; 98   : 	ANTLR3_UINT32   cs;
; 99   : 
; 100  : 	pANTLR3_BASE_TREE	t;
; 101  : 	if	(tree->children != NULL)

  0001c	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  0001f	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00023	0f 84 8a 00 00
	00		 je	 $LN3@getFirstCh

; 102  : 	{
; 103  : 		cs	= tree->children->size(tree->children);

  00029	8b f4		 mov	 esi, esp
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _tree$[ebp]
  0002e	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00031	52		 push	 edx
  00032	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  00035	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00038	8b 91 b0 00 00
	00		 mov	 edx, DWORD PTR [ecx+176]
  0003e	ff d2		 call	 edx
  00040	83 c4 04	 add	 esp, 4
  00043	3b f4		 cmp	 esi, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	89 45 f8	 mov	 DWORD PTR _cs$[ebp], eax

; 104  : 		for	(i = 0; i < cs; i++)

  0004d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00054	eb 09		 jmp	 SHORT $LN4@getFirstCh
$LN2@getFirstCh:
  00056	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00059	83 c0 01	 add	 eax, 1
  0005c	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@getFirstCh:
  0005f	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00062	3b 4d f8	 cmp	 ecx, DWORD PTR _cs$[ebp]
  00065	73 4c		 jae	 SHORT $LN3@getFirstCh

; 105  : 		{
; 106  : 			t = (pANTLR3_BASE_TREE) (tree->children->get(tree->children, i));

  00067	8b f4		 mov	 esi, esp
  00069	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0006c	52		 push	 edx
  0006d	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  00070	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00073	51		 push	 ecx
  00074	8b 55 08	 mov	 edx, DWORD PTR _tree$[ebp]
  00077	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0007a	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [eax+152]
  00080	ff d1		 call	 ecx
  00082	83 c4 08	 add	 esp, 8
  00085	3b f4		 cmp	 esi, esp
  00087	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008c	89 45 f4	 mov	 DWORD PTR _t$[ebp], eax

; 107  : 			if  (tree->getType(t) == type)

  0008f	8b f4		 mov	 esi, esp
  00091	8b 55 f4	 mov	 edx, DWORD PTR _t$[ebp]
  00094	52		 push	 edx
  00095	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  00098	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  0009b	ff d1		 call	 ecx
  0009d	83 c4 04	 add	 esp, 4
  000a0	3b f4		 cmp	 esi, esp
  000a2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a7	3b 45 0c	 cmp	 eax, DWORD PTR _type$[ebp]
  000aa	75 05		 jne	 SHORT $LN6@getFirstCh

; 108  : 			{
; 109  : 				return  (pANTLR3_BASE_TREE)t;

  000ac	8b 45 f4	 mov	 eax, DWORD PTR _t$[ebp]
  000af	eb 04		 jmp	 SHORT $LN1@getFirstCh
$LN6@getFirstCh:

; 110  : 			}
; 111  : 		}

  000b1	eb a3		 jmp	 SHORT $LN2@getFirstCh
$LN3@getFirstCh:

; 112  : 	}
; 113  : 	return  NULL;

  000b3	33 c0		 xor	 eax, eax
$LN1@getFirstCh:

; 114  : }

  000b5	5e		 pop	 esi
  000b6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b9	3b ec		 cmp	 ebp, esp
  000bb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c3		 ret	 0
_getFirstChildWithType ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3basetree.c
;	COMDAT _getLine
_TEXT	SEGMENT
_tree$ = 8						; size = 4
_getLine PROC						; COMDAT

; 91   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 92   : 	return  0;

  00003	33 c0		 xor	 eax, eax

; 93   : }

  00005	5d		 pop	 ebp
  00006	c3		 ret	 0
_getLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3basetree.c
;	COMDAT _getCharPositionInLine
_TEXT	SEGMENT
_tree$ = 8						; size = 4
_getCharPositionInLine PROC				; COMDAT

; 85   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 86   : 	return  0;

  00003	33 c0		 xor	 eax, eax

; 87   : }

  00005	5d		 pop	 ebp
  00006	c3		 ret	 0
_getCharPositionInLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3basetree.c
;	COMDAT _getChildCount
_TEXT	SEGMENT
_tree$ = 8						; size = 4
_getChildCount PROC					; COMDAT

; 132  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 133  : 	if	(tree->children == NULL)

  00004	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  00007	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0000b	75 06		 jne	 SHORT $LN2@getChildCo

; 134  : 	{
; 135  : 		return 0;

  0000d	33 c0		 xor	 eax, eax
  0000f	eb 23		 jmp	 SHORT $LN3@getChildCo

; 136  : 	}

  00011	eb 21		 jmp	 SHORT $LN3@getChildCo
$LN2@getChildCo:

; 137  : 	else
; 138  : 	{
; 139  : 		return	tree->children->size(tree->children);

  00013	8b f4		 mov	 esi, esp
  00015	8b 4d 08	 mov	 ecx, DWORD PTR _tree$[ebp]
  00018	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0001b	52		 push	 edx
  0001c	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  0001f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00022	8b 91 b0 00 00
	00		 mov	 edx, DWORD PTR [ecx+176]
  00028	ff d2		 call	 edx
  0002a	83 c4 04	 add	 esp, 4
  0002d	3b f4		 cmp	 esi, esp
  0002f	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@getChildCo:

; 140  : 	}
; 141  : }

  00034	5e		 pop	 esi
  00035	3b ec		 cmp	 ebp, esp
  00037	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
_getChildCount ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3basetree.c
;	COMDAT _getChild
_TEXT	SEGMENT
_tree$ = 8						; size = 4
_i$ = 12						; size = 4
_getChild PROC						; COMDAT

; 120  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 121  : 	if	(      tree->children == NULL
; 122  : 		|| i >= tree->children->size(tree->children))

  00004	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  00007	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0000b	74 26		 je	 SHORT $LN3@getChild
  0000d	8b f4		 mov	 esi, esp
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _tree$[ebp]
  00012	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00015	52		 push	 edx
  00016	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  00019	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0001c	8b 91 b0 00 00
	00		 mov	 edx, DWORD PTR [ecx+176]
  00022	ff d2		 call	 edx
  00024	83 c4 04	 add	 esp, 4
  00027	3b f4		 cmp	 esi, esp
  00029	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002e	39 45 0c	 cmp	 DWORD PTR _i$[ebp], eax
  00031	72 04		 jb	 SHORT $LN2@getChild
$LN3@getChild:

; 123  : 	{
; 124  : 		return NULL;

  00033	33 c0		 xor	 eax, eax
  00035	eb 25		 jmp	 SHORT $LN1@getChild
$LN2@getChild:

; 125  : 	}
; 126  : 	return  tree->children->get(tree->children, i);

  00037	8b f4		 mov	 esi, esp
  00039	8b 45 0c	 mov	 eax, DWORD PTR _i$[ebp]
  0003c	50		 push	 eax
  0003d	8b 4d 08	 mov	 ecx, DWORD PTR _tree$[ebp]
  00040	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00043	52		 push	 edx
  00044	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  00047	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0004a	8b 91 98 00 00
	00		 mov	 edx, DWORD PTR [ecx+152]
  00050	ff d2		 call	 edx
  00052	83 c4 08	 add	 esp, 8
  00055	3b f4		 cmp	 esi, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@getChild:

; 127  : }

  0005c	5e		 pop	 esi
  0005d	3b ec		 cmp	 ebp, esp
  0005f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
_getChild ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3basetree.c
;	COMDAT _antlr3BaseTreeNew
_TEXT	SEGMENT
_tree$ = 8						; size = 4
_antlr3BaseTreeNew PROC					; COMDAT

; 59   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 60   : 	/* api */
; 61   : 	tree->getChild				= getChild;

  00003	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  00006	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [eax+56], OFFSET _getChild

; 62   : 	tree->getChildCount			= getChildCount;

  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _tree$[ebp]
  00010	c7 41 44 00 00
	00 00		 mov	 DWORD PTR [ecx+68], OFFSET _getChildCount

; 63   : 	tree->addChild				= (void (*)(pANTLR3_BASE_TREE, void *))(addChild);

  00017	8b 55 08	 mov	 edx, DWORD PTR _tree$[ebp]
  0001a	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET _addChild

; 64   : 	tree->addChildren			= addChildren;

  00021	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  00024	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], OFFSET _addChildren

; 65   : 	tree->setChild				= setChild;

  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _tree$[ebp]
  0002e	c7 41 64 00 00
	00 00		 mov	 DWORD PTR [ecx+100], OFFSET _setChild

; 66   : 	tree->deleteChild			= deleteChild;

  00035	8b 55 08	 mov	 edx, DWORD PTR _tree$[ebp]
  00038	c7 42 24 00 00
	00 00		 mov	 DWORD PTR [edx+36], OFFSET _deleteChild

; 67   : 	tree->dupTree				= dupTree;

  0003f	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  00042	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], OFFSET _dupTree

; 68   : 	tree->toStringTree			= toStringTree;

  00049	8b 4d 08	 mov	 ecx, DWORD PTR _tree$[ebp]
  0004c	c7 41 68 00 00
	00 00		 mov	 DWORD PTR [ecx+104], OFFSET _toStringTree

; 69   : 	tree->getCharPositionInLine	= getCharPositionInLine;

  00053	8b 55 08	 mov	 edx, DWORD PTR _tree$[ebp]
  00056	c7 42 34 00 00
	00 00		 mov	 DWORD PTR [edx+52], OFFSET _getCharPositionInLine

; 70   : 	tree->getLine				= getLine;

  0005d	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  00060	c7 40 58 00 00
	00 00		 mov	 DWORD PTR [eax+88], OFFSET _getLine

; 71   : 	tree->replaceChildren		= replaceChildren;

  00067	8b 4d 08	 mov	 ecx, DWORD PTR _tree$[ebp]
  0006a	c7 41 28 00 00
	00 00		 mov	 DWORD PTR [ecx+40], OFFSET _replaceChildren

; 72   : 	tree->freshenPACIndexesAll	= freshenPACIndexesAll;

  00071	8b 55 08	 mov	 edx, DWORD PTR _tree$[ebp]
  00074	c7 42 70 00 00
	00 00		 mov	 DWORD PTR [edx+112], OFFSET _freshenPACIndexesAll

; 73   : 	tree->freshenPACIndexes		= freshenPACIndexes;

  0007b	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  0007e	c7 40 74 00 00
	00 00		 mov	 DWORD PTR [eax+116], OFFSET _freshenPACIndexes

; 74   : 	tree->getFirstChildWithType	= (void *(*)(pANTLR3_BASE_TREE, ANTLR3_UINT32))(getFirstChildWithType);

  00085	8b 4d 08	 mov	 ecx, DWORD PTR _tree$[ebp]
  00088	c7 41 54 00 00
	00 00		 mov	 DWORD PTR [ecx+84], OFFSET _getFirstChildWithType

; 75   : 	tree->children				= NULL;

  0008f	8b 55 08	 mov	 edx, DWORD PTR _tree$[ebp]
  00092	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 76   : 	tree->strFactory			= NULL;

  00099	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]
  0009c	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 77   : 
; 78   : 	/* Rest must be filled in by caller.
; 79   : 	*/
; 80   : 	return  tree;

  000a3	8b 45 08	 mov	 eax, DWORD PTR _tree$[ebp]

; 81   : }

  000a6	5d		 pop	 ebp
  000a7	c3		 ret	 0
_antlr3BaseTreeNew ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 837  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 838  :         int _Result;
; 839  :         va_list _ArgList;
; 840  :         __crt_va_start(_ArgList, _Format);

  00014	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00017	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 841  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

  0001a	8b 4d f8	 mov	 ecx, DWORD PTR __ArgList$[ebp]
  0001d	51		 push	 ecx
  0001e	6a 00		 push	 0
  00020	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00023	52		 push	 edx
  00024	8b 45 08	 mov	 eax, DWORD PTR __Stream$[ebp]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 __vfprintf_l
  0002d	83 c4 10	 add	 esp, 16			; 00000010H
  00030	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 842  :         __crt_va_end(_ArgList);

  00033	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 843  :         return _Result;

  0003a	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 844  :     }

  0003d	83 c4 08	 add	 esp, 8
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 644  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00004	8b f4		 mov	 esi, esp
  00006	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  0000d	51		 push	 ecx
  0000e	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00011	52		 push	 edx
  00012	8b 45 08	 mov	 eax, DWORD PTR __Stream$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  0001b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001e	51		 push	 ecx
  0001f	8b 10		 mov	 edx, DWORD PTR [eax]
  00021	52		 push	 edx
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vfprintf
  00028	83 c4 18	 add	 esp, 24			; 00000018H
  0002b	3b f4		 cmp	 esi, esp
  0002d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 646  :     }

  00032	5e		 pop	 esi
  00033	3b ec		 cmp	 ebp, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 90   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00003	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
