; Listing generated by Microsoft (R) Optimizing Compiler Version 19.42.34436.0 

	TITLE	C:\SPO_labs\C\DebugDLL\antlr3debughandlers.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	___local_stdio_printf_options
PUBLIC	__vfprintf_l
PUBLIC	_printf
PUBLIC	__vsnprintf_l
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	_antlr3DebugListenerNew
PUBLIC	_antlr3DebugListenerNewPort
PUBLIC	_serializeText
PUBLIC	_serializeToken
PUBLIC	_serializeNode
PUBLIC	??_C@_09ILMAJDDB@ANTLR?5?$CFd?6@		; `string'
PUBLIC	??_C@_0N@LDLKKDCB@grammar?5?$CC?$CFs?6@		; `string'
PUBLIC	??_C@_0DF@DGFGDKCA@Exiting?5debugger?5as?5remote?5clie@ ; `string'
PUBLIC	??_C@_0DN@JOJNMFAB@Received?5char?5count?5was?5?$CFd?0?5and@ ; `string'
PUBLIC	??_C@_02KINNFLEC@?7?$CC@			; `string'
PUBLIC	??_C@_03IEFOOEDL@?$CF0A@			; `string'
PUBLIC	??_C@_03PJCJBAHO@?$CF0D@			; `string'
PUBLIC	??_C@_03MMIJIMKH@?$CF25@			; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_0BB@ENKMDCBO@enterRule?7?$CFs?7?$CFs?6@	; `string'
PUBLIC	??_C@_0N@JDALHHAO@enterAlt?7?$CFd?6@		; `string'
PUBLIC	??_C@_0BA@HKINPPNN@exitRule?7?$CFs?7?$CFs?6@	; `string'
PUBLIC	??_C@_0BB@GEBKADNP@enterSubRule?7?$CFd?6@	; `string'
PUBLIC	??_C@_0BA@FDDLMOBM@exitSubRule?7?$CFd?6@	; `string'
PUBLIC	??_C@_0BC@JHLNNKII@enterDecision?7?$CFd?6@	; `string'
PUBLIC	??_C@_0BB@JFOHGIEP@exitDecision?7?$CFd?6@	; `string'
PUBLIC	??_C@_0O@CLDGECJA@consumeToken?7@		; `string'
PUBLIC	??_C@_0BE@GEGFGNHF@consumeHiddenToken?7@	; `string'
PUBLIC	??_C@_01GPOEFGEJ@?7@				; `string'
PUBLIC	??_C@_03LFAOPKED@LT?7@				; `string'
PUBLIC	??_C@_08JOJCKFBH@mark?7?$CFd?6@			; `string'
PUBLIC	??_C@_0L@DJLPLDGG@rewind?7?$CFd?6@		; `string'
PUBLIC	??_C@_07EBOLPGDK@rewind?6@			; `string'
PUBLIC	??_C@_0BD@LEGDBIBN@beginBacktrack?7?$CFd?6@	; `string'
PUBLIC	??_C@_0BE@JACBLDCL@endBacktrack?7?$CFd?7?$CFd?6@ ; `string'
PUBLIC	??_C@_0BA@DOLCCEBI@location?7?$CFd?7?$CFd?6@	; `string'
PUBLIC	??_C@_0BH@FBDPJABF@exception?7?$CFs?7?$CFd?7?$CFd?7?$CFd?6@ ; `string'
PUBLIC	??_C@_0N@DCBHEMKM@beginResync?6@		; `string'
PUBLIC	??_C@_0L@KHCEOHOJ@endResync?6@			; `string'
PUBLIC	??_C@_04LOAJBDKD@true@				; `string'
PUBLIC	??_C@_05LAPONLG@false@				; `string'
PUBLIC	??_C@_0BG@LEAPHAIG@semanticPredicate?7?$CFs?7@	; `string'
PUBLIC	??_C@_0L@KANKBBAE@terminate?6@			; `string'
PUBLIC	??_C@_0N@CLFGHGNF@consumeNode?7@		; `string'
PUBLIC	??_C@_03KELPNMOF@LN?7@				; `string'
PUBLIC	??_C@_0M@LCJNOAFD@nilNode?7?$CFd?6@		; `string'
PUBLIC	??_C@_0BN@GBIFKPIJ@createNodeFromTokenElements?5@ ; `string'
PUBLIC	??_C@_0L@OOIEOANM@errorNode?7@			; `string'
PUBLIC	??_C@_0BC@JHAHHABL@createNode?7?$CFd?7?$CFd?6@	; `string'
PUBLIC	??_C@_0BC@HDNJJMMJ@becomeRoot?7?$CFd?7?$CFd?6@	; `string'
PUBLIC	??_C@_0BA@CIOIAFCB@addChild?7?$CFd?7?$CFd?6@	; `string'
PUBLIC	??_C@_0BF@NJPIKMHA@becomeRoot?7?$CFd?7?$CFd?7?$CFd?6@ ; `string'
EXTRN	_strlen:PROC
EXTRN	__imp__calloc:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp__exit:PROC
EXTRN	_accept@12:PROC
EXTRN	_bind@12:PROC
EXTRN	_closesocket@4:PROC
EXTRN	_htonl@4:PROC
EXTRN	_htons@4:PROC
EXTRN	_listen@8:PROC
EXTRN	_recv@16:PROC
EXTRN	_send@16:PROC
EXTRN	_setsockopt@20:PROC
EXTRN	_shutdown@8:PROC
EXTRN	_socket@12:PROC
EXTRN	_WSAStartup@8:PROC
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___security_cookie:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0BF@NJPIKMHA@becomeRoot?7?$CFd?7?$CFd?7?$CFd?6@
CONST	SEGMENT
??_C@_0BF@NJPIKMHA@becomeRoot?7?$CFd?7?$CFd?7?$CFd?6@ DB 'becomeRoot', 09H
	DB	'%d', 09H, '%d', 09H, '%d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@CIOIAFCB@addChild?7?$CFd?7?$CFd?6@
CONST	SEGMENT
??_C@_0BA@CIOIAFCB@addChild?7?$CFd?7?$CFd?6@ DB 'addChild', 09H, '%d', 09H
	DB	'%d', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HDNJJMMJ@becomeRoot?7?$CFd?7?$CFd?6@
CONST	SEGMENT
??_C@_0BC@HDNJJMMJ@becomeRoot?7?$CFd?7?$CFd?6@ DB 'becomeRoot', 09H, '%d', 09H
	DB	'%d', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JHAHHABL@createNode?7?$CFd?7?$CFd?6@
CONST	SEGMENT
??_C@_0BC@JHAHHABL@createNode?7?$CFd?7?$CFd?6@ DB 'createNode', 09H, '%d', 09H
	DB	'%d', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OOIEOANM@errorNode?7@
CONST	SEGMENT
??_C@_0L@OOIEOANM@errorNode?7@ DB 'errorNode', 09H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@GBIFKPIJ@createNodeFromTokenElements?5@
CONST	SEGMENT
??_C@_0BN@GBIFKPIJ@createNodeFromTokenElements?5@ DB 'createNodeFromToken'
	DB	'Elements ', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LCJNOAFD@nilNode?7?$CFd?6@
CONST	SEGMENT
??_C@_0M@LCJNOAFD@nilNode?7?$CFd?6@ DB 'nilNode', 09H, '%d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03KELPNMOF@LN?7@
CONST	SEGMENT
??_C@_03KELPNMOF@LN?7@ DB 'LN', 09H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CLFGHGNF@consumeNode?7@
CONST	SEGMENT
??_C@_0N@CLFGHGNF@consumeNode?7@ DB 'consumeNode', 09H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KANKBBAE@terminate?6@
CONST	SEGMENT
??_C@_0L@KANKBBAE@terminate?6@ DB 'terminate', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LEAPHAIG@semanticPredicate?7?$CFs?7@
CONST	SEGMENT
??_C@_0BG@LEAPHAIG@semanticPredicate?7?$CFs?7@ DB 'semanticPredicate', 09H
	DB	'%s', 09H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false@
CONST	SEGMENT
??_C@_05LAPONLG@false@ DB 'false', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true@
CONST	SEGMENT
??_C@_04LOAJBDKD@true@ DB 'true', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KHCEOHOJ@endResync?6@
CONST	SEGMENT
??_C@_0L@KHCEOHOJ@endResync?6@ DB 'endResync', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DCBHEMKM@beginResync?6@
CONST	SEGMENT
??_C@_0N@DCBHEMKM@beginResync?6@ DB 'beginResync', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@FBDPJABF@exception?7?$CFs?7?$CFd?7?$CFd?7?$CFd?6@
CONST	SEGMENT
??_C@_0BH@FBDPJABF@exception?7?$CFs?7?$CFd?7?$CFd?7?$CFd?6@ DB 'exception'
	DB	09H, '%s', 09H, '%d', 09H, '%d', 09H, '%d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DOLCCEBI@location?7?$CFd?7?$CFd?6@
CONST	SEGMENT
??_C@_0BA@DOLCCEBI@location?7?$CFd?7?$CFd?6@ DB 'location', 09H, '%d', 09H
	DB	'%d', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JACBLDCL@endBacktrack?7?$CFd?7?$CFd?6@
CONST	SEGMENT
??_C@_0BE@JACBLDCL@endBacktrack?7?$CFd?7?$CFd?6@ DB 'endBacktrack', 09H, '%'
	DB	'd', 09H, '%d', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LEGDBIBN@beginBacktrack?7?$CFd?6@
CONST	SEGMENT
??_C@_0BD@LEGDBIBN@beginBacktrack?7?$CFd?6@ DB 'beginBacktrack', 09H, '%d'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_07EBOLPGDK@rewind?6@
CONST	SEGMENT
??_C@_07EBOLPGDK@rewind?6@ DB 'rewind', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DJLPLDGG@rewind?7?$CFd?6@
CONST	SEGMENT
??_C@_0L@DJLPLDGG@rewind?7?$CFd?6@ DB 'rewind', 09H, '%d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08JOJCKFBH@mark?7?$CFd?6@
CONST	SEGMENT
??_C@_08JOJCKFBH@mark?7?$CFd?6@ DB 'mark', 09H, '%d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03LFAOPKED@LT?7@
CONST	SEGMENT
??_C@_03LFAOPKED@LT?7@ DB 'LT', 09H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01GPOEFGEJ@?7@
CONST	SEGMENT
??_C@_01GPOEFGEJ@?7@ DB 09H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GEGFGNHF@consumeHiddenToken?7@
CONST	SEGMENT
??_C@_0BE@GEGFGNHF@consumeHiddenToken?7@ DB 'consumeHiddenToken', 09H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CLDGECJA@consumeToken?7@
CONST	SEGMENT
??_C@_0O@CLDGECJA@consumeToken?7@ DB 'consumeToken', 09H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JFOHGIEP@exitDecision?7?$CFd?6@
CONST	SEGMENT
??_C@_0BB@JFOHGIEP@exitDecision?7?$CFd?6@ DB 'exitDecision', 09H, '%d', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JHLNNKII@enterDecision?7?$CFd?6@
CONST	SEGMENT
??_C@_0BC@JHLNNKII@enterDecision?7?$CFd?6@ DB 'enterDecision', 09H, '%d', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FDDLMOBM@exitSubRule?7?$CFd?6@
CONST	SEGMENT
??_C@_0BA@FDDLMOBM@exitSubRule?7?$CFd?6@ DB 'exitSubRule', 09H, '%d', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GEBKADNP@enterSubRule?7?$CFd?6@
CONST	SEGMENT
??_C@_0BB@GEBKADNP@enterSubRule?7?$CFd?6@ DB 'enterSubRule', 09H, '%d', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HKINPPNN@exitRule?7?$CFs?7?$CFs?6@
CONST	SEGMENT
??_C@_0BA@HKINPPNN@exitRule?7?$CFs?7?$CFs?6@ DB 'exitRule', 09H, '%s', 09H
	DB	'%s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JDALHHAO@enterAlt?7?$CFd?6@
CONST	SEGMENT
??_C@_0N@JDALHHAO@enterAlt?7?$CFd?6@ DB 'enterAlt', 09H, '%d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@ENKMDCBO@enterRule?7?$CFs?7?$CFs?6@
CONST	SEGMENT
??_C@_0BB@ENKMDCBO@enterRule?7?$CFs?7?$CFs?6@ DB 'enterRule', 09H, '%s', 09H
	DB	'%s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_03MMIJIMKH@?$CF25@
CONST	SEGMENT
??_C@_03MMIJIMKH@?$CF25@ DB '%25', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03PJCJBAHO@?$CF0D@
CONST	SEGMENT
??_C@_03PJCJBAHO@?$CF0D@ DB '%0D', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03IEFOOEDL@?$CF0A@
CONST	SEGMENT
??_C@_03IEFOOEDL@?$CF0A@ DB '%0A', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KINNFLEC@?7?$CC@
CONST	SEGMENT
??_C@_02KINNFLEC@?7?$CC@ DB 09H, '"', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@JOJNMFAB@Received?5char?5count?5was?5?$CFd?0?5and@
CONST	SEGMENT
??_C@_0DN@JOJNMFAB@Received?5char?5count?5was?5?$CFd?0?5and@ DB 'Received'
	DB	' char count was %d, and last char received was %02X', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@DGFGDKCA@Exiting?5debugger?5as?5remote?5clie@
CONST	SEGMENT
??_C@_0DF@DGFGDKCA@Exiting?5debugger?5as?5remote?5clie@ DB 'Exiting debug'
	DB	'ger as remote client closed the socket', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LDLKKDCB@grammar?5?$CC?$CFs?6@
CONST	SEGMENT
??_C@_0N@LDLKKDCB@grammar?5?$CC?$CFs?6@ DB 'grammar "%s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09ILMAJDDB@ANTLR?5?$CFd?6@
CONST	SEGMENT
??_C@_09ILMAJDDB@ANTLR?5?$CFd?6@ DB 'ANTLR %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	08fH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	0adH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	0adH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	0a0H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	087H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	023H
	DB	07bH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	023H
	DB	067H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	023H
	DB	068H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	023H
	DB	063H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	023H
	DB	063H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	023H
	DB	063H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	023H
	DB	063H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	023H
	DB	063H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	023H
	DB	063H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	023H
	DB	063H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	023H
	DB	067H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	023H
	DB	063H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	023H
	DB	067H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	023H
	DW	01f6H
voltbl	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3debughandlers.c
;	COMDAT _serializeNode
_TEXT	SEGMENT
_token$ = -4						; size = 4
_delboy$ = 8						; size = 4
_node$ = 12						; size = 4
_serializeNode PROC					; COMDAT

; 465  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 466  : 	pANTLR3_COMMON_TOKEN	token;
; 467  : 
; 468  : 
; 469  : 	// Do we already have a serialization buffer?
; 470  : 	//
; 471  : 	if	(delboy->tokenString == NULL)

  0000c	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  0000f	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  00013	75 2a		 jne	 SHORT $LN2@serializeN

; 472  : 	{
; 473  : 		// No, so create one, using the string factory that
; 474  : 		// the grammar name used, which is guaranteed to exist.
; 475  : 		// 64 bytes will do us here for starters. 
; 476  : 		//
; 477  : 		delboy->tokenString = delboy->grammarFileName->factory->newSize(delboy->grammarFileName->factory, 64);

  00015	8b f4		 mov	 esi, esp
  00017	6a 40		 push	 64			; 00000040H
  00019	8b 4d 08	 mov	 ecx, DWORD PTR _delboy$[ebp]
  0001c	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0001f	8b 02		 mov	 eax, DWORD PTR [edx]
  00021	50		 push	 eax
  00022	8b 4d 08	 mov	 ecx, DWORD PTR _delboy$[ebp]
  00025	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00028	8b 02		 mov	 eax, DWORD PTR [edx]
  0002a	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0002d	ff d1		 call	 ecx
  0002f	83 c4 08	 add	 esp, 8
  00032	3b f4		 cmp	 esi, esp
  00034	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00039	8b 55 08	 mov	 edx, DWORD PTR _delboy$[ebp]
  0003c	89 42 14	 mov	 DWORD PTR [edx+20], eax
$LN2@serializeN:

; 478  : 	}
; 479  : 
; 480  : 	// Empty string
; 481  : 	//
; 482  : 	delboy->tokenString->set(delboy->tokenString, (const char *)"");

  0003f	8b f4		 mov	 esi, esp
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
  00046	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  00049	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0004c	51		 push	 ecx
  0004d	8b 55 08	 mov	 edx, DWORD PTR _delboy$[ebp]
  00050	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00053	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00056	ff d1		 call	 ecx
  00058	83 c4 08	 add	 esp, 8
  0005b	3b f4		 cmp	 esi, esp
  0005d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 483  : 
; 484  : 	// Protect against bugs/errors etc
; 485  : 	//
; 486  : 	if	(node == NULL)

  00062	83 7d 0c 00	 cmp	 DWORD PTR _node$[ebp], 0
  00066	75 0b		 jne	 SHORT $LN3@serializeN

; 487  : 	{
; 488  : 		return delboy->tokenString;

  00068	8b 55 08	 mov	 edx, DWORD PTR _delboy$[ebp]
  0006b	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0006e	e9 bd 02 00 00	 jmp	 $LN1@serializeN
$LN3@serializeN:

; 489  : 	}
; 490  : 
; 491  : 	// Now we serialize the elements of the node.Note that the debugger only
; 492  : 	// uses 32 bits.
; 493  : 	//
; 494  : 	delboy->tokenString->addc(delboy->tokenString, '\t');

  00073	8b f4		 mov	 esi, esp
  00075	6a 09		 push	 9
  00077	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  0007a	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0007d	51		 push	 ecx
  0007e	8b 55 08	 mov	 edx, DWORD PTR _delboy$[ebp]
  00081	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00084	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  00087	ff d1		 call	 ecx
  00089	83 c4 08	 add	 esp, 8
  0008c	3b f4		 cmp	 esi, esp
  0008e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 495  : 
; 496  : 	// Adaptor ID
; 497  : 	//
; 498  : 	delboy->tokenString->addi(delboy->tokenString, delboy->adaptor->getUniqueID(delboy->adaptor, node));

  00093	8b f4		 mov	 esi, esp
  00095	8b 55 0c	 mov	 edx, DWORD PTR _node$[ebp]
  00098	52		 push	 edx
  00099	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  0009c	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0009f	51		 push	 ecx
  000a0	8b 55 08	 mov	 edx, DWORD PTR _delboy$[ebp]
  000a3	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  000a6	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  000ac	ff d1		 call	 ecx
  000ae	83 c4 08	 add	 esp, 8
  000b1	3b f4		 cmp	 esi, esp
  000b3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b8	8b f4		 mov	 esi, esp
  000ba	50		 push	 eax
  000bb	8b 55 08	 mov	 edx, DWORD PTR _delboy$[ebp]
  000be	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  000c1	50		 push	 eax
  000c2	8b 4d 08	 mov	 ecx, DWORD PTR _delboy$[ebp]
  000c5	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  000c8	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  000cb	ff d0		 call	 eax
  000cd	83 c4 08	 add	 esp, 8
  000d0	3b f4		 cmp	 esi, esp
  000d2	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 499  : 	delboy->tokenString->addc(delboy->tokenString, '\t');

  000d7	8b f4		 mov	 esi, esp
  000d9	6a 09		 push	 9
  000db	8b 4d 08	 mov	 ecx, DWORD PTR _delboy$[ebp]
  000de	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  000e1	52		 push	 edx
  000e2	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  000e5	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000e8	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  000eb	ff d2		 call	 edx
  000ed	83 c4 08	 add	 esp, 8
  000f0	3b f4		 cmp	 esi, esp
  000f2	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 500  : 
; 501  : 	// Type of the current token (which may be imaginary)
; 502  : 	//
; 503  : 	delboy->tokenString->addi(delboy->tokenString, delboy->adaptor->getType(delboy->adaptor, node));

  000f7	8b f4		 mov	 esi, esp
  000f9	8b 45 0c	 mov	 eax, DWORD PTR _node$[ebp]
  000fc	50		 push	 eax
  000fd	8b 4d 08	 mov	 ecx, DWORD PTR _delboy$[ebp]
  00100	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00103	52		 push	 edx
  00104	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  00107	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0010a	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  0010d	ff d2		 call	 edx
  0010f	83 c4 08	 add	 esp, 8
  00112	3b f4		 cmp	 esi, esp
  00114	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00119	8b f4		 mov	 esi, esp
  0011b	50		 push	 eax
  0011c	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  0011f	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00122	51		 push	 ecx
  00123	8b 55 08	 mov	 edx, DWORD PTR _delboy$[ebp]
  00126	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00129	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  0012c	ff d1		 call	 ecx
  0012e	83 c4 08	 add	 esp, 8
  00131	3b f4		 cmp	 esi, esp
  00133	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 504  : 
; 505  : 	// See if we have an actual token or just an imaginary
; 506  : 	//
; 507  : 	token	= delboy->adaptor->getToken(delboy->adaptor, node);

  00138	8b f4		 mov	 esi, esp
  0013a	8b 55 0c	 mov	 edx, DWORD PTR _node$[ebp]
  0013d	52		 push	 edx
  0013e	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  00141	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00144	51		 push	 ecx
  00145	8b 55 08	 mov	 edx, DWORD PTR _delboy$[ebp]
  00148	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0014b	8b 88 8c 00 00
	00		 mov	 ecx, DWORD PTR [eax+140]
  00151	ff d1		 call	 ecx
  00153	83 c4 08	 add	 esp, 8
  00156	3b f4		 cmp	 esi, esp
  00158	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0015d	89 45 fc	 mov	 DWORD PTR _token$[ebp], eax

; 508  : 
; 509  : 	delboy->tokenString->addc(delboy->tokenString, '\t');

  00160	8b f4		 mov	 esi, esp
  00162	6a 09		 push	 9
  00164	8b 55 08	 mov	 edx, DWORD PTR _delboy$[ebp]
  00167	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0016a	50		 push	 eax
  0016b	8b 4d 08	 mov	 ecx, DWORD PTR _delboy$[ebp]
  0016e	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00171	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  00174	ff d0		 call	 eax
  00176	83 c4 08	 add	 esp, 8
  00179	3b f4		 cmp	 esi, esp
  0017b	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 510  : 	if	(token != NULL)

  00180	83 7d fc 00	 cmp	 DWORD PTR _token$[ebp], 0
  00184	0f 84 91 00 00
	00		 je	 $LN4@serializeN

; 511  : 	{
; 512  : 		// Real token
; 513  : 		//
; 514  : 		delboy->tokenString->addi(delboy->tokenString, (ANTLR3_INT32)(token->getLine(token)));

  0018a	8b f4		 mov	 esi, esp
  0018c	8b 4d fc	 mov	 ecx, DWORD PTR _token$[ebp]
  0018f	51		 push	 ecx
  00190	8b 55 fc	 mov	 edx, DWORD PTR _token$[ebp]
  00193	8b 42 5c	 mov	 eax, DWORD PTR [edx+92]
  00196	ff d0		 call	 eax
  00198	83 c4 04	 add	 esp, 4
  0019b	3b f4		 cmp	 esi, esp
  0019d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001a2	8b f4		 mov	 esi, esp
  001a4	50		 push	 eax
  001a5	8b 4d 08	 mov	 ecx, DWORD PTR _delboy$[ebp]
  001a8	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  001ab	52		 push	 edx
  001ac	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  001af	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  001b2	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  001b5	ff d2		 call	 edx
  001b7	83 c4 08	 add	 esp, 8
  001ba	3b f4		 cmp	 esi, esp
  001bc	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 515  : 		delboy->tokenString->addc(delboy->tokenString, ' ');

  001c1	8b f4		 mov	 esi, esp
  001c3	6a 20		 push	 32			; 00000020H
  001c5	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  001c8	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  001cb	51		 push	 ecx
  001cc	8b 55 08	 mov	 edx, DWORD PTR _delboy$[ebp]
  001cf	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  001d2	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  001d5	ff d1		 call	 ecx
  001d7	83 c4 08	 add	 esp, 8
  001da	3b f4		 cmp	 esi, esp
  001dc	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 516  : 		delboy->tokenString->addi(delboy->tokenString, (ANTLR3_INT32)(token->getCharPositionInLine(token)));

  001e1	8b f4		 mov	 esi, esp
  001e3	8b 55 fc	 mov	 edx, DWORD PTR _token$[ebp]
  001e6	52		 push	 edx
  001e7	8b 45 fc	 mov	 eax, DWORD PTR _token$[ebp]
  001ea	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  001ed	ff d1		 call	 ecx
  001ef	83 c4 04	 add	 esp, 4
  001f2	3b f4		 cmp	 esi, esp
  001f4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001f9	8b f4		 mov	 esi, esp
  001fb	50		 push	 eax
  001fc	8b 55 08	 mov	 edx, DWORD PTR _delboy$[ebp]
  001ff	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00202	50		 push	 eax
  00203	8b 4d 08	 mov	 ecx, DWORD PTR _delboy$[ebp]
  00206	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00209	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  0020c	ff d0		 call	 eax
  0020e	83 c4 08	 add	 esp, 8
  00211	3b f4		 cmp	 esi, esp
  00213	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00218	90		 npad	 1

; 517  : 	}

  00219	eb 61		 jmp	 SHORT $LN5@serializeN
$LN4@serializeN:

; 518  : 	else
; 519  : 	{
; 520  : 		// Imaginary tokens have no location
; 521  : 		//
; 522  : 		delboy->tokenString->addi(delboy->tokenString, -1);

  0021b	8b f4		 mov	 esi, esp
  0021d	6a ff		 push	 -1
  0021f	8b 4d 08	 mov	 ecx, DWORD PTR _delboy$[ebp]
  00222	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00225	52		 push	 edx
  00226	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  00229	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0022c	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  0022f	ff d2		 call	 edx
  00231	83 c4 08	 add	 esp, 8
  00234	3b f4		 cmp	 esi, esp
  00236	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 523  : 		delboy->tokenString->addc(delboy->tokenString, '\t');

  0023b	8b f4		 mov	 esi, esp
  0023d	6a 09		 push	 9
  0023f	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  00242	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00245	51		 push	 ecx
  00246	8b 55 08	 mov	 edx, DWORD PTR _delboy$[ebp]
  00249	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0024c	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  0024f	ff d1		 call	 ecx
  00251	83 c4 08	 add	 esp, 8
  00254	3b f4		 cmp	 esi, esp
  00256	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 524  : 		delboy->tokenString->addi(delboy->tokenString, -1);

  0025b	8b f4		 mov	 esi, esp
  0025d	6a ff		 push	 -1
  0025f	8b 55 08	 mov	 edx, DWORD PTR _delboy$[ebp]
  00262	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00265	50		 push	 eax
  00266	8b 4d 08	 mov	 ecx, DWORD PTR _delboy$[ebp]
  00269	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0026c	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  0026f	ff d0		 call	 eax
  00271	83 c4 08	 add	 esp, 8
  00274	3b f4		 cmp	 esi, esp
  00276	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0027b	90		 npad	 1
$LN5@serializeN:

; 525  : 	}
; 526  : 
; 527  : 	// Start Index of the node
; 528  : 	//
; 529  : 	delboy->tokenString->addc(delboy->tokenString, '\t');

  0027c	8b f4		 mov	 esi, esp
  0027e	6a 09		 push	 9
  00280	8b 4d 08	 mov	 ecx, DWORD PTR _delboy$[ebp]
  00283	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00286	52		 push	 edx
  00287	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  0028a	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0028d	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  00290	ff d2		 call	 edx
  00292	83 c4 08	 add	 esp, 8
  00295	3b f4		 cmp	 esi, esp
  00297	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 530  : 	delboy->tokenString->addi(delboy->tokenString, (ANTLR3_UINT32)(delboy->adaptor->getTokenStartIndex(delboy->adaptor, node)));

  0029c	8b f4		 mov	 esi, esp
  0029e	8b 45 0c	 mov	 eax, DWORD PTR _node$[ebp]
  002a1	50		 push	 eax
  002a2	8b 4d 08	 mov	 ecx, DWORD PTR _delboy$[ebp]
  002a5	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  002a8	52		 push	 edx
  002a9	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  002ac	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  002af	8b 91 94 00 00
	00		 mov	 edx, DWORD PTR [ecx+148]
  002b5	ff d2		 call	 edx
  002b7	83 c4 08	 add	 esp, 8
  002ba	3b f4		 cmp	 esi, esp
  002bc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002c1	8b f4		 mov	 esi, esp
  002c3	50		 push	 eax
  002c4	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  002c7	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  002ca	51		 push	 ecx
  002cb	8b 55 08	 mov	 edx, DWORD PTR _delboy$[ebp]
  002ce	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  002d1	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  002d4	ff d1		 call	 ecx
  002d6	83 c4 08	 add	 esp, 8
  002d9	3b f4		 cmp	 esi, esp
  002db	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 531  : 
; 532  : 	// Now send the text that the node represents.
; 533  : 	//
; 534  : 	serializeText(delboy->tokenString, delboy->adaptor->getText(delboy->adaptor, node));

  002e0	8b f4		 mov	 esi, esp
  002e2	8b 55 0c	 mov	 edx, DWORD PTR _node$[ebp]
  002e5	52		 push	 edx
  002e6	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  002e9	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  002ec	51		 push	 ecx
  002ed	8b 55 08	 mov	 edx, DWORD PTR _delboy$[ebp]
  002f0	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  002f3	8b 48 5c	 mov	 ecx, DWORD PTR [eax+92]
  002f6	ff d1		 call	 ecx
  002f8	83 c4 08	 add	 esp, 8
  002fb	3b f4		 cmp	 esi, esp
  002fd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00302	50		 push	 eax
  00303	8b 55 08	 mov	 edx, DWORD PTR _delboy$[ebp]
  00306	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00309	50		 push	 eax
  0030a	e8 00 00 00 00	 call	 _serializeText
  0030f	83 c4 08	 add	 esp, 8

; 535  : 
; 536  : 	// Finally, as the debugger is a Java program it will expect to get UTF-8
; 537  : 	// encoded strings. We don't use UTF-8 internally to the C runtime, so we 
; 538  : 	// must force encode it. We have a method to do this in the string class, but
; 539  : 	// there is no utf8 string implementation as of yet
; 540  : 	//
; 541  : 	return delboy->tokenString->toUTF8(delboy->tokenString);

  00312	8b f4		 mov	 esi, esp
  00314	8b 4d 08	 mov	 ecx, DWORD PTR _delboy$[ebp]
  00317	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0031a	52		 push	 edx
  0031b	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  0031e	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00321	8b 51 64	 mov	 edx, DWORD PTR [ecx+100]
  00324	ff d2		 call	 edx
  00326	83 c4 04	 add	 esp, 4
  00329	3b f4		 cmp	 esi, esp
  0032b	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@serializeN:

; 542  : }

  00330	5e		 pop	 esi
  00331	83 c4 04	 add	 esp, 4
  00334	3b ec		 cmp	 ebp, esp
  00336	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0033b	8b e5		 mov	 esp, ebp
  0033d	5d		 pop	 ebp
  0033e	c3		 ret	 0
_serializeNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3debughandlers.c
;	COMDAT _serializeToken
_TEXT	SEGMENT
_delboy$ = 8						; size = 4
_t$ = 12						; size = 4
_serializeToken PROC					; COMDAT

; 419  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 420  : 	// Do we already have a serialization buffer?
; 421  : 	//
; 422  : 	if	(delboy->tokenString == NULL)

  00004	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  00007	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  0000b	75 2a		 jne	 SHORT $LN2@serializeT

; 423  : 	{
; 424  : 		// No, so create one, using the string factory that
; 425  : 		// the grammar name used, which is guaranteed to exist.
; 426  : 		// 64 bytes will do us here for starters. 
; 427  : 		//
; 428  : 		delboy->tokenString = delboy->grammarFileName->factory->newSize(delboy->grammarFileName->factory, 64);

  0000d	8b f4		 mov	 esi, esp
  0000f	6a 40		 push	 64			; 00000040H
  00011	8b 4d 08	 mov	 ecx, DWORD PTR _delboy$[ebp]
  00014	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00017	8b 02		 mov	 eax, DWORD PTR [edx]
  00019	50		 push	 eax
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR _delboy$[ebp]
  0001d	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00020	8b 02		 mov	 eax, DWORD PTR [edx]
  00022	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00025	ff d1		 call	 ecx
  00027	83 c4 08	 add	 esp, 8
  0002a	3b f4		 cmp	 esi, esp
  0002c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00031	8b 55 08	 mov	 edx, DWORD PTR _delboy$[ebp]
  00034	89 42 14	 mov	 DWORD PTR [edx+20], eax
$LN2@serializeT:

; 429  : 	}
; 430  : 
; 431  : 	// Empty string
; 432  : 	//
; 433  : 	delboy->tokenString->set(delboy->tokenString, (const char *)"");

  00037	8b f4		 mov	 esi, esp
  00039	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
  0003e	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  00041	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00044	51		 push	 ecx
  00045	8b 55 08	 mov	 edx, DWORD PTR _delboy$[ebp]
  00048	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0004b	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0004e	ff d1		 call	 ecx
  00050	83 c4 08	 add	 esp, 8
  00053	3b f4		 cmp	 esi, esp
  00055	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 434  : 
; 435  : 	// Now we serialize the elements of the token.Note that the debugger only
; 436  : 	// uses 32 bits.
; 437  : 	//
; 438  : 	delboy->tokenString->addi(delboy->tokenString, (ANTLR3_INT32)(t->getTokenIndex(t)));

  0005a	8b f4		 mov	 esi, esp
  0005c	8b 55 0c	 mov	 edx, DWORD PTR _t$[ebp]
  0005f	52		 push	 edx
  00060	8b 45 0c	 mov	 eax, DWORD PTR _t$[ebp]
  00063	8b 48 74	 mov	 ecx, DWORD PTR [eax+116]
  00066	ff d1		 call	 ecx
  00068	83 c4 04	 add	 esp, 4
  0006b	3b f4		 cmp	 esi, esp
  0006d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00072	8b f4		 mov	 esi, esp
  00074	50		 push	 eax
  00075	8b 55 08	 mov	 edx, DWORD PTR _delboy$[ebp]
  00078	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0007b	50		 push	 eax
  0007c	8b 4d 08	 mov	 ecx, DWORD PTR _delboy$[ebp]
  0007f	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00082	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  00085	ff d0		 call	 eax
  00087	83 c4 08	 add	 esp, 8
  0008a	3b f4		 cmp	 esi, esp
  0008c	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 439  : 	delboy->tokenString->addc(delboy->tokenString, '\t');

  00091	8b f4		 mov	 esi, esp
  00093	6a 09		 push	 9
  00095	8b 4d 08	 mov	 ecx, DWORD PTR _delboy$[ebp]
  00098	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0009b	52		 push	 edx
  0009c	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  0009f	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000a2	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  000a5	ff d2		 call	 edx
  000a7	83 c4 08	 add	 esp, 8
  000aa	3b f4		 cmp	 esi, esp
  000ac	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 440  : 	delboy->tokenString->addi(delboy->tokenString, (ANTLR3_INT32)(t->getType(t)));

  000b1	8b f4		 mov	 esi, esp
  000b3	8b 45 0c	 mov	 eax, DWORD PTR _t$[ebp]
  000b6	50		 push	 eax
  000b7	8b 4d 0c	 mov	 ecx, DWORD PTR _t$[ebp]
  000ba	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  000bd	ff d2		 call	 edx
  000bf	83 c4 04	 add	 esp, 4
  000c2	3b f4		 cmp	 esi, esp
  000c4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c9	8b f4		 mov	 esi, esp
  000cb	50		 push	 eax
  000cc	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  000cf	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000d2	51		 push	 ecx
  000d3	8b 55 08	 mov	 edx, DWORD PTR _delboy$[ebp]
  000d6	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  000d9	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  000dc	ff d1		 call	 ecx
  000de	83 c4 08	 add	 esp, 8
  000e1	3b f4		 cmp	 esi, esp
  000e3	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 441  : 	delboy->tokenString->addc(delboy->tokenString, '\t');

  000e8	8b f4		 mov	 esi, esp
  000ea	6a 09		 push	 9
  000ec	8b 55 08	 mov	 edx, DWORD PTR _delboy$[ebp]
  000ef	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  000f2	50		 push	 eax
  000f3	8b 4d 08	 mov	 ecx, DWORD PTR _delboy$[ebp]
  000f6	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  000f9	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  000fc	ff d0		 call	 eax
  000fe	83 c4 08	 add	 esp, 8
  00101	3b f4		 cmp	 esi, esp
  00103	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 442  : 	delboy->tokenString->addi(delboy->tokenString, (ANTLR3_INT32)(t->getChannel(t)));

  00108	8b f4		 mov	 esi, esp
  0010a	8b 4d 0c	 mov	 ecx, DWORD PTR _t$[ebp]
  0010d	51		 push	 ecx
  0010e	8b 55 0c	 mov	 edx, DWORD PTR _t$[ebp]
  00111	8b 42 6c	 mov	 eax, DWORD PTR [edx+108]
  00114	ff d0		 call	 eax
  00116	83 c4 04	 add	 esp, 4
  00119	3b f4		 cmp	 esi, esp
  0011b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00120	8b f4		 mov	 esi, esp
  00122	50		 push	 eax
  00123	8b 4d 08	 mov	 ecx, DWORD PTR _delboy$[ebp]
  00126	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00129	52		 push	 edx
  0012a	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  0012d	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00130	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  00133	ff d2		 call	 edx
  00135	83 c4 08	 add	 esp, 8
  00138	3b f4		 cmp	 esi, esp
  0013a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 443  : 	delboy->tokenString->addc(delboy->tokenString, '\t');

  0013f	8b f4		 mov	 esi, esp
  00141	6a 09		 push	 9
  00143	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  00146	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00149	51		 push	 ecx
  0014a	8b 55 08	 mov	 edx, DWORD PTR _delboy$[ebp]
  0014d	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00150	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  00153	ff d1		 call	 ecx
  00155	83 c4 08	 add	 esp, 8
  00158	3b f4		 cmp	 esi, esp
  0015a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 444  : 	delboy->tokenString->addi(delboy->tokenString, (ANTLR3_INT32)(t->getLine(t)));

  0015f	8b f4		 mov	 esi, esp
  00161	8b 55 0c	 mov	 edx, DWORD PTR _t$[ebp]
  00164	52		 push	 edx
  00165	8b 45 0c	 mov	 eax, DWORD PTR _t$[ebp]
  00168	8b 48 5c	 mov	 ecx, DWORD PTR [eax+92]
  0016b	ff d1		 call	 ecx
  0016d	83 c4 04	 add	 esp, 4
  00170	3b f4		 cmp	 esi, esp
  00172	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00177	8b f4		 mov	 esi, esp
  00179	50		 push	 eax
  0017a	8b 55 08	 mov	 edx, DWORD PTR _delboy$[ebp]
  0017d	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00180	50		 push	 eax
  00181	8b 4d 08	 mov	 ecx, DWORD PTR _delboy$[ebp]
  00184	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00187	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  0018a	ff d0		 call	 eax
  0018c	83 c4 08	 add	 esp, 8
  0018f	3b f4		 cmp	 esi, esp
  00191	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 445  : 	delboy->tokenString->addc(delboy->tokenString, '\t');

  00196	8b f4		 mov	 esi, esp
  00198	6a 09		 push	 9
  0019a	8b 4d 08	 mov	 ecx, DWORD PTR _delboy$[ebp]
  0019d	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  001a0	52		 push	 edx
  001a1	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  001a4	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  001a7	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  001aa	ff d2		 call	 edx
  001ac	83 c4 08	 add	 esp, 8
  001af	3b f4		 cmp	 esi, esp
  001b1	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 446  : 	delboy->tokenString->addi(delboy->tokenString, (ANTLR3_INT32)(t->getCharPositionInLine(t)));

  001b6	8b f4		 mov	 esi, esp
  001b8	8b 45 0c	 mov	 eax, DWORD PTR _t$[ebp]
  001bb	50		 push	 eax
  001bc	8b 4d 0c	 mov	 ecx, DWORD PTR _t$[ebp]
  001bf	8b 51 64	 mov	 edx, DWORD PTR [ecx+100]
  001c2	ff d2		 call	 edx
  001c4	83 c4 04	 add	 esp, 4
  001c7	3b f4		 cmp	 esi, esp
  001c9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001ce	8b f4		 mov	 esi, esp
  001d0	50		 push	 eax
  001d1	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  001d4	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  001d7	51		 push	 ecx
  001d8	8b 55 08	 mov	 edx, DWORD PTR _delboy$[ebp]
  001db	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  001de	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  001e1	ff d1		 call	 ecx
  001e3	83 c4 08	 add	 esp, 8
  001e6	3b f4		 cmp	 esi, esp
  001e8	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 447  : 
; 448  : 	// Now send the text that the token represents.
; 449  : 	//
; 450  : 	serializeText(delboy->tokenString, t->getText(t));

  001ed	8b f4		 mov	 esi, esp
  001ef	8b 55 0c	 mov	 edx, DWORD PTR _t$[ebp]
  001f2	52		 push	 edx
  001f3	8b 45 0c	 mov	 eax, DWORD PTR _t$[ebp]
  001f6	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  001f9	ff d1		 call	 ecx
  001fb	83 c4 04	 add	 esp, 4
  001fe	3b f4		 cmp	 esi, esp
  00200	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00205	50		 push	 eax
  00206	8b 55 08	 mov	 edx, DWORD PTR _delboy$[ebp]
  00209	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0020c	50		 push	 eax
  0020d	e8 00 00 00 00	 call	 _serializeText
  00212	83 c4 08	 add	 esp, 8

; 451  : 
; 452  : 	// Finally, as the debugger is a Java program it will expect to get UTF-8
; 453  : 	// encoded strings. We don't use UTF-8 internally to the C runtime, so we 
; 454  : 	// must force encode it. We have a method to do this in the string class, but
; 455  : 	// it returns malloc space that we must free afterwards.
; 456  : 	//
; 457  : 	return delboy->tokenString->toUTF8(delboy->tokenString);

  00215	8b f4		 mov	 esi, esp
  00217	8b 4d 08	 mov	 ecx, DWORD PTR _delboy$[ebp]
  0021a	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0021d	52		 push	 edx
  0021e	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  00221	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00224	8b 51 64	 mov	 edx, DWORD PTR [ecx+100]
  00227	ff d2		 call	 edx
  00229	83 c4 04	 add	 esp, 4
  0022c	3b f4		 cmp	 esi, esp
  0022e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 458  : }

  00233	5e		 pop	 esi
  00234	3b ec		 cmp	 ebp, esp
  00236	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0023b	5d		 pop	 ebp
  0023c	c3		 ret	 0
_serializeToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3debughandlers.c
;	COMDAT _serializeText
_TEXT	SEGMENT
tv75 = -12						; size = 4
_character$ = -8					; size = 4
_c$ = -4						; size = 4
_buffer$ = 8						; size = 4
_text$ = 12						; size = 4
_serializeText PROC					; COMDAT

; 366  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000e	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00015	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 367  : 	ANTLR3_UINT32	c;
; 368  : 	ANTLR3_UCHAR	character;
; 369  : 
; 370  : 	// strings lead in with a "
; 371  : 	//
; 372  : 	buffer->append(buffer, "\t\"");

  0001c	8b f4		 mov	 esi, esp
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_02KINNFLEC@?7?$CC@
  00023	8b 45 08	 mov	 eax, DWORD PTR _buffer$[ebp]
  00026	50		 push	 eax
  00027	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  0002a	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  0002d	ff d2		 call	 edx
  0002f	83 c4 08	 add	 esp, 8
  00032	3b f4		 cmp	 esi, esp
  00034	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 373  : 
; 374  : 	if	(text == NULL)

  00039	83 7d 0c 00	 cmp	 DWORD PTR _text$[ebp], 0
  0003d	75 05		 jne	 SHORT $LN7@serializeT

; 375  : 	{
; 376  : 		return;

  0003f	e9 dc 00 00 00	 jmp	 $LN3@serializeT
$LN7@serializeT:

; 377  : 	}
; 378  : 
; 379  : 	// Now we replace linefeeds, newlines and the escape
; 380  : 	// leadin character '%' with their hex equivalents
; 381  : 	// prefixed by '%'
; 382  : 	//
; 383  : 	for	(c = 0; c < text->len; c++)

  00044	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _c$[ebp], 0
  0004b	eb 09		 jmp	 SHORT $LN4@serializeT
$LN2@serializeT:
  0004d	8b 45 fc	 mov	 eax, DWORD PTR _c$[ebp]
  00050	83 c0 01	 add	 eax, 1
  00053	89 45 fc	 mov	 DWORD PTR _c$[ebp], eax
$LN4@serializeT:
  00056	8b 4d 0c	 mov	 ecx, DWORD PTR _text$[ebp]
  00059	8b 55 fc	 mov	 edx, DWORD PTR _c$[ebp]
  0005c	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0005f	0f 83 bb 00 00
	00		 jae	 $LN3@serializeT

; 384  : 	{
; 385  : 		switch	(character = text->charAt(text, c))

  00065	8b f4		 mov	 esi, esp
  00067	8b 45 fc	 mov	 eax, DWORD PTR _c$[ebp]
  0006a	50		 push	 eax
  0006b	8b 4d 0c	 mov	 ecx, DWORD PTR _text$[ebp]
  0006e	51		 push	 ecx
  0006f	8b 55 0c	 mov	 edx, DWORD PTR _text$[ebp]
  00072	8b 42 54	 mov	 eax, DWORD PTR [edx+84]
  00075	ff d0		 call	 eax
  00077	83 c4 08	 add	 esp, 8
  0007a	3b f4		 cmp	 esi, esp
  0007c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00081	89 45 f8	 mov	 DWORD PTR _character$[ebp], eax
  00084	8b 4d f8	 mov	 ecx, DWORD PTR _character$[ebp]
  00087	89 4d f4	 mov	 DWORD PTR tv75[ebp], ecx
  0008a	83 7d f4 0a	 cmp	 DWORD PTR tv75[ebp], 10	; 0000000aH
  0008e	74 0e		 je	 SHORT $LN8@serializeT
  00090	83 7d f4 0d	 cmp	 DWORD PTR tv75[ebp], 13	; 0000000dH
  00094	74 28		 je	 SHORT $LN9@serializeT
  00096	83 7d f4 5c	 cmp	 DWORD PTR tv75[ebp], 92	; 0000005cH
  0009a	74 42		 je	 SHORT $LN10@serializeT
  0009c	eb 60		 jmp	 SHORT $LN11@serializeT
$LN8@serializeT:

; 386  : 		{
; 387  : 			case	'\n':
; 388  : 
; 389  : 				buffer->append(buffer, "%0A");

  0009e	8b f4		 mov	 esi, esp
  000a0	68 00 00 00 00	 push	 OFFSET ??_C@_03IEFOOEDL@?$CF0A@
  000a5	8b 55 08	 mov	 edx, DWORD PTR _buffer$[ebp]
  000a8	52		 push	 edx
  000a9	8b 45 08	 mov	 eax, DWORD PTR _buffer$[ebp]
  000ac	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  000af	ff d1		 call	 ecx
  000b1	83 c4 08	 add	 esp, 8
  000b4	3b f4		 cmp	 esi, esp
  000b6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bb	90		 npad	 1

; 390  : 				break;

  000bc	eb 5d		 jmp	 SHORT $LN5@serializeT
$LN9@serializeT:

; 391  : 
; 392  : 			case	'\r':
; 393  : 			
; 394  : 				buffer->append(buffer, "%0D");

  000be	8b f4		 mov	 esi, esp
  000c0	68 00 00 00 00	 push	 OFFSET ??_C@_03PJCJBAHO@?$CF0D@
  000c5	8b 55 08	 mov	 edx, DWORD PTR _buffer$[ebp]
  000c8	52		 push	 edx
  000c9	8b 45 08	 mov	 eax, DWORD PTR _buffer$[ebp]
  000cc	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  000cf	ff d1		 call	 ecx
  000d1	83 c4 08	 add	 esp, 8
  000d4	3b f4		 cmp	 esi, esp
  000d6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000db	90		 npad	 1

; 395  : 				break;

  000dc	eb 3d		 jmp	 SHORT $LN5@serializeT
$LN10@serializeT:

; 396  : 
; 397  : 			case	'\\':
; 398  : 
; 399  : 				buffer->append(buffer, "%25");

  000de	8b f4		 mov	 esi, esp
  000e0	68 00 00 00 00	 push	 OFFSET ??_C@_03MMIJIMKH@?$CF25@
  000e5	8b 55 08	 mov	 edx, DWORD PTR _buffer$[ebp]
  000e8	52		 push	 edx
  000e9	8b 45 08	 mov	 eax, DWORD PTR _buffer$[ebp]
  000ec	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  000ef	ff d1		 call	 ecx
  000f1	83 c4 08	 add	 esp, 8
  000f4	3b f4		 cmp	 esi, esp
  000f6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000fb	90		 npad	 1

; 400  : 				break;

  000fc	eb 1d		 jmp	 SHORT $LN5@serializeT
$LN11@serializeT:

; 401  : 
; 402  : 				// Other characters: The Song Remains the Same.
; 403  : 				//
; 404  : 			default:
; 405  : 					
; 406  : 				buffer->addc(buffer, character);

  000fe	8b f4		 mov	 esi, esp
  00100	8b 55 f8	 mov	 edx, DWORD PTR _character$[ebp]
  00103	52		 push	 edx
  00104	8b 45 08	 mov	 eax, DWORD PTR _buffer$[ebp]
  00107	50		 push	 eax
  00108	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  0010b	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  0010e	ff d2		 call	 edx
  00110	83 c4 08	 add	 esp, 8
  00113	3b f4		 cmp	 esi, esp
  00115	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0011a	90		 npad	 1
$LN5@serializeT:

; 407  : 				break;
; 408  : 		}
; 409  : 	}

  0011b	e9 2d ff ff ff	 jmp	 $LN2@serializeT
$LN3@serializeT:

; 410  : }

  00120	5e		 pop	 esi
  00121	83 c4 0c	 add	 esp, 12			; 0000000cH
  00124	3b ec		 cmp	 ebp, esp
  00126	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0012b	8b e5		 mov	 esp, ebp
  0012d	5d		 pop	 ebp
  0012e	c3		 ret	 0
_serializeText ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3debughandlers.c
;	COMDAT _transmit
_TEXT	SEGMENT
_delboy$ = 8						; size = 4
_ptr$ = 12						; size = 4
_transmit PROC						; COMDAT

; 324  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 325  : 	sockSend(delboy->socket, ptr, (int)strlen(ptr));

  00003	8b 45 0c	 mov	 eax, DWORD PTR _ptr$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 _strlen
  0000c	83 c4 04	 add	 esp, 4
  0000f	50		 push	 eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR _ptr$[ebp]
  00013	51		 push	 ecx
  00014	8b 55 08	 mov	 edx, DWORD PTR _delboy$[ebp]
  00017	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 _sockSend
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 326  : 	ack(delboy);

  00023	8b 4d 08	 mov	 ecx, DWORD PTR _delboy$[ebp]
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 _ack
  0002c	83 c4 04	 add	 esp, 4

; 327  : }

  0002f	3b ec		 cmp	 ebp, esp
  00031	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
_transmit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3debughandlers.c
;	COMDAT _sockSend
_TEXT	SEGMENT
_thisSend$ = -8						; size = 4
_sent$ = -4						; size = 4
_sock$ = 8						; size = 4
_ptr$ = 12						; size = 4
_len$ = 16						; size = 4
_sockSend PROC						; COMDAT

; 166  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 167  : 	int		sent;
; 168  : 	int		thisSend;
; 169  : 
; 170  : 	sent	= 0;

  00014	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _sent$[ebp], 0
$LN2@sockSend:

; 171  : 		
; 172  : 	while	(sent < len)

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _sent$[ebp]
  0001e	3b 45 10	 cmp	 eax, DWORD PTR _len$[ebp]
  00021	7d 37		 jge	 SHORT $LN3@sockSend

; 173  : 	{
; 174  : 		// Send as many bytes as we can
; 175  : 		//
; 176  : 		thisSend =	send(sock, ptr, len - sent, 0);

  00023	6a 00		 push	 0
  00025	8b 4d 10	 mov	 ecx, DWORD PTR _len$[ebp]
  00028	2b 4d fc	 sub	 ecx, DWORD PTR _sent$[ebp]
  0002b	51		 push	 ecx
  0002c	8b 55 0c	 mov	 edx, DWORD PTR _ptr$[ebp]
  0002f	52		 push	 edx
  00030	8b 45 08	 mov	 eax, DWORD PTR _sock$[ebp]
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 _send@16
  00039	89 45 f8	 mov	 DWORD PTR _thisSend$[ebp], eax

; 177  : 
; 178  : 		// Check for errors and tell the user if we got one
; 179  : 		//
; 180  : 		if	(thisSend	== -1)

  0003c	83 7d f8 ff	 cmp	 DWORD PTR _thisSend$[ebp], -1
  00040	75 04		 jne	 SHORT $LN4@sockSend

; 181  : 		{
; 182  : 			return	ANTLR3_FALSE;

  00042	33 c0		 xor	 eax, eax
  00044	eb 19		 jmp	 SHORT $LN1@sockSend
$LN4@sockSend:

; 183  : 		}
; 184  : 
; 185  : 		// Increment our offset by how many we were able to send
; 186  : 		//
; 187  : 		ptr			+= thisSend;

  00046	8b 4d 0c	 mov	 ecx, DWORD PTR _ptr$[ebp]
  00049	03 4d f8	 add	 ecx, DWORD PTR _thisSend$[ebp]
  0004c	89 4d 0c	 mov	 DWORD PTR _ptr$[ebp], ecx

; 188  : 		sent		+= thisSend;

  0004f	8b 55 fc	 mov	 edx, DWORD PTR _sent$[ebp]
  00052	03 55 f8	 add	 edx, DWORD PTR _thisSend$[ebp]
  00055	89 55 fc	 mov	 DWORD PTR _sent$[ebp], edx

; 189  : 	}

  00058	eb c1		 jmp	 SHORT $LN2@sockSend
$LN3@sockSend:

; 190  : 	return	ANTLR3_TRUE;

  0005a	b8 01 00 00 00	 mov	 eax, 1
$LN1@sockSend:

; 191  : }

  0005f	83 c4 08	 add	 esp, 8
  00062	3b ec		 cmp	 ebp, esp
  00064	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
_sockSend ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3debughandlers.c
;	COMDAT _antlr3DebugListenerNewPort
_TEXT	SEGMENT
_delboy$ = -4						; size = 4
_port$ = 8						; size = 4
_antlr3DebugListenerNewPort PROC			; COMDAT

; 148  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 149  : 	pANTLR3_DEBUG_EVENT_LISTENER	delboy;
; 150  : 
; 151  : 	delboy		 = antlr3DebugListenerNew();

  0000b	e8 00 00 00 00	 call	 _antlr3DebugListenerNew
  00010	89 45 fc	 mov	 DWORD PTR _delboy$[ebp], eax

; 152  : 
; 153  : 	if	(delboy != NULL)

  00013	83 7d fc 00	 cmp	 DWORD PTR _delboy$[ebp], 0
  00017	74 08		 je	 SHORT $LN2@antlr3Debu

; 154  : 	{
; 155  : 		delboy->port = port;

  00019	8b 45 fc	 mov	 eax, DWORD PTR _delboy$[ebp]
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR _port$[ebp]
  0001f	89 08		 mov	 DWORD PTR [eax], ecx
$LN2@antlr3Debu:

; 156  : 	}
; 157  : 
; 158  : 	return delboy;

  00021	8b 45 fc	 mov	 eax, DWORD PTR _delboy$[ebp]

; 159  : }

  00024	83 c4 04	 add	 esp, 4
  00027	3b ec		 cmp	 ebp, esp
  00029	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
_antlr3DebugListenerNewPort ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3debughandlers.c
;	COMDAT _ack
_TEXT	SEGMENT
_rCount$ = -16						; size = 4
_buffer$ = -5						; size = 1
_delboy$ = 8						; size = 4
_ack	PROC						; COMDAT

; 331  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000f	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00012	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00015	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
$LN4@ack:

; 332  : 	// Local buffer to read the next character in to
; 333  : 	//
; 334  : 	char	buffer;
; 335  : 	int		rCount;
; 336  : 
; 337  : 	// Ack terminates in a line feed, so we just wait for
; 338  : 	// one of those. Speed is not of the essence so we don't need
; 339  : 	// to buffer the input or anything.
; 340  : 	//
; 341  : 	do
; 342  : 	{
; 343  : 		rCount = recv(delboy->socket, &buffer, 1, 0);

  00018	6a 00		 push	 0
  0001a	6a 01		 push	 1
  0001c	8d 45 fb	 lea	 eax, DWORD PTR _buffer$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d 08	 mov	 ecx, DWORD PTR _delboy$[ebp]
  00023	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00026	52		 push	 edx
  00027	e8 00 00 00 00	 call	 _recv@16
  0002c	89 45 f0	 mov	 DWORD PTR _rCount$[ebp], eax

; 344  : 	}
; 345  : 	while	(rCount == 1 && buffer != '\n');

  0002f	83 7d f0 01	 cmp	 DWORD PTR _rCount$[ebp], 1
  00033	75 09		 jne	 SHORT $LN5@ack
  00035	0f be 45 fb	 movsx	 eax, BYTE PTR _buffer$[ebp]
  00039	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0003c	75 da		 jne	 SHORT $LN4@ack
$LN5@ack:

; 346  : 
; 347  : 	// If the socket ws closed on us, then we will get an error or
; 348  : 	// (with a graceful close), 0. We can assume the the debugger stopped for some reason
; 349  : 	// (such as Java crashing again). Therefore we just exit the program
; 350  : 	// completely if we don't get the terminating '\n' for the ack.
; 351  : 	//
; 352  : 	if	(rCount != 1)

  0003e	83 7d f0 01	 cmp	 DWORD PTR _rCount$[ebp], 1
  00042	74 35		 je	 SHORT $LN6@ack

; 353  : 	{
; 354  : 		ANTLR3_PRINTF("Exiting debugger as remote client closed the socket\n");

  00044	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@DGFGDKCA@Exiting?5debugger?5as?5remote?5clie@
  00049	e8 00 00 00 00	 call	 _printf
  0004e	83 c4 04	 add	 esp, 4

; 355  : 		ANTLR3_PRINTF("Received char count was %d, and last char received was %02X\n", rCount, buffer);

  00051	0f be 4d fb	 movsx	 ecx, BYTE PTR _buffer$[ebp]
  00055	51		 push	 ecx
  00056	8b 55 f0	 mov	 edx, DWORD PTR _rCount$[ebp]
  00059	52		 push	 edx
  0005a	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@JOJNMFAB@Received?5char?5count?5was?5?$CFd?0?5and@
  0005f	e8 00 00 00 00	 call	 _printf
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH

; 356  : 		exit(0);

  00067	8b f4		 mov	 esi, esp
  00069	6a 00		 push	 0
  0006b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
  00071	3b f4		 cmp	 esi, esp
  00073	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00078	90		 npad	 1
$LN6@ack:

; 357  : 	}
; 358  : }

  00079	52		 push	 edx
  0007a	8b cd		 mov	 ecx, ebp
  0007c	50		 push	 eax
  0007d	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN10@ack
  00083	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00088	58		 pop	 eax
  00089	5a		 pop	 edx
  0008a	5e		 pop	 esi
  0008b	83 c4 10	 add	 esp, 16			; 00000010H
  0008e	3b ec		 cmp	 ebp, esp
  00090	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00095	8b e5		 mov	 esp, ebp
  00097	5d		 pop	 ebp
  00098	c3		 ret	 0
  00099	0f 1f 00	 npad	 3
$LN10@ack:
  0009c	01 00 00 00	 DD	 1
  000a0	00 00 00 00	 DD	 $LN9@ack
$LN9@ack:
  000a4	fb ff ff ff	 DD	 -5			; fffffffbH
  000a8	01 00 00 00	 DD	 1
  000ac	00 00 00 00	 DD	 $LN8@ack
$LN8@ack:
  000b0	62		 DB	 98			; 00000062H
  000b1	75		 DB	 117			; 00000075H
  000b2	66		 DB	 102			; 00000066H
  000b3	66		 DB	 102			; 00000066H
  000b4	65		 DB	 101			; 00000065H
  000b5	72		 DB	 114			; 00000072H
  000b6	00		 DB	 0
_ack	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3debughandlers.c
;	COMDAT _setTokenBoundaries
_TEXT	SEGMENT
_buffer$ = -136						; size = 128
__$ArrayPad$ = -4					; size = 4
_delboy$ = 8						; size = 4
_t$ = 12						; size = 4
_tokenStartIndex$ = 16					; size = 4
_tokenStopIndex$ = 20					; size = 4
_setTokenBoundaries PROC				; COMDAT

; 1037 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 8c 00 00
	00		 sub	 esp, 140		; 0000008cH
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8d bd 74 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-140]
  00011	b9 23 00 00 00	 mov	 ecx, 35			; 00000023H
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1038 : 	char	buffer[128];
; 1039 : 
; 1040 : 	sprintf(buffer, "becomeRoot\t%d\t%d\t%d\n",	delboy->adaptor->getUniqueID(delboy->adaptor, t),

  00027	8b 45 14	 mov	 eax, DWORD PTR _tokenStopIndex$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 10	 mov	 ecx, DWORD PTR _tokenStartIndex$[ebp]
  0002e	51		 push	 ecx
  0002f	8b f4		 mov	 esi, esp
  00031	8b 55 0c	 mov	 edx, DWORD PTR _t$[ebp]
  00034	52		 push	 edx
  00035	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  00038	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0003b	51		 push	 ecx
  0003c	8b 55 08	 mov	 edx, DWORD PTR _delboy$[ebp]
  0003f	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00042	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  00048	ff d1		 call	 ecx
  0004a	83 c4 08	 add	 esp, 8
  0004d	3b f4		 cmp	 esi, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00054	50		 push	 eax
  00055	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@NJPIKMHA@becomeRoot?7?$CFd?7?$CFd?7?$CFd?6@
  0005a	8d 95 78 ff ff
	ff		 lea	 edx, DWORD PTR _buffer$[ebp]
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 _sprintf
  00066	83 c4 14	 add	 esp, 20			; 00000014H

; 1041 : 												(ANTLR3_UINT32)tokenStartIndex,
; 1042 : 												(ANTLR3_UINT32)tokenStopIndex
; 1043 : 											);
; 1044 : 	transmit(delboy, buffer);

  00069	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _buffer$[ebp]
  0006f	50		 push	 eax
  00070	8b 4d 08	 mov	 ecx, DWORD PTR _delboy$[ebp]
  00073	51		 push	 ecx
  00074	e8 00 00 00 00	 call	 _transmit
  00079	83 c4 08	 add	 esp, 8

; 1045 : }

  0007c	52		 push	 edx
  0007d	8b cd		 mov	 ecx, ebp
  0007f	50		 push	 eax
  00080	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@setTokenBo
  00086	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0008b	58		 pop	 eax
  0008c	5a		 pop	 edx
  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi
  0008f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00092	33 cd		 xor	 ecx, ebp
  00094	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00099	81 c4 8c 00 00
	00		 add	 esp, 140		; 0000008cH
  0009f	3b ec		 cmp	 ebp, esp
  000a1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a6	8b e5		 mov	 esp, ebp
  000a8	5d		 pop	 ebp
  000a9	c3		 ret	 0
  000aa	66 90		 npad	 2
$LN5@setTokenBo:
  000ac	01 00 00 00	 DD	 1
  000b0	00 00 00 00	 DD	 $LN4@setTokenBo
$LN4@setTokenBo:
  000b4	78 ff ff ff	 DD	 -136			; ffffff78H
  000b8	80 00 00 00	 DD	 128			; 00000080H
  000bc	00 00 00 00	 DD	 $LN3@setTokenBo
$LN3@setTokenBo:
  000c0	62		 DB	 98			; 00000062H
  000c1	75		 DB	 117			; 00000075H
  000c2	66		 DB	 102			; 00000066H
  000c3	66		 DB	 102			; 00000066H
  000c4	65		 DB	 101			; 00000065H
  000c5	72		 DB	 114			; 00000072H
  000c6	00		 DB	 0
_setTokenBoundaries ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3debughandlers.c
;	COMDAT _addChild
_TEXT	SEGMENT
_buffer$ = -136						; size = 128
__$ArrayPad$ = -4					; size = 4
_delboy$ = 8						; size = 4
_root$ = 12						; size = 4
_child$ = 16						; size = 4
_addChild PROC						; COMDAT

; 1026 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 8c 00 00
	00		 sub	 esp, 140		; 0000008cH
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8d bd 74 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-140]
  00011	b9 23 00 00 00	 mov	 ecx, 35			; 00000023H
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1027 : 	char	buffer[128];
; 1028 : 
; 1029 : 	sprintf(buffer, "addChild\t%d\t%d\n",	delboy->adaptor->getUniqueID(delboy->adaptor, root),

  00027	8b f4		 mov	 esi, esp
  00029	8b 45 10	 mov	 eax, DWORD PTR _child$[ebp]
  0002c	50		 push	 eax
  0002d	8b 4d 08	 mov	 ecx, DWORD PTR _delboy$[ebp]
  00030	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00033	52		 push	 edx
  00034	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  00037	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0003a	8b 91 80 00 00
	00		 mov	 edx, DWORD PTR [ecx+128]
  00040	ff d2		 call	 edx
  00042	83 c4 08	 add	 esp, 8
  00045	3b f4		 cmp	 esi, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	50		 push	 eax
  0004d	8b f4		 mov	 esi, esp
  0004f	8b 45 0c	 mov	 eax, DWORD PTR _root$[ebp]
  00052	50		 push	 eax
  00053	8b 4d 08	 mov	 ecx, DWORD PTR _delboy$[ebp]
  00056	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00059	52		 push	 edx
  0005a	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  0005d	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00060	8b 91 80 00 00
	00		 mov	 edx, DWORD PTR [ecx+128]
  00066	ff d2		 call	 edx
  00068	83 c4 08	 add	 esp, 8
  0006b	3b f4		 cmp	 esi, esp
  0006d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00072	50		 push	 eax
  00073	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@CIOIAFCB@addChild?7?$CFd?7?$CFd?6@
  00078	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _buffer$[ebp]
  0007e	50		 push	 eax
  0007f	e8 00 00 00 00	 call	 _sprintf
  00084	83 c4 10	 add	 esp, 16			; 00000010H

; 1030 : 											delboy->adaptor->getUniqueID(delboy->adaptor, child)
; 1031 : 											);
; 1032 : 	transmit(delboy, buffer);

  00087	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _buffer$[ebp]
  0008d	51		 push	 ecx
  0008e	8b 55 08	 mov	 edx, DWORD PTR _delboy$[ebp]
  00091	52		 push	 edx
  00092	e8 00 00 00 00	 call	 _transmit
  00097	83 c4 08	 add	 esp, 8

; 1033 : }

  0009a	52		 push	 edx
  0009b	8b cd		 mov	 ecx, ebp
  0009d	50		 push	 eax
  0009e	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@addChild
  000a4	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000a9	58		 pop	 eax
  000aa	5a		 pop	 edx
  000ab	5f		 pop	 edi
  000ac	5e		 pop	 esi
  000ad	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b0	33 cd		 xor	 ecx, ebp
  000b2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b7	81 c4 8c 00 00
	00		 add	 esp, 140		; 0000008cH
  000bd	3b ec		 cmp	 ebp, esp
  000bf	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c4	8b e5		 mov	 esp, ebp
  000c6	5d		 pop	 ebp
  000c7	c3		 ret	 0
$LN5@addChild:
  000c8	01 00 00 00	 DD	 1
  000cc	00 00 00 00	 DD	 $LN4@addChild
$LN4@addChild:
  000d0	78 ff ff ff	 DD	 -136			; ffffff78H
  000d4	80 00 00 00	 DD	 128			; 00000080H
  000d8	00 00 00 00	 DD	 $LN3@addChild
$LN3@addChild:
  000dc	62		 DB	 98			; 00000062H
  000dd	75		 DB	 117			; 00000075H
  000de	66		 DB	 102			; 00000066H
  000df	66		 DB	 102			; 00000066H
  000e0	65		 DB	 101			; 00000065H
  000e1	72		 DB	 114			; 00000072H
  000e2	00		 DB	 0
_addChild ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3debughandlers.c
;	COMDAT _becomeRoot
_TEXT	SEGMENT
_buffer$ = -136						; size = 128
__$ArrayPad$ = -4					; size = 4
_delboy$ = 8						; size = 4
_newRoot$ = 12						; size = 4
_oldRoot$ = 16						; size = 4
_becomeRoot PROC					; COMDAT

; 1014 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 8c 00 00
	00		 sub	 esp, 140		; 0000008cH
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8d bd 74 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-140]
  00011	b9 23 00 00 00	 mov	 ecx, 35			; 00000023H
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1015 : 	char	buffer[128];
; 1016 : 
; 1017 : 	sprintf(buffer, "becomeRoot\t%d\t%d\n",	delboy->adaptor->getUniqueID(delboy->adaptor, newRoot),

  00027	8b f4		 mov	 esi, esp
  00029	8b 45 10	 mov	 eax, DWORD PTR _oldRoot$[ebp]
  0002c	50		 push	 eax
  0002d	8b 4d 08	 mov	 ecx, DWORD PTR _delboy$[ebp]
  00030	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00033	52		 push	 edx
  00034	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  00037	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0003a	8b 91 80 00 00
	00		 mov	 edx, DWORD PTR [ecx+128]
  00040	ff d2		 call	 edx
  00042	83 c4 08	 add	 esp, 8
  00045	3b f4		 cmp	 esi, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	50		 push	 eax
  0004d	8b f4		 mov	 esi, esp
  0004f	8b 45 0c	 mov	 eax, DWORD PTR _newRoot$[ebp]
  00052	50		 push	 eax
  00053	8b 4d 08	 mov	 ecx, DWORD PTR _delboy$[ebp]
  00056	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00059	52		 push	 edx
  0005a	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  0005d	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00060	8b 91 80 00 00
	00		 mov	 edx, DWORD PTR [ecx+128]
  00066	ff d2		 call	 edx
  00068	83 c4 08	 add	 esp, 8
  0006b	3b f4		 cmp	 esi, esp
  0006d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00072	50		 push	 eax
  00073	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@HDNJJMMJ@becomeRoot?7?$CFd?7?$CFd?6@
  00078	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _buffer$[ebp]
  0007e	50		 push	 eax
  0007f	e8 00 00 00 00	 call	 _sprintf
  00084	83 c4 10	 add	 esp, 16			; 00000010H

; 1018 : 											delboy->adaptor->getUniqueID(delboy->adaptor, oldRoot)
; 1019 : 											);
; 1020 : 	transmit(delboy, buffer);

  00087	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _buffer$[ebp]
  0008d	51		 push	 ecx
  0008e	8b 55 08	 mov	 edx, DWORD PTR _delboy$[ebp]
  00091	52		 push	 edx
  00092	e8 00 00 00 00	 call	 _transmit
  00097	83 c4 08	 add	 esp, 8

; 1021 : }

  0009a	52		 push	 edx
  0009b	8b cd		 mov	 ecx, ebp
  0009d	50		 push	 eax
  0009e	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@becomeRoot
  000a4	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000a9	58		 pop	 eax
  000aa	5a		 pop	 edx
  000ab	5f		 pop	 edi
  000ac	5e		 pop	 esi
  000ad	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b0	33 cd		 xor	 ecx, ebp
  000b2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b7	81 c4 8c 00 00
	00		 add	 esp, 140		; 0000008cH
  000bd	3b ec		 cmp	 ebp, esp
  000bf	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c4	8b e5		 mov	 esp, ebp
  000c6	5d		 pop	 ebp
  000c7	c3		 ret	 0
$LN5@becomeRoot:
  000c8	01 00 00 00	 DD	 1
  000cc	00 00 00 00	 DD	 $LN4@becomeRoot
$LN4@becomeRoot:
  000d0	78 ff ff ff	 DD	 -136			; ffffff78H
  000d4	80 00 00 00	 DD	 128			; 00000080H
  000d8	00 00 00 00	 DD	 $LN3@becomeRoot
$LN3@becomeRoot:
  000dc	62		 DB	 98			; 00000062H
  000dd	75		 DB	 117			; 00000075H
  000de	66		 DB	 102			; 00000066H
  000df	66		 DB	 102			; 00000066H
  000e0	65		 DB	 101			; 00000065H
  000e1	72		 DB	 114			; 00000072H
  000e2	00		 DB	 0
_becomeRoot ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3debughandlers.c
;	COMDAT _createNodeTok
_TEXT	SEGMENT
_buffer$ = -136						; size = 128
__$ArrayPad$ = -4					; size = 4
_delboy$ = 8						; size = 4
_node$ = 12						; size = 4
_token$ = 16						; size = 4
_createNodeTok PROC					; COMDAT

; 1004 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 8c 00 00
	00		 sub	 esp, 140		; 0000008cH
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8d bd 74 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-140]
  00011	b9 23 00 00 00	 mov	 ecx, 35			; 00000023H
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1005 : 	char	buffer[128];
; 1006 : 
; 1007 : 	sprintf(buffer, "createNode\t%d\t%d\n",	delboy->adaptor->getUniqueID(delboy->adaptor, node), (ANTLR3_UINT32)token->getTokenIndex(token));

  00027	8b f4		 mov	 esi, esp
  00029	8b 45 10	 mov	 eax, DWORD PTR _token$[ebp]
  0002c	50		 push	 eax
  0002d	8b 4d 10	 mov	 ecx, DWORD PTR _token$[ebp]
  00030	8b 51 74	 mov	 edx, DWORD PTR [ecx+116]
  00033	ff d2		 call	 edx
  00035	83 c4 04	 add	 esp, 4
  00038	3b f4		 cmp	 esi, esp
  0003a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003f	50		 push	 eax
  00040	8b f4		 mov	 esi, esp
  00042	8b 45 0c	 mov	 eax, DWORD PTR _node$[ebp]
  00045	50		 push	 eax
  00046	8b 4d 08	 mov	 ecx, DWORD PTR _delboy$[ebp]
  00049	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0004c	52		 push	 edx
  0004d	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  00050	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00053	8b 91 80 00 00
	00		 mov	 edx, DWORD PTR [ecx+128]
  00059	ff d2		 call	 edx
  0005b	83 c4 08	 add	 esp, 8
  0005e	3b f4		 cmp	 esi, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	50		 push	 eax
  00066	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@JHAHHABL@createNode?7?$CFd?7?$CFd?6@
  0006b	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _buffer$[ebp]
  00071	50		 push	 eax
  00072	e8 00 00 00 00	 call	 _sprintf
  00077	83 c4 10	 add	 esp, 16			; 00000010H

; 1008 : 
; 1009 : 	transmit(delboy, buffer);

  0007a	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _buffer$[ebp]
  00080	51		 push	 ecx
  00081	8b 55 08	 mov	 edx, DWORD PTR _delboy$[ebp]
  00084	52		 push	 edx
  00085	e8 00 00 00 00	 call	 _transmit
  0008a	83 c4 08	 add	 esp, 8

; 1010 : }

  0008d	52		 push	 edx
  0008e	8b cd		 mov	 ecx, ebp
  00090	50		 push	 eax
  00091	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@createNode
  00097	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0009c	58		 pop	 eax
  0009d	5a		 pop	 edx
  0009e	5f		 pop	 edi
  0009f	5e		 pop	 esi
  000a0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a3	33 cd		 xor	 ecx, ebp
  000a5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000aa	81 c4 8c 00 00
	00		 add	 esp, 140		; 0000008cH
  000b0	3b ec		 cmp	 ebp, esp
  000b2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b7	8b e5		 mov	 esp, ebp
  000b9	5d		 pop	 ebp
  000ba	c3		 ret	 0
  000bb	90		 npad	 1
$LN5@createNode:
  000bc	01 00 00 00	 DD	 1
  000c0	00 00 00 00	 DD	 $LN4@createNode
$LN4@createNode:
  000c4	78 ff ff ff	 DD	 -136			; ffffff78H
  000c8	80 00 00 00	 DD	 128			; 00000080H
  000cc	00 00 00 00	 DD	 $LN3@createNode
$LN3@createNode:
  000d0	62		 DB	 98			; 00000062H
  000d1	75		 DB	 117			; 00000075H
  000d2	66		 DB	 102			; 00000066H
  000d3	66		 DB	 102			; 00000066H
  000d4	65		 DB	 101			; 00000065H
  000d5	72		 DB	 114			; 00000072H
  000d6	00		 DB	 0
_createNodeTok ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3debughandlers.c
;	COMDAT _createNode
_TEXT	SEGMENT
_delboy$ = 8						; size = 4
_t$ = 12						; size = 4
_createNode PROC					; COMDAT

; 917  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 918  : 	// Do we already have a serialization buffer?
; 919  : 	//
; 920  : 	if	(delboy->tokenString == NULL)

  00004	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  00007	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  0000b	75 2a		 jne	 SHORT $LN2@createNode

; 921  : 	{
; 922  : 		// No, so create one, using the string factory that
; 923  : 		// the grammar name used, which is guaranteed to exist.
; 924  : 		// 64 bytes will do us here for starters. 
; 925  : 		//
; 926  : 		delboy->tokenString = delboy->grammarFileName->factory->newSize(delboy->grammarFileName->factory, 64);

  0000d	8b f4		 mov	 esi, esp
  0000f	6a 40		 push	 64			; 00000040H
  00011	8b 4d 08	 mov	 ecx, DWORD PTR _delboy$[ebp]
  00014	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00017	8b 02		 mov	 eax, DWORD PTR [edx]
  00019	50		 push	 eax
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR _delboy$[ebp]
  0001d	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00020	8b 02		 mov	 eax, DWORD PTR [edx]
  00022	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00025	ff d1		 call	 ecx
  00027	83 c4 08	 add	 esp, 8
  0002a	3b f4		 cmp	 esi, esp
  0002c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00031	8b 55 08	 mov	 edx, DWORD PTR _delboy$[ebp]
  00034	89 42 14	 mov	 DWORD PTR [edx+20], eax
$LN2@createNode:

; 927  : 	}
; 928  : 
; 929  : 	// Empty string
; 930  : 	//
; 931  : 	delboy->tokenString->set8(delboy->tokenString, (const char *)"createNodeFromTokenElements ");

  00037	8b f4		 mov	 esi, esp
  00039	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@GBIFKPIJ@createNodeFromTokenElements?5@
  0003e	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  00041	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00044	51		 push	 ecx
  00045	8b 55 08	 mov	 edx, DWORD PTR _delboy$[ebp]
  00048	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0004b	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0004e	ff d1		 call	 ecx
  00050	83 c4 08	 add	 esp, 8
  00053	3b f4		 cmp	 esi, esp
  00055	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 932  : 
; 933  : 	// Now we serialize the elements of the node.Note that the debugger only
; 934  : 	// uses 32 bits.
; 935  : 	//
; 936  : 	// Adaptor ID
; 937  : 	//
; 938  : 	delboy->tokenString->addi(delboy->tokenString, delboy->adaptor->getUniqueID(delboy->adaptor, t));

  0005a	8b f4		 mov	 esi, esp
  0005c	8b 55 0c	 mov	 edx, DWORD PTR _t$[ebp]
  0005f	52		 push	 edx
  00060	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  00063	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00066	51		 push	 ecx
  00067	8b 55 08	 mov	 edx, DWORD PTR _delboy$[ebp]
  0006a	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0006d	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  00073	ff d1		 call	 ecx
  00075	83 c4 08	 add	 esp, 8
  00078	3b f4		 cmp	 esi, esp
  0007a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007f	8b f4		 mov	 esi, esp
  00081	50		 push	 eax
  00082	8b 55 08	 mov	 edx, DWORD PTR _delboy$[ebp]
  00085	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00088	50		 push	 eax
  00089	8b 4d 08	 mov	 ecx, DWORD PTR _delboy$[ebp]
  0008c	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0008f	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  00092	ff d0		 call	 eax
  00094	83 c4 08	 add	 esp, 8
  00097	3b f4		 cmp	 esi, esp
  00099	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 939  : 	delboy->tokenString->addc(delboy->tokenString, '\t');

  0009e	8b f4		 mov	 esi, esp
  000a0	6a 09		 push	 9
  000a2	8b 4d 08	 mov	 ecx, DWORD PTR _delboy$[ebp]
  000a5	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  000a8	52		 push	 edx
  000a9	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  000ac	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000af	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  000b2	ff d2		 call	 edx
  000b4	83 c4 08	 add	 esp, 8
  000b7	3b f4		 cmp	 esi, esp
  000b9	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 940  : 
; 941  : 	// Type of the current token (which may be imaginary)
; 942  : 	//
; 943  : 	delboy->tokenString->addi(delboy->tokenString, delboy->adaptor->getType(delboy->adaptor, t));

  000be	8b f4		 mov	 esi, esp
  000c0	8b 45 0c	 mov	 eax, DWORD PTR _t$[ebp]
  000c3	50		 push	 eax
  000c4	8b 4d 08	 mov	 ecx, DWORD PTR _delboy$[ebp]
  000c7	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  000ca	52		 push	 edx
  000cb	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  000ce	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000d1	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  000d4	ff d2		 call	 edx
  000d6	83 c4 08	 add	 esp, 8
  000d9	3b f4		 cmp	 esi, esp
  000db	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e0	8b f4		 mov	 esi, esp
  000e2	50		 push	 eax
  000e3	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  000e6	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000e9	51		 push	 ecx
  000ea	8b 55 08	 mov	 edx, DWORD PTR _delboy$[ebp]
  000ed	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  000f0	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  000f3	ff d1		 call	 ecx
  000f5	83 c4 08	 add	 esp, 8
  000f8	3b f4		 cmp	 esi, esp
  000fa	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 944  : 
; 945  : 	// The text that this node represents
; 946  : 	//
; 947  : 	serializeText(delboy->tokenString, delboy->adaptor->getText(delboy->adaptor, t));

  000ff	8b f4		 mov	 esi, esp
  00101	8b 55 0c	 mov	 edx, DWORD PTR _t$[ebp]
  00104	52		 push	 edx
  00105	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  00108	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0010b	51		 push	 ecx
  0010c	8b 55 08	 mov	 edx, DWORD PTR _delboy$[ebp]
  0010f	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00112	8b 48 5c	 mov	 ecx, DWORD PTR [eax+92]
  00115	ff d1		 call	 ecx
  00117	83 c4 08	 add	 esp, 8
  0011a	3b f4		 cmp	 esi, esp
  0011c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00121	50		 push	 eax
  00122	8b 55 08	 mov	 edx, DWORD PTR _delboy$[ebp]
  00125	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00128	50		 push	 eax
  00129	e8 00 00 00 00	 call	 _serializeText
  0012e	83 c4 08	 add	 esp, 8

; 948  : 	delboy->tokenString->addc(delboy->tokenString, '\n');

  00131	8b f4		 mov	 esi, esp
  00133	6a 0a		 push	 10			; 0000000aH
  00135	8b 4d 08	 mov	 ecx, DWORD PTR _delboy$[ebp]
  00138	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0013b	52		 push	 edx
  0013c	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  0013f	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00142	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  00145	ff d2		 call	 edx
  00147	83 c4 08	 add	 esp, 8
  0014a	3b f4		 cmp	 esi, esp
  0014c	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 949  : 
; 950  : 	// Finally, as the debugger is a Java program it will expect to get UTF-8
; 951  : 	// encoded strings. We don't use UTF-8 internally to the C runtime, so we 
; 952  : 	// must force encode it. We have a method to do this in the string class, but
; 953  : 	// there is no utf8 string implementation as of yet
; 954  : 	//
; 955  : 	transmit(delboy, (const char *)(delboy->tokenString->toUTF8(delboy->tokenString)->chars));

  00151	8b f4		 mov	 esi, esp
  00153	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  00156	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00159	51		 push	 ecx
  0015a	8b 55 08	 mov	 edx, DWORD PTR _delboy$[ebp]
  0015d	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00160	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  00163	ff d1		 call	 ecx
  00165	83 c4 04	 add	 esp, 4
  00168	3b f4		 cmp	 esi, esp
  0016a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0016f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00172	52		 push	 edx
  00173	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  00176	50		 push	 eax
  00177	e8 00 00 00 00	 call	 _transmit
  0017c	83 c4 08	 add	 esp, 8

; 956  : 
; 957  : }

  0017f	5e		 pop	 esi
  00180	3b ec		 cmp	 ebp, esp
  00182	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00187	5d		 pop	 ebp
  00188	c3		 ret	 0
_createNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3debughandlers.c
;	COMDAT _errorNode
_TEXT	SEGMENT
_delboy$ = 8						; size = 4
_t$ = 12						; size = 4
_errorNode PROC						; COMDAT

; 960  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 961  : 	// Do we already have a serialization buffer?
; 962  : 	//
; 963  : 	if	(delboy->tokenString == NULL)

  00004	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  00007	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  0000b	75 2a		 jne	 SHORT $LN2@errorNode

; 964  : 	{
; 965  : 		// No, so create one, using the string factory that
; 966  : 		// the grammar name used, which is guaranteed to exist.
; 967  : 		// 64 bytes will do us here for starters. 
; 968  : 		//
; 969  : 		delboy->tokenString = delboy->grammarFileName->factory->newSize(delboy->grammarFileName->factory, 64);

  0000d	8b f4		 mov	 esi, esp
  0000f	6a 40		 push	 64			; 00000040H
  00011	8b 4d 08	 mov	 ecx, DWORD PTR _delboy$[ebp]
  00014	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00017	8b 02		 mov	 eax, DWORD PTR [edx]
  00019	50		 push	 eax
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR _delboy$[ebp]
  0001d	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00020	8b 02		 mov	 eax, DWORD PTR [edx]
  00022	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00025	ff d1		 call	 ecx
  00027	83 c4 08	 add	 esp, 8
  0002a	3b f4		 cmp	 esi, esp
  0002c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00031	8b 55 08	 mov	 edx, DWORD PTR _delboy$[ebp]
  00034	89 42 14	 mov	 DWORD PTR [edx+20], eax
$LN2@errorNode:

; 970  : 	}
; 971  : 
; 972  : 	// Empty string
; 973  : 	//
; 974  : 	delboy->tokenString->set8(delboy->tokenString, (const char *)"errorNode\t");

  00037	8b f4		 mov	 esi, esp
  00039	68 00 00 00 00	 push	 OFFSET ??_C@_0L@OOIEOANM@errorNode?7@
  0003e	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  00041	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00044	51		 push	 ecx
  00045	8b 55 08	 mov	 edx, DWORD PTR _delboy$[ebp]
  00048	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0004b	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0004e	ff d1		 call	 ecx
  00050	83 c4 08	 add	 esp, 8
  00053	3b f4		 cmp	 esi, esp
  00055	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 975  : 
; 976  : 	// Now we serialize the elements of the node.Note that the debugger only
; 977  : 	// uses 32 bits.
; 978  : 	//
; 979  : 	// Adaptor ID
; 980  : 	//
; 981  : 	delboy->tokenString->addi(delboy->tokenString, delboy->adaptor->getUniqueID(delboy->adaptor, t));

  0005a	8b f4		 mov	 esi, esp
  0005c	8b 55 0c	 mov	 edx, DWORD PTR _t$[ebp]
  0005f	52		 push	 edx
  00060	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  00063	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00066	51		 push	 ecx
  00067	8b 55 08	 mov	 edx, DWORD PTR _delboy$[ebp]
  0006a	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0006d	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  00073	ff d1		 call	 ecx
  00075	83 c4 08	 add	 esp, 8
  00078	3b f4		 cmp	 esi, esp
  0007a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007f	8b f4		 mov	 esi, esp
  00081	50		 push	 eax
  00082	8b 55 08	 mov	 edx, DWORD PTR _delboy$[ebp]
  00085	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00088	50		 push	 eax
  00089	8b 4d 08	 mov	 ecx, DWORD PTR _delboy$[ebp]
  0008c	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0008f	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  00092	ff d0		 call	 eax
  00094	83 c4 08	 add	 esp, 8
  00097	3b f4		 cmp	 esi, esp
  00099	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 982  : 	delboy->tokenString->addc(delboy->tokenString, '\t');

  0009e	8b f4		 mov	 esi, esp
  000a0	6a 09		 push	 9
  000a2	8b 4d 08	 mov	 ecx, DWORD PTR _delboy$[ebp]
  000a5	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  000a8	52		 push	 edx
  000a9	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  000ac	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000af	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  000b2	ff d2		 call	 edx
  000b4	83 c4 08	 add	 esp, 8
  000b7	3b f4		 cmp	 esi, esp
  000b9	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 983  : 
; 984  : 	// Type of the current token (which is an error)
; 985  : 	//
; 986  : 	delboy->tokenString->addi(delboy->tokenString, ANTLR3_TOKEN_INVALID);

  000be	8b f4		 mov	 esi, esp
  000c0	6a 00		 push	 0
  000c2	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  000c5	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000c8	51		 push	 ecx
  000c9	8b 55 08	 mov	 edx, DWORD PTR _delboy$[ebp]
  000cc	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  000cf	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  000d2	ff d1		 call	 ecx
  000d4	83 c4 08	 add	 esp, 8
  000d7	3b f4		 cmp	 esi, esp
  000d9	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 987  : 
; 988  : 	// The text that this node represents
; 989  : 	//
; 990  : 	serializeText(delboy->tokenString, delboy->adaptor->getText(delboy->adaptor, t));

  000de	8b f4		 mov	 esi, esp
  000e0	8b 55 0c	 mov	 edx, DWORD PTR _t$[ebp]
  000e3	52		 push	 edx
  000e4	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  000e7	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000ea	51		 push	 ecx
  000eb	8b 55 08	 mov	 edx, DWORD PTR _delboy$[ebp]
  000ee	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  000f1	8b 48 5c	 mov	 ecx, DWORD PTR [eax+92]
  000f4	ff d1		 call	 ecx
  000f6	83 c4 08	 add	 esp, 8
  000f9	3b f4		 cmp	 esi, esp
  000fb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00100	50		 push	 eax
  00101	8b 55 08	 mov	 edx, DWORD PTR _delboy$[ebp]
  00104	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00107	50		 push	 eax
  00108	e8 00 00 00 00	 call	 _serializeText
  0010d	83 c4 08	 add	 esp, 8

; 991  : 	delboy->tokenString->addc(delboy->tokenString, '\n');

  00110	8b f4		 mov	 esi, esp
  00112	6a 0a		 push	 10			; 0000000aH
  00114	8b 4d 08	 mov	 ecx, DWORD PTR _delboy$[ebp]
  00117	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0011a	52		 push	 edx
  0011b	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  0011e	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00121	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  00124	ff d2		 call	 edx
  00126	83 c4 08	 add	 esp, 8
  00129	3b f4		 cmp	 esi, esp
  0012b	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 992  : 
; 993  : 	// Finally, as the debugger is a Java program it will expect to get UTF-8
; 994  : 	// encoded strings. We don't use UTF-8 internally to the C runtime, so we 
; 995  : 	// must force encode it. We have a method to do this in the string class, but
; 996  : 	// there is no utf8 string implementation as of yet
; 997  : 	//
; 998  : 	transmit(delboy, (const char *)(delboy->tokenString->toUTF8(delboy->tokenString)->chars));

  00130	8b f4		 mov	 esi, esp
  00132	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  00135	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00138	51		 push	 ecx
  00139	8b 55 08	 mov	 edx, DWORD PTR _delboy$[ebp]
  0013c	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0013f	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  00142	ff d1		 call	 ecx
  00144	83 c4 04	 add	 esp, 4
  00147	3b f4		 cmp	 esi, esp
  00149	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0014e	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00151	52		 push	 edx
  00152	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  00155	50		 push	 eax
  00156	e8 00 00 00 00	 call	 _transmit
  0015b	83 c4 08	 add	 esp, 8

; 999  : 
; 1000 : }

  0015e	5e		 pop	 esi
  0015f	3b ec		 cmp	 ebp, esp
  00161	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00166	5d		 pop	 ebp
  00167	c3		 ret	 0
_errorNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3debughandlers.c
;	COMDAT _nilNode
_TEXT	SEGMENT
_buffer$ = -136						; size = 128
__$ArrayPad$ = -4					; size = 4
_delboy$ = 8						; size = 4
_t$ = 12						; size = 4
_nilNode PROC						; COMDAT

; 909  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 8c 00 00
	00		 sub	 esp, 140		; 0000008cH
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8d bd 74 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-140]
  00011	b9 23 00 00 00	 mov	 ecx, 35			; 00000023H
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 910  : 	char	buffer[128];
; 911  : 	sprintf(buffer, "nilNode\t%d\n", delboy->adaptor->getUniqueID(delboy->adaptor, t));

  00027	8b f4		 mov	 esi, esp
  00029	8b 45 0c	 mov	 eax, DWORD PTR _t$[ebp]
  0002c	50		 push	 eax
  0002d	8b 4d 08	 mov	 ecx, DWORD PTR _delboy$[ebp]
  00030	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00033	52		 push	 edx
  00034	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  00037	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0003a	8b 91 80 00 00
	00		 mov	 edx, DWORD PTR [ecx+128]
  00040	ff d2		 call	 edx
  00042	83 c4 08	 add	 esp, 8
  00045	3b f4		 cmp	 esi, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	50		 push	 eax
  0004d	68 00 00 00 00	 push	 OFFSET ??_C@_0M@LCJNOAFD@nilNode?7?$CFd?6@
  00052	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _buffer$[ebp]
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 _sprintf
  0005e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 912  : 	transmit(delboy, buffer);

  00061	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _buffer$[ebp]
  00067	51		 push	 ecx
  00068	8b 55 08	 mov	 edx, DWORD PTR _delboy$[ebp]
  0006b	52		 push	 edx
  0006c	e8 00 00 00 00	 call	 _transmit
  00071	83 c4 08	 add	 esp, 8

; 913  : }

  00074	52		 push	 edx
  00075	8b cd		 mov	 ecx, ebp
  00077	50		 push	 eax
  00078	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@nilNode
  0007e	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00083	58		 pop	 eax
  00084	5a		 pop	 edx
  00085	5f		 pop	 edi
  00086	5e		 pop	 esi
  00087	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008a	33 cd		 xor	 ecx, ebp
  0008c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00091	81 c4 8c 00 00
	00		 add	 esp, 140		; 0000008cH
  00097	3b ec		 cmp	 ebp, esp
  00099	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c3		 ret	 0
  000a2	66 90		 npad	 2
$LN5@nilNode:
  000a4	01 00 00 00	 DD	 1
  000a8	00 00 00 00	 DD	 $LN4@nilNode
$LN4@nilNode:
  000ac	78 ff ff ff	 DD	 -136			; ffffff78H
  000b0	80 00 00 00	 DD	 128			; 00000080H
  000b4	00 00 00 00	 DD	 $LN3@nilNode
$LN3@nilNode:
  000b8	62		 DB	 98			; 00000062H
  000b9	75		 DB	 117			; 00000075H
  000ba	66		 DB	 102			; 00000066H
  000bb	66		 DB	 102			; 00000066H
  000bc	65		 DB	 101			; 00000065H
  000bd	72		 DB	 114			; 00000072H
  000be	00		 DB	 0
_nilNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3debughandlers.c
;	COMDAT _LTT
_TEXT	SEGMENT
_buffer$ = -4						; size = 4
_delboy$ = 8						; size = 4
_i$ = 12						; size = 4
_t$ = 16						; size = 4
_LTT	PROC						; COMDAT

; 890  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 891  : 	pANTLR3_STRING	buffer;
; 892  : 
; 893  : 	buffer = serializeNode	(delboy, t);

  0000c	8b 45 10	 mov	 eax, DWORD PTR _t$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _delboy$[ebp]
  00013	51		 push	 ecx
  00014	e8 00 00 00 00	 call	 _serializeNode
  00019	83 c4 08	 add	 esp, 8
  0001c	89 45 fc	 mov	 DWORD PTR _buffer$[ebp], eax

; 894  : 
; 895  : 	// Now prepend the command
; 896  : 	//
; 897  : 	buffer->insert8	(buffer, 0, "\t");

  0001f	8b f4		 mov	 esi, esp
  00021	68 00 00 00 00	 push	 OFFSET ??_C@_01GPOEFGEJ@?7@
  00026	6a 00		 push	 0
  00028	8b 55 fc	 mov	 edx, DWORD PTR _buffer$[ebp]
  0002b	52		 push	 edx
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _buffer$[ebp]
  0002f	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  00032	ff d1		 call	 ecx
  00034	83 c4 0c	 add	 esp, 12			; 0000000cH
  00037	3b f4		 cmp	 esi, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 898  : 	buffer->inserti	(buffer, 0, i);

  0003e	8b f4		 mov	 esi, esp
  00040	8b 55 0c	 mov	 edx, DWORD PTR _i$[ebp]
  00043	52		 push	 edx
  00044	6a 00		 push	 0
  00046	8b 45 fc	 mov	 eax, DWORD PTR _buffer$[ebp]
  00049	50		 push	 eax
  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _buffer$[ebp]
  0004d	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  00050	ff d2		 call	 edx
  00052	83 c4 0c	 add	 esp, 12			; 0000000cH
  00055	3b f4		 cmp	 esi, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 899  : 	buffer->insert8	(buffer, 0, "LN\t");

  0005c	8b f4		 mov	 esi, esp
  0005e	68 00 00 00 00	 push	 OFFSET ??_C@_03KELPNMOF@LN?7@
  00063	6a 00		 push	 0
  00065	8b 45 fc	 mov	 eax, DWORD PTR _buffer$[ebp]
  00068	50		 push	 eax
  00069	8b 4d fc	 mov	 ecx, DWORD PTR _buffer$[ebp]
  0006c	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  0006f	ff d2		 call	 edx
  00071	83 c4 0c	 add	 esp, 12			; 0000000cH
  00074	3b f4		 cmp	 esi, esp
  00076	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 900  : 	buffer->addc	(buffer, '\n');

  0007b	8b f4		 mov	 esi, esp
  0007d	6a 0a		 push	 10			; 0000000aH
  0007f	8b 45 fc	 mov	 eax, DWORD PTR _buffer$[ebp]
  00082	50		 push	 eax
  00083	8b 4d fc	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00086	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  00089	ff d2		 call	 edx
  0008b	83 c4 08	 add	 esp, 8
  0008e	3b f4		 cmp	 esi, esp
  00090	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 901  : 
; 902  : 	// Send to the debugger and wait for the ack
; 903  : 	//
; 904  : 	transmit		(delboy, (const char *)(delboy->tokenString->toUTF8(delboy->tokenString)->chars));

  00095	8b f4		 mov	 esi, esp
  00097	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  0009a	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0009d	51		 push	 ecx
  0009e	8b 55 08	 mov	 edx, DWORD PTR _delboy$[ebp]
  000a1	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  000a4	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  000a7	ff d1		 call	 ecx
  000a9	83 c4 04	 add	 esp, 4
  000ac	3b f4		 cmp	 esi, esp
  000ae	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b3	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000b6	52		 push	 edx
  000b7	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  000ba	50		 push	 eax
  000bb	e8 00 00 00 00	 call	 _transmit
  000c0	83 c4 08	 add	 esp, 8

; 905  : }

  000c3	5e		 pop	 esi
  000c4	83 c4 04	 add	 esp, 4
  000c7	3b ec		 cmp	 ebp, esp
  000c9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ce	8b e5		 mov	 esp, ebp
  000d0	5d		 pop	 ebp
  000d1	c3		 ret	 0
_LTT	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3debughandlers.c
;	COMDAT _consumeNode
_TEXT	SEGMENT
_buffer$ = -4						; size = 4
_delboy$ = 8						; size = 4
_t$ = 12						; size = 4
_consumeNode PROC					; COMDAT

; 873  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 874  : 	pANTLR3_STRING	buffer;
; 875  : 
; 876  : 	buffer = serializeNode	(delboy, t);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR _t$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _delboy$[ebp]
  00013	51		 push	 ecx
  00014	e8 00 00 00 00	 call	 _serializeNode
  00019	83 c4 08	 add	 esp, 8
  0001c	89 45 fc	 mov	 DWORD PTR _buffer$[ebp], eax

; 877  : 
; 878  : 	// Now prepend the command
; 879  : 	//
; 880  : 	buffer->insert8	(buffer, 0, "consumeNode\t");

  0001f	8b f4		 mov	 esi, esp
  00021	68 00 00 00 00	 push	 OFFSET ??_C@_0N@CLFGHGNF@consumeNode?7@
  00026	6a 00		 push	 0
  00028	8b 55 fc	 mov	 edx, DWORD PTR _buffer$[ebp]
  0002b	52		 push	 edx
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _buffer$[ebp]
  0002f	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  00032	ff d1		 call	 ecx
  00034	83 c4 0c	 add	 esp, 12			; 0000000cH
  00037	3b f4		 cmp	 esi, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 881  : 	buffer->addc	(buffer, '\n');

  0003e	8b f4		 mov	 esi, esp
  00040	6a 0a		 push	 10			; 0000000aH
  00042	8b 55 fc	 mov	 edx, DWORD PTR _buffer$[ebp]
  00045	52		 push	 edx
  00046	8b 45 fc	 mov	 eax, DWORD PTR _buffer$[ebp]
  00049	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  0004c	ff d1		 call	 ecx
  0004e	83 c4 08	 add	 esp, 8
  00051	3b f4		 cmp	 esi, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 882  : 
; 883  : 	// Send to the debugger and wait for the ack
; 884  : 	//
; 885  : 	transmit		(delboy, (const char *)(delboy->tokenString->toUTF8(delboy->tokenString)->chars));

  00058	8b f4		 mov	 esi, esp
  0005a	8b 55 08	 mov	 edx, DWORD PTR _delboy$[ebp]
  0005d	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00060	50		 push	 eax
  00061	8b 4d 08	 mov	 ecx, DWORD PTR _delboy$[ebp]
  00064	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00067	8b 42 64	 mov	 eax, DWORD PTR [edx+100]
  0006a	ff d0		 call	 eax
  0006c	83 c4 04	 add	 esp, 4
  0006f	3b f4		 cmp	 esi, esp
  00071	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00076	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00079	51		 push	 ecx
  0007a	8b 55 08	 mov	 edx, DWORD PTR _delboy$[ebp]
  0007d	52		 push	 edx
  0007e	e8 00 00 00 00	 call	 _transmit
  00083	83 c4 08	 add	 esp, 8

; 886  : }

  00086	5e		 pop	 esi
  00087	83 c4 04	 add	 esp, 4
  0008a	3b ec		 cmp	 ebp, esp
  0008c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c3		 ret	 0
_consumeNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3debughandlers.c
;	COMDAT _terminate
_TEXT	SEGMENT
_delboy$ = 8						; size = 4
_terminate PROC						; COMDAT

; 862  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 863  : 	// Terminate sequence
; 864  : 	//
; 865  : 	sockSend(delboy->socket, "terminate\n", 10);		// Send out the command

  00003	6a 0a		 push	 10			; 0000000aH
  00005	68 00 00 00 00	 push	 OFFSET ??_C@_0L@KANKBBAE@terminate?6@
  0000a	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  0000d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 _sockSend
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH

; 866  : }

  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
_terminate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3debughandlers.c
;	COMDAT _commence
_TEXT	SEGMENT
_delboy$ = 8						; size = 4
_commence PROC						; COMDAT

; 851  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 852  : 	// Nothing to see here
; 853  : 	//
; 854  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
_commence ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3debughandlers.c
;	COMDAT _semanticPredicate
_TEXT	SEGMENT
tv86 = -16						; size = 4
tv78 = -12						; size = 4
_out$ = -8						; size = 4
_buffer$ = -4						; size = 4
_delboy$ = 8						; size = 4
_result$ = 12						; size = 1
_predicate$ = 16					; size = 4
_semanticPredicate PROC					; COMDAT

; 788  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000f	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00012	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00015	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 789  : 	unsigned char * buffer;
; 790  : 	unsigned char * out;
; 791  : 
; 792  : 	if	(predicate != NULL)

  00018	83 7d 10 00	 cmp	 DWORD PTR _predicate$[ebp], 0
  0001c	0f 84 6d 01 00
	00		 je	 $LN6@semanticPr

; 793  : 	{
; 794  : 		buffer	= (unsigned char *)ANTLR3_MALLOC(64 + 2*strlen(predicate));

  00022	8b 45 10	 mov	 eax, DWORD PTR _predicate$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _strlen
  0002b	83 c4 04	 add	 esp, 4
  0002e	8d 4c 00 40	 lea	 ecx, DWORD PTR [eax+eax+64]
  00032	8b f4		 mov	 esi, esp
  00034	51		 push	 ecx
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0003b	83 c4 04	 add	 esp, 4
  0003e	3b f4		 cmp	 esi, esp
  00040	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00045	89 45 fc	 mov	 DWORD PTR _buffer$[ebp], eax

; 795  : 
; 796  : 		if	(buffer != NULL)

  00048	83 7d fc 00	 cmp	 DWORD PTR _buffer$[ebp], 0
  0004c	0f 84 2d 01 00
	00		 je	 $LN7@semanticPr

; 797  : 		{
; 798  : 			out = buffer + sprintf((char *)buffer, "semanticPredicate\t%s\t", result == ANTLR3_TRUE ? "true" : "false");

  00052	0f b6 55 0c	 movzx	 edx, BYTE PTR _result$[ebp]
  00056	83 fa 01	 cmp	 edx, 1
  00059	75 09		 jne	 SHORT $LN13@semanticPr
  0005b	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], OFFSET ??_C@_04LOAJBDKD@true@
  00062	eb 07		 jmp	 SHORT $LN14@semanticPr
$LN13@semanticPr:
  00064	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], OFFSET ??_C@_05LAPONLG@false@
$LN14@semanticPr:
  0006b	8b 45 f4	 mov	 eax, DWORD PTR tv78[ebp]
  0006e	50		 push	 eax
  0006f	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@LEAPHAIG@semanticPredicate?7?$CFs?7@
  00074	8b 4d fc	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00077	51		 push	 ecx
  00078	e8 00 00 00 00	 call	 _sprintf
  0007d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00080	03 45 fc	 add	 eax, DWORD PTR _buffer$[ebp]
  00083	89 45 f8	 mov	 DWORD PTR _out$[ebp], eax
$LN2@semanticPr:

; 799  : 
; 800  : 			while (*predicate != '\0')

  00086	8b 55 10	 mov	 edx, DWORD PTR _predicate$[ebp]
  00089	0f be 02	 movsx	 eax, BYTE PTR [edx]
  0008c	85 c0		 test	 eax, eax
  0008e	0f 84 cd 00 00
	00		 je	 $LN3@semanticPr

; 801  : 			{
; 802  : 				switch(*predicate)

  00094	8b 4d 10	 mov	 ecx, DWORD PTR _predicate$[ebp]
  00097	8a 11		 mov	 dl, BYTE PTR [ecx]
  00099	88 55 f0	 mov	 BYTE PTR tv86[ebp], dl
  0009c	80 7d f0 0a	 cmp	 BYTE PTR tv86[ebp], 10	; 0000000aH
  000a0	74 11		 je	 SHORT $LN8@semanticPr
  000a2	80 7d f0 0d	 cmp	 BYTE PTR tv86[ebp], 13	; 0000000dH
  000a6	74 3a		 je	 SHORT $LN9@semanticPr
  000a8	80 7d f0 25	 cmp	 BYTE PTR tv86[ebp], 37	; 00000025H
  000ac	74 63		 je	 SHORT $LN10@semanticPr
  000ae	e9 8d 00 00 00	 jmp	 $LN11@semanticPr
$LN8@semanticPr:

; 803  : 				{
; 804  : 					case	'\n':
; 805  : 						
; 806  : 						*out++	= '%';

  000b3	8b 45 f8	 mov	 eax, DWORD PTR _out$[ebp]
  000b6	c6 00 25	 mov	 BYTE PTR [eax], 37	; 00000025H
  000b9	8b 4d f8	 mov	 ecx, DWORD PTR _out$[ebp]
  000bc	83 c1 01	 add	 ecx, 1
  000bf	89 4d f8	 mov	 DWORD PTR _out$[ebp], ecx

; 807  : 						*out++	= '0';

  000c2	8b 55 f8	 mov	 edx, DWORD PTR _out$[ebp]
  000c5	c6 02 30	 mov	 BYTE PTR [edx], 48	; 00000030H
  000c8	8b 45 f8	 mov	 eax, DWORD PTR _out$[ebp]
  000cb	83 c0 01	 add	 eax, 1
  000ce	89 45 f8	 mov	 DWORD PTR _out$[ebp], eax

; 808  : 						*out++	= 'A';

  000d1	8b 4d f8	 mov	 ecx, DWORD PTR _out$[ebp]
  000d4	c6 01 41	 mov	 BYTE PTR [ecx], 65	; 00000041H
  000d7	8b 55 f8	 mov	 edx, DWORD PTR _out$[ebp]
  000da	83 c2 01	 add	 edx, 1
  000dd	89 55 f8	 mov	 DWORD PTR _out$[ebp], edx

; 809  : 						break;

  000e0	eb 71		 jmp	 SHORT $LN4@semanticPr
$LN9@semanticPr:

; 810  : 
; 811  : 					case	'\r':
; 812  : 
; 813  : 						*out++	= '%';

  000e2	8b 45 f8	 mov	 eax, DWORD PTR _out$[ebp]
  000e5	c6 00 25	 mov	 BYTE PTR [eax], 37	; 00000025H
  000e8	8b 4d f8	 mov	 ecx, DWORD PTR _out$[ebp]
  000eb	83 c1 01	 add	 ecx, 1
  000ee	89 4d f8	 mov	 DWORD PTR _out$[ebp], ecx

; 814  : 						*out++	= '0';

  000f1	8b 55 f8	 mov	 edx, DWORD PTR _out$[ebp]
  000f4	c6 02 30	 mov	 BYTE PTR [edx], 48	; 00000030H
  000f7	8b 45 f8	 mov	 eax, DWORD PTR _out$[ebp]
  000fa	83 c0 01	 add	 eax, 1
  000fd	89 45 f8	 mov	 DWORD PTR _out$[ebp], eax

; 815  : 						*out++	= 'D';

  00100	8b 4d f8	 mov	 ecx, DWORD PTR _out$[ebp]
  00103	c6 01 44	 mov	 BYTE PTR [ecx], 68	; 00000044H
  00106	8b 55 f8	 mov	 edx, DWORD PTR _out$[ebp]
  00109	83 c2 01	 add	 edx, 1
  0010c	89 55 f8	 mov	 DWORD PTR _out$[ebp], edx

; 816  : 						break;

  0010f	eb 42		 jmp	 SHORT $LN4@semanticPr
$LN10@semanticPr:

; 817  : 
; 818  : 					case	'%':
; 819  : 
; 820  : 						*out++	= '%';

  00111	8b 45 f8	 mov	 eax, DWORD PTR _out$[ebp]
  00114	c6 00 25	 mov	 BYTE PTR [eax], 37	; 00000025H
  00117	8b 4d f8	 mov	 ecx, DWORD PTR _out$[ebp]
  0011a	83 c1 01	 add	 ecx, 1
  0011d	89 4d f8	 mov	 DWORD PTR _out$[ebp], ecx

; 821  : 						*out++	= '0';

  00120	8b 55 f8	 mov	 edx, DWORD PTR _out$[ebp]
  00123	c6 02 30	 mov	 BYTE PTR [edx], 48	; 00000030H
  00126	8b 45 f8	 mov	 eax, DWORD PTR _out$[ebp]
  00129	83 c0 01	 add	 eax, 1
  0012c	89 45 f8	 mov	 DWORD PTR _out$[ebp], eax

; 822  : 						*out++	= 'D';

  0012f	8b 4d f8	 mov	 ecx, DWORD PTR _out$[ebp]
  00132	c6 01 44	 mov	 BYTE PTR [ecx], 68	; 00000044H
  00135	8b 55 f8	 mov	 edx, DWORD PTR _out$[ebp]
  00138	83 c2 01	 add	 edx, 1
  0013b	89 55 f8	 mov	 DWORD PTR _out$[ebp], edx

; 823  : 						break;

  0013e	eb 13		 jmp	 SHORT $LN4@semanticPr
$LN11@semanticPr:

; 824  : 
; 825  : 
; 826  : 					default:
; 827  : 
; 828  : 						*out++	= *predicate;

  00140	8b 45 f8	 mov	 eax, DWORD PTR _out$[ebp]
  00143	8b 4d 10	 mov	 ecx, DWORD PTR _predicate$[ebp]
  00146	8a 11		 mov	 dl, BYTE PTR [ecx]
  00148	88 10		 mov	 BYTE PTR [eax], dl
  0014a	8b 45 f8	 mov	 eax, DWORD PTR _out$[ebp]
  0014d	83 c0 01	 add	 eax, 1
  00150	89 45 f8	 mov	 DWORD PTR _out$[ebp], eax
$LN4@semanticPr:

; 829  : 						break;
; 830  : 				}
; 831  : 
; 832  : 				predicate++;

  00153	8b 4d 10	 mov	 ecx, DWORD PTR _predicate$[ebp]
  00156	83 c1 01	 add	 ecx, 1
  00159	89 4d 10	 mov	 DWORD PTR _predicate$[ebp], ecx

; 833  : 			}

  0015c	e9 25 ff ff ff	 jmp	 $LN2@semanticPr
$LN3@semanticPr:

; 834  : 			*out++	= '\n';

  00161	8b 55 f8	 mov	 edx, DWORD PTR _out$[ebp]
  00164	c6 02 0a	 mov	 BYTE PTR [edx], 10	; 0000000aH
  00167	8b 45 f8	 mov	 eax, DWORD PTR _out$[ebp]
  0016a	83 c0 01	 add	 eax, 1
  0016d	89 45 f8	 mov	 DWORD PTR _out$[ebp], eax

; 835  : 			*out++	= '\0';

  00170	8b 4d f8	 mov	 ecx, DWORD PTR _out$[ebp]
  00173	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00176	8b 55 f8	 mov	 edx, DWORD PTR _out$[ebp]
  00179	83 c2 01	 add	 edx, 1
  0017c	89 55 f8	 mov	 DWORD PTR _out$[ebp], edx
$LN7@semanticPr:

; 836  : 		}
; 837  : 
; 838  : 		// Send it and wait for the ack
; 839  : 		//
; 840  : 		transmit(delboy, (const char *)buffer);

  0017f	8b 45 fc	 mov	 eax, DWORD PTR _buffer$[ebp]
  00182	50		 push	 eax
  00183	8b 4d 08	 mov	 ecx, DWORD PTR _delboy$[ebp]
  00186	51		 push	 ecx
  00187	e8 00 00 00 00	 call	 _transmit
  0018c	83 c4 08	 add	 esp, 8
$LN6@semanticPr:

; 841  : 	}
; 842  : }

  0018f	5e		 pop	 esi
  00190	83 c4 10	 add	 esp, 16			; 00000010H
  00193	3b ec		 cmp	 ebp, esp
  00195	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0019a	8b e5		 mov	 esp, ebp
  0019c	5d		 pop	 ebp
  0019d	c3		 ret	 0
_semanticPredicate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3debughandlers.c
;	COMDAT _endResync
_TEXT	SEGMENT
_delboy$ = 8						; size = 4
_endResync PROC						; COMDAT

; 782  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 783  : 	transmit(delboy, (const char *)"endResync\n");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0L@KHCEOHOJ@endResync?6@
  00008	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 _transmit
  00011	83 c4 08	 add	 esp, 8

; 784  : }

  00014	3b ec		 cmp	 ebp, esp
  00016	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
_endResync ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3debughandlers.c
;	COMDAT _beginResync
_TEXT	SEGMENT
_delboy$ = 8						; size = 4
_beginResync PROC					; COMDAT

; 776  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 777  : 	transmit(delboy, (const char *)"beginResync\n");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0N@DCBHEMKM@beginResync?6@
  00008	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 _transmit
  00011	83 c4 08	 add	 esp, 8

; 778  : }

  00014	3b ec		 cmp	 ebp, esp
  00016	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
_beginResync ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3debughandlers.c
;	COMDAT _recognitionException
_TEXT	SEGMENT
_buffer$ = -264						; size = 256
__$ArrayPad$ = -4					; size = 4
_delboy$ = 8						; size = 4
_e$ = 12						; size = 4
_recognitionException PROC				; COMDAT

; 764  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH
  00009	57		 push	 edi
  0000a	8d bd f4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-268]
  00010	b9 43 00 00 00	 mov	 ecx, 67			; 00000043H
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 765  : 	char	buffer[256];
; 766  : 
; 767  : 	sprintf(buffer, "exception\t%s\t%d\t%d\t%d\n", (char *)(e->name), (ANTLR3_INT32)(e->index), e->line, e->charPositionInLine);

  00026	8b 45 0c	 mov	 eax, DWORD PTR _e$[ebp]
  00029	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  0002c	51		 push	 ecx
  0002d	8b 55 0c	 mov	 edx, DWORD PTR _e$[ebp]
  00030	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  00033	50		 push	 eax
  00034	8b 4d 0c	 mov	 ecx, DWORD PTR _e$[ebp]
  00037	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0003a	52		 push	 edx
  0003b	8b 45 0c	 mov	 eax, DWORD PTR _e$[ebp]
  0003e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00041	51		 push	 ecx
  00042	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@FBDPJABF@exception?7?$CFs?7?$CFd?7?$CFd?7?$CFd?6@
  00047	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR _buffer$[ebp]
  0004d	52		 push	 edx
  0004e	e8 00 00 00 00	 call	 _sprintf
  00053	83 c4 18	 add	 esp, 24			; 00000018H

; 768  : 
; 769  : 	// Transmit the message and wait for ack
; 770  : 	//
; 771  : 	transmit(delboy, buffer);

  00056	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _buffer$[ebp]
  0005c	50		 push	 eax
  0005d	8b 4d 08	 mov	 ecx, DWORD PTR _delboy$[ebp]
  00060	51		 push	 ecx
  00061	e8 00 00 00 00	 call	 _transmit
  00066	83 c4 08	 add	 esp, 8

; 772  : }

  00069	52		 push	 edx
  0006a	8b cd		 mov	 ecx, ebp
  0006c	50		 push	 eax
  0006d	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@recognitio
  00073	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00078	58		 pop	 eax
  00079	5a		 pop	 edx
  0007a	5f		 pop	 edi
  0007b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0007e	33 cd		 xor	 ecx, ebp
  00080	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00085	81 c4 0c 01 00
	00		 add	 esp, 268		; 0000010cH
  0008b	3b ec		 cmp	 ebp, esp
  0008d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c3		 ret	 0
  00096	66 90		 npad	 2
$LN5@recognitio:
  00098	01 00 00 00	 DD	 1
  0009c	00 00 00 00	 DD	 $LN4@recognitio
$LN4@recognitio:
  000a0	f8 fe ff ff	 DD	 -264			; fffffef8H
  000a4	00 01 00 00	 DD	 256			; 00000100H
  000a8	00 00 00 00	 DD	 $LN3@recognitio
$LN3@recognitio:
  000ac	62		 DB	 98			; 00000062H
  000ad	75		 DB	 117			; 00000075H
  000ae	66		 DB	 102			; 00000066H
  000af	66		 DB	 102			; 00000066H
  000b0	65		 DB	 101			; 00000065H
  000b1	72		 DB	 114			; 00000072H
  000b2	00		 DB	 0
_recognitionException ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3debughandlers.c
;	COMDAT _location
_TEXT	SEGMENT
_buffer$ = -136						; size = 128
__$ArrayPad$ = -4					; size = 4
_delboy$ = 8						; size = 4
_line$ = 12						; size = 4
_pos$ = 16						; size = 4
_location PROC						; COMDAT

; 752  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 8c 00 00
	00		 sub	 esp, 140		; 0000008cH
  00009	57		 push	 edi
  0000a	8d bd 74 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-140]
  00010	b9 23 00 00 00	 mov	 ecx, 35			; 00000023H
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 753  : 	char buffer[128];
; 754  : 
; 755  : 	sprintf(buffer, "location\t%d\t%d\n", line, pos);

  00026	8b 45 10	 mov	 eax, DWORD PTR _pos$[ebp]
  00029	50		 push	 eax
  0002a	8b 4d 0c	 mov	 ecx, DWORD PTR _line$[ebp]
  0002d	51		 push	 ecx
  0002e	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@DOLCCEBI@location?7?$CFd?7?$CFd?6@
  00033	8d 95 78 ff ff
	ff		 lea	 edx, DWORD PTR _buffer$[ebp]
  00039	52		 push	 edx
  0003a	e8 00 00 00 00	 call	 _sprintf
  0003f	83 c4 10	 add	 esp, 16			; 00000010H

; 756  : 
; 757  : 	// Transmit the message and wait for ack
; 758  : 	//
; 759  : 	transmit(delboy, buffer);

  00042	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _buffer$[ebp]
  00048	50		 push	 eax
  00049	8b 4d 08	 mov	 ecx, DWORD PTR _delboy$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 _transmit
  00052	83 c4 08	 add	 esp, 8

; 760  : }

  00055	52		 push	 edx
  00056	8b cd		 mov	 ecx, ebp
  00058	50		 push	 eax
  00059	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@location
  0005f	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00064	58		 pop	 eax
  00065	5a		 pop	 edx
  00066	5f		 pop	 edi
  00067	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006a	33 cd		 xor	 ecx, ebp
  0006c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00071	81 c4 8c 00 00
	00		 add	 esp, 140		; 0000008cH
  00077	3b ec		 cmp	 ebp, esp
  00079	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c3		 ret	 0
  00082	66 90		 npad	 2
$LN5@location:
  00084	01 00 00 00	 DD	 1
  00088	00 00 00 00	 DD	 $LN4@location
$LN4@location:
  0008c	78 ff ff ff	 DD	 -136			; ffffff78H
  00090	80 00 00 00	 DD	 128			; 00000080H
  00094	00 00 00 00	 DD	 $LN3@location
$LN3@location:
  00098	62		 DB	 98			; 00000062H
  00099	75		 DB	 117			; 00000075H
  0009a	66		 DB	 102			; 00000066H
  0009b	66		 DB	 102			; 00000066H
  0009c	65		 DB	 101			; 00000065H
  0009d	72		 DB	 114			; 00000072H
  0009e	00		 DB	 0
_location ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3debughandlers.c
;	COMDAT _endBacktrack
_TEXT	SEGMENT
_buffer$ = -136						; size = 128
__$ArrayPad$ = -4					; size = 4
_delboy$ = 8						; size = 4
_level$ = 12						; size = 4
_successful$ = 16					; size = 1
_endBacktrack PROC					; COMDAT

; 740  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 8c 00 00
	00		 sub	 esp, 140		; 0000008cH
  00009	57		 push	 edi
  0000a	8d bd 74 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-140]
  00010	b9 23 00 00 00	 mov	 ecx, 35			; 00000023H
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 741  : 	char buffer[128];
; 742  : 
; 743  : 	sprintf(buffer, "endBacktrack\t%d\t%d\n", level, successful);

  00026	0f b6 45 10	 movzx	 eax, BYTE PTR _successful$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR _level$[ebp]
  0002e	51		 push	 ecx
  0002f	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@JACBLDCL@endBacktrack?7?$CFd?7?$CFd?6@
  00034	8d 95 78 ff ff
	ff		 lea	 edx, DWORD PTR _buffer$[ebp]
  0003a	52		 push	 edx
  0003b	e8 00 00 00 00	 call	 _sprintf
  00040	83 c4 10	 add	 esp, 16			; 00000010H

; 744  : 
; 745  : 	// Transmit the message and wait for ack
; 746  : 	//
; 747  : 	transmit(delboy, buffer);

  00043	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _buffer$[ebp]
  00049	50		 push	 eax
  0004a	8b 4d 08	 mov	 ecx, DWORD PTR _delboy$[ebp]
  0004d	51		 push	 ecx
  0004e	e8 00 00 00 00	 call	 _transmit
  00053	83 c4 08	 add	 esp, 8

; 748  : }

  00056	52		 push	 edx
  00057	8b cd		 mov	 ecx, ebp
  00059	50		 push	 eax
  0005a	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@endBacktra
  00060	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00065	58		 pop	 eax
  00066	5a		 pop	 edx
  00067	5f		 pop	 edi
  00068	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006b	33 cd		 xor	 ecx, ebp
  0006d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00072	81 c4 8c 00 00
	00		 add	 esp, 140		; 0000008cH
  00078	3b ec		 cmp	 ebp, esp
  0007a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
  00083	90		 npad	 1
$LN5@endBacktra:
  00084	01 00 00 00	 DD	 1
  00088	00 00 00 00	 DD	 $LN4@endBacktra
$LN4@endBacktra:
  0008c	78 ff ff ff	 DD	 -136			; ffffff78H
  00090	80 00 00 00	 DD	 128			; 00000080H
  00094	00 00 00 00	 DD	 $LN3@endBacktra
$LN3@endBacktra:
  00098	62		 DB	 98			; 00000062H
  00099	75		 DB	 117			; 00000075H
  0009a	66		 DB	 102			; 00000066H
  0009b	66		 DB	 102			; 00000066H
  0009c	65		 DB	 101			; 00000065H
  0009d	72		 DB	 114			; 00000072H
  0009e	00		 DB	 0
_endBacktrack ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3debughandlers.c
;	COMDAT _beginBacktrack
_TEXT	SEGMENT
_buffer$ = -136						; size = 128
__$ArrayPad$ = -4					; size = 4
_delboy$ = 8						; size = 4
_level$ = 12						; size = 4
_beginBacktrack PROC					; COMDAT

; 728  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 8c 00 00
	00		 sub	 esp, 140		; 0000008cH
  00009	57		 push	 edi
  0000a	8d bd 74 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-140]
  00010	b9 23 00 00 00	 mov	 ecx, 35			; 00000023H
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 729  : 	char buffer[128];
; 730  : 
; 731  : 	sprintf(buffer, "beginBacktrack\t%d\n", (ANTLR3_UINT32)(level & 0xFFFFFFFF));

  00026	8b 45 0c	 mov	 eax, DWORD PTR _level$[ebp]
  00029	50		 push	 eax
  0002a	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@LEGDBIBN@beginBacktrack?7?$CFd?6@
  0002f	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _buffer$[ebp]
  00035	51		 push	 ecx
  00036	e8 00 00 00 00	 call	 _sprintf
  0003b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 732  : 
; 733  : 	// Transmit the message and wait for ack
; 734  : 	//
; 735  : 	transmit(delboy, buffer);

  0003e	8d 95 78 ff ff
	ff		 lea	 edx, DWORD PTR _buffer$[ebp]
  00044	52		 push	 edx
  00045	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  00048	50		 push	 eax
  00049	e8 00 00 00 00	 call	 _transmit
  0004e	83 c4 08	 add	 esp, 8

; 736  : }

  00051	52		 push	 edx
  00052	8b cd		 mov	 ecx, ebp
  00054	50		 push	 eax
  00055	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@beginBackt
  0005b	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00060	58		 pop	 eax
  00061	5a		 pop	 edx
  00062	5f		 pop	 edi
  00063	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00066	33 cd		 xor	 ecx, ebp
  00068	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006d	81 c4 8c 00 00
	00		 add	 esp, 140		; 0000008cH
  00073	3b ec		 cmp	 ebp, esp
  00075	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
  0007e	66 90		 npad	 2
$LN5@beginBackt:
  00080	01 00 00 00	 DD	 1
  00084	00 00 00 00	 DD	 $LN4@beginBackt
$LN4@beginBackt:
  00088	78 ff ff ff	 DD	 -136			; ffffff78H
  0008c	80 00 00 00	 DD	 128			; 00000080H
  00090	00 00 00 00	 DD	 $LN3@beginBackt
$LN3@beginBackt:
  00094	62		 DB	 98			; 00000062H
  00095	75		 DB	 117			; 00000075H
  00096	66		 DB	 102			; 00000066H
  00097	66		 DB	 102			; 00000066H
  00098	65		 DB	 101			; 00000065H
  00099	72		 DB	 114			; 00000072H
  0009a	00		 DB	 0
_beginBacktrack ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3debughandlers.c
;	COMDAT _rewindLast
_TEXT	SEGMENT
_delboy$ = 8						; size = 4
_rewindLast PROC					; COMDAT

; 722  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 723  : 	transmit(delboy, (const char *)"rewind\n");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_07EBOLPGDK@rewind?6@
  00008	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 _transmit
  00011	83 c4 08	 add	 esp, 8

; 724  : }

  00014	3b ec		 cmp	 ebp, esp
  00016	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
_rewindLast ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3debughandlers.c
;	COMDAT _rewindMark
_TEXT	SEGMENT
_buffer$ = -136						; size = 128
__$ArrayPad$ = -4					; size = 4
_delboy$ = 8						; size = 4
_marker$ = 12						; size = 4
_rewindMark PROC					; COMDAT

; 709  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 8c 00 00
	00		 sub	 esp, 140		; 0000008cH
  00009	57		 push	 edi
  0000a	8d bd 74 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-140]
  00010	b9 23 00 00 00	 mov	 ecx, 35			; 00000023H
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 710  : 	char buffer[128];
; 711  : 
; 712  : 	sprintf(buffer, "rewind\t%d\n", (ANTLR3_UINT32)(marker & 0xFFFFFFFF));

  00026	8b 45 0c	 mov	 eax, DWORD PTR _marker$[ebp]
  00029	50		 push	 eax
  0002a	68 00 00 00 00	 push	 OFFSET ??_C@_0L@DJLPLDGG@rewind?7?$CFd?6@
  0002f	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _buffer$[ebp]
  00035	51		 push	 ecx
  00036	e8 00 00 00 00	 call	 _sprintf
  0003b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 713  : 
; 714  : 	// Transmit the message and wait for ack
; 715  : 	//
; 716  : 	transmit(delboy, buffer);

  0003e	8d 95 78 ff ff
	ff		 lea	 edx, DWORD PTR _buffer$[ebp]
  00044	52		 push	 edx
  00045	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  00048	50		 push	 eax
  00049	e8 00 00 00 00	 call	 _transmit
  0004e	83 c4 08	 add	 esp, 8

; 717  : 
; 718  : }

  00051	52		 push	 edx
  00052	8b cd		 mov	 ecx, ebp
  00054	50		 push	 eax
  00055	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@rewindMark
  0005b	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00060	58		 pop	 eax
  00061	5a		 pop	 edx
  00062	5f		 pop	 edi
  00063	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00066	33 cd		 xor	 ecx, ebp
  00068	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006d	81 c4 8c 00 00
	00		 add	 esp, 140		; 0000008cH
  00073	3b ec		 cmp	 ebp, esp
  00075	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
  0007e	66 90		 npad	 2
$LN5@rewindMark:
  00080	01 00 00 00	 DD	 1
  00084	00 00 00 00	 DD	 $LN4@rewindMark
$LN4@rewindMark:
  00088	78 ff ff ff	 DD	 -136			; ffffff78H
  0008c	80 00 00 00	 DD	 128			; 00000080H
  00090	00 00 00 00	 DD	 $LN3@rewindMark
$LN3@rewindMark:
  00094	62		 DB	 98			; 00000062H
  00095	75		 DB	 117			; 00000075H
  00096	66		 DB	 102			; 00000066H
  00097	66		 DB	 102			; 00000066H
  00098	65		 DB	 101			; 00000065H
  00099	72		 DB	 114			; 00000072H
  0009a	00		 DB	 0
_rewindMark ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3debughandlers.c
;	COMDAT _mark
_TEXT	SEGMENT
_buffer$ = -136						; size = 128
__$ArrayPad$ = -4					; size = 4
_delboy$ = 8						; size = 4
_marker$ = 12						; size = 4
_mark	PROC						; COMDAT

; 697  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 8c 00 00
	00		 sub	 esp, 140		; 0000008cH
  00009	57		 push	 edi
  0000a	8d bd 74 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-140]
  00010	b9 23 00 00 00	 mov	 ecx, 35			; 00000023H
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 698  : 	char buffer[128];
; 699  : 
; 700  : 	sprintf(buffer, "mark\t%d\n", (ANTLR3_UINT32)(marker & 0xFFFFFFFF));

  00026	8b 45 0c	 mov	 eax, DWORD PTR _marker$[ebp]
  00029	50		 push	 eax
  0002a	68 00 00 00 00	 push	 OFFSET ??_C@_08JOJCKFBH@mark?7?$CFd?6@
  0002f	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _buffer$[ebp]
  00035	51		 push	 ecx
  00036	e8 00 00 00 00	 call	 _sprintf
  0003b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 701  : 
; 702  : 	// Transmit the message and wait for ack
; 703  : 	//
; 704  : 	transmit(delboy, buffer);

  0003e	8d 95 78 ff ff
	ff		 lea	 edx, DWORD PTR _buffer$[ebp]
  00044	52		 push	 edx
  00045	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  00048	50		 push	 eax
  00049	e8 00 00 00 00	 call	 _transmit
  0004e	83 c4 08	 add	 esp, 8

; 705  : }

  00051	52		 push	 edx
  00052	8b cd		 mov	 ecx, ebp
  00054	50		 push	 eax
  00055	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@mark
  0005b	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00060	58		 pop	 eax
  00061	5a		 pop	 edx
  00062	5f		 pop	 edi
  00063	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00066	33 cd		 xor	 ecx, ebp
  00068	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006d	81 c4 8c 00 00
	00		 add	 esp, 140		; 0000008cH
  00073	3b ec		 cmp	 ebp, esp
  00075	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
  0007e	66 90		 npad	 2
$LN5@mark:
  00080	01 00 00 00	 DD	 1
  00084	00 00 00 00	 DD	 $LN4@mark
$LN4@mark:
  00088	78 ff ff ff	 DD	 -136			; ffffff78H
  0008c	80 00 00 00	 DD	 128			; 00000080H
  00090	00 00 00 00	 DD	 $LN3@mark
$LN3@mark:
  00094	62		 DB	 98			; 00000062H
  00095	75		 DB	 117			; 00000075H
  00096	66		 DB	 102			; 00000066H
  00097	66		 DB	 102			; 00000066H
  00098	65		 DB	 101			; 00000065H
  00099	72		 DB	 114			; 00000072H
  0009a	00		 DB	 0
_mark	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3debughandlers.c
;	COMDAT _LT
_TEXT	SEGMENT
_msg$ = -4						; size = 4
_delboy$ = 8						; size = 4
_i$ = 12						; size = 4
_t$ = 16						; size = 4
_LT	PROC						; COMDAT

; 669  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 670  : 	pANTLR3_STRING msg;
; 671  : 
; 672  : 	if	(t != NULL)

  0000c	83 7d 10 00	 cmp	 DWORD PTR _t$[ebp], 0
  00010	0f 84 9c 00 00
	00		 je	 $LN2@LT

; 673  : 	{
; 674  : 		// Create the serialized token
; 675  : 		//
; 676  : 		msg = serializeToken(delboy, t);

  00016	8b 45 10	 mov	 eax, DWORD PTR _t$[ebp]
  00019	50		 push	 eax
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR _delboy$[ebp]
  0001d	51		 push	 ecx
  0001e	e8 00 00 00 00	 call	 _serializeToken
  00023	83 c4 08	 add	 esp, 8
  00026	89 45 fc	 mov	 DWORD PTR _msg$[ebp], eax

; 677  : 
; 678  : 		// Insert the index parameter
; 679  : 		//
; 680  : 		msg->insert8(msg, 0, "\t");

  00029	8b f4		 mov	 esi, esp
  0002b	68 00 00 00 00	 push	 OFFSET ??_C@_01GPOEFGEJ@?7@
  00030	6a 00		 push	 0
  00032	8b 55 fc	 mov	 edx, DWORD PTR _msg$[ebp]
  00035	52		 push	 edx
  00036	8b 45 fc	 mov	 eax, DWORD PTR _msg$[ebp]
  00039	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  0003c	ff d1		 call	 ecx
  0003e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00041	3b f4		 cmp	 esi, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 681  : 		msg->inserti(msg, 0, i);

  00048	8b f4		 mov	 esi, esp
  0004a	8b 55 0c	 mov	 edx, DWORD PTR _i$[ebp]
  0004d	52		 push	 edx
  0004e	6a 00		 push	 0
  00050	8b 45 fc	 mov	 eax, DWORD PTR _msg$[ebp]
  00053	50		 push	 eax
  00054	8b 4d fc	 mov	 ecx, DWORD PTR _msg$[ebp]
  00057	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  0005a	ff d2		 call	 edx
  0005c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005f	3b f4		 cmp	 esi, esp
  00061	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 682  : 
; 683  : 		// Insert the debug event indicator
; 684  : 		//
; 685  : 		msg->insert8(msg, 0, "LT\t");

  00066	8b f4		 mov	 esi, esp
  00068	68 00 00 00 00	 push	 OFFSET ??_C@_03LFAOPKED@LT?7@
  0006d	6a 00		 push	 0
  0006f	8b 45 fc	 mov	 eax, DWORD PTR _msg$[ebp]
  00072	50		 push	 eax
  00073	8b 4d fc	 mov	 ecx, DWORD PTR _msg$[ebp]
  00076	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00079	ff d2		 call	 edx
  0007b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007e	3b f4		 cmp	 esi, esp
  00080	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 686  : 
; 687  : 		msg->addc(msg, '\n');

  00085	8b f4		 mov	 esi, esp
  00087	6a 0a		 push	 10			; 0000000aH
  00089	8b 45 fc	 mov	 eax, DWORD PTR _msg$[ebp]
  0008c	50		 push	 eax
  0008d	8b 4d fc	 mov	 ecx, DWORD PTR _msg$[ebp]
  00090	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  00093	ff d2		 call	 edx
  00095	83 c4 08	 add	 esp, 8
  00098	3b f4		 cmp	 esi, esp
  0009a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 688  : 
; 689  : 		// Transmit the message and wait for ack
; 690  : 		//
; 691  : 		transmit(delboy, (const char *)(msg->chars));

  0009f	8b 45 fc	 mov	 eax, DWORD PTR _msg$[ebp]
  000a2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000a5	51		 push	 ecx
  000a6	8b 55 08	 mov	 edx, DWORD PTR _delboy$[ebp]
  000a9	52		 push	 edx
  000aa	e8 00 00 00 00	 call	 _transmit
  000af	83 c4 08	 add	 esp, 8
$LN2@LT:

; 692  : 	}
; 693  : }

  000b2	5e		 pop	 esi
  000b3	83 c4 04	 add	 esp, 4
  000b6	3b ec		 cmp	 ebp, esp
  000b8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bd	8b e5		 mov	 esp, ebp
  000bf	5d		 pop	 ebp
  000c0	c3		 ret	 0
_LT	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3debughandlers.c
;	COMDAT _consumeHiddenToken
_TEXT	SEGMENT
_msg$ = -4						; size = 4
_delboy$ = 8						; size = 4
_t$ = 12						; size = 4
_consumeHiddenToken PROC				; COMDAT

; 647  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 648  : 	pANTLR3_STRING msg;
; 649  : 
; 650  : 	// Create the serialized token
; 651  : 	//
; 652  : 	msg = serializeToken(delboy, t);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR _t$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _delboy$[ebp]
  00013	51		 push	 ecx
  00014	e8 00 00 00 00	 call	 _serializeToken
  00019	83 c4 08	 add	 esp, 8
  0001c	89 45 fc	 mov	 DWORD PTR _msg$[ebp], eax

; 653  : 
; 654  : 	// Insert the debug event indicator
; 655  : 	//
; 656  : 	msg->insert8(msg, 0, "consumeHiddenToken\t");

  0001f	8b f4		 mov	 esi, esp
  00021	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@GEGFGNHF@consumeHiddenToken?7@
  00026	6a 00		 push	 0
  00028	8b 55 fc	 mov	 edx, DWORD PTR _msg$[ebp]
  0002b	52		 push	 edx
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _msg$[ebp]
  0002f	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  00032	ff d1		 call	 ecx
  00034	83 c4 0c	 add	 esp, 12			; 0000000cH
  00037	3b f4		 cmp	 esi, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 657  : 
; 658  : 	msg->addc(msg, '\n');

  0003e	8b f4		 mov	 esi, esp
  00040	6a 0a		 push	 10			; 0000000aH
  00042	8b 55 fc	 mov	 edx, DWORD PTR _msg$[ebp]
  00045	52		 push	 edx
  00046	8b 45 fc	 mov	 eax, DWORD PTR _msg$[ebp]
  00049	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  0004c	ff d1		 call	 ecx
  0004e	83 c4 08	 add	 esp, 8
  00051	3b f4		 cmp	 esi, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 659  : 
; 660  : 	// Transmit the message and wait for ack
; 661  : 	//
; 662  : 	transmit(delboy, (const char *)(msg->chars));

  00058	8b 55 fc	 mov	 edx, DWORD PTR _msg$[ebp]
  0005b	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0005e	50		 push	 eax
  0005f	8b 4d 08	 mov	 ecx, DWORD PTR _delboy$[ebp]
  00062	51		 push	 ecx
  00063	e8 00 00 00 00	 call	 _transmit
  00068	83 c4 08	 add	 esp, 8

; 663  : }

  0006b	5e		 pop	 esi
  0006c	83 c4 04	 add	 esp, 4
  0006f	3b ec		 cmp	 ebp, esp
  00071	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00076	8b e5		 mov	 esp, ebp
  00078	5d		 pop	 ebp
  00079	c3		 ret	 0
_consumeHiddenToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3debughandlers.c
;	COMDAT _consumeToken
_TEXT	SEGMENT
_msg$ = -4						; size = 4
_delboy$ = 8						; size = 4
_t$ = 12						; size = 4
_consumeToken PROC					; COMDAT

; 627  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 628  : 	pANTLR3_STRING msg;
; 629  : 
; 630  : 	// Create the serialized token
; 631  : 	//
; 632  : 	msg = serializeToken(delboy, t);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR _t$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _delboy$[ebp]
  00013	51		 push	 ecx
  00014	e8 00 00 00 00	 call	 _serializeToken
  00019	83 c4 08	 add	 esp, 8
  0001c	89 45 fc	 mov	 DWORD PTR _msg$[ebp], eax

; 633  : 
; 634  : 	// Insert the debug event indicator
; 635  : 	//
; 636  : 	msg->insert8(msg, 0, "consumeToken\t");

  0001f	8b f4		 mov	 esi, esp
  00021	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CLDGECJA@consumeToken?7@
  00026	6a 00		 push	 0
  00028	8b 55 fc	 mov	 edx, DWORD PTR _msg$[ebp]
  0002b	52		 push	 edx
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _msg$[ebp]
  0002f	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  00032	ff d1		 call	 ecx
  00034	83 c4 0c	 add	 esp, 12			; 0000000cH
  00037	3b f4		 cmp	 esi, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 637  : 
; 638  : 	msg->addc(msg, '\n');

  0003e	8b f4		 mov	 esi, esp
  00040	6a 0a		 push	 10			; 0000000aH
  00042	8b 55 fc	 mov	 edx, DWORD PTR _msg$[ebp]
  00045	52		 push	 edx
  00046	8b 45 fc	 mov	 eax, DWORD PTR _msg$[ebp]
  00049	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  0004c	ff d1		 call	 ecx
  0004e	83 c4 08	 add	 esp, 8
  00051	3b f4		 cmp	 esi, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 639  : 
; 640  : 	// Transmit the message and wait for ack
; 641  : 	//
; 642  : 	transmit(delboy, (const char *)(msg->chars));

  00058	8b 55 fc	 mov	 edx, DWORD PTR _msg$[ebp]
  0005b	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0005e	50		 push	 eax
  0005f	8b 4d 08	 mov	 ecx, DWORD PTR _delboy$[ebp]
  00062	51		 push	 ecx
  00063	e8 00 00 00 00	 call	 _transmit
  00068	83 c4 08	 add	 esp, 8

; 643  : }

  0006b	5e		 pop	 esi
  0006c	83 c4 04	 add	 esp, 4
  0006f	3b ec		 cmp	 ebp, esp
  00071	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00076	8b e5		 mov	 esp, ebp
  00078	5d		 pop	 ebp
  00079	c3		 ret	 0
_consumeToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3debughandlers.c
;	COMDAT _exitDecision
_TEXT	SEGMENT
_buffer$ = -520						; size = 512
__$ArrayPad$ = -4					; size = 4
_delboy$ = 8						; size = 4
_decisionNumber$ = 12					; size = 4
_exitDecision PROC					; COMDAT

; 616  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 02 00
	00		 sub	 esp, 524		; 0000020cH
  00009	57		 push	 edi
  0000a	8d bd f4 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-524]
  00010	b9 83 00 00 00	 mov	 ecx, 131		; 00000083H
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 617  : 	char	buffer[512];
; 618  : 
; 619  : 	// Create the message (speed is not of the essence)
; 620  : 	//
; 621  : 	sprintf(buffer, "exitDecision\t%d\n", decisionNumber);

  00026	8b 45 0c	 mov	 eax, DWORD PTR _decisionNumber$[ebp]
  00029	50		 push	 eax
  0002a	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@JFOHGIEP@exitDecision?7?$CFd?6@
  0002f	8d 8d f8 fd ff
	ff		 lea	 ecx, DWORD PTR _buffer$[ebp]
  00035	51		 push	 ecx
  00036	e8 00 00 00 00	 call	 _sprintf
  0003b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 622  : 	transmit(delboy, buffer);

  0003e	8d 95 f8 fd ff
	ff		 lea	 edx, DWORD PTR _buffer$[ebp]
  00044	52		 push	 edx
  00045	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  00048	50		 push	 eax
  00049	e8 00 00 00 00	 call	 _transmit
  0004e	83 c4 08	 add	 esp, 8

; 623  : }

  00051	52		 push	 edx
  00052	8b cd		 mov	 ecx, ebp
  00054	50		 push	 eax
  00055	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@exitDecisi
  0005b	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00060	58		 pop	 eax
  00061	5a		 pop	 edx
  00062	5f		 pop	 edi
  00063	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00066	33 cd		 xor	 ecx, ebp
  00068	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006d	81 c4 0c 02 00
	00		 add	 esp, 524		; 0000020cH
  00073	3b ec		 cmp	 ebp, esp
  00075	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
  0007e	66 90		 npad	 2
$LN5@exitDecisi:
  00080	01 00 00 00	 DD	 1
  00084	00 00 00 00	 DD	 $LN4@exitDecisi
$LN4@exitDecisi:
  00088	f8 fd ff ff	 DD	 -520			; fffffdf8H
  0008c	00 02 00 00	 DD	 512			; 00000200H
  00090	00 00 00 00	 DD	 $LN3@exitDecisi
$LN3@exitDecisi:
  00094	62		 DB	 98			; 00000062H
  00095	75		 DB	 117			; 00000075H
  00096	66		 DB	 102			; 00000066H
  00097	66		 DB	 102			; 00000066H
  00098	65		 DB	 101			; 00000065H
  00099	72		 DB	 114			; 00000072H
  0009a	00		 DB	 0
_exitDecision ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3debughandlers.c
;	COMDAT _enterDecision
_TEXT	SEGMENT
_buffer$ = -520						; size = 512
__$ArrayPad$ = -4					; size = 4
_delboy$ = 8						; size = 4
_decisionNumber$ = 12					; size = 4
_enterDecision PROC					; COMDAT

; 604  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 02 00
	00		 sub	 esp, 524		; 0000020cH
  00009	57		 push	 edi
  0000a	8d bd f4 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-524]
  00010	b9 83 00 00 00	 mov	 ecx, 131		; 00000083H
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 605  : 	char	buffer[512];
; 606  : 
; 607  : 	// Create the message (speed is not of the essence)
; 608  : 	//
; 609  : 	sprintf(buffer, "enterDecision\t%d\n", decisionNumber);

  00026	8b 45 0c	 mov	 eax, DWORD PTR _decisionNumber$[ebp]
  00029	50		 push	 eax
  0002a	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@JHLNNKII@enterDecision?7?$CFd?6@
  0002f	8d 8d f8 fd ff
	ff		 lea	 ecx, DWORD PTR _buffer$[ebp]
  00035	51		 push	 ecx
  00036	e8 00 00 00 00	 call	 _sprintf
  0003b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 610  : 	transmit(delboy, buffer);

  0003e	8d 95 f8 fd ff
	ff		 lea	 edx, DWORD PTR _buffer$[ebp]
  00044	52		 push	 edx
  00045	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  00048	50		 push	 eax
  00049	e8 00 00 00 00	 call	 _transmit
  0004e	83 c4 08	 add	 esp, 8

; 611  : 
; 612  : }

  00051	52		 push	 edx
  00052	8b cd		 mov	 ecx, ebp
  00054	50		 push	 eax
  00055	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@enterDecis
  0005b	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00060	58		 pop	 eax
  00061	5a		 pop	 edx
  00062	5f		 pop	 edi
  00063	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00066	33 cd		 xor	 ecx, ebp
  00068	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006d	81 c4 0c 02 00
	00		 add	 esp, 524		; 0000020cH
  00073	3b ec		 cmp	 ebp, esp
  00075	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
  0007e	66 90		 npad	 2
$LN5@enterDecis:
  00080	01 00 00 00	 DD	 1
  00084	00 00 00 00	 DD	 $LN4@enterDecis
$LN4@enterDecis:
  00088	f8 fd ff ff	 DD	 -520			; fffffdf8H
  0008c	00 02 00 00	 DD	 512			; 00000200H
  00090	00 00 00 00	 DD	 $LN3@enterDecis
$LN3@enterDecis:
  00094	62		 DB	 98			; 00000062H
  00095	75		 DB	 117			; 00000075H
  00096	66		 DB	 102			; 00000066H
  00097	66		 DB	 102			; 00000066H
  00098	65		 DB	 101			; 00000065H
  00099	72		 DB	 114			; 00000072H
  0009a	00		 DB	 0
_enterDecision ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3debughandlers.c
;	COMDAT _exitSubRule
_TEXT	SEGMENT
_buffer$ = -520						; size = 512
__$ArrayPad$ = -4					; size = 4
_delboy$ = 8						; size = 4
_decisionNumber$ = 12					; size = 4
_exitSubRule PROC					; COMDAT

; 593  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 02 00
	00		 sub	 esp, 524		; 0000020cH
  00009	57		 push	 edi
  0000a	8d bd f4 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-524]
  00010	b9 83 00 00 00	 mov	 ecx, 131		; 00000083H
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 594  : 	char	buffer[512];
; 595  : 
; 596  : 	// Create the message (speed is not of the essence)
; 597  : 	//
; 598  : 	sprintf(buffer, "exitSubRule\t%d\n", decisionNumber);

  00026	8b 45 0c	 mov	 eax, DWORD PTR _decisionNumber$[ebp]
  00029	50		 push	 eax
  0002a	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FDDLMOBM@exitSubRule?7?$CFd?6@
  0002f	8d 8d f8 fd ff
	ff		 lea	 ecx, DWORD PTR _buffer$[ebp]
  00035	51		 push	 ecx
  00036	e8 00 00 00 00	 call	 _sprintf
  0003b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 599  : 	transmit(delboy, buffer);

  0003e	8d 95 f8 fd ff
	ff		 lea	 edx, DWORD PTR _buffer$[ebp]
  00044	52		 push	 edx
  00045	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  00048	50		 push	 eax
  00049	e8 00 00 00 00	 call	 _transmit
  0004e	83 c4 08	 add	 esp, 8

; 600  : }

  00051	52		 push	 edx
  00052	8b cd		 mov	 ecx, ebp
  00054	50		 push	 eax
  00055	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@exitSubRul
  0005b	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00060	58		 pop	 eax
  00061	5a		 pop	 edx
  00062	5f		 pop	 edi
  00063	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00066	33 cd		 xor	 ecx, ebp
  00068	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006d	81 c4 0c 02 00
	00		 add	 esp, 524		; 0000020cH
  00073	3b ec		 cmp	 ebp, esp
  00075	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
  0007e	66 90		 npad	 2
$LN5@exitSubRul:
  00080	01 00 00 00	 DD	 1
  00084	00 00 00 00	 DD	 $LN4@exitSubRul
$LN4@exitSubRul:
  00088	f8 fd ff ff	 DD	 -520			; fffffdf8H
  0008c	00 02 00 00	 DD	 512			; 00000200H
  00090	00 00 00 00	 DD	 $LN3@exitSubRul
$LN3@exitSubRul:
  00094	62		 DB	 98			; 00000062H
  00095	75		 DB	 117			; 00000075H
  00096	66		 DB	 102			; 00000066H
  00097	66		 DB	 102			; 00000066H
  00098	65		 DB	 101			; 00000065H
  00099	72		 DB	 114			; 00000072H
  0009a	00		 DB	 0
_exitSubRule ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3debughandlers.c
;	COMDAT _enterSubRule
_TEXT	SEGMENT
_buffer$ = -520						; size = 512
__$ArrayPad$ = -4					; size = 4
_delboy$ = 8						; size = 4
_decisionNumber$ = 12					; size = 4
_enterSubRule PROC					; COMDAT

; 582  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 02 00
	00		 sub	 esp, 524		; 0000020cH
  00009	57		 push	 edi
  0000a	8d bd f4 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-524]
  00010	b9 83 00 00 00	 mov	 ecx, 131		; 00000083H
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 583  : 	char	buffer[512];
; 584  : 
; 585  : 	// Create the message (speed is not of the essence)
; 586  : 	//
; 587  : 	sprintf(buffer, "enterSubRule\t%d\n", decisionNumber);

  00026	8b 45 0c	 mov	 eax, DWORD PTR _decisionNumber$[ebp]
  00029	50		 push	 eax
  0002a	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@GEBKADNP@enterSubRule?7?$CFd?6@
  0002f	8d 8d f8 fd ff
	ff		 lea	 ecx, DWORD PTR _buffer$[ebp]
  00035	51		 push	 ecx
  00036	e8 00 00 00 00	 call	 _sprintf
  0003b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 588  : 	transmit(delboy, buffer);

  0003e	8d 95 f8 fd ff
	ff		 lea	 edx, DWORD PTR _buffer$[ebp]
  00044	52		 push	 edx
  00045	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  00048	50		 push	 eax
  00049	e8 00 00 00 00	 call	 _transmit
  0004e	83 c4 08	 add	 esp, 8

; 589  : }

  00051	52		 push	 edx
  00052	8b cd		 mov	 ecx, ebp
  00054	50		 push	 eax
  00055	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@enterSubRu
  0005b	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00060	58		 pop	 eax
  00061	5a		 pop	 edx
  00062	5f		 pop	 edi
  00063	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00066	33 cd		 xor	 ecx, ebp
  00068	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006d	81 c4 0c 02 00
	00		 add	 esp, 524		; 0000020cH
  00073	3b ec		 cmp	 ebp, esp
  00075	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
  0007e	66 90		 npad	 2
$LN5@enterSubRu:
  00080	01 00 00 00	 DD	 1
  00084	00 00 00 00	 DD	 $LN4@enterSubRu
$LN4@enterSubRu:
  00088	f8 fd ff ff	 DD	 -520			; fffffdf8H
  0008c	00 02 00 00	 DD	 512			; 00000200H
  00090	00 00 00 00	 DD	 $LN3@enterSubRu
$LN3@enterSubRu:
  00094	62		 DB	 98			; 00000062H
  00095	75		 DB	 117			; 00000075H
  00096	66		 DB	 102			; 00000066H
  00097	66		 DB	 102			; 00000066H
  00098	65		 DB	 101			; 00000065H
  00099	72		 DB	 114			; 00000072H
  0009a	00		 DB	 0
_enterSubRule ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3debughandlers.c
;	COMDAT _exitRule
_TEXT	SEGMENT
_buffer$ = -520						; size = 512
__$ArrayPad$ = -4					; size = 4
_delboy$ = 8						; size = 4
_grammarFileName$ = 12					; size = 4
_ruleName$ = 16						; size = 4
_exitRule PROC						; COMDAT

; 571  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 02 00
	00		 sub	 esp, 524		; 0000020cH
  00009	57		 push	 edi
  0000a	8d bd f4 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-524]
  00010	b9 83 00 00 00	 mov	 ecx, 131		; 00000083H
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 572  : 	char	buffer[512];
; 573  : 
; 574  : 	// Create the message (speed is not of the essence)
; 575  : 	//
; 576  : 	sprintf(buffer, "exitRule\t%s\t%s\n", grammarFileName, ruleName);

  00026	8b 45 10	 mov	 eax, DWORD PTR _ruleName$[ebp]
  00029	50		 push	 eax
  0002a	8b 4d 0c	 mov	 ecx, DWORD PTR _grammarFileName$[ebp]
  0002d	51		 push	 ecx
  0002e	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@HKINPPNN@exitRule?7?$CFs?7?$CFs?6@
  00033	8d 95 f8 fd ff
	ff		 lea	 edx, DWORD PTR _buffer$[ebp]
  00039	52		 push	 edx
  0003a	e8 00 00 00 00	 call	 _sprintf
  0003f	83 c4 10	 add	 esp, 16			; 00000010H

; 577  : 	transmit(delboy, buffer);

  00042	8d 85 f8 fd ff
	ff		 lea	 eax, DWORD PTR _buffer$[ebp]
  00048	50		 push	 eax
  00049	8b 4d 08	 mov	 ecx, DWORD PTR _delboy$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 _transmit
  00052	83 c4 08	 add	 esp, 8

; 578  : }

  00055	52		 push	 edx
  00056	8b cd		 mov	 ecx, ebp
  00058	50		 push	 eax
  00059	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@exitRule
  0005f	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00064	58		 pop	 eax
  00065	5a		 pop	 edx
  00066	5f		 pop	 edi
  00067	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006a	33 cd		 xor	 ecx, ebp
  0006c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00071	81 c4 0c 02 00
	00		 add	 esp, 524		; 0000020cH
  00077	3b ec		 cmp	 ebp, esp
  00079	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c3		 ret	 0
  00082	66 90		 npad	 2
$LN5@exitRule:
  00084	01 00 00 00	 DD	 1
  00088	00 00 00 00	 DD	 $LN4@exitRule
$LN4@exitRule:
  0008c	f8 fd ff ff	 DD	 -520			; fffffdf8H
  00090	00 02 00 00	 DD	 512			; 00000200H
  00094	00 00 00 00	 DD	 $LN3@exitRule
$LN3@exitRule:
  00098	62		 DB	 98			; 00000062H
  00099	75		 DB	 117			; 00000075H
  0009a	66		 DB	 102			; 00000066H
  0009b	66		 DB	 102			; 00000066H
  0009c	65		 DB	 101			; 00000065H
  0009d	72		 DB	 114			; 00000072H
  0009e	00		 DB	 0
_exitRule ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3debughandlers.c
;	COMDAT _enterAlt
_TEXT	SEGMENT
_buffer$ = -520						; size = 512
__$ArrayPad$ = -4					; size = 4
_delboy$ = 8						; size = 4
_alt$ = 12						; size = 4
_enterAlt PROC						; COMDAT

; 560  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 02 00
	00		 sub	 esp, 524		; 0000020cH
  00009	57		 push	 edi
  0000a	8d bd f4 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-524]
  00010	b9 83 00 00 00	 mov	 ecx, 131		; 00000083H
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 561  : 	char	buffer[512];
; 562  : 
; 563  : 	// Create the message (speed is not of the essence)
; 564  : 	//
; 565  : 	sprintf(buffer, "enterAlt\t%d\n", alt);

  00026	8b 45 0c	 mov	 eax, DWORD PTR _alt$[ebp]
  00029	50		 push	 eax
  0002a	68 00 00 00 00	 push	 OFFSET ??_C@_0N@JDALHHAO@enterAlt?7?$CFd?6@
  0002f	8d 8d f8 fd ff
	ff		 lea	 ecx, DWORD PTR _buffer$[ebp]
  00035	51		 push	 ecx
  00036	e8 00 00 00 00	 call	 _sprintf
  0003b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 566  : 	transmit(delboy, buffer);

  0003e	8d 95 f8 fd ff
	ff		 lea	 edx, DWORD PTR _buffer$[ebp]
  00044	52		 push	 edx
  00045	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  00048	50		 push	 eax
  00049	e8 00 00 00 00	 call	 _transmit
  0004e	83 c4 08	 add	 esp, 8

; 567  : }

  00051	52		 push	 edx
  00052	8b cd		 mov	 ecx, ebp
  00054	50		 push	 eax
  00055	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@enterAlt
  0005b	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00060	58		 pop	 eax
  00061	5a		 pop	 edx
  00062	5f		 pop	 edi
  00063	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00066	33 cd		 xor	 ecx, ebp
  00068	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006d	81 c4 0c 02 00
	00		 add	 esp, 524		; 0000020cH
  00073	3b ec		 cmp	 ebp, esp
  00075	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
  0007e	66 90		 npad	 2
$LN5@enterAlt:
  00080	01 00 00 00	 DD	 1
  00084	00 00 00 00	 DD	 $LN4@enterAlt
$LN4@enterAlt:
  00088	f8 fd ff ff	 DD	 -520			; fffffdf8H
  0008c	00 02 00 00	 DD	 512			; 00000200H
  00090	00 00 00 00	 DD	 $LN3@enterAlt
$LN3@enterAlt:
  00094	62		 DB	 98			; 00000062H
  00095	75		 DB	 117			; 00000075H
  00096	66		 DB	 102			; 00000066H
  00097	66		 DB	 102			; 00000066H
  00098	65		 DB	 101			; 00000065H
  00099	72		 DB	 114			; 00000072H
  0009a	00		 DB	 0
_enterAlt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3debughandlers.c
;	COMDAT _enterRule
_TEXT	SEGMENT
_buffer$ = -520						; size = 512
__$ArrayPad$ = -4					; size = 4
_delboy$ = 8						; size = 4
_grammarFileName$ = 12					; size = 4
_ruleName$ = 16						; size = 4
_enterRule PROC						; COMDAT

; 549  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 02 00
	00		 sub	 esp, 524		; 0000020cH
  00009	57		 push	 edi
  0000a	8d bd f4 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-524]
  00010	b9 83 00 00 00	 mov	 ecx, 131		; 00000083H
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 550  : 	char	buffer[512];
; 551  : 
; 552  : 	// Create the message (speed is not of the essence)
; 553  : 	//
; 554  : 	sprintf(buffer, "enterRule\t%s\t%s\n", grammarFileName, ruleName);

  00026	8b 45 10	 mov	 eax, DWORD PTR _ruleName$[ebp]
  00029	50		 push	 eax
  0002a	8b 4d 0c	 mov	 ecx, DWORD PTR _grammarFileName$[ebp]
  0002d	51		 push	 ecx
  0002e	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@ENKMDCBO@enterRule?7?$CFs?7?$CFs?6@
  00033	8d 95 f8 fd ff
	ff		 lea	 edx, DWORD PTR _buffer$[ebp]
  00039	52		 push	 edx
  0003a	e8 00 00 00 00	 call	 _sprintf
  0003f	83 c4 10	 add	 esp, 16			; 00000010H

; 555  : 	transmit(delboy, buffer);

  00042	8d 85 f8 fd ff
	ff		 lea	 eax, DWORD PTR _buffer$[ebp]
  00048	50		 push	 eax
  00049	8b 4d 08	 mov	 ecx, DWORD PTR _delboy$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 _transmit
  00052	83 c4 08	 add	 esp, 8

; 556  : }

  00055	52		 push	 edx
  00056	8b cd		 mov	 ecx, ebp
  00058	50		 push	 eax
  00059	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@enterRule
  0005f	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00064	58		 pop	 eax
  00065	5a		 pop	 edx
  00066	5f		 pop	 edi
  00067	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006a	33 cd		 xor	 ecx, ebp
  0006c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00071	81 c4 0c 02 00
	00		 add	 esp, 524		; 0000020cH
  00077	3b ec		 cmp	 ebp, esp
  00079	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c3		 ret	 0
  00082	66 90		 npad	 2
$LN5@enterRule:
  00084	01 00 00 00	 DD	 1
  00088	00 00 00 00	 DD	 $LN4@enterRule
$LN4@enterRule:
  0008c	f8 fd ff ff	 DD	 -520			; fffffdf8H
  00090	00 02 00 00	 DD	 512			; 00000200H
  00094	00 00 00 00	 DD	 $LN3@enterRule
$LN3@enterRule:
  00098	62		 DB	 98			; 00000062H
  00099	75		 DB	 117			; 00000075H
  0009a	66		 DB	 102			; 00000066H
  0009b	66		 DB	 102			; 00000066H
  0009c	65		 DB	 101			; 00000065H
  0009d	72		 DB	 114			; 00000072H
  0009e	00		 DB	 0
_enterRule ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3debughandlers.c
;	COMDAT _handshake
_TEXT	SEGMENT
_err$1 = -760						; size = 4
_wsaData$2 = -752					; size = 400
_wVersionRequested$3 = -348				; size = 2
_optVal$ = -340						; size = 4
_sockaddr_len$ = -328					; size = 4
_message$ = -316					; size = 256
_server$ = -52						; size = 16
_client$ = -28						; size = 16
_serverSocket$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_delboy$ = 8						; size = 4
_handshake PROC						; COMDAT

; 195  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f8 02 00
	00		 sub	 esp, 760		; 000002f8H
  00009	57		 push	 edi
  0000a	8d bd 08 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-760]
  00010	b9 be 00 00 00	 mov	 ecx, 190		; 000000beH
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 196  : 	/// Connection structure with which to wait and accept a connection from
; 197  : 	/// a debugger.
; 198  : 	///
; 199  : 	SOCKET				serverSocket;
; 200  : 
; 201  : 	// Connection structures to deal with the client after we accept the connection
; 202  : 	// and the server while we accept a connection.
; 203  : 	//
; 204  : 	ANTLR3_SOCKADDRT	client;
; 205  : 	ANTLR3_SOCKADDRT	server;
; 206  : 
; 207  : 	// Buffer to construct our message in
; 208  : 	//
; 209  : 	char	message[256];
; 210  : 
; 211  : 	// Specifies the length of the connection structure to accept()
; 212  : 	// Windows use int, everyone else uses size_t
; 213  : 	//
; 214  : 	ANTLR3_SALENT				sockaddr_len;
; 215  : 
; 216  : 	// Option holder for setsockopt()
; 217  : 	//
; 218  : 	int		optVal;
; 219  : 
; 220  : 	if	(delboy->initialized == ANTLR3_FALSE)

  00026	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  00029	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  0002d	85 c9		 test	 ecx, ecx
  0002f	0f 85 15 01 00
	00		 jne	 $LN2@handshake

; 221  : 	{
; 222  : 		// Windows requires us to initialize WinSock.
; 223  : 		//
; 224  : #ifdef ANTLR3_WINDOWS
; 225  : 		{
; 226  : 			WORD		wVersionRequested;
; 227  : 			WSADATA		wsaData;
; 228  : 			int			err;			// Return code from WSAStartup
; 229  : 
; 230  : 			// We must initialise the Windows socket system when the DLL is loaded.
; 231  : 			// We are asking for Winsock 1.1 or better as we don't need anything
; 232  : 			// too complicated for this.
; 233  : 			//
; 234  : 			wVersionRequested = MAKEWORD( 1, 1);

  00035	ba 01 01 00 00	 mov	 edx, 257		; 00000101H
  0003a	66 89 95 a4 fe
	ff ff		 mov	 WORD PTR _wVersionRequested$3[ebp], dx

; 235  : 
; 236  : 			err = WSAStartup( wVersionRequested, &wsaData );

  00041	8d 85 10 fd ff
	ff		 lea	 eax, DWORD PTR _wsaData$2[ebp]
  00047	50		 push	 eax
  00048	0f b7 8d a4 fe
	ff ff		 movzx	 ecx, WORD PTR _wVersionRequested$3[ebp]
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 _WSAStartup@8
  00055	89 85 08 fd ff
	ff		 mov	 DWORD PTR _err$1[ebp], eax

; 237  : 
; 238  : 			if ( err != 0 ) 

  0005b	83 bd 08 fd ff
	ff 00		 cmp	 DWORD PTR _err$1[ebp], 0
  00062	74 07		 je	 SHORT $LN3@handshake

; 239  : 			{
; 240  : 				// Tell the user that we could not find a usable
; 241  : 				// WinSock DLL
; 242  : 				//
; 243  : 				return FALSE;

  00064	32 c0		 xor	 al, al
  00066	e9 79 01 00 00	 jmp	 $LN1@handshake
$LN3@handshake:

; 244  : 			}
; 245  : 		}
; 246  : #endif
; 247  : 
; 248  : 		// Create the server socket, we are the server because we just wait until
; 249  : 		// a debugger connects to the port we are listening on.
; 250  : 		//
; 251  : 		serverSocket	= socket(AF_INET, SOCK_STREAM, 0);

  0006b	6a 00		 push	 0
  0006d	6a 01		 push	 1
  0006f	6a 02		 push	 2
  00071	e8 00 00 00 00	 call	 _socket@12
  00076	89 45 f8	 mov	 DWORD PTR _serverSocket$[ebp], eax

; 252  : 
; 253  : 		if	(serverSocket == INVALID_SOCKET)

  00079	83 7d f8 ff	 cmp	 DWORD PTR _serverSocket$[ebp], -1
  0007d	75 07		 jne	 SHORT $LN4@handshake

; 254  : 		{
; 255  : 			return ANTLR3_FALSE;

  0007f	32 c0		 xor	 al, al
  00081	e9 5e 01 00 00	 jmp	 $LN1@handshake
$LN4@handshake:

; 256  : 		}
; 257  : 
; 258  : 		// Set the listening port
; 259  : 		//
; 260  : 		server.sin_port			= htons((unsigned short)delboy->port);

  00086	8b 55 08	 mov	 edx, DWORD PTR _delboy$[ebp]
  00089	0f b7 02	 movzx	 eax, WORD PTR [edx]
  0008c	50		 push	 eax
  0008d	e8 00 00 00 00	 call	 _htons@4
  00092	66 89 45 ce	 mov	 WORD PTR _server$[ebp+2], ax

; 261  : 		server.sin_family		= AF_INET;

  00096	b9 02 00 00 00	 mov	 ecx, 2
  0009b	66 89 4d cc	 mov	 WORD PTR _server$[ebp], cx

; 262  : 		server.sin_addr.s_addr	= htonl (INADDR_ANY);

  0009f	6a 00		 push	 0
  000a1	e8 00 00 00 00	 call	 _htonl@4
  000a6	89 45 d0	 mov	 DWORD PTR _server$[ebp+4], eax

; 263  : 
; 264  : 		// We could allow a rebind on the same addr/port pair I suppose, but
; 265  : 		// I imagine that most people will just want to start debugging one parser at once.
; 266  : 		// Maybe change this at some point, but rejecting the bind at this point will ensure
; 267  : 		// that people realize they have left something running in the background.
; 268  : 		//
; 269  : 		if	(bind(serverSocket, (pANTLR3_SOCKADDRC)&server, sizeof(server)) == -1)

  000a9	6a 10		 push	 16			; 00000010H
  000ab	8d 55 cc	 lea	 edx, DWORD PTR _server$[ebp]
  000ae	52		 push	 edx
  000af	8b 45 f8	 mov	 eax, DWORD PTR _serverSocket$[ebp]
  000b2	50		 push	 eax
  000b3	e8 00 00 00 00	 call	 _bind@12
  000b8	83 f8 ff	 cmp	 eax, -1
  000bb	75 07		 jne	 SHORT $LN5@handshake

; 270  : 		{
; 271  : 			return ANTLR3_FALSE;

  000bd	32 c0		 xor	 al, al
  000bf	e9 20 01 00 00	 jmp	 $LN1@handshake
$LN5@handshake:

; 272  : 		}
; 273  : 
; 274  : 		// We have bound the socket to the port and address so we now ask the TCP subsystem
; 275  : 		// to start listening on that address/port
; 276  : 		//
; 277  : 		if	(listen(serverSocket, 1) == -1)

  000c4	6a 01		 push	 1
  000c6	8b 4d f8	 mov	 ecx, DWORD PTR _serverSocket$[ebp]
  000c9	51		 push	 ecx
  000ca	e8 00 00 00 00	 call	 _listen@8
  000cf	83 f8 ff	 cmp	 eax, -1
  000d2	75 07		 jne	 SHORT $LN6@handshake

; 278  : 		{
; 279  : 			// Some error, just fail
; 280  : 			//
; 281  : 			return	ANTLR3_FALSE;

  000d4	32 c0		 xor	 al, al
  000d6	e9 09 01 00 00	 jmp	 $LN1@handshake
$LN6@handshake:

; 282  : 		}
; 283  : 
; 284  : 		// Now we can try to accept a connection on the port
; 285  : 		//
; 286  : 		sockaddr_len	= sizeof(client);

  000db	c7 85 b8 fe ff
	ff 10 00 00 00	 mov	 DWORD PTR _sockaddr_len$[ebp], 16 ; 00000010H

; 287  : 		delboy->socket	= accept(serverSocket, (pANTLR3_SOCKADDRC)&client, &sockaddr_len);

  000e5	8d 95 b8 fe ff
	ff		 lea	 edx, DWORD PTR _sockaddr_len$[ebp]
  000eb	52		 push	 edx
  000ec	8d 45 e4	 lea	 eax, DWORD PTR _client$[ebp]
  000ef	50		 push	 eax
  000f0	8b 4d f8	 mov	 ecx, DWORD PTR _serverSocket$[ebp]
  000f3	51		 push	 ecx
  000f4	e8 00 00 00 00	 call	 _accept@12
  000f9	8b 55 08	 mov	 edx, DWORD PTR _delboy$[ebp]
  000fc	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 288  : 
; 289  : 		// Having accepted a connection, we can stop listening and close down the socket
; 290  : 		//
; 291  : 		shutdown		(serverSocket, 0x02);

  000ff	6a 02		 push	 2
  00101	8b 45 f8	 mov	 eax, DWORD PTR _serverSocket$[ebp]
  00104	50		 push	 eax
  00105	e8 00 00 00 00	 call	 _shutdown@8

; 292  : 		ANTLR3_CLOSESOCKET		(serverSocket);

  0010a	8b 4d f8	 mov	 ecx, DWORD PTR _serverSocket$[ebp]
  0010d	51		 push	 ecx
  0010e	e8 00 00 00 00	 call	 _closesocket@4

; 293  : 
; 294  : 		if	(delboy->socket == -1)

  00113	8b 55 08	 mov	 edx, DWORD PTR _delboy$[ebp]
  00116	83 7a 04 ff	 cmp	 DWORD PTR [edx+4], -1
  0011a	75 07		 jne	 SHORT $LN7@handshake

; 295  : 		{
; 296  : 			return ANTLR3_FALSE;

  0011c	32 c0		 xor	 al, al
  0011e	e9 c1 00 00 00	 jmp	 $LN1@handshake
$LN7@handshake:

; 297  : 		}
; 298  : 
; 299  : 		// Disable Nagle as this is essentially a chat exchange
; 300  : 		//
; 301  : 		optVal	= 1;

  00123	c7 85 ac fe ff
	ff 01 00 00 00	 mov	 DWORD PTR _optVal$[ebp], 1

; 302  : 		setsockopt(delboy->socket, SOL_SOCKET, TCP_NODELAY, (const char *)&optVal, sizeof(optVal));

  0012d	6a 04		 push	 4
  0012f	8d 85 ac fe ff
	ff		 lea	 eax, DWORD PTR _optVal$[ebp]
  00135	50		 push	 eax
  00136	6a 01		 push	 1
  00138	68 ff ff 00 00	 push	 65535			; 0000ffffH
  0013d	8b 4d 08	 mov	 ecx, DWORD PTR _delboy$[ebp]
  00140	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00143	52		 push	 edx
  00144	e8 00 00 00 00	 call	 _setsockopt@20
  00149	90		 npad	 1
$LN2@handshake:

; 303  : 		
; 304  : 	}
; 305  : 
; 306  : 	// We now have a good socket connection with the debugging client, so we
; 307  : 	// send it the protocol version we are using and what the name of the grammar
; 308  : 	// is that we represent.
; 309  : 	//
; 310  : 	sprintf		(message, "ANTLR %d\n", delboy->protocol_version);

  0014a	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  0014d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00150	51		 push	 ecx
  00151	68 00 00 00 00	 push	 OFFSET ??_C@_09ILMAJDDB@ANTLR?5?$CFd?6@
  00156	8d 95 c4 fe ff
	ff		 lea	 edx, DWORD PTR _message$[ebp]
  0015c	52		 push	 edx
  0015d	e8 00 00 00 00	 call	 _sprintf
  00162	83 c4 0c	 add	 esp, 12			; 0000000cH

; 311  : 	sockSend	(delboy->socket, message, (int)strlen(message));

  00165	8d 85 c4 fe ff
	ff		 lea	 eax, DWORD PTR _message$[ebp]
  0016b	50		 push	 eax
  0016c	e8 00 00 00 00	 call	 _strlen
  00171	83 c4 04	 add	 esp, 4
  00174	50		 push	 eax
  00175	8d 8d c4 fe ff
	ff		 lea	 ecx, DWORD PTR _message$[ebp]
  0017b	51		 push	 ecx
  0017c	8b 55 08	 mov	 edx, DWORD PTR _delboy$[ebp]
  0017f	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00182	50		 push	 eax
  00183	e8 00 00 00 00	 call	 _sockSend
  00188	83 c4 0c	 add	 esp, 12			; 0000000cH

; 312  : 	sprintf		(message, "grammar \"%s\n", delboy->grammarFileName->chars);

  0018b	8b 4d 08	 mov	 ecx, DWORD PTR _delboy$[ebp]
  0018e	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00191	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00194	50		 push	 eax
  00195	68 00 00 00 00	 push	 OFFSET ??_C@_0N@LDLKKDCB@grammar?5?$CC?$CFs?6@
  0019a	8d 8d c4 fe ff
	ff		 lea	 ecx, DWORD PTR _message$[ebp]
  001a0	51		 push	 ecx
  001a1	e8 00 00 00 00	 call	 _sprintf
  001a6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 313  : 	sockSend	(delboy->socket, message, (int)strlen(message));

  001a9	8d 95 c4 fe ff
	ff		 lea	 edx, DWORD PTR _message$[ebp]
  001af	52		 push	 edx
  001b0	e8 00 00 00 00	 call	 _strlen
  001b5	83 c4 04	 add	 esp, 4
  001b8	50		 push	 eax
  001b9	8d 85 c4 fe ff
	ff		 lea	 eax, DWORD PTR _message$[ebp]
  001bf	50		 push	 eax
  001c0	8b 4d 08	 mov	 ecx, DWORD PTR _delboy$[ebp]
  001c3	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  001c6	52		 push	 edx
  001c7	e8 00 00 00 00	 call	 _sockSend
  001cc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 314  : 	ack			(delboy);

  001cf	8b 45 08	 mov	 eax, DWORD PTR _delboy$[ebp]
  001d2	50		 push	 eax
  001d3	e8 00 00 00 00	 call	 _ack
  001d8	83 c4 04	 add	 esp, 4

; 315  : 
; 316  : 	delboy->initialized = ANTLR3_TRUE;

  001db	8b 4d 08	 mov	 ecx, DWORD PTR _delboy$[ebp]
  001de	c6 41 10 01	 mov	 BYTE PTR [ecx+16], 1

; 317  : 
; 318  : 	return	ANTLR3_TRUE;

  001e2	b0 01		 mov	 al, 1
$LN1@handshake:

; 319  : }

  001e4	52		 push	 edx
  001e5	8b cd		 mov	 ecx, ebp
  001e7	50		 push	 eax
  001e8	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN16@handshake
  001ee	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  001f3	58		 pop	 eax
  001f4	5a		 pop	 edx
  001f5	5f		 pop	 edi
  001f6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001f9	33 cd		 xor	 ecx, ebp
  001fb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00200	81 c4 f8 02 00
	00		 add	 esp, 760		; 000002f8H
  00206	3b ec		 cmp	 ebp, esp
  00208	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0020d	8b e5		 mov	 esp, ebp
  0020f	5d		 pop	 ebp
  00210	c3		 ret	 0
  00211	0f 1f 00	 npad	 3
$LN16@handshake:
  00214	06 00 00 00	 DD	 6
  00218	00 00 00 00	 DD	 $LN15@handshake
$LN15@handshake:
  0021c	e4 ff ff ff	 DD	 -28			; ffffffe4H
  00220	10 00 00 00	 DD	 16			; 00000010H
  00224	00 00 00 00	 DD	 $LN9@handshake
  00228	cc ff ff ff	 DD	 -52			; ffffffccH
  0022c	10 00 00 00	 DD	 16			; 00000010H
  00230	00 00 00 00	 DD	 $LN10@handshake
  00234	c4 fe ff ff	 DD	 -316			; fffffec4H
  00238	00 01 00 00	 DD	 256			; 00000100H
  0023c	00 00 00 00	 DD	 $LN11@handshake
  00240	b8 fe ff ff	 DD	 -328			; fffffeb8H
  00244	04 00 00 00	 DD	 4
  00248	00 00 00 00	 DD	 $LN12@handshake
  0024c	ac fe ff ff	 DD	 -340			; fffffeacH
  00250	04 00 00 00	 DD	 4
  00254	00 00 00 00	 DD	 $LN13@handshake
  00258	10 fd ff ff	 DD	 -752			; fffffd10H
  0025c	90 01 00 00	 DD	 400			; 00000190H
  00260	00 00 00 00	 DD	 $LN14@handshake
$LN14@handshake:
  00264	77		 DB	 119			; 00000077H
  00265	73		 DB	 115			; 00000073H
  00266	61		 DB	 97			; 00000061H
  00267	44		 DB	 68			; 00000044H
  00268	61		 DB	 97			; 00000061H
  00269	74		 DB	 116			; 00000074H
  0026a	61		 DB	 97			; 00000061H
  0026b	00		 DB	 0
$LN13@handshake:
  0026c	6f		 DB	 111			; 0000006fH
  0026d	70		 DB	 112			; 00000070H
  0026e	74		 DB	 116			; 00000074H
  0026f	56		 DB	 86			; 00000056H
  00270	61		 DB	 97			; 00000061H
  00271	6c		 DB	 108			; 0000006cH
  00272	00		 DB	 0
$LN12@handshake:
  00273	73		 DB	 115			; 00000073H
  00274	6f		 DB	 111			; 0000006fH
  00275	63		 DB	 99			; 00000063H
  00276	6b		 DB	 107			; 0000006bH
  00277	61		 DB	 97			; 00000061H
  00278	64		 DB	 100			; 00000064H
  00279	64		 DB	 100			; 00000064H
  0027a	72		 DB	 114			; 00000072H
  0027b	5f		 DB	 95			; 0000005fH
  0027c	6c		 DB	 108			; 0000006cH
  0027d	65		 DB	 101			; 00000065H
  0027e	6e		 DB	 110			; 0000006eH
  0027f	00		 DB	 0
$LN11@handshake:
  00280	6d		 DB	 109			; 0000006dH
  00281	65		 DB	 101			; 00000065H
  00282	73		 DB	 115			; 00000073H
  00283	73		 DB	 115			; 00000073H
  00284	61		 DB	 97			; 00000061H
  00285	67		 DB	 103			; 00000067H
  00286	65		 DB	 101			; 00000065H
  00287	00		 DB	 0
$LN10@handshake:
  00288	73		 DB	 115			; 00000073H
  00289	65		 DB	 101			; 00000065H
  0028a	72		 DB	 114			; 00000072H
  0028b	76		 DB	 118			; 00000076H
  0028c	65		 DB	 101			; 00000065H
  0028d	72		 DB	 114			; 00000072H
  0028e	00		 DB	 0
$LN9@handshake:
  0028f	63		 DB	 99			; 00000063H
  00290	6c		 DB	 108			; 0000006cH
  00291	69		 DB	 105			; 00000069H
  00292	65		 DB	 101			; 00000065H
  00293	6e		 DB	 110			; 0000006eH
  00294	74		 DB	 116			; 00000074H
  00295	00		 DB	 0
_handshake ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3debughandlers.c
;	COMDAT _antlr3DebugListenerNew
_TEXT	SEGMENT
_delboy$ = -4						; size = 4
_antlr3DebugListenerNew PROC				; COMDAT

; 94   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 95   : 	pANTLR3_DEBUG_EVENT_LISTENER	delboy;
; 96   : 
; 97   : 	delboy = (pANTLR3_DEBUG_EVENT_LISTENER)ANTLR3_CALLOC(1, sizeof(ANTLR3_DEBUG_EVENT_LISTENER));

  0000c	8b f4		 mov	 esi, esp
  0000e	68 a4 00 00 00	 push	 164			; 000000a4H
  00013	6a 01		 push	 1
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__calloc
  0001b	83 c4 08	 add	 esp, 8
  0001e	3b f4		 cmp	 esi, esp
  00020	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00025	89 45 fc	 mov	 DWORD PTR _delboy$[ebp], eax

; 98   : 
; 99   : 	if	(delboy == NULL)

  00028	83 7d fc 00	 cmp	 DWORD PTR _delboy$[ebp], 0
  0002c	75 07		 jne	 SHORT $LN2@antlr3Debu

; 100  : 	{
; 101  : 		return NULL;

  0002e	33 c0		 xor	 eax, eax
  00030	e9 6e 01 00 00	 jmp	 $LN1@antlr3Debu
$LN2@antlr3Debu:

; 102  : 	}
; 103  : 
; 104  : 	// Initialize the API
; 105  : 	//
; 106  : 	delboy->addChild				= addChild;

  00035	8b 45 fc	 mov	 eax, DWORD PTR _delboy$[ebp]
  00038	c7 80 98 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+152], OFFSET _addChild

; 107  : 	delboy->becomeRoot				= becomeRoot;

  00042	8b 4d fc	 mov	 ecx, DWORD PTR _delboy$[ebp]
  00045	c7 81 94 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+148], OFFSET _becomeRoot

; 108  : 	delboy->beginBacktrack			= beginBacktrack;

  0004f	8b 55 fc	 mov	 edx, DWORD PTR _delboy$[ebp]
  00052	c7 42 54 00 00
	00 00		 mov	 DWORD PTR [edx+84], OFFSET _beginBacktrack

; 109  : 	delboy->beginResync				= beginResync;

  00059	8b 45 fc	 mov	 eax, DWORD PTR _delboy$[ebp]
  0005c	c7 40 64 00 00
	00 00		 mov	 DWORD PTR [eax+100], OFFSET _beginResync

; 110  : 	delboy->commence				= commence;

  00063	8b 4d fc	 mov	 ecx, DWORD PTR _delboy$[ebp]
  00066	c7 41 70 00 00
	00 00		 mov	 DWORD PTR [ecx+112], OFFSET _commence

; 111  : 	delboy->consumeHiddenToken		= consumeHiddenToken;

  0006d	8b 55 fc	 mov	 edx, DWORD PTR _delboy$[ebp]
  00070	c7 42 40 00 00
	00 00		 mov	 DWORD PTR [edx+64], OFFSET _consumeHiddenToken

; 112  : 	delboy->consumeNode				= consumeNode;

  00077	8b 45 fc	 mov	 eax, DWORD PTR _delboy$[ebp]
  0007a	c7 40 7c 00 00
	00 00		 mov	 DWORD PTR [eax+124], OFFSET _consumeNode

; 113  : 	delboy->consumeToken			= consumeToken;

  00081	8b 4d fc	 mov	 ecx, DWORD PTR _delboy$[ebp]
  00084	c7 41 3c 00 00
	00 00		 mov	 DWORD PTR [ecx+60], OFFSET _consumeToken

; 114  : 	delboy->createNode				= createNode;

  0008b	8b 55 fc	 mov	 edx, DWORD PTR _delboy$[ebp]
  0008e	c7 82 8c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+140], OFFSET _createNode

; 115  : 	delboy->createNodeTok			= createNodeTok;

  00098	8b 45 fc	 mov	 eax, DWORD PTR _delboy$[ebp]
  0009b	c7 80 90 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+144], OFFSET _createNodeTok

; 116  : 	delboy->endBacktrack			= endBacktrack;

  000a5	8b 4d fc	 mov	 ecx, DWORD PTR _delboy$[ebp]
  000a8	c7 41 58 00 00
	00 00		 mov	 DWORD PTR [ecx+88], OFFSET _endBacktrack

; 117  : 	delboy->endResync				= endResync;

  000af	8b 55 fc	 mov	 edx, DWORD PTR _delboy$[ebp]
  000b2	c7 42 68 00 00
	00 00		 mov	 DWORD PTR [edx+104], OFFSET _endResync

; 118  : 	delboy->enterAlt				= enterAlt;

  000b9	8b 45 fc	 mov	 eax, DWORD PTR _delboy$[ebp]
  000bc	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], OFFSET _enterAlt

; 119  : 	delboy->enterDecision			= enterDecision;

  000c3	8b 4d fc	 mov	 ecx, DWORD PTR _delboy$[ebp]
  000c6	c7 41 34 00 00
	00 00		 mov	 DWORD PTR [ecx+52], OFFSET _enterDecision

; 120  : 	delboy->enterRule				= enterRule;

  000cd	8b 55 fc	 mov	 edx, DWORD PTR _delboy$[ebp]
  000d0	c7 42 20 00 00
	00 00		 mov	 DWORD PTR [edx+32], OFFSET _enterRule

; 121  : 	delboy->enterSubRule			= enterSubRule;

  000d7	8b 45 fc	 mov	 eax, DWORD PTR _delboy$[ebp]
  000da	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], OFFSET _enterSubRule

; 122  : 	delboy->exitDecision			= exitDecision;

  000e1	8b 4d fc	 mov	 ecx, DWORD PTR _delboy$[ebp]
  000e4	c7 41 38 00 00
	00 00		 mov	 DWORD PTR [ecx+56], OFFSET _exitDecision

; 123  : 	delboy->exitRule				= exitRule;

  000eb	8b 55 fc	 mov	 edx, DWORD PTR _delboy$[ebp]
  000ee	c7 42 28 00 00
	00 00		 mov	 DWORD PTR [edx+40], OFFSET _exitRule

; 124  : 	delboy->exitSubRule				= exitSubRule;

  000f5	8b 45 fc	 mov	 eax, DWORD PTR _delboy$[ebp]
  000f8	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], OFFSET _exitSubRule

; 125  : 	delboy->handshake				= handshake;

  000ff	8b 4d fc	 mov	 ecx, DWORD PTR _delboy$[ebp]
  00102	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], OFFSET _handshake

; 126  : 	delboy->location				= location;

  00109	8b 55 fc	 mov	 edx, DWORD PTR _delboy$[ebp]
  0010c	c7 42 5c 00 00
	00 00		 mov	 DWORD PTR [edx+92], OFFSET _location

; 127  : 	delboy->LT						= LT;

  00113	8b 45 fc	 mov	 eax, DWORD PTR _delboy$[ebp]
  00116	c7 40 44 00 00
	00 00		 mov	 DWORD PTR [eax+68], OFFSET _LT

; 128  : 	delboy->LTT						= LTT;

  0011d	8b 4d fc	 mov	 ecx, DWORD PTR _delboy$[ebp]
  00120	c7 81 80 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+128], OFFSET _LTT

; 129  : 	delboy->mark					= mark;

  0012a	8b 55 fc	 mov	 edx, DWORD PTR _delboy$[ebp]
  0012d	c7 42 48 00 00
	00 00		 mov	 DWORD PTR [edx+72], OFFSET _mark

; 130  : 	delboy->nilNode					= nilNode;

  00134	8b 45 fc	 mov	 eax, DWORD PTR _delboy$[ebp]
  00137	c7 80 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+132], OFFSET _nilNode

; 131  : 	delboy->recognitionException	= recognitionException;

  00141	8b 4d fc	 mov	 ecx, DWORD PTR _delboy$[ebp]
  00144	c7 41 60 00 00
	00 00		 mov	 DWORD PTR [ecx+96], OFFSET _recognitionException

; 132  : 	delboy->rewind					= rewindMark;

  0014b	8b 55 fc	 mov	 edx, DWORD PTR _delboy$[ebp]
  0014e	c7 42 4c 00 00
	00 00		 mov	 DWORD PTR [edx+76], OFFSET _rewindMark

; 133  : 	delboy->rewindLast				= rewindLast;

  00155	8b 45 fc	 mov	 eax, DWORD PTR _delboy$[ebp]
  00158	c7 40 50 00 00
	00 00		 mov	 DWORD PTR [eax+80], OFFSET _rewindLast

; 134  : 	delboy->semanticPredicate		= semanticPredicate;

  0015f	8b 4d fc	 mov	 ecx, DWORD PTR _delboy$[ebp]
  00162	c7 41 6c 00 00
	00 00		 mov	 DWORD PTR [ecx+108], OFFSET _semanticPredicate

; 135  : 	delboy->setTokenBoundaries		= setTokenBoundaries;

  00169	8b 55 fc	 mov	 edx, DWORD PTR _delboy$[ebp]
  0016c	c7 82 9c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+156], OFFSET _setTokenBoundaries

; 136  : 	delboy->terminate				= terminate;

  00176	8b 45 fc	 mov	 eax, DWORD PTR _delboy$[ebp]
  00179	c7 40 74 00 00
	00 00		 mov	 DWORD PTR [eax+116], OFFSET _terminate

; 137  : 	delboy->errorNode				= errorNode;

  00180	8b 4d fc	 mov	 ecx, DWORD PTR _delboy$[ebp]
  00183	c7 81 88 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+136], OFFSET _errorNode

; 138  : 
; 139  : 	delboy->protocol_version		= 2;	// ANTLR 3.1 is at protocol version 2

  0018d	8b 55 fc	 mov	 edx, DWORD PTR _delboy$[ebp]
  00190	c7 42 08 02 00
	00 00		 mov	 DWORD PTR [edx+8], 2

; 140  : 
; 141  : 	delboy->port					= DEFAULT_DEBUGGER_PORT;

  00197	8b 45 fc	 mov	 eax, DWORD PTR _delboy$[ebp]
  0019a	c7 00 cc bf 00
	00		 mov	 DWORD PTR [eax], 49100	; 0000bfccH

; 142  : 
; 143  : 	return delboy;

  001a0	8b 45 fc	 mov	 eax, DWORD PTR _delboy$[ebp]
$LN1@antlr3Debu:

; 144  : }

  001a3	5e		 pop	 esi
  001a4	83 c4 04	 add	 esp, 4
  001a7	3b ec		 cmp	 ebp, esp
  001a9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001ae	8b e5		 mov	 esp, ebp
  001b0	5d		 pop	 ebp
  001b1	c3		 ret	 0
_antlr3DebugListenerNew ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1771 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 1772 :         int _Result;
; 1773 :         va_list _ArgList;
; 1774 :         __crt_va_start(_ArgList, _Format);

  00014	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00017	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1775 : 
; 1776 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  0001a	8b 4d f8	 mov	 ecx, DWORD PTR __ArgList$[ebp]
  0001d	51		 push	 ecx
  0001e	6a 00		 push	 0
  00020	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00023	52		 push	 edx
  00024	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 __vsprintf_l
  0002d	83 c4 10	 add	 esp, 16			; 00000010H
  00030	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1777 : 
; 1778 :         __crt_va_end(_ArgList);

  00033	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 1779 :         return _Result;

  0003a	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 1780 :     }

  0003d	83 c4 08	 add	 esp, 8
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1458 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1459 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00003	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  0000e	52		 push	 edx
  0000f	6a ff		 push	 -1
  00011	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 __vsnprintf_l
  0001a	83 c4 14	 add	 esp, 20			; 00000014H

; 1460 :     }

  0001d	3b ec		 cmp	 ebp, esp
  0001f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1391 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 1392 :         int const _Result = __stdio_common_vsprintf(

  00015	8b f4		 mov	 esi, esp
  00017	8b 45 18	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0001a	50		 push	 eax
  0001b	8b 4d 14	 mov	 ecx, DWORD PTR __Locale$[ebp]
  0001e	51		 push	 ecx
  0001f	8b 55 10	 mov	 edx, DWORD PTR __Format$[ebp]
  00022	52		 push	 edx
  00023	8b 45 0c	 mov	 eax, DWORD PTR __BufferCount$[ebp]
  00026	50		 push	 eax
  00027	8b 4d 08	 mov	 ecx, DWORD PTR __Buffer$[ebp]
  0002a	51		 push	 ecx
  0002b	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00030	8b 10		 mov	 edx, DWORD PTR [eax]
  00032	83 ca 01	 or	 edx, 1
  00035	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00038	50		 push	 eax
  00039	52		 push	 edx
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsprintf
  00040	83 c4 1c	 add	 esp, 28			; 0000001cH
  00043	3b f4		 cmp	 esi, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

  0004d	83 7d fc 00	 cmp	 DWORD PTR __Result$[ebp], 0
  00051	7d 09		 jge	 SHORT $LN3@vsnprintf_
  00053	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR tv74[ebp], -1
  0005a	eb 06		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  0005c	8b 4d fc	 mov	 ecx, DWORD PTR __Result$[ebp]
  0005f	89 4d f8	 mov	 DWORD PTR tv74[ebp], ecx
$LN4@vsnprintf_:
  00062	8b 45 f8	 mov	 eax, DWORD PTR tv74[ebp]

; 1397 :     }

  00065	5e		 pop	 esi
  00066	83 c4 08	 add	 esp, 8
  00069	3b ec		 cmp	 ebp, esp
  0006b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _printf
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Format$ = 8						; size = 4
_printf	PROC						; COMDAT

; 956  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 957  :         int _Result;
; 958  :         va_list _ArgList;
; 959  :         __crt_va_start(_ArgList, _Format);

  00015	8d 45 0c	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00018	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 960  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  0001b	8b 4d f8	 mov	 ecx, DWORD PTR __ArgList$[ebp]
  0001e	51		 push	 ecx
  0001f	6a 00		 push	 0
  00021	8b 55 08	 mov	 edx, DWORD PTR __Format$[ebp]
  00024	52		 push	 edx
  00025	8b f4		 mov	 esi, esp
  00027	6a 01		 push	 1
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  0002f	83 c4 04	 add	 esp, 4
  00032	3b f4		 cmp	 esi, esp
  00034	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 __vfprintf_l
  0003f	83 c4 10	 add	 esp, 16			; 00000010H
  00042	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 961  :         __crt_va_end(_ArgList);

  00045	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 962  :         return _Result;

  0004c	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 963  :     }

  0004f	5e		 pop	 esi
  00050	83 c4 08	 add	 esp, 8
  00053	3b ec		 cmp	 ebp, esp
  00055	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
_printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 644  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00004	8b f4		 mov	 esi, esp
  00006	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  0000d	51		 push	 ecx
  0000e	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00011	52		 push	 edx
  00012	8b 45 08	 mov	 eax, DWORD PTR __Stream$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  0001b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001e	51		 push	 ecx
  0001f	8b 10		 mov	 edx, DWORD PTR [eax]
  00021	52		 push	 edx
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vfprintf
  00028	83 c4 18	 add	 esp, 24			; 00000018H
  0002b	3b f4		 cmp	 esi, esp
  0002d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 646  :     }

  00032	5e		 pop	 esi
  00033	3b ec		 cmp	 ebp, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 90   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00003	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
