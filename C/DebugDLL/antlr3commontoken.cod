; Listing generated by Microsoft (R) Optimizing Compiler Version 19.42.34436.0 

	TITLE	C:\SPO_labs\C\DebugDLL\antlr3commontoken.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_antlr3CommonTokenNew
PUBLIC	_antlr3TokenFactoryNew
PUBLIC	_antlr3SetTokenAPI
PUBLIC	??_C@_05FLDDOMNH@?$DMEOF?$DO@			; `string'
PUBLIC	??_C@_08NEOOKDGC@?$FLIndex?3?5@			; `string'
PUBLIC	??_C@_09LBBAKIIA@?5?$CIStart?3?5@		; `string'
PUBLIC	??_C@_07LGAFOPAI@?9Stop?3?5@			; `string'
PUBLIC	??_C@_04KDEICOAP@?$CJ?5?$DN?8@			; `string'
PUBLIC	??_C@_08KMKDFHHP@?8?0?5type?$DM@		; `string'
PUBLIC	??_C@_02LLMPMKNF@?$DO?5@			; `string'
PUBLIC	??_C@_0M@NJBPMJAH@?$CIchannel?5?$DN?5@		; `string'
PUBLIC	??_C@_02KCKGHPCA@?$CJ?5@			; `string'
PUBLIC	??_C@_06FIEBOLOH@Line?3?5@			; `string'
PUBLIC	??_C@_09PNCFGGF@?5LinePos?3@			; `string'
EXTRN	__imp__calloc:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp__realloc:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_09PNCFGGF@?5LinePos?3@
CONST	SEGMENT
??_C@_09PNCFGGF@?5LinePos?3@ DB ' LinePos:', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06FIEBOLOH@Line?3?5@
CONST	SEGMENT
??_C@_06FIEBOLOH@Line?3?5@ DB 'Line: ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02KCKGHPCA@?$CJ?5@
CONST	SEGMENT
??_C@_02KCKGHPCA@?$CJ?5@ DB ') ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NJBPMJAH@?$CIchannel?5?$DN?5@
CONST	SEGMENT
??_C@_0M@NJBPMJAH@?$CIchannel?5?$DN?5@ DB '(channel = ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02LLMPMKNF@?$DO?5@
CONST	SEGMENT
??_C@_02LLMPMKNF@?$DO?5@ DB '> ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08KMKDFHHP@?8?0?5type?$DM@
CONST	SEGMENT
??_C@_08KMKDFHHP@?8?0?5type?$DM@ DB ''', type<', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04KDEICOAP@?$CJ?5?$DN?8@
CONST	SEGMENT
??_C@_04KDEICOAP@?$CJ?5?$DN?8@ DB ') =''', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07LGAFOPAI@?9Stop?3?5@
CONST	SEGMENT
??_C@_07LGAFOPAI@?9Stop?3?5@ DB '-Stop: ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09LBBAKIIA@?5?$CIStart?3?5@
CONST	SEGMENT
??_C@_09LBBAKIIA@?5?$CIStart?3?5@ DB ' (Start: ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08NEOOKDGC@?$FLIndex?3?5@
CONST	SEGMENT
??_C@_08NEOOKDGC@?$FLIndex?3?5@ DB '[Index: ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05FLDDOMNH@?$DMEOF?$DO@
CONST	SEGMENT
??_C@_05FLDDOMNH@?$DMEOF?$DO@ DB '<EOF>', 00H		; `string'
CONST	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontoken.c
;	COMDAT _newPoolToken
_TEXT	SEGMENT
tv130 = -8						; size = 4
_token$ = -4						; size = 4
_factory$ = 8						; size = 4
_newPoolToken PROC					; COMDAT

; 206  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 207  :     pANTLR3_COMMON_TOKEN token;
; 208  : 
; 209  : 	if (factory == NULL) { return NULL; }

  00014	83 7d 08 00	 cmp	 DWORD PTR _factory$[ebp], 0
  00018	75 07		 jne	 SHORT $LN2@newPoolTok
  0001a	33 c0		 xor	 eax, eax
  0001c	e9 d5 00 00 00	 jmp	 $LN1@newPoolTok
$LN2@newPoolTok:

; 210  : 
; 211  :     /* See if we need a new token pool before allocating a new
; 212  :      * one
; 213  :      */
; 214  :     if (factory->nextToken >= ANTLR3_FACTORY_POOL_SIZE)

  00021	8b 45 08	 mov	 eax, DWORD PTR _factory$[ebp]
  00024	81 78 0c 00 04
	00 00		 cmp	 DWORD PTR [eax+12], 1024 ; 00000400H
  0002b	72 1a		 jb	 SHORT $LN4@newPoolTok

; 215  :     {
; 216  :         /* We ran out of tokens in the current pool, so we need a new pool
; 217  :          */
; 218  :         if (!newPool(factory))

  0002d	8b 4d 08	 mov	 ecx, DWORD PTR _factory$[ebp]
  00030	51		 push	 ecx
  00031	e8 00 00 00 00	 call	 _newPool
  00036	83 c4 04	 add	 esp, 4
  00039	0f b6 d0	 movzx	 edx, al
  0003c	85 d2		 test	 edx, edx
  0003e	75 07		 jne	 SHORT $LN4@newPoolTok

; 219  : 		{
; 220  : 			return NULL;

  00040	33 c0		 xor	 eax, eax
  00042	e9 af 00 00 00	 jmp	 $LN1@newPoolTok
$LN4@newPoolTok:

; 221  : 		}
; 222  :     }
; 223  : 
; 224  : 	// make sure the factory is sane
; 225  : 	if (factory->pools == NULL) { return NULL; }

  00047	8b 45 08	 mov	 eax, DWORD PTR _factory$[ebp]
  0004a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0004d	75 07		 jne	 SHORT $LN5@newPoolTok
  0004f	33 c0		 xor	 eax, eax
  00051	e9 a0 00 00 00	 jmp	 $LN1@newPoolTok
$LN5@newPoolTok:

; 226  : 	if (factory->pools[factory->thisPool] == NULL) { return NULL; }

  00056	8b 4d 08	 mov	 ecx, DWORD PTR _factory$[ebp]
  00059	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0005c	8b 45 08	 mov	 eax, DWORD PTR _factory$[ebp]
  0005f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00061	83 3c 91 00	 cmp	 DWORD PTR [ecx+edx*4], 0
  00065	75 07		 jne	 SHORT $LN6@newPoolTok
  00067	33 c0		 xor	 eax, eax
  00069	e9 88 00 00 00	 jmp	 $LN1@newPoolTok
$LN6@newPoolTok:

; 227  : 
; 228  :     /* Assuming everything went well (we are trying for performance here so doing minimal
; 229  :      * error checking. Then we can work out what the pointer is to the next token.
; 230  :      */
; 231  :     token = factory->pools[factory->thisPool] + factory->nextToken;

  0006e	8b 55 08	 mov	 edx, DWORD PTR _factory$[ebp]
  00071	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00074	8b 4d 08	 mov	 ecx, DWORD PTR _factory$[ebp]
  00077	8b 11		 mov	 edx, DWORD PTR [ecx]
  00079	8b 4d 08	 mov	 ecx, DWORD PTR _factory$[ebp]
  0007c	69 49 0c 90 00
	00 00		 imul	 ecx, DWORD PTR [ecx+12], 144
  00083	03 0c 82	 add	 ecx, DWORD PTR [edx+eax*4]
  00086	89 4d fc	 mov	 DWORD PTR _token$[ebp], ecx

; 232  :     factory->nextToken++;

  00089	8b 55 08	 mov	 edx, DWORD PTR _factory$[ebp]
  0008c	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0008f	83 c0 01	 add	 eax, 1
  00092	8b 4d 08	 mov	 ecx, DWORD PTR _factory$[ebp]
  00095	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 233  : 
; 234  :     /* We have our token pointer now, so we can initialize it to the predefined model.
; 235  :      * We only need do this though if the token is not already initialized, we just check
; 236  :      * an api function pointer for this as they are allocated via calloc.
; 237  :      */
; 238  :     if  (token->setStartIndex == NULL)

  00098	8b 55 fc	 mov	 edx, DWORD PTR _token$[ebp]
  0009b	83 ba 80 00 00
	00 00		 cmp	 DWORD PTR [edx+128], 0
  000a2	75 4f		 jne	 SHORT $LN7@newPoolTok

; 239  :     {
; 240  :         antlr3SetTokenAPI(token);

  000a4	8b 45 fc	 mov	 eax, DWORD PTR _token$[ebp]
  000a7	50		 push	 eax
  000a8	e8 00 00 00 00	 call	 _antlr3SetTokenAPI
  000ad	83 c4 04	 add	 esp, 4

; 241  : 
; 242  :         // It is factory made, and we need to copy the string factory pointer
; 243  :         //
; 244  :         token->factoryMade  = ANTLR3_TRUE;

  000b0	8b 4d fc	 mov	 ecx, DWORD PTR _token$[ebp]
  000b3	c6 41 04 01	 mov	 BYTE PTR [ecx+4], 1

; 245  :         token->strFactory   = factory->input == NULL ? NULL : factory->input->strFactory;

  000b7	8b 55 08	 mov	 edx, DWORD PTR _factory$[ebp]
  000ba	83 ba a0 00 00
	00 00		 cmp	 DWORD PTR [edx+160], 0
  000c1	75 09		 jne	 SHORT $LN9@newPoolTok
  000c3	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv130[ebp], 0
  000ca	eb 0f		 jmp	 SHORT $LN10@newPoolTok
$LN9@newPoolTok:
  000cc	8b 45 08	 mov	 eax, DWORD PTR _factory$[ebp]
  000cf	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [eax+160]
  000d5	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  000d8	89 55 f8	 mov	 DWORD PTR tv130[ebp], edx
$LN10@newPoolTok:
  000db	8b 45 fc	 mov	 eax, DWORD PTR _token$[ebp]
  000de	8b 4d f8	 mov	 ecx, DWORD PTR tv130[ebp]
  000e1	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 246  :         token->input        = factory->input;

  000e4	8b 55 fc	 mov	 edx, DWORD PTR _token$[ebp]
  000e7	8b 45 08	 mov	 eax, DWORD PTR _factory$[ebp]
  000ea	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [eax+160]
  000f0	89 4a 1c	 mov	 DWORD PTR [edx+28], ecx
$LN7@newPoolTok:

; 247  :     }
; 248  : 
; 249  :     /* And we are done
; 250  :      */
; 251  :     return token;

  000f3	8b 45 fc	 mov	 eax, DWORD PTR _token$[ebp]
$LN1@newPoolTok:

; 252  : }

  000f6	83 c4 08	 add	 esp, 8
  000f9	3b ec		 cmp	 ebp, esp
  000fb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00100	8b e5		 mov	 esp, ebp
  00102	5d		 pop	 ebp
  00103	c3		 ret	 0
_newPoolToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontoken.c
;	COMDAT _newPool
_TEXT	SEGMENT
_newPools$1 = -4					; size = 4
_factory$ = 8						; size = 4
_newPool PROC						; COMDAT

; 153  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 154  :     /* Increment factory count
; 155  :      */
; 156  :     ++(factory->thisPool);

  0000c	8b 45 08	 mov	 eax, DWORD PTR _factory$[ebp]
  0000f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00012	83 c1 01	 add	 ecx, 1
  00015	8b 55 08	 mov	 edx, DWORD PTR _factory$[ebp]
  00018	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 157  : 
; 158  :     // If we were reusing this token factory then we may already have a pool
; 159  :     // allocated. If we exceeded the max available then we must allocate a new
; 160  :     // one.
; 161  :     if  (factory->thisPool > factory->maxPool)

  0001b	8b 45 08	 mov	 eax, DWORD PTR _factory$[ebp]
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR _factory$[ebp]
  00021	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00024	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00027	0f 8e a1 00 00
	00		 jle	 $LN2@newPool

; 162  :     {
; 163  :         /* Ensure we have enough pointers allocated
; 164  :          */
; 165  : 		pANTLR3_COMMON_TOKEN *newPools = (pANTLR3_COMMON_TOKEN *)

  0002d	8b 45 08	 mov	 eax, DWORD PTR _factory$[ebp]
  00030	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00033	8d 14 8d 04 00
	00 00		 lea	 edx, DWORD PTR [ecx*4+4]
  0003a	8b f4		 mov	 esi, esp
  0003c	52		 push	 edx
  0003d	8b 45 08	 mov	 eax, DWORD PTR _factory$[ebp]
  00040	8b 08		 mov	 ecx, DWORD PTR [eax]
  00042	51		 push	 ecx
  00043	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__realloc
  00049	83 c4 08	 add	 esp, 8
  0004c	3b f4		 cmp	 esi, esp
  0004e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00053	89 45 fc	 mov	 DWORD PTR _newPools$1[ebp], eax

; 166  : 			ANTLR3_REALLOC((void *)factory->pools,	    /* Current pools pointer (starts at NULL)	*/
; 167  : 		                   (ANTLR3_UINT32)((factory->thisPool + 1) * sizeof(pANTLR3_COMMON_TOKEN *))	/* Memory for new pool pointers */
; 168  : 			);
; 169  : 		if (newPools == NULL)

  00056	83 7d fc 00	 cmp	 DWORD PTR _newPools$1[ebp], 0
  0005a	75 13		 jne	 SHORT $LN3@newPool

; 170  : 		{
; 171  : 			// We are out of memory, but the old allocation is still valid for now
; 172  : 			--(factory->thisPool);

  0005c	8b 55 08	 mov	 edx, DWORD PTR _factory$[ebp]
  0005f	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00062	83 e8 01	 sub	 eax, 1
  00065	8b 4d 08	 mov	 ecx, DWORD PTR _factory$[ebp]
  00068	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 173  : 			return ANTLR3_FALSE;

  0006b	32 c0		 xor	 al, al
  0006d	eb 6b		 jmp	 SHORT $LN1@newPool
$LN3@newPool:

; 174  : 		}
; 175  : 
; 176  :         factory->pools = newPools;

  0006f	8b 55 08	 mov	 edx, DWORD PTR _factory$[ebp]
  00072	8b 45 fc	 mov	 eax, DWORD PTR _newPools$1[ebp]
  00075	89 02		 mov	 DWORD PTR [edx], eax

; 177  : 
; 178  :         /* Allocate a new pool for the factory
; 179  :          */
; 180  :         factory->pools[factory->thisPool]	=

  00077	8b f4		 mov	 esi, esp
  00079	68 00 40 02 00	 push	 147456			; 00024000H
  0007e	6a 01		 push	 1
  00080	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__calloc
  00086	83 c4 08	 add	 esp, 8
  00089	3b f4		 cmp	 esi, esp
  0008b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00090	8b 4d 08	 mov	 ecx, DWORD PTR _factory$[ebp]
  00093	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00096	8b 4d 08	 mov	 ecx, DWORD PTR _factory$[ebp]
  00099	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0009b	89 04 91	 mov	 DWORD PTR [ecx+edx*4], eax

; 181  : 			        (pANTLR3_COMMON_TOKEN) 
; 182  : 				    ANTLR3_CALLOC(1, (size_t)(sizeof(ANTLR3_COMMON_TOKEN) * ANTLR3_FACTORY_POOL_SIZE));
; 183  : 		if (factory->pools[factory->thisPool] == NULL)

  0009e	8b 55 08	 mov	 edx, DWORD PTR _factory$[ebp]
  000a1	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000a4	8b 4d 08	 mov	 ecx, DWORD PTR _factory$[ebp]
  000a7	8b 11		 mov	 edx, DWORD PTR [ecx]
  000a9	83 3c 82 00	 cmp	 DWORD PTR [edx+eax*4], 0
  000ad	75 13		 jne	 SHORT $LN4@newPool

; 184  : 		{
; 185  : 			// Allocation failed
; 186  : 			--(factory->thisPool);

  000af	8b 45 08	 mov	 eax, DWORD PTR _factory$[ebp]
  000b2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000b5	83 e9 01	 sub	 ecx, 1
  000b8	8b 55 08	 mov	 edx, DWORD PTR _factory$[ebp]
  000bb	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 187  : 			return ANTLR3_FALSE;

  000be	32 c0		 xor	 al, al
  000c0	eb 18		 jmp	 SHORT $LN1@newPool
$LN4@newPool:

; 188  : 		}
; 189  : 
; 190  :         // We now have a new pool and can track it as the maximum we have created so far
; 191  :         //
; 192  :         factory->maxPool = factory->thisPool;

  000c2	8b 45 08	 mov	 eax, DWORD PTR _factory$[ebp]
  000c5	8b 4d 08	 mov	 ecx, DWORD PTR _factory$[ebp]
  000c8	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000cb	89 50 08	 mov	 DWORD PTR [eax+8], edx
$LN2@newPool:

; 193  :     }
; 194  : 
; 195  :     /* Reset the counters
; 196  :      */
; 197  :     factory->nextToken	= 0;

  000ce	8b 45 08	 mov	 eax, DWORD PTR _factory$[ebp]
  000d1	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 198  :   
; 199  :     /* Done
; 200  :      */
; 201  :     return ANTLR3_TRUE;

  000d8	b0 01		 mov	 al, 1
$LN1@newPool:

; 202  : }

  000da	5e		 pop	 esi
  000db	83 c4 04	 add	 esp, 4
  000de	3b ec		 cmp	 ebp, esp
  000e0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e5	8b e5		 mov	 esp, ebp
  000e7	5d		 pop	 ebp
  000e8	c3		 ret	 0
_newPool ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontoken.c
;	COMDAT _factoryReset
_TEXT	SEGMENT
_factory$ = 8						; size = 4
_factoryReset PROC					; COMDAT

; 256  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 257  :     // Just start again with pool #0 when we are
; 258  :     // called.
; 259  :     //
; 260  :     factory->thisPool   = -1;

  00003	8b 45 08	 mov	 eax, DWORD PTR _factory$[ebp]
  00006	c7 40 04 ff ff
	ff ff		 mov	 DWORD PTR [eax+4], -1

; 261  :     newPool(factory);

  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _factory$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 _newPool
  00016	83 c4 04	 add	 esp, 4

; 262  : }

  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
_factoryReset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontoken.c
;	COMDAT _setInputStream
_TEXT	SEGMENT
_factory$ = 8						; size = 4
_input$ = 12						; size = 4
_setInputStream PROC					; COMDAT

; 138  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 139  :     factory->input          =  input;

  00003	8b 45 08	 mov	 eax, DWORD PTR _factory$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _input$[ebp]
  00009	89 88 a0 00 00
	00		 mov	 DWORD PTR [eax+160], ecx

; 140  :     factory->unTruc.input   =  input;

  0000f	8b 55 08	 mov	 edx, DWORD PTR _factory$[ebp]
  00012	8b 45 0c	 mov	 eax, DWORD PTR _input$[ebp]
  00015	89 42 2c	 mov	 DWORD PTR [edx+44], eax

; 141  : 	if	(input != NULL)

  00018	83 7d 0c 00	 cmp	 DWORD PTR _input$[ebp], 0
  0001c	74 0e		 je	 SHORT $LN2@setInputSt

; 142  : 	{
; 143  : 		factory->unTruc.strFactory	= input->strFactory;

  0001e	8b 4d 08	 mov	 ecx, DWORD PTR _factory$[ebp]
  00021	8b 55 0c	 mov	 edx, DWORD PTR _input$[ebp]
  00024	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00027	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 144  : 	}

  0002a	eb 0a		 jmp	 SHORT $LN3@setInputSt
$LN2@setInputSt:

; 145  : 	else
; 146  : 	{
; 147  : 		factory->unTruc.strFactory = NULL;

  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _factory$[ebp]
  0002f	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
$LN3@setInputSt:

; 148  :     }
; 149  : }

  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
_setInputStream ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontoken.c
;	COMDAT _newToken
_TEXT	SEGMENT
_token$ = -4						; size = 4
_newToken PROC						; COMDAT

; 328  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 329  :     pANTLR3_COMMON_TOKEN    token;
; 330  : 
; 331  :     /* Allocate memory for this
; 332  :      */
; 333  :     token   = (pANTLR3_COMMON_TOKEN) ANTLR3_CALLOC(1, (size_t)(sizeof(ANTLR3_COMMON_TOKEN)));

  0000c	8b f4		 mov	 esi, esp
  0000e	68 90 00 00 00	 push	 144			; 00000090H
  00013	6a 01		 push	 1
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__calloc
  0001b	83 c4 08	 add	 esp, 8
  0001e	3b f4		 cmp	 esi, esp
  00020	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00025	89 45 fc	 mov	 DWORD PTR _token$[ebp], eax

; 334  : 
; 335  :     if	(token == NULL)

  00028	83 7d fc 00	 cmp	 DWORD PTR _token$[ebp], 0
  0002c	75 04		 jne	 SHORT $LN2@newToken

; 336  :     {
; 337  : 	return	NULL;

  0002e	33 c0		 xor	 eax, eax
  00030	eb 16		 jmp	 SHORT $LN1@newToken
$LN2@newToken:

; 338  :     }
; 339  : 
; 340  :     // Install the API
; 341  :     //
; 342  :     antlr3SetTokenAPI(token);

  00032	8b 45 fc	 mov	 eax, DWORD PTR _token$[ebp]
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 _antlr3SetTokenAPI
  0003b	83 c4 04	 add	 esp, 4

; 343  :     token->factoryMade = ANTLR3_FALSE;

  0003e	8b 4d fc	 mov	 ecx, DWORD PTR _token$[ebp]
  00041	c6 41 04 00	 mov	 BYTE PTR [ecx+4], 0

; 344  : 
; 345  :     return  token;

  00045	8b 45 fc	 mov	 eax, DWORD PTR _token$[ebp]
$LN1@newToken:

; 346  : }

  00048	5e		 pop	 esi
  00049	83 c4 04	 add	 esp, 4
  0004c	3b ec		 cmp	 ebp, esp
  0004e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
_newToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontoken.c
;	COMDAT _factoryClose
_TEXT	SEGMENT
tv73 = -24						; size = 4
_check$ = -20						; size = 4
_token$ = -16						; size = 4
_limit$ = -12						; size = 4
_poolCount$ = -8					; size = 4
_pool$ = -4						; size = 4
_factory$ = 8						; size = 4
_factoryClose PROC					; COMDAT

; 266  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  0000f	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00012	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00015	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00018	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001b	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 267  :     pANTLR3_COMMON_TOKEN    pool;
; 268  :     ANTLR3_INT32	    poolCount;
; 269  :     ANTLR3_UINT32	    limit;
; 270  :     ANTLR3_UINT32	    token;
; 271  :     pANTLR3_COMMON_TOKEN    check;
; 272  : 
; 273  :     /* We iterate the token pools one at a time
; 274  :      */
; 275  :     for	(poolCount = 0; poolCount <= factory->thisPool; poolCount++)

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _poolCount$[ebp], 0
  00025	eb 09		 jmp	 SHORT $LN4@factoryClo
$LN2@factoryClo:
  00027	8b 45 f8	 mov	 eax, DWORD PTR _poolCount$[ebp]
  0002a	83 c0 01	 add	 eax, 1
  0002d	89 45 f8	 mov	 DWORD PTR _poolCount$[ebp], eax
$LN4@factoryClo:
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _factory$[ebp]
  00033	8b 55 f8	 mov	 edx, DWORD PTR _poolCount$[ebp]
  00036	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00039	0f 8f c9 00 00
	00		 jg	 $LN3@factoryClo

; 276  :     {
; 277  : 	/* Pointer to current pool
; 278  : 	 */
; 279  : 	pool	= factory->pools[poolCount];

  0003f	8b 45 08	 mov	 eax, DWORD PTR _factory$[ebp]
  00042	8b 08		 mov	 ecx, DWORD PTR [eax]
  00044	8b 55 f8	 mov	 edx, DWORD PTR _poolCount$[ebp]
  00047	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  0004a	89 45 fc	 mov	 DWORD PTR _pool$[ebp], eax

; 280  : 
; 281  : 	/* Work out how many tokens we need to check in this pool.
; 282  : 	 */
; 283  : 	limit	= (poolCount == factory->thisPool ? factory->nextToken : ANTLR3_FACTORY_POOL_SIZE);

  0004d	8b 4d 08	 mov	 ecx, DWORD PTR _factory$[ebp]
  00050	8b 55 f8	 mov	 edx, DWORD PTR _poolCount$[ebp]
  00053	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00056	75 0b		 jne	 SHORT $LN11@factoryClo
  00058	8b 45 08	 mov	 eax, DWORD PTR _factory$[ebp]
  0005b	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0005e	89 4d e8	 mov	 DWORD PTR tv73[ebp], ecx
  00061	eb 07		 jmp	 SHORT $LN12@factoryClo
$LN11@factoryClo:
  00063	c7 45 e8 00 04
	00 00		 mov	 DWORD PTR tv73[ebp], 1024 ; 00000400H
$LN12@factoryClo:
  0006a	8b 55 e8	 mov	 edx, DWORD PTR tv73[ebp]
  0006d	89 55 f4	 mov	 DWORD PTR _limit$[ebp], edx

; 284  : 	
; 285  : 	/* Marginal condition, we might be at the start of a brand new pool
; 286  : 	 * where the nextToken is 0 and nothing has been allocated.
; 287  : 	 */
; 288  : 	if  (limit > 0)

  00070	83 7d f4 00	 cmp	 DWORD PTR _limit$[ebp], 0
  00074	76 60		 jbe	 SHORT $LN6@factoryClo

; 289  : 	{
; 290  : 	    /* We have some tokens allocated from this pool
; 291  : 	     */
; 292  : 	    for (token = 0; token < limit; token++)

  00076	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _token$[ebp], 0
  0007d	eb 09		 jmp	 SHORT $LN7@factoryClo
$LN5@factoryClo:
  0007f	8b 45 f0	 mov	 eax, DWORD PTR _token$[ebp]
  00082	83 c0 01	 add	 eax, 1
  00085	89 45 f0	 mov	 DWORD PTR _token$[ebp], eax
$LN7@factoryClo:
  00088	8b 4d f0	 mov	 ecx, DWORD PTR _token$[ebp]
  0008b	3b 4d f4	 cmp	 ecx, DWORD PTR _limit$[ebp]
  0008e	73 46		 jae	 SHORT $LN6@factoryClo

; 293  : 	    {
; 294  : 		/* Next one in the chain
; 295  : 		 */
; 296  : 		check	= pool + token;

  00090	69 55 f0 90 00
	00 00		 imul	 edx, DWORD PTR _token$[ebp], 144
  00097	03 55 fc	 add	 edx, DWORD PTR _pool$[ebp]
  0009a	89 55 ec	 mov	 DWORD PTR _check$[ebp], edx

; 297  : 
; 298  : 		/* If the programmer made this a custom token, then
; 299  : 		 * see if we need to call their free routine.
; 300  : 		 */
; 301  : 		if  (check->custom != NULL && check->freeCustom != NULL)

  0009d	8b 45 ec	 mov	 eax, DWORD PTR _check$[ebp]
  000a0	83 78 40 00	 cmp	 DWORD PTR [eax+64], 0
  000a4	74 2e		 je	 SHORT $LN9@factoryClo
  000a6	8b 4d ec	 mov	 ecx, DWORD PTR _check$[ebp]
  000a9	83 79 44 00	 cmp	 DWORD PTR [ecx+68], 0
  000ad	74 25		 je	 SHORT $LN9@factoryClo

; 302  : 		{
; 303  : 		    check->freeCustom(check->custom);

  000af	8b f4		 mov	 esi, esp
  000b1	8b 55 ec	 mov	 edx, DWORD PTR _check$[ebp]
  000b4	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  000b7	50		 push	 eax
  000b8	8b 4d ec	 mov	 ecx, DWORD PTR _check$[ebp]
  000bb	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  000be	ff d2		 call	 edx
  000c0	83 c4 04	 add	 esp, 4
  000c3	3b f4		 cmp	 esi, esp
  000c5	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 304  : 		    check->custom = NULL;

  000ca	8b 45 ec	 mov	 eax, DWORD PTR _check$[ebp]
  000cd	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [eax+64], 0
$LN9@factoryClo:

; 305  : 		}
; 306  : 	    }

  000d4	eb a9		 jmp	 SHORT $LN5@factoryClo
$LN6@factoryClo:

; 307  : 	}
; 308  : 
; 309  : 	/* We can now free this pool allocation
; 310  : 	 */
; 311  : 	ANTLR3_FREE(factory->pools[poolCount]);

  000d6	8b 4d 08	 mov	 ecx, DWORD PTR _factory$[ebp]
  000d9	8b 11		 mov	 edx, DWORD PTR [ecx]
  000db	8b f4		 mov	 esi, esp
  000dd	8b 45 f8	 mov	 eax, DWORD PTR _poolCount$[ebp]
  000e0	8b 0c 82	 mov	 ecx, DWORD PTR [edx+eax*4]
  000e3	51		 push	 ecx
  000e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  000ea	83 c4 04	 add	 esp, 4
  000ed	3b f4		 cmp	 esi, esp
  000ef	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 312  : 	factory->pools[poolCount] = NULL;

  000f4	8b 55 08	 mov	 edx, DWORD PTR _factory$[ebp]
  000f7	8b 02		 mov	 eax, DWORD PTR [edx]
  000f9	8b 4d f8	 mov	 ecx, DWORD PTR _poolCount$[ebp]
  000fc	c7 04 88 00 00
	00 00		 mov	 DWORD PTR [eax+ecx*4], 0

; 313  :     }

  00103	e9 1f ff ff ff	 jmp	 $LN2@factoryClo
$LN3@factoryClo:

; 314  : 
; 315  :     /* All the pools are deallocated we can free the pointers to the pools
; 316  :      * now.
; 317  :      */
; 318  :     ANTLR3_FREE(factory->pools);

  00108	8b f4		 mov	 esi, esp
  0010a	8b 55 08	 mov	 edx, DWORD PTR _factory$[ebp]
  0010d	8b 02		 mov	 eax, DWORD PTR [edx]
  0010f	50		 push	 eax
  00110	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00116	83 c4 04	 add	 esp, 4
  00119	3b f4		 cmp	 esi, esp
  0011b	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 319  : 
; 320  :     /* Finally, we can free the space for the factory itself
; 321  :      */
; 322  :     ANTLR3_FREE(factory);

  00120	8b f4		 mov	 esi, esp
  00122	8b 4d 08	 mov	 ecx, DWORD PTR _factory$[ebp]
  00125	51		 push	 ecx
  00126	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0012c	83 c4 04	 add	 esp, 4
  0012f	3b f4		 cmp	 esi, esp
  00131	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00136	90		 npad	 1

; 323  : }

  00137	5e		 pop	 esi
  00138	83 c4 18	 add	 esp, 24			; 00000018H
  0013b	3b ec		 cmp	 ebp, esp
  0013d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00142	8b e5		 mov	 esp, ebp
  00144	5d		 pop	 ebp
  00145	c3		 ret	 0
_factoryClose ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontoken.c
;	COMDAT _toString
_TEXT	SEGMENT
_outtext$ = -8						; size = 4
_text$ = -4						; size = 4
_token$ = 8						; size = 4
_toString PROC						; COMDAT

; 558  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 559  :     pANTLR3_STRING  text;
; 560  :     pANTLR3_STRING  outtext;
; 561  : 
; 562  :     text    =	token->getText(token);

  00015	8b f4		 mov	 esi, esp
  00017	8b 45 08	 mov	 eax, DWORD PTR _token$[ebp]
  0001a	50		 push	 eax
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR _token$[ebp]
  0001e	8b 51 48	 mov	 edx, DWORD PTR [ecx+72]
  00021	ff d2		 call	 edx
  00023	83 c4 04	 add	 esp, 4
  00026	3b f4		 cmp	 esi, esp
  00028	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002d	89 45 fc	 mov	 DWORD PTR _text$[ebp], eax

; 563  :     
; 564  :     if	(text == NULL)

  00030	83 7d fc 00	 cmp	 DWORD PTR _text$[ebp], 0
  00034	75 07		 jne	 SHORT $LN2@toString

; 565  :     {
; 566  : 		return NULL;

  00036	33 c0		 xor	 eax, eax
  00038	e9 ee 02 00 00	 jmp	 $LN1@toString
$LN2@toString:

; 567  :     }
; 568  : 
; 569  : 	if	(text->factory == NULL)

  0003d	8b 45 fc	 mov	 eax, DWORD PTR _text$[ebp]
  00040	83 38 00	 cmp	 DWORD PTR [eax], 0
  00043	75 08		 jne	 SHORT $LN3@toString

; 570  : 	{
; 571  : 		return text;		// This usally means it is the EOF token

  00045	8b 45 fc	 mov	 eax, DWORD PTR _text$[ebp]
  00048	e9 de 02 00 00	 jmp	 $LN1@toString
$LN3@toString:

; 572  : 	}
; 573  : 
; 574  :     /* A new empty string to assemble all the stuff in
; 575  :      */
; 576  :     outtext = text->factory->newRaw(text->factory);

  0004d	8b f4		 mov	 esi, esp
  0004f	8b 4d fc	 mov	 ecx, DWORD PTR _text$[ebp]
  00052	8b 11		 mov	 edx, DWORD PTR [ecx]
  00054	52		 push	 edx
  00055	8b 45 fc	 mov	 eax, DWORD PTR _text$[ebp]
  00058	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0005d	ff d2		 call	 edx
  0005f	83 c4 04	 add	 esp, 4
  00062	3b f4		 cmp	 esi, esp
  00064	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00069	89 45 f8	 mov	 DWORD PTR _outtext$[ebp], eax

; 577  : 
; 578  :     /* Now we use our handy dandy string utility to assemble the
; 579  :      * the reporting string
; 580  :      * return "[@"+getTokenIndex()+","+start+":"+stop+"='"+txt+"',<"+type+">"+channelStr+","+line+":"+getCharPositionInLine()+"]";
; 581  :      */
; 582  :     outtext->append8(outtext, "[Index: ");

  0006c	8b f4		 mov	 esi, esp
  0006e	68 00 00 00 00	 push	 OFFSET ??_C@_08NEOOKDGC@?$FLIndex?3?5@
  00073	8b 45 f8	 mov	 eax, DWORD PTR _outtext$[ebp]
  00076	50		 push	 eax
  00077	8b 4d f8	 mov	 ecx, DWORD PTR _outtext$[ebp]
  0007a	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  0007d	ff d2		 call	 edx
  0007f	83 c4 08	 add	 esp, 8
  00082	3b f4		 cmp	 esi, esp
  00084	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 583  :     outtext->addi   (outtext, (ANTLR3_INT32)token->getTokenIndex(token));

  00089	8b f4		 mov	 esi, esp
  0008b	8b 45 08	 mov	 eax, DWORD PTR _token$[ebp]
  0008e	50		 push	 eax
  0008f	8b 4d 08	 mov	 ecx, DWORD PTR _token$[ebp]
  00092	8b 51 74	 mov	 edx, DWORD PTR [ecx+116]
  00095	ff d2		 call	 edx
  00097	83 c4 04	 add	 esp, 4
  0009a	3b f4		 cmp	 esi, esp
  0009c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a1	8b f4		 mov	 esi, esp
  000a3	50		 push	 eax
  000a4	8b 45 f8	 mov	 eax, DWORD PTR _outtext$[ebp]
  000a7	50		 push	 eax
  000a8	8b 4d f8	 mov	 ecx, DWORD PTR _outtext$[ebp]
  000ab	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  000ae	ff d2		 call	 edx
  000b0	83 c4 08	 add	 esp, 8
  000b3	3b f4		 cmp	 esi, esp
  000b5	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 584  :     outtext->append8(outtext, " (Start: ");

  000ba	8b f4		 mov	 esi, esp
  000bc	68 00 00 00 00	 push	 OFFSET ??_C@_09LBBAKIIA@?5?$CIStart?3?5@
  000c1	8b 45 f8	 mov	 eax, DWORD PTR _outtext$[ebp]
  000c4	50		 push	 eax
  000c5	8b 4d f8	 mov	 ecx, DWORD PTR _outtext$[ebp]
  000c8	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  000cb	ff d2		 call	 edx
  000cd	83 c4 08	 add	 esp, 8
  000d0	3b f4		 cmp	 esi, esp
  000d2	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 585  :     outtext->addi   (outtext, (ANTLR3_INT32)token->getStartIndex(token));

  000d7	8b f4		 mov	 esi, esp
  000d9	8b 45 08	 mov	 eax, DWORD PTR _token$[ebp]
  000dc	50		 push	 eax
  000dd	8b 4d 08	 mov	 ecx, DWORD PTR _token$[ebp]
  000e0	8b 51 7c	 mov	 edx, DWORD PTR [ecx+124]
  000e3	ff d2		 call	 edx
  000e5	83 c4 04	 add	 esp, 4
  000e8	3b f4		 cmp	 esi, esp
  000ea	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ef	8b f4		 mov	 esi, esp
  000f1	50		 push	 eax
  000f2	8b 45 f8	 mov	 eax, DWORD PTR _outtext$[ebp]
  000f5	50		 push	 eax
  000f6	8b 4d f8	 mov	 ecx, DWORD PTR _outtext$[ebp]
  000f9	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  000fc	ff d2		 call	 edx
  000fe	83 c4 08	 add	 esp, 8
  00101	3b f4		 cmp	 esi, esp
  00103	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 586  :     outtext->append8(outtext, "-Stop: ");

  00108	8b f4		 mov	 esi, esp
  0010a	68 00 00 00 00	 push	 OFFSET ??_C@_07LGAFOPAI@?9Stop?3?5@
  0010f	8b 45 f8	 mov	 eax, DWORD PTR _outtext$[ebp]
  00112	50		 push	 eax
  00113	8b 4d f8	 mov	 ecx, DWORD PTR _outtext$[ebp]
  00116	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00119	ff d2		 call	 edx
  0011b	83 c4 08	 add	 esp, 8
  0011e	3b f4		 cmp	 esi, esp
  00120	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 587  :     outtext->addi   (outtext, (ANTLR3_INT32)token->getStopIndex(token));

  00125	8b f4		 mov	 esi, esp
  00127	8b 45 08	 mov	 eax, DWORD PTR _token$[ebp]
  0012a	50		 push	 eax
  0012b	8b 4d 08	 mov	 ecx, DWORD PTR _token$[ebp]
  0012e	8b 91 84 00 00
	00		 mov	 edx, DWORD PTR [ecx+132]
  00134	ff d2		 call	 edx
  00136	83 c4 04	 add	 esp, 4
  00139	3b f4		 cmp	 esi, esp
  0013b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00140	8b f4		 mov	 esi, esp
  00142	50		 push	 eax
  00143	8b 45 f8	 mov	 eax, DWORD PTR _outtext$[ebp]
  00146	50		 push	 eax
  00147	8b 4d f8	 mov	 ecx, DWORD PTR _outtext$[ebp]
  0014a	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  0014d	ff d2		 call	 edx
  0014f	83 c4 08	 add	 esp, 8
  00152	3b f4		 cmp	 esi, esp
  00154	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 588  :     outtext->append8(outtext, ") ='");

  00159	8b f4		 mov	 esi, esp
  0015b	68 00 00 00 00	 push	 OFFSET ??_C@_04KDEICOAP@?$CJ?5?$DN?8@
  00160	8b 45 f8	 mov	 eax, DWORD PTR _outtext$[ebp]
  00163	50		 push	 eax
  00164	8b 4d f8	 mov	 ecx, DWORD PTR _outtext$[ebp]
  00167	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  0016a	ff d2		 call	 edx
  0016c	83 c4 08	 add	 esp, 8
  0016f	3b f4		 cmp	 esi, esp
  00171	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 589  :     outtext->appendS(outtext, text);

  00176	8b f4		 mov	 esi, esp
  00178	8b 45 fc	 mov	 eax, DWORD PTR _text$[ebp]
  0017b	50		 push	 eax
  0017c	8b 4d f8	 mov	 ecx, DWORD PTR _outtext$[ebp]
  0017f	51		 push	 ecx
  00180	8b 55 f8	 mov	 edx, DWORD PTR _outtext$[ebp]
  00183	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00186	ff d0		 call	 eax
  00188	83 c4 08	 add	 esp, 8
  0018b	3b f4		 cmp	 esi, esp
  0018d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 590  :     outtext->append8(outtext, "', type<");

  00192	8b f4		 mov	 esi, esp
  00194	68 00 00 00 00	 push	 OFFSET ??_C@_08KMKDFHHP@?8?0?5type?$DM@
  00199	8b 4d f8	 mov	 ecx, DWORD PTR _outtext$[ebp]
  0019c	51		 push	 ecx
  0019d	8b 55 f8	 mov	 edx, DWORD PTR _outtext$[ebp]
  001a0	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  001a3	ff d0		 call	 eax
  001a5	83 c4 08	 add	 esp, 8
  001a8	3b f4		 cmp	 esi, esp
  001aa	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 591  :     outtext->addi   (outtext, token->type);

  001af	8b f4		 mov	 esi, esp
  001b1	8b 4d 08	 mov	 ecx, DWORD PTR _token$[ebp]
  001b4	8b 11		 mov	 edx, DWORD PTR [ecx]
  001b6	52		 push	 edx
  001b7	8b 45 f8	 mov	 eax, DWORD PTR _outtext$[ebp]
  001ba	50		 push	 eax
  001bb	8b 4d f8	 mov	 ecx, DWORD PTR _outtext$[ebp]
  001be	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  001c1	ff d2		 call	 edx
  001c3	83 c4 08	 add	 esp, 8
  001c6	3b f4		 cmp	 esi, esp
  001c8	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 592  :     outtext->append8(outtext, "> ");

  001cd	8b f4		 mov	 esi, esp
  001cf	68 00 00 00 00	 push	 OFFSET ??_C@_02LLMPMKNF@?$DO?5@
  001d4	8b 45 f8	 mov	 eax, DWORD PTR _outtext$[ebp]
  001d7	50		 push	 eax
  001d8	8b 4d f8	 mov	 ecx, DWORD PTR _outtext$[ebp]
  001db	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  001de	ff d2		 call	 edx
  001e0	83 c4 08	 add	 esp, 8
  001e3	3b f4		 cmp	 esi, esp
  001e5	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 593  : 
; 594  :     if	(token->getChannel(token) > ANTLR3_TOKEN_DEFAULT_CHANNEL)

  001ea	8b f4		 mov	 esi, esp
  001ec	8b 45 08	 mov	 eax, DWORD PTR _token$[ebp]
  001ef	50		 push	 eax
  001f0	8b 4d 08	 mov	 ecx, DWORD PTR _token$[ebp]
  001f3	8b 51 6c	 mov	 edx, DWORD PTR [ecx+108]
  001f6	ff d2		 call	 edx
  001f8	83 c4 04	 add	 esp, 4
  001fb	3b f4		 cmp	 esi, esp
  001fd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00202	85 c0		 test	 eax, eax
  00204	76 6c		 jbe	 SHORT $LN4@toString

; 595  :     {
; 596  : 		outtext->append8(outtext, "(channel = ");

  00206	8b f4		 mov	 esi, esp
  00208	68 00 00 00 00	 push	 OFFSET ??_C@_0M@NJBPMJAH@?$CIchannel?5?$DN?5@
  0020d	8b 45 f8	 mov	 eax, DWORD PTR _outtext$[ebp]
  00210	50		 push	 eax
  00211	8b 4d f8	 mov	 ecx, DWORD PTR _outtext$[ebp]
  00214	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00217	ff d2		 call	 edx
  00219	83 c4 08	 add	 esp, 8
  0021c	3b f4		 cmp	 esi, esp
  0021e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 597  : 		outtext->addi	(outtext, (ANTLR3_INT32)token->getChannel(token));

  00223	8b f4		 mov	 esi, esp
  00225	8b 45 08	 mov	 eax, DWORD PTR _token$[ebp]
  00228	50		 push	 eax
  00229	8b 4d 08	 mov	 ecx, DWORD PTR _token$[ebp]
  0022c	8b 51 6c	 mov	 edx, DWORD PTR [ecx+108]
  0022f	ff d2		 call	 edx
  00231	83 c4 04	 add	 esp, 4
  00234	3b f4		 cmp	 esi, esp
  00236	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0023b	8b f4		 mov	 esi, esp
  0023d	50		 push	 eax
  0023e	8b 45 f8	 mov	 eax, DWORD PTR _outtext$[ebp]
  00241	50		 push	 eax
  00242	8b 4d f8	 mov	 ecx, DWORD PTR _outtext$[ebp]
  00245	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  00248	ff d2		 call	 edx
  0024a	83 c4 08	 add	 esp, 8
  0024d	3b f4		 cmp	 esi, esp
  0024f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 598  : 		outtext->append8(outtext, ") ");

  00254	8b f4		 mov	 esi, esp
  00256	68 00 00 00 00	 push	 OFFSET ??_C@_02KCKGHPCA@?$CJ?5@
  0025b	8b 45 f8	 mov	 eax, DWORD PTR _outtext$[ebp]
  0025e	50		 push	 eax
  0025f	8b 4d f8	 mov	 ecx, DWORD PTR _outtext$[ebp]
  00262	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00265	ff d2		 call	 edx
  00267	83 c4 08	 add	 esp, 8
  0026a	3b f4		 cmp	 esi, esp
  0026c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00271	90		 npad	 1
$LN4@toString:

; 599  :     }
; 600  : 
; 601  :     outtext->append8(outtext, "Line: ");

  00272	8b f4		 mov	 esi, esp
  00274	68 00 00 00 00	 push	 OFFSET ??_C@_06FIEBOLOH@Line?3?5@
  00279	8b 45 f8	 mov	 eax, DWORD PTR _outtext$[ebp]
  0027c	50		 push	 eax
  0027d	8b 4d f8	 mov	 ecx, DWORD PTR _outtext$[ebp]
  00280	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00283	ff d2		 call	 edx
  00285	83 c4 08	 add	 esp, 8
  00288	3b f4		 cmp	 esi, esp
  0028a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 602  :     outtext->addi   (outtext, (ANTLR3_INT32)token->getLine(token));

  0028f	8b f4		 mov	 esi, esp
  00291	8b 45 08	 mov	 eax, DWORD PTR _token$[ebp]
  00294	50		 push	 eax
  00295	8b 4d 08	 mov	 ecx, DWORD PTR _token$[ebp]
  00298	8b 51 5c	 mov	 edx, DWORD PTR [ecx+92]
  0029b	ff d2		 call	 edx
  0029d	83 c4 04	 add	 esp, 4
  002a0	3b f4		 cmp	 esi, esp
  002a2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002a7	8b f4		 mov	 esi, esp
  002a9	50		 push	 eax
  002aa	8b 45 f8	 mov	 eax, DWORD PTR _outtext$[ebp]
  002ad	50		 push	 eax
  002ae	8b 4d f8	 mov	 ecx, DWORD PTR _outtext$[ebp]
  002b1	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  002b4	ff d2		 call	 edx
  002b6	83 c4 08	 add	 esp, 8
  002b9	3b f4		 cmp	 esi, esp
  002bb	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 603  :     outtext->append8(outtext, " LinePos:");

  002c0	8b f4		 mov	 esi, esp
  002c2	68 00 00 00 00	 push	 OFFSET ??_C@_09PNCFGGF@?5LinePos?3@
  002c7	8b 45 f8	 mov	 eax, DWORD PTR _outtext$[ebp]
  002ca	50		 push	 eax
  002cb	8b 4d f8	 mov	 ecx, DWORD PTR _outtext$[ebp]
  002ce	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  002d1	ff d2		 call	 edx
  002d3	83 c4 08	 add	 esp, 8
  002d6	3b f4		 cmp	 esi, esp
  002d8	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 604  :     outtext->addi   (outtext, token->getCharPositionInLine(token));

  002dd	8b f4		 mov	 esi, esp
  002df	8b 45 08	 mov	 eax, DWORD PTR _token$[ebp]
  002e2	50		 push	 eax
  002e3	8b 4d 08	 mov	 ecx, DWORD PTR _token$[ebp]
  002e6	8b 51 64	 mov	 edx, DWORD PTR [ecx+100]
  002e9	ff d2		 call	 edx
  002eb	83 c4 04	 add	 esp, 4
  002ee	3b f4		 cmp	 esi, esp
  002f0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002f5	8b f4		 mov	 esi, esp
  002f7	50		 push	 eax
  002f8	8b 45 f8	 mov	 eax, DWORD PTR _outtext$[ebp]
  002fb	50		 push	 eax
  002fc	8b 4d f8	 mov	 ecx, DWORD PTR _outtext$[ebp]
  002ff	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  00302	ff d2		 call	 edx
  00304	83 c4 08	 add	 esp, 8
  00307	3b f4		 cmp	 esi, esp
  00309	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 605  :     outtext->addc   (outtext, ']');

  0030e	8b f4		 mov	 esi, esp
  00310	6a 5d		 push	 93			; 0000005dH
  00312	8b 45 f8	 mov	 eax, DWORD PTR _outtext$[ebp]
  00315	50		 push	 eax
  00316	8b 4d f8	 mov	 ecx, DWORD PTR _outtext$[ebp]
  00319	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  0031c	ff d2		 call	 edx
  0031e	83 c4 08	 add	 esp, 8
  00321	3b f4		 cmp	 esi, esp
  00323	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 606  : 
; 607  :     return  outtext;

  00328	8b 45 f8	 mov	 eax, DWORD PTR _outtext$[ebp]
$LN1@toString:

; 608  : }

  0032b	5e		 pop	 esi
  0032c	83 c4 08	 add	 esp, 8
  0032f	3b ec		 cmp	 ebp, esp
  00331	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00336	8b e5		 mov	 esp, ebp
  00338	5d		 pop	 ebp
  00339	c3		 ret	 0
_toString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontoken.c
;	COMDAT _setStopIndex
_TEXT	SEGMENT
_token$ = 8						; size = 4
_stop$ = 12						; size = 4
_setStopIndex PROC					; COMDAT

; 553  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 554  :     token->stop	= stop;

  00003	8b 45 08	 mov	 eax, DWORD PTR _token$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _stop$[ebp]
  00009	89 48 28	 mov	 DWORD PTR [eax+40], ecx

; 555  : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
_setStopIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontoken.c
;	COMDAT _getStopIndex
_TEXT	SEGMENT
_token$ = 8						; size = 4
_getStopIndex PROC					; COMDAT

; 548  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 549  :     return  token->stop;

  00003	8b 45 08	 mov	 eax, DWORD PTR _token$[ebp]
  00006	8b 40 28	 mov	 eax, DWORD PTR [eax+40]

; 550  : }

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
_getStopIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontoken.c
;	COMDAT _setStartIndex
_TEXT	SEGMENT
_token$ = 8						; size = 4
_start$ = 12						; size = 4
_setStartIndex PROC					; COMDAT

; 543  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 544  :     token->start    = start;

  00003	8b 45 08	 mov	 eax, DWORD PTR _token$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _start$[ebp]
  00009	89 48 24	 mov	 DWORD PTR [eax+36], ecx

; 545  : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
_setStartIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontoken.c
;	COMDAT _getStartIndex
_TEXT	SEGMENT
tv69 = -4						; size = 4
_token$ = 8						; size = 4
_getStartIndex PROC					; COMDAT

; 538  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 539  : 	return  token->start == -1 ? (ANTLR3_MARKER)(token->input->data) : token->start;

  00004	8b 45 08	 mov	 eax, DWORD PTR _token$[ebp]
  00007	83 78 24 ff	 cmp	 DWORD PTR [eax+36], -1
  0000b	75 0e		 jne	 SHORT $LN3@getStartIn
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _token$[ebp]
  00010	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00013	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00016	89 45 fc	 mov	 DWORD PTR tv69[ebp], eax
  00019	eb 09		 jmp	 SHORT $LN4@getStartIn
$LN3@getStartIn:
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR _token$[ebp]
  0001e	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00021	89 55 fc	 mov	 DWORD PTR tv69[ebp], edx
$LN4@getStartIn:
  00024	8b 45 fc	 mov	 eax, DWORD PTR tv69[ebp]

; 540  : }

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
_getStartIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontoken.c
;	COMDAT _setTokenIndex
_TEXT	SEGMENT
_token$ = 8						; size = 4
_index$ = 12						; size = 4
_setTokenIndex PROC					; COMDAT

; 533  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 534  :     token->index    = index;

  00003	8b 45 08	 mov	 eax, DWORD PTR _token$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _index$[ebp]
  00009	89 48 20	 mov	 DWORD PTR [eax+32], ecx

; 535  : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
_setTokenIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontoken.c
;	COMDAT _getTokenIndex
_TEXT	SEGMENT
_token$ = 8						; size = 4
_getTokenIndex PROC					; COMDAT

; 528  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 529  :     return  token->index;

  00003	8b 45 08	 mov	 eax, DWORD PTR _token$[ebp]
  00006	8b 40 20	 mov	 eax, DWORD PTR [eax+32]

; 530  : }

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
_getTokenIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontoken.c
;	COMDAT _setChannel
_TEXT	SEGMENT
_token$ = 8						; size = 4
_channel$ = 12						; size = 4
_setChannel PROC					; COMDAT

; 523  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 524  :     token->channel  = channel;

  00003	8b 45 08	 mov	 eax, DWORD PTR _token$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _channel$[ebp]
  00009	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 525  : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
_setChannel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontoken.c
;	COMDAT _getChannel
_TEXT	SEGMENT
_token$ = 8						; size = 4
_getChannel PROC					; COMDAT

; 518  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 519  :     return  token->channel;

  00003	8b 45 08	 mov	 eax, DWORD PTR _token$[ebp]
  00006	8b 40 18	 mov	 eax, DWORD PTR [eax+24]

; 520  : }

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
_getChannel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontoken.c
;	COMDAT _setCharPositionInLine
_TEXT	SEGMENT
_token$ = 8						; size = 4
_pos$ = 12						; size = 4
_setCharPositionInLine PROC				; COMDAT

; 513  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 514  :     token->charPosition = pos;

  00003	8b 45 08	 mov	 eax, DWORD PTR _token$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _pos$[ebp]
  00009	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 515  : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
_setCharPositionInLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontoken.c
;	COMDAT _getCharPositionInLine
_TEXT	SEGMENT
_token$ = 8						; size = 4
_getCharPositionInLine PROC				; COMDAT

; 508  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 509  :     return  token->charPosition;

  00003	8b 45 08	 mov	 eax, DWORD PTR _token$[ebp]
  00006	8b 40 14	 mov	 eax, DWORD PTR [eax+20]

; 510  : }

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
_getCharPositionInLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontoken.c
;	COMDAT _setLine
_TEXT	SEGMENT
_token$ = 8						; size = 4
_line$ = 12						; size = 4
_setLine PROC						; COMDAT

; 503  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 504  :     token->line = line;

  00003	8b 45 08	 mov	 eax, DWORD PTR _token$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _line$[ebp]
  00009	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 505  : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
_setLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontoken.c
;	COMDAT _getLine
_TEXT	SEGMENT
_token$ = 8						; size = 4
_getLine PROC						; COMDAT

; 498  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 499  :     return  token->line;

  00003	8b 45 08	 mov	 eax, DWORD PTR _token$[ebp]
  00006	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]

; 500  : }

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
_getLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontoken.c
;	COMDAT _setType
_TEXT	SEGMENT
_token$ = 8						; size = 4
_type$ = 12						; size = 4
_setType PROC						; COMDAT

; 493  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 494  :     token->type = type;

  00003	8b 45 08	 mov	 eax, DWORD PTR _token$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _type$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 495  : }

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
_setType ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontoken.c
;	COMDAT _getType
_TEXT	SEGMENT
_token$ = 8						; size = 4
_getType PROC						; COMDAT

; 488  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 489  :     return  token->type;

  00003	8b 45 08	 mov	 eax, DWORD PTR _token$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]

; 490  : }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
_getType ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontoken.c
;	COMDAT _setText8
_TEXT	SEGMENT
tv66 = -4						; size = 4
_token$ = 8						; size = 4
_text$ = 12						; size = 4
_setText8 PROC						; COMDAT

; 439  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 440  : 	// No text to set, so ignore
; 441  : 	//
; 442  : 	if	(text == NULL) return;

  0000c	83 7d 0c 00	 cmp	 DWORD PTR _text$[ebp], 0
  00010	75 02		 jne	 SHORT $LN4@setText8
  00012	eb 4f		 jmp	 SHORT $LN1@setText8
$LN4@setText8:

; 443  : 
; 444  : 	switch	(token->textState)

  00014	8b 45 08	 mov	 eax, DWORD PTR _token$[ebp]
  00017	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  0001a	89 4d fc	 mov	 DWORD PTR tv66[ebp], ecx
  0001d	83 7d fc 00	 cmp	 DWORD PTR tv66[ebp], 0
  00021	74 08		 je	 SHORT $LN5@setText8
  00023	83 7d fc 01	 cmp	 DWORD PTR tv66[ebp], 1
  00027	74 02		 je	 SHORT $LN5@setText8
  00029	eb 15		 jmp	 SHORT $LN7@setText8
$LN5@setText8:

; 445  : 	{
; 446  : 		case	ANTLR3_TEXT_NONE:
; 447  : 		case	ANTLR3_TEXT_CHARP:	// Caller must free before setting again, if it needs to be freed
; 448  : 
; 449  : 			// Nothing in there yet, or just a char *, so just set the
; 450  : 			// text as a pointer
; 451  : 			//
; 452  : 			token->textState		= ANTLR3_TEXT_CHARP;

  0002b	8b 55 08	 mov	 edx, DWORD PTR _token$[ebp]
  0002e	c7 42 2c 01 00
	00 00		 mov	 DWORD PTR [edx+44], 1

; 453  : 			token->tokText.chars	= (pANTLR3_UCHAR)text;

  00035	8b 45 08	 mov	 eax, DWORD PTR _token$[ebp]
  00038	8b 4d 0c	 mov	 ecx, DWORD PTR _text$[ebp]
  0003b	89 48 30	 mov	 DWORD PTR [eax+48], ecx

; 454  : 			break;

  0003e	eb 23		 jmp	 SHORT $LN2@setText8
$LN7@setText8:

; 455  : 
; 456  : 		default:
; 457  : 
; 458  : 			// It was already a pANTLR3_STRING, so just override it
; 459  : 			//
; 460  : 			token->tokText.text->set8(token->tokText.text, (const char *)text);

  00040	8b f4		 mov	 esi, esp
  00042	8b 55 0c	 mov	 edx, DWORD PTR _text$[ebp]
  00045	52		 push	 edx
  00046	8b 45 08	 mov	 eax, DWORD PTR _token$[ebp]
  00049	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  0004c	51		 push	 ecx
  0004d	8b 55 08	 mov	 edx, DWORD PTR _token$[ebp]
  00050	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  00053	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00056	ff d1		 call	 ecx
  00058	83 c4 08	 add	 esp, 8
  0005b	3b f4		 cmp	 esi, esp
  0005d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00062	90		 npad	 1
$LN2@setText8:
$LN1@setText8:

; 461  : 			break;
; 462  : 	}
; 463  : 
; 464  : 	// We are done 
; 465  : 	//
; 466  : 	return;
; 467  : }

  00063	5e		 pop	 esi
  00064	83 c4 04	 add	 esp, 4
  00067	3b ec		 cmp	 ebp, esp
  00069	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c3		 ret	 0
_setText8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontoken.c
;	COMDAT _setText
_TEXT	SEGMENT
_token$ = 8						; size = 4
_text$ = 12						; size = 4
_setText PROC						; COMDAT

; 475  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 476  : 	// Merely replaces and existing pre-defined text with the supplied
; 477  : 	// string
; 478  : 	//
; 479  : 	token->textState	= ANTLR3_TEXT_STRING;

  00003	8b 45 08	 mov	 eax, DWORD PTR _token$[ebp]
  00006	c7 40 2c 02 00
	00 00		 mov	 DWORD PTR [eax+44], 2

; 480  : 	token->tokText.text	= text;

  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _token$[ebp]
  00010	8b 55 0c	 mov	 edx, DWORD PTR _text$[ebp]
  00013	89 51 30	 mov	 DWORD PTR [ecx+48], edx

; 481  : 
; 482  : 	/* We are done 
; 483  : 	*/
; 484  : 	return;
; 485  : }

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
_setText ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontoken.c
;	COMDAT _getText
_TEXT	SEGMENT
tv65 = -4						; size = 4
_token$ = 8						; size = 4
_getText PROC						; COMDAT

; 375  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 376  : 	switch (token->textState)

  0000d	8b 45 08	 mov	 eax, DWORD PTR _token$[ebp]
  00010	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  00013	89 4d fc	 mov	 DWORD PTR tv65[ebp], ecx
  00016	83 7d fc 01	 cmp	 DWORD PTR tv65[ebp], 1
  0001a	74 18		 je	 SHORT $LN5@getText
  0001c	83 7d fc 02	 cmp	 DWORD PTR tv65[ebp], 2
  00020	74 02		 je	 SHORT $LN4@getText
  00022	eb 67		 jmp	 SHORT $LN8@getText
$LN4@getText:

; 377  : 	{
; 378  : 		case ANTLR3_TEXT_STRING:
; 379  : 
; 380  : 			// Someone already created a string for this token, so we just
; 381  : 			// use it.
; 382  : 			//
; 383  : 			return	token->tokText.text;

  00024	8b 55 08	 mov	 edx, DWORD PTR _token$[ebp]
  00027	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  0002a	e9 0d 01 00 00	 jmp	 $LN2@getText

; 384  : 			break;

  0002f	e9 08 01 00 00	 jmp	 $LN2@getText
$LN5@getText:

; 385  :     
; 386  : 		case ANTLR3_TEXT_CHARP:
; 387  : 
; 388  : 			// We had a straight text pointer installed, now we
; 389  : 			// must convert it to a string. Note we have to do this here
; 390  : 			// or otherwise setText8() will just install the same char*
; 391  : 			//
; 392  : 			if	(token->strFactory != NULL)

  00034	8b 45 08	 mov	 eax, DWORD PTR _token$[ebp]
  00037	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0003b	74 42		 je	 SHORT $LN6@getText

; 393  : 			{
; 394  : 				token->tokText.text	= token->strFactory->newStr8(token->strFactory, (pANTLR3_UINT8)token->tokText.chars);

  0003d	8b f4		 mov	 esi, esp
  0003f	8b 4d 08	 mov	 ecx, DWORD PTR _token$[ebp]
  00042	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00045	52		 push	 edx
  00046	8b 45 08	 mov	 eax, DWORD PTR _token$[ebp]
  00049	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0004c	51		 push	 ecx
  0004d	8b 55 08	 mov	 edx, DWORD PTR _token$[ebp]
  00050	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00053	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00056	ff d1		 call	 ecx
  00058	83 c4 08	 add	 esp, 8
  0005b	3b f4		 cmp	 esi, esp
  0005d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00062	8b 55 08	 mov	 edx, DWORD PTR _token$[ebp]
  00065	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 395  : 				token->textState	= ANTLR3_TEXT_STRING;

  00068	8b 45 08	 mov	 eax, DWORD PTR _token$[ebp]
  0006b	c7 40 2c 02 00
	00 00		 mov	 DWORD PTR [eax+44], 2

; 396  : 				return token->tokText.text;

  00072	8b 4d 08	 mov	 ecx, DWORD PTR _token$[ebp]
  00075	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00078	e9 bf 00 00 00	 jmp	 $LN2@getText

; 397  : 			}

  0007d	eb 07		 jmp	 SHORT $LN7@getText
$LN6@getText:

; 398  : 			else
; 399  : 			{
; 400  : 				// We cannot do anything here
; 401  : 				//
; 402  : 				return NULL;

  0007f	33 c0		 xor	 eax, eax
  00081	e9 b6 00 00 00	 jmp	 $LN2@getText
$LN7@getText:

; 403  : 			}
; 404  : 			break;

  00086	e9 b1 00 00 00	 jmp	 $LN2@getText
$LN8@getText:

; 405  : 
; 406  : 		default:
; 407  : 
; 408  : 			// EOF is a special case
; 409  : 			//
; 410  : 			if (token->type == ANTLR3_TOKEN_EOF)

  0008b	8b 55 08	 mov	 edx, DWORD PTR _token$[ebp]
  0008e	83 3a ff	 cmp	 DWORD PTR [edx], -1
  00091	75 49		 jne	 SHORT $LN9@getText

; 411  : 			{
; 412  : 				token->tokText.text				= token->strFactory->newStr8(token->strFactory, (pANTLR3_UINT8)"<EOF>");

  00093	8b f4		 mov	 esi, esp
  00095	68 00 00 00 00	 push	 OFFSET ??_C@_05FLDDOMNH@?$DMEOF?$DO@
  0009a	8b 45 08	 mov	 eax, DWORD PTR _token$[ebp]
  0009d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000a0	51		 push	 ecx
  000a1	8b 55 08	 mov	 edx, DWORD PTR _token$[ebp]
  000a4	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000a7	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  000aa	ff d1		 call	 ecx
  000ac	83 c4 08	 add	 esp, 8
  000af	3b f4		 cmp	 esi, esp
  000b1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b6	8b 55 08	 mov	 edx, DWORD PTR _token$[ebp]
  000b9	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 413  : 				token->textState				= ANTLR3_TEXT_STRING;

  000bc	8b 45 08	 mov	 eax, DWORD PTR _token$[ebp]
  000bf	c7 40 2c 02 00
	00 00		 mov	 DWORD PTR [eax+44], 2

; 414  : 				token->tokText.text->factory	= token->strFactory;

  000c6	8b 4d 08	 mov	 ecx, DWORD PTR _token$[ebp]
  000c9	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  000cc	8b 45 08	 mov	 eax, DWORD PTR _token$[ebp]
  000cf	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000d2	89 0a		 mov	 DWORD PTR [edx], ecx

; 415  : 				return token->tokText.text;

  000d4	8b 55 08	 mov	 edx, DWORD PTR _token$[ebp]
  000d7	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  000da	eb 60		 jmp	 SHORT $LN2@getText
$LN9@getText:

; 416  : 			}
; 417  : 
; 418  : 
; 419  : 			// We had nothing installed in the token, create a new string
; 420  : 			// from the input stream
; 421  : 			//
; 422  : 
; 423  : 			if	(token->input != NULL)

  000dc	8b 45 08	 mov	 eax, DWORD PTR _token$[ebp]
  000df	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  000e3	74 55		 je	 SHORT $LN10@getText

; 424  : 			{
; 425  : 			
; 426  : 				return	token->input->substr(	token->input, 

  000e5	8b f4		 mov	 esi, esp
  000e7	8b 4d 08	 mov	 ecx, DWORD PTR _token$[ebp]
  000ea	51		 push	 ecx
  000eb	8b 55 08	 mov	 edx, DWORD PTR _token$[ebp]
  000ee	8b 82 84 00 00
	00		 mov	 eax, DWORD PTR [edx+132]
  000f4	ff d0		 call	 eax
  000f6	83 c4 04	 add	 esp, 4
  000f9	3b f4		 cmp	 esi, esp
  000fb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00100	8b f4		 mov	 esi, esp
  00102	50		 push	 eax
  00103	8b fc		 mov	 edi, esp
  00105	8b 4d 08	 mov	 ecx, DWORD PTR _token$[ebp]
  00108	51		 push	 ecx
  00109	8b 55 08	 mov	 edx, DWORD PTR _token$[ebp]
  0010c	8b 42 7c	 mov	 eax, DWORD PTR [edx+124]
  0010f	ff d0		 call	 eax
  00111	83 c4 04	 add	 esp, 4
  00114	3b fc		 cmp	 edi, esp
  00116	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0011b	50		 push	 eax
  0011c	8b 4d 08	 mov	 ecx, DWORD PTR _token$[ebp]
  0011f	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00122	52		 push	 edx
  00123	8b 45 08	 mov	 eax, DWORD PTR _token$[ebp]
  00126	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00129	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  0012c	ff d2		 call	 edx
  0012e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00131	3b f4		 cmp	 esi, esp
  00133	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00138	eb 02		 jmp	 SHORT $LN2@getText
$LN10@getText:

; 427  : 												token->getStartIndex(token), 
; 428  :  												token->getStopIndex(token)
; 429  : 											);
; 430  : 			}
; 431  : 
; 432  : 			// Nothing to return, there is no input stream
; 433  : 			//
; 434  : 			return NULL;

  0013a	33 c0		 xor	 eax, eax
$LN2@getText:

; 435  : 			break;
; 436  : 	}
; 437  : }

  0013c	5f		 pop	 edi
  0013d	5e		 pop	 esi
  0013e	83 c4 04	 add	 esp, 4
  00141	3b ec		 cmp	 ebp, esp
  00143	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00148	8b e5		 mov	 esp, ebp
  0014a	5d		 pop	 ebp
  0014b	c3		 ret	 0
_getText ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontoken.c
;	COMDAT _antlr3SetTokenAPI
_TEXT	SEGMENT
_token$ = 8						; size = 4
_antlr3SetTokenAPI PROC					; COMDAT

; 350  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 351  :     token->getText		    = getText;

  00003	8b 45 08	 mov	 eax, DWORD PTR _token$[ebp]
  00006	c7 40 48 00 00
	00 00		 mov	 DWORD PTR [eax+72], OFFSET _getText

; 352  :     token->setText		    = setText;

  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _token$[ebp]
  00010	c7 41 4c 00 00
	00 00		 mov	 DWORD PTR [ecx+76], OFFSET _setText

; 353  :     token->setText8		    = setText8;

  00017	8b 55 08	 mov	 edx, DWORD PTR _token$[ebp]
  0001a	c7 42 50 00 00
	00 00		 mov	 DWORD PTR [edx+80], OFFSET _setText8

; 354  :     token->getType		    = getType;

  00021	8b 45 08	 mov	 eax, DWORD PTR _token$[ebp]
  00024	c7 40 54 00 00
	00 00		 mov	 DWORD PTR [eax+84], OFFSET _getType

; 355  :     token->setType		    = setType;

  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _token$[ebp]
  0002e	c7 41 58 00 00
	00 00		 mov	 DWORD PTR [ecx+88], OFFSET _setType

; 356  :     token->getLine		    = getLine;

  00035	8b 55 08	 mov	 edx, DWORD PTR _token$[ebp]
  00038	c7 42 5c 00 00
	00 00		 mov	 DWORD PTR [edx+92], OFFSET _getLine

; 357  :     token->setLine		    = setLine;

  0003f	8b 45 08	 mov	 eax, DWORD PTR _token$[ebp]
  00042	c7 40 60 00 00
	00 00		 mov	 DWORD PTR [eax+96], OFFSET _setLine

; 358  :     token->setLine		    = setLine;

  00049	8b 4d 08	 mov	 ecx, DWORD PTR _token$[ebp]
  0004c	c7 41 60 00 00
	00 00		 mov	 DWORD PTR [ecx+96], OFFSET _setLine

; 359  :     token->getCharPositionInLine    = getCharPositionInLine;

  00053	8b 55 08	 mov	 edx, DWORD PTR _token$[ebp]
  00056	c7 42 64 00 00
	00 00		 mov	 DWORD PTR [edx+100], OFFSET _getCharPositionInLine

; 360  :     token->setCharPositionInLine    = setCharPositionInLine;

  0005d	8b 45 08	 mov	 eax, DWORD PTR _token$[ebp]
  00060	c7 40 68 00 00
	00 00		 mov	 DWORD PTR [eax+104], OFFSET _setCharPositionInLine

; 361  :     token->getChannel		    = getChannel;

  00067	8b 4d 08	 mov	 ecx, DWORD PTR _token$[ebp]
  0006a	c7 41 6c 00 00
	00 00		 mov	 DWORD PTR [ecx+108], OFFSET _getChannel

; 362  :     token->setChannel		    = setChannel;

  00071	8b 55 08	 mov	 edx, DWORD PTR _token$[ebp]
  00074	c7 42 70 00 00
	00 00		 mov	 DWORD PTR [edx+112], OFFSET _setChannel

; 363  :     token->getTokenIndex	    = getTokenIndex;

  0007b	8b 45 08	 mov	 eax, DWORD PTR _token$[ebp]
  0007e	c7 40 74 00 00
	00 00		 mov	 DWORD PTR [eax+116], OFFSET _getTokenIndex

; 364  :     token->setTokenIndex	    = setTokenIndex;

  00085	8b 4d 08	 mov	 ecx, DWORD PTR _token$[ebp]
  00088	c7 41 78 00 00
	00 00		 mov	 DWORD PTR [ecx+120], OFFSET _setTokenIndex

; 365  :     token->getStartIndex	    = getStartIndex;

  0008f	8b 55 08	 mov	 edx, DWORD PTR _token$[ebp]
  00092	c7 42 7c 00 00
	00 00		 mov	 DWORD PTR [edx+124], OFFSET _getStartIndex

; 366  :     token->setStartIndex	    = setStartIndex;

  00099	8b 45 08	 mov	 eax, DWORD PTR _token$[ebp]
  0009c	c7 80 80 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+128], OFFSET _setStartIndex

; 367  :     token->getStopIndex		    = getStopIndex;

  000a6	8b 4d 08	 mov	 ecx, DWORD PTR _token$[ebp]
  000a9	c7 81 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+132], OFFSET _getStopIndex

; 368  :     token->setStopIndex		    = setStopIndex;

  000b3	8b 55 08	 mov	 edx, DWORD PTR _token$[ebp]
  000b6	c7 82 88 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+136], OFFSET _setStopIndex

; 369  :     token->toString		    = toString;

  000c0	8b 45 08	 mov	 eax, DWORD PTR _token$[ebp]
  000c3	c7 80 8c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+140], OFFSET _toString

; 370  : 
; 371  :     return;
; 372  : }

  000cd	5d		 pop	 ebp
  000ce	c3		 ret	 0
_antlr3SetTokenAPI ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontoken.c
;	COMDAT _antlr3TokenFactoryNew
_TEXT	SEGMENT
_factory$ = -4						; size = 4
_input$ = 8						; size = 4
_antlr3TokenFactoryNew PROC				; COMDAT

; 93   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 94   :     pANTLR3_TOKEN_FACTORY   factory;
; 95   : 
; 96   :     /* allocate memory
; 97   :      */
; 98   :     factory	= (pANTLR3_TOKEN_FACTORY) ANTLR3_MALLOC((size_t)sizeof(ANTLR3_TOKEN_FACTORY));

  0000c	8b f4		 mov	 esi, esp
  0000e	68 b4 00 00 00	 push	 180			; 000000b4H
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00019	83 c4 04	 add	 esp, 4
  0001c	3b f4		 cmp	 esi, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	89 45 fc	 mov	 DWORD PTR _factory$[ebp], eax

; 99   : 
; 100  :     if	(factory == NULL)

  00026	83 7d fc 00	 cmp	 DWORD PTR _factory$[ebp], 0
  0002a	75 07		 jne	 SHORT $LN2@antlr3Toke

; 101  :     {
; 102  : 	return	NULL;

  0002c	33 c0		 xor	 eax, eax
  0002e	e9 86 00 00 00	 jmp	 $LN1@antlr3Toke
$LN2@antlr3Toke:

; 103  :     }
; 104  : 
; 105  :     /* Install factory API
; 106  :      */
; 107  :     factory->newToken	    = newPoolToken;

  00033	8b 45 fc	 mov	 eax, DWORD PTR _factory$[ebp]
  00036	c7 80 a4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+164], OFFSET _newPoolToken

; 108  :     factory->close	    = factoryClose;

  00040	8b 4d fc	 mov	 ecx, DWORD PTR _factory$[ebp]
  00043	c7 81 b0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+176], OFFSET _factoryClose

; 109  :     factory->setInputStream = setInputStream;

  0004d	8b 55 fc	 mov	 edx, DWORD PTR _factory$[ebp]
  00050	c7 82 ac 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+172], OFFSET _setInputStream

; 110  :     factory->reset          = factoryReset;

  0005a	8b 45 fc	 mov	 eax, DWORD PTR _factory$[ebp]
  0005d	c7 80 a8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+168], OFFSET _factoryReset

; 111  :     
; 112  :     /* Allocate the initial pool
; 113  :      */
; 114  :     factory->thisPool	= -1;

  00067	8b 4d fc	 mov	 ecx, DWORD PTR _factory$[ebp]
  0006a	c7 41 04 ff ff
	ff ff		 mov	 DWORD PTR [ecx+4], -1

; 115  :     factory->pools      = NULL;

  00071	8b 55 fc	 mov	 edx, DWORD PTR _factory$[ebp]
  00074	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 116  :     factory->maxPool    = -1;

  0007a	8b 45 fc	 mov	 eax, DWORD PTR _factory$[ebp]
  0007d	c7 40 08 ff ff
	ff ff		 mov	 DWORD PTR [eax+8], -1

; 117  :     newPool(factory);

  00084	8b 4d fc	 mov	 ecx, DWORD PTR _factory$[ebp]
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 _newPool
  0008d	83 c4 04	 add	 esp, 4

; 118  : 
; 119  :     /* Factory space is good, we now want to initialize our cheating token
; 120  :      * which one it is initialized is the model for all tokens we manufacture
; 121  :      */
; 122  :     antlr3SetTokenAPI(&factory->unTruc);

  00090	8b 55 fc	 mov	 edx, DWORD PTR _factory$[ebp]
  00093	83 c2 10	 add	 edx, 16			; 00000010H
  00096	52		 push	 edx
  00097	e8 00 00 00 00	 call	 _antlr3SetTokenAPI
  0009c	83 c4 04	 add	 esp, 4

; 123  : 
; 124  :     /* Set some initial variables for future copying
; 125  :      */
; 126  :     factory->unTruc.factoryMade	= ANTLR3_TRUE;

  0009f	8b 45 fc	 mov	 eax, DWORD PTR _factory$[ebp]
  000a2	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1

; 127  : 
; 128  :     // Input stream
; 129  :     //
; 130  :     setInputStream(factory, input);

  000a6	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  000a9	51		 push	 ecx
  000aa	8b 55 fc	 mov	 edx, DWORD PTR _factory$[ebp]
  000ad	52		 push	 edx
  000ae	e8 00 00 00 00	 call	 _setInputStream
  000b3	83 c4 08	 add	 esp, 8

; 131  :     
; 132  :     return  factory;

  000b6	8b 45 fc	 mov	 eax, DWORD PTR _factory$[ebp]
$LN1@antlr3Toke:

; 133  : 
; 134  : }

  000b9	5e		 pop	 esi
  000ba	83 c4 04	 add	 esp, 4
  000bd	3b ec		 cmp	 ebp, esp
  000bf	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c4	8b e5		 mov	 esp, ebp
  000c6	5d		 pop	 ebp
  000c7	c3		 ret	 0
_antlr3TokenFactoryNew ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3commontoken.c
;	COMDAT _antlr3CommonTokenNew
_TEXT	SEGMENT
_token$ = -4						; size = 4
_ttype$ = 8						; size = 4
_antlr3CommonTokenNew PROC				; COMDAT

; 74   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 75   : 	pANTLR3_COMMON_TOKEN    token;
; 76   : 
; 77   : 	// Create a raw token with the interface installed
; 78   : 	//
; 79   : 	token   = newToken();

  0000c	e8 00 00 00 00	 call	 _newToken
  00011	89 45 fc	 mov	 DWORD PTR _token$[ebp], eax

; 80   : 
; 81   : 	if	(token != NULL)

  00014	83 7d fc 00	 cmp	 DWORD PTR _token$[ebp], 0
  00018	74 1d		 je	 SHORT $LN2@antlr3Comm

; 82   : 	{
; 83   : 		token->setType(token, ttype);

  0001a	8b f4		 mov	 esi, esp
  0001c	8b 45 08	 mov	 eax, DWORD PTR _ttype$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _token$[ebp]
  00023	51		 push	 ecx
  00024	8b 55 fc	 mov	 edx, DWORD PTR _token$[ebp]
  00027	8b 42 58	 mov	 eax, DWORD PTR [edx+88]
  0002a	ff d0		 call	 eax
  0002c	83 c4 08	 add	 esp, 8
  0002f	3b f4		 cmp	 esi, esp
  00031	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00036	90		 npad	 1
$LN2@antlr3Comm:

; 84   : 	}
; 85   : 
; 86   : 	// All good
; 87   : 	//
; 88   : 	return  token;

  00037	8b 45 fc	 mov	 eax, DWORD PTR _token$[ebp]

; 89   : }

  0003a	5e		 pop	 esi
  0003b	83 c4 04	 add	 esp, 4
  0003e	3b ec		 cmp	 ebp, esp
  00040	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
_antlr3CommonTokenNew ENDP
_TEXT	ENDS
END
