; Listing generated by Microsoft (R) Optimizing Compiler Version 19.42.34436.0 

	TITLE	C:\SPO_labs\C\DebugDLL\antlr3baserecognizer.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	___local_stdio_printf_options
PUBLIC	__vfprintf_l
PUBLIC	_fprintf
PUBLIC	_antlr3BaseRecognizerNew
PUBLIC	_antlr3RecognitionExceptionNew
PUBLIC	_antlr3MTExceptionNew
PUBLIC	??_C@_0CL@GOBGIMMF@org?4antlr?4runtime?4MismatchedTok@ ; `string'
PUBLIC	??_C@_0HL@JIGEPJEO@Base?5recognizer?5function?5antlr3@ ; `string'
PUBLIC	??_C@_0CH@CEOAHODC@org?4antlr?4runtime?4RecognitionEx@ ; `string'
PUBLIC	??_C@_0BF@BIIJEBMB@Unexpected?5character@	; `string'
PUBLIC	??_C@_0BB@FKAIECKK@Unexpected?5token@		; `string'
PUBLIC	??_C@_0BB@DHPGECBL@?9unknown?5source?9@		; `string'
PUBLIC	??_C@_0BA@IGJLDFLP@Unexpected?5node@		; `string'
PUBLIC	??_C@_0GF@OHPBBBJJ@Base?5recognizer?5function?5?8match@ ; `string'
PUBLIC	??_C@_0GI@PFDGGJHE@Base?5recognizer?5function?5?8match@ ; `string'
PUBLIC	??_C@_0GI@PGJHCPC@Base?5recognizer?5function?5?8misma@ ; `string'
PUBLIC	??_C@_0CJ@DEJOPFAB@org?4antlr?4runtime?4UnwantedToken@ ; `string'
PUBLIC	??_C@_0CI@FIMBDEFG@org?4antlr?4runtime?4MissingTokenE@ ; `string'
PUBLIC	??_C@_0BA@NHDJPBJB@?9end?5of?5input?9?$CI@	; `string'
PUBLIC	??_C@_0BC@NHAPJBAE@?9unknown?5source?9?$CI@	; `string'
PUBLIC	??_C@_03ECLNAHEM@?$CFs?$CI@			; `string'
PUBLIC	??_C@_04CGKAJBAP@?$CFd?$CJ?5@			; `string'
PUBLIC	??_C@_0BB@IEOPNPCE@?5?3?5error?5?$CFd?5?3?5?$CFs@ ; `string'
PUBLIC	??_C@_0P@FFBCLMBE@?0?5at?5offset?5?$CFd@	; `string'
PUBLIC	??_C@_0L@OOBCNBEJ@?0?5at?5?$DMEOF?$DO@		; `string'
PUBLIC	??_C@_0BI@JEIKDPEP@?$DMno?5text?5for?5the?5token?$DO@ ; `string'
PUBLIC	??_C@_0BC@FCBIMOGO@?6?5?5?5?5near?5?$CFs?6?5?5?5?5@ ; `string'
PUBLIC	??_C@_09NBGEJOP@?0?5near?5?$CFs@		; `string'
PUBLIC	??_C@_0HF@PILNDIMB@Base?5recognizer?5function?5displa@ ; `string'
PUBLIC	??_C@_0BH@MJPMEPDL@?5?3?5Extraneous?5input?4?4?4@ ; `string'
PUBLIC	??_C@_0CG@FKGGLHMC@?5?3?5Extraneous?5input?5?9?5expected?5@ ; `string'
PUBLIC	??_C@_0CH@BICFKPGJ@?5?3?5Extraneous?5input?5?9?5expected?5@ ; `string'
PUBLIC	??_C@_0BK@FIODKMIN@?5?3?5Missing?5token?5?$CI?$CFd?$CJ?4?4?4?6@ ; `string'
PUBLIC	??_C@_0BC@DMIEBDKC@?5?3?5Missing?5?$DMEOF?$DO?6@ ; `string'
PUBLIC	??_C@_0BA@JJEGDFKK@?5?3?5Missing?5?$CFs?5?6@	; `string'
PUBLIC	??_C@_0BE@CLJLAAJJ@?5?3?5syntax?5error?4?4?4?6@	; `string'
PUBLIC	??_C@_0BD@GBFOJBLI@?5?3?5expected?5?$DMEOF?$DO?6@ ; `string'
PUBLIC	??_C@_0BE@KIMOAPGN@?5?3?5expected?5?$CFs?5?4?4?4?6@ ; `string'
PUBLIC	??_C@_0CL@DEBMMGOB@?5?3?5cannot?5match?5to?5any?5predicte@ ; `string'
PUBLIC	??_C@_0CM@CIKJCOFM@?5?3?5unexpected?5input?4?4?4?6?5?5expect@ ; `string'
PUBLIC	??_C@_02KEGNLNML@?0?5@				; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_04HDOCAJNK@?$CFs?$CFs@			; `string'
PUBLIC	??_C@_01EEMJAFIK@?6@				; `string'
PUBLIC	??_C@_0EK@GLJFAOIP@Actually?5dude?0?5we?5didn?8t?5seem?5t@ ; `string'
PUBLIC	??_C@_0EL@LCDOFIDJ@I?5could?5not?5work?5out?5what?5I?5was@ ; `string'
PUBLIC	??_C@_0BI@LEAIIGMG@?5?3?5missing?5elements?4?4?4?6@ ; `string'
PUBLIC	??_C@_0BN@OMNOHKEK@?5?3?5syntax?5not?5recognized?4?4?4?6@ ; `string'
PUBLIC	??_C@_0GF@LHIHPDDL@Base?5recognizer?5function?5recove@ ; `string'
PUBLIC	??_C@_0HI@JHLMLNCB@Base?5recognizer?5function?5recove@ ; `string'
PUBLIC	??_C@_0HG@PBJLBMBD@Base?5recognizer?5function?5recove@ ; `string'
PUBLIC	??_C@_0GM@GBPBPFEJ@Base?5recognizer?5function?5?8consu@ ; `string'
PUBLIC	??_C@_0GP@DAFOBMIL@Base?5recognizer?5function?5?8consu@ ; `string'
PUBLIC	??_C@_0HB@KELCLOME@Base?5recognizer?5function?5?8alrea@ ; `string'
PUBLIC	??_C@_0GN@OCPDGBBI@Base?5recognizer?5function?5consum@ ; `string'
PUBLIC	??_C@_0GH@CJOFJAFO@Base?5recognizer?5function?5?8synPr@ ; `string'
PUBLIC	??_C@_09MLMDPBIO@?$DMmissing?5@			; `string'
PUBLIC	??_C@_01PPODPGHN@?$DO@				; `string'
EXTRN	__imp__calloc:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	_antlr3IntTrieNew:PROC
EXTRN	_antlr3BitsetNew:PROC
EXTRN	_antlr3BitsetLoad:PROC
EXTRN	_antlr3VectorNew:PROC
EXTRN	_antlr3StackNew:PROC
EXTRN	_antlr3ExceptionNew:PROC
EXTRN	_antlr3TokenFactoryNew:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_01PPODPGHN@?$DO@
CONST	SEGMENT
??_C@_01PPODPGHN@?$DO@ DB '>', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09MLMDPBIO@?$DMmissing?5@
CONST	SEGMENT
??_C@_09MLMDPBIO@?$DMmissing?5@ DB '<missing ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GH@CJOFJAFO@Base?5recognizer?5function?5?8synPr@
CONST	SEGMENT
??_C@_0GH@CJOFJAFO@Base?5recognizer?5function?5?8synPr@ DB 'Base recogniz'
	DB	'er function ''synPred'' called by unknown parser type - provi'
	DB	'de override for this function', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GN@OCPDGBBI@Base?5recognizer?5function?5consum@
CONST	SEGMENT
??_C@_0GN@OCPDGBBI@Base?5recognizer?5function?5consum@ DB 'Base recognize'
	DB	'r function consumeUntilSet called by unknown parser type - pr'
	DB	'ovide override for this function', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0HB@KELCLOME@Base?5recognizer?5function?5?8alrea@
CONST	SEGMENT
??_C@_0HB@KELCLOME@Base?5recognizer?5function?5?8alrea@ DB 'Base recogniz'
	DB	'er function ''alreadyParsedRule'' called by unknown parser ty'
	DB	'pe - provide override for this function', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GP@DAFOBMIL@Base?5recognizer?5function?5?8consu@
CONST	SEGMENT
??_C@_0GP@DAFOBMIL@Base?5recognizer?5function?5?8consu@ DB 'Base recogniz'
	DB	'er function ''consumeUntilSet'' called by unknown parser type'
	DB	' - provide override for this function', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GM@GBPBPFEJ@Base?5recognizer?5function?5?8consu@
CONST	SEGMENT
??_C@_0GM@GBPBPFEJ@Base?5recognizer?5function?5?8consu@ DB 'Base recogniz'
	DB	'er function ''consumeUntil'' called by unknown parser type - '
	DB	'provide override for this function', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HG@PBJLBMBD@Base?5recognizer?5function?5recove@
CONST	SEGMENT
??_C@_0HG@PBJLBMBD@Base?5recognizer?5function?5recove@ DB 'Base recognize'
	DB	'r function recoverFromMismatchedSet called by unknown parser '
	DB	'type - provide override for this function', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HI@JHLMLNCB@Base?5recognizer?5function?5recove@
CONST	SEGMENT
??_C@_0HI@JHLMLNCB@Base?5recognizer?5function?5recove@ DB 'Base recognize'
	DB	'r function recoverFromMismatchedToken called by unknown parse'
	DB	'r type - provide override for this function', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GF@LHIHPDDL@Base?5recognizer?5function?5recove@
CONST	SEGMENT
??_C@_0GF@LHIHPDDL@Base?5recognizer?5function?5recove@ DB 'Base recognize'
	DB	'r function recover called by unknown parser type - provide ov'
	DB	'erride for this function', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@OMNOHKEK@?5?3?5syntax?5not?5recognized?4?4?4?6@
CONST	SEGMENT
??_C@_0BN@OMNOHKEK@?5?3?5syntax?5not?5recognized?4?4?4?6@ DB ' : syntax n'
	DB	'ot recognized...', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LEAIIGMG@?5?3?5missing?5elements?4?4?4?6@
CONST	SEGMENT
??_C@_0BI@LEAIIGMG@?5?3?5missing?5elements?4?4?4?6@ DB ' : missing elemen'
	DB	'ts...', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@LCDOFIDJ@I?5could?5not?5work?5out?5what?5I?5was@
CONST	SEGMENT
??_C@_0EL@LCDOFIDJ@I?5could?5not?5work?5out?5what?5I?5was@ DB 'I could no'
	DB	't work out what I was expecting, like so many of us these day'
	DB	's!', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@GLJFAOIP@Actually?5dude?0?5we?5didn?8t?5seem?5t@
CONST	SEGMENT
??_C@_0EK@GLJFAOIP@Actually?5dude?0?5we?5didn?8t?5seem?5t@ DB 'Actually d'
	DB	'ude, we didn''t seem to be expecting anything here, or at lea'
	DB	'st', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04HDOCAJNK@?$CFs?$CFs@
CONST	SEGMENT
??_C@_04HDOCAJNK@?$CFs?$CFs@ DB '%s%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02KEGNLNML@?0?5@
CONST	SEGMENT
??_C@_02KEGNLNML@?0?5@ DB ', ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@CIKJCOFM@?5?3?5unexpected?5input?4?4?4?6?5?5expect@
CONST	SEGMENT
??_C@_0CM@CIKJCOFM@?5?3?5unexpected?5input?4?4?4?6?5?5expect@ DB ' : unex'
	DB	'pected input...', 0aH, '  expected one of : ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@DEBMMGOB@?5?3?5cannot?5match?5to?5any?5predicte@
CONST	SEGMENT
??_C@_0CL@DEBMMGOB@?5?3?5cannot?5match?5to?5any?5predicte@ DB ' : cannot '
	DB	'match to any predicted input...', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KIMOAPGN@?5?3?5expected?5?$CFs?5?4?4?4?6@
CONST	SEGMENT
??_C@_0BE@KIMOAPGN@?5?3?5expected?5?$CFs?5?4?4?4?6@ DB ' : expected %s ..'
	DB	'.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GBFOJBLI@?5?3?5expected?5?$DMEOF?$DO?6@
CONST	SEGMENT
??_C@_0BD@GBFOJBLI@?5?3?5expected?5?$DMEOF?$DO?6@ DB ' : expected <EOF>', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@CLJLAAJJ@?5?3?5syntax?5error?4?4?4?6@
CONST	SEGMENT
??_C@_0BE@CLJLAAJJ@?5?3?5syntax?5error?4?4?4?6@ DB ' : syntax error...', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JJEGDFKK@?5?3?5Missing?5?$CFs?5?6@
CONST	SEGMENT
??_C@_0BA@JJEGDFKK@?5?3?5Missing?5?$CFs?5?6@ DB ' : Missing %s ', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DMIEBDKC@?5?3?5Missing?5?$DMEOF?$DO?6@
CONST	SEGMENT
??_C@_0BC@DMIEBDKC@?5?3?5Missing?5?$DMEOF?$DO?6@ DB ' : Missing <EOF>', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@FIODKMIN@?5?3?5Missing?5token?5?$CI?$CFd?$CJ?4?4?4?6@
CONST	SEGMENT
??_C@_0BK@FIODKMIN@?5?3?5Missing?5token?5?$CI?$CFd?$CJ?4?4?4?6@ DB ' : Mi'
	DB	'ssing token (%d)...', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@BICFKPGJ@?5?3?5Extraneous?5input?5?9?5expected?5@
CONST	SEGMENT
??_C@_0CH@BICFKPGJ@?5?3?5Extraneous?5input?5?9?5expected?5@ DB ' : Extran'
	DB	'eous input - expected %s ...', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@FKGGLHMC@?5?3?5Extraneous?5input?5?9?5expected?5@
CONST	SEGMENT
??_C@_0CG@FKGGLHMC@?5?3?5Extraneous?5input?5?9?5expected?5@ DB ' : Extran'
	DB	'eous input - expected <EOF>', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@MJPMEPDL@?5?3?5Extraneous?5input?4?4?4@
CONST	SEGMENT
??_C@_0BH@MJPMEPDL@?5?3?5Extraneous?5input?4?4?4@ DB ' : Extraneous input'
	DB	'...', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0HF@PILNDIMB@Base?5recognizer?5function?5displa@
CONST	SEGMENT
??_C@_0HF@PILNDIMB@Base?5recognizer?5function?5displa@ DB 'Base recognize'
	DB	'r function displayRecognitionError called by unknown parser t'
	DB	'ype - provide override for this function', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09NBGEJOP@?0?5near?5?$CFs@
CONST	SEGMENT
??_C@_09NBGEJOP@?0?5near?5?$CFs@ DB ', near %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@FCBIMOGO@?6?5?5?5?5near?5?$CFs?6?5?5?5?5@
CONST	SEGMENT
??_C@_0BC@FCBIMOGO@?6?5?5?5?5near?5?$CFs?6?5?5?5?5@ DB 0aH, '    near %s', 0aH
	DB	'    ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@JEIKDPEP@?$DMno?5text?5for?5the?5token?$DO@
CONST	SEGMENT
??_C@_0BI@JEIKDPEP@?$DMno?5text?5for?5the?5token?$DO@ DB '<no text for th'
	DB	'e token>', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OOBCNBEJ@?0?5at?5?$DMEOF?$DO@
CONST	SEGMENT
??_C@_0L@OOBCNBEJ@?0?5at?5?$DMEOF?$DO@ DB ', at <EOF>', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FFBCLMBE@?0?5at?5offset?5?$CFd@
CONST	SEGMENT
??_C@_0P@FFBCLMBE@?0?5at?5offset?5?$CFd@ DB ', at offset %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IEOPNPCE@?5?3?5error?5?$CFd?5?3?5?$CFs@
CONST	SEGMENT
??_C@_0BB@IEOPNPCE@?5?3?5error?5?$CFd?5?3?5?$CFs@ DB ' : error %d : %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04CGKAJBAP@?$CFd?$CJ?5@
CONST	SEGMENT
??_C@_04CGKAJBAP@?$CFd?$CJ?5@ DB '%d) ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03ECLNAHEM@?$CFs?$CI@
CONST	SEGMENT
??_C@_03ECLNAHEM@?$CFs?$CI@ DB '%s(', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NHAPJBAE@?9unknown?5source?9?$CI@
CONST	SEGMENT
??_C@_0BC@NHAPJBAE@?9unknown?5source?9?$CI@ DB '-unknown source-(', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NHDJPBJB@?9end?5of?5input?9?$CI@
CONST	SEGMENT
??_C@_0BA@NHDJPBJB@?9end?5of?5input?9?$CI@ DB '-end of input-(', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@FIMBDEFG@org?4antlr?4runtime?4MissingTokenE@
CONST	SEGMENT
??_C@_0CI@FIMBDEFG@org?4antlr?4runtime?4MissingTokenE@ DB 'org.antlr.runt'
	DB	'ime.MissingTokenException', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@DEJOPFAB@org?4antlr?4runtime?4UnwantedToken@
CONST	SEGMENT
??_C@_0CJ@DEJOPFAB@org?4antlr?4runtime?4UnwantedToken@ DB 'org.antlr.runt'
	DB	'ime.UnwantedTokenException', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GI@PGJHCPC@Base?5recognizer?5function?5?8misma@
CONST	SEGMENT
??_C@_0GI@PGJHCPC@Base?5recognizer?5function?5?8misma@ DB 'Base recognize'
	DB	'r function ''mismatch'' called by unknown parser type - provi'
	DB	'de override for this function', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GI@PFDGGJHE@Base?5recognizer?5function?5?8match@
CONST	SEGMENT
??_C@_0GI@PFDGGJHE@Base?5recognizer?5function?5?8match@ DB 'Base recogniz'
	DB	'er function ''matchAny'' called by unknown parser type - prov'
	DB	'ide override for this function', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GF@OHPBBBJJ@Base?5recognizer?5function?5?8match@
CONST	SEGMENT
??_C@_0GF@OHPBBBJJ@Base?5recognizer?5function?5?8match@ DB 'Base recogniz'
	DB	'er function ''match'' called by unknown parser type - provide'
	DB	' override for this function', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@IGJLDFLP@Unexpected?5node@
CONST	SEGMENT
??_C@_0BA@IGJLDFLP@Unexpected?5node@ DB 'Unexpected node', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DHPGECBL@?9unknown?5source?9@
CONST	SEGMENT
??_C@_0BB@DHPGECBL@?9unknown?5source?9@ DB '-unknown source-', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FKAIECKK@Unexpected?5token@
CONST	SEGMENT
??_C@_0BB@FKAIECKK@Unexpected?5token@ DB 'Unexpected token', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@BIIJEBMB@Unexpected?5character@
CONST	SEGMENT
??_C@_0BF@BIIJEBMB@Unexpected?5character@ DB 'Unexpected character', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@CEOAHODC@org?4antlr?4runtime?4RecognitionEx@
CONST	SEGMENT
??_C@_0CH@CEOAHODC@org?4antlr?4runtime?4RecognitionEx@ DB 'org.antlr.runt'
	DB	'ime.RecognitionException', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0HL@JIGEPJEO@Base?5recognizer?5function?5antlr3@
CONST	SEGMENT
??_C@_0HL@JIGEPJEO@Base?5recognizer?5function?5antlr3@ DB 'Base recognize'
	DB	'r function antlr3RecognitionExceptionNew called by unknown pa'
	DB	'rser type - provide override for this function', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@GOBGIMMF@org?4antlr?4runtime?4MismatchedTok@
CONST	SEGMENT
??_C@_0CL@GOBGIMMF@org?4antlr?4runtime?4MismatchedTok@ DB 'org.antlr.runt'
	DB	'ime.MismatchedTokenException', 00H		; `string'
CONST	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3baserecognizer.c
;	COMDAT _freeIntTrie
_TEXT	SEGMENT
_trie$ = 8						; size = 4
_freeIntTrie PROC					; COMDAT

; 1839 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1840 :     ((pANTLR3_INT_TRIE)trie)->free((pANTLR3_INT_TRIE)trie);

  00004	8b f4		 mov	 esi, esp
  00006	8b 45 08	 mov	 eax, DWORD PTR _trie$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _trie$[ebp]
  0000d	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00010	ff d2		 call	 edx
  00012	83 c4 04	 add	 esp, 4
  00015	3b f4		 cmp	 esi, esp
  00017	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001c	90		 npad	 1

; 1841 : }

  0001d	5e		 pop	 esi
  0001e	3b ec		 cmp	 ebp, esp
  00020	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
_freeIntTrie ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3baserecognizer.c
;	COMDAT _getNumberOfSyntaxErrors
_TEXT	SEGMENT
_recognizer$ = 8					; size = 4
_getNumberOfSyntaxErrors PROC				; COMDAT

; 1311 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1312 : 	return	recognizer->state->errorCount;

  00003	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  00006	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00009	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]

; 1313 : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
_getNumberOfSyntaxErrors ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3baserecognizer.c
;	COMDAT _getMissingSymbol
_TEXT	SEGMENT
_text$ = -20						; size = 4
_current$ = -16						; size = 4
_token$ = -12						; size = 4
_cts$ = -8						; size = 4
_ts$ = -4						; size = 4
_recognizer$ = 8					; size = 4
_istream$ = 12						; size = 4
_e$ = 16						; size = 4
_expectedTokenType$ = 20				; size = 4
_follow$ = 24						; size = 4
_getMissingSymbol PROC					; COMDAT

; 2174 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0000f	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00012	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00015	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00018	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 2175 : 	pANTLR3_TOKEN_STREAM			ts;
; 2176 : 	pANTLR3_COMMON_TOKEN_STREAM		cts;
; 2177 : 	pANTLR3_COMMON_TOKEN			token;
; 2178 : 	pANTLR3_COMMON_TOKEN			current;
; 2179 : 	pANTLR3_STRING					text;
; 2180 : 
; 2181 : 	// Dereference the standard pointers
; 2182 : 	//
; 2183 : 	ts		= (pANTLR3_TOKEN_STREAM)istream->super;

  0001b	8b 45 0c	 mov	 eax, DWORD PTR _istream$[ebp]
  0001e	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00021	89 4d fc	 mov	 DWORD PTR _ts$[ebp], ecx

; 2184 : 	cts		= (pANTLR3_COMMON_TOKEN_STREAM)ts->super;

  00024	8b 55 fc	 mov	 edx, DWORD PTR _ts$[ebp]
  00027	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0002a	89 45 f8	 mov	 DWORD PTR _cts$[ebp], eax

; 2185 : 	
; 2186 : 	// Work out what to use as the current symbol to make a line and offset etc
; 2187 : 	// If we are at EOF, we use the token before EOF
; 2188 : 	//
; 2189 : 	current	= ts->_LT(ts, 1);

  0002d	8b f4		 mov	 esi, esp
  0002f	6a 01		 push	 1
  00031	8b 4d fc	 mov	 ecx, DWORD PTR _ts$[ebp]
  00034	51		 push	 ecx
  00035	8b 55 fc	 mov	 edx, DWORD PTR _ts$[ebp]
  00038	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0003b	ff d0		 call	 eax
  0003d	83 c4 08	 add	 esp, 8
  00040	3b f4		 cmp	 esi, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	89 45 f0	 mov	 DWORD PTR _current$[ebp], eax

; 2190 : 	if	(current->getType(current) == ANTLR3_TOKEN_EOF)

  0004a	8b f4		 mov	 esi, esp
  0004c	8b 4d f0	 mov	 ecx, DWORD PTR _current$[ebp]
  0004f	51		 push	 ecx
  00050	8b 55 f0	 mov	 edx, DWORD PTR _current$[ebp]
  00053	8b 42 54	 mov	 eax, DWORD PTR [edx+84]
  00056	ff d0		 call	 eax
  00058	83 c4 04	 add	 esp, 4
  0005b	3b f4		 cmp	 esi, esp
  0005d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00062	83 f8 ff	 cmp	 eax, -1
  00065	75 1d		 jne	 SHORT $LN2@getMissing

; 2191 : 	{
; 2192 : 		current = ts->_LT(ts, -1);

  00067	8b f4		 mov	 esi, esp
  00069	6a ff		 push	 -1
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR _ts$[ebp]
  0006e	51		 push	 ecx
  0006f	8b 55 fc	 mov	 edx, DWORD PTR _ts$[ebp]
  00072	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00075	ff d0		 call	 eax
  00077	83 c4 08	 add	 esp, 8
  0007a	3b f4		 cmp	 esi, esp
  0007c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00081	89 45 f0	 mov	 DWORD PTR _current$[ebp], eax
$LN2@getMissing:

; 2193 : 	}
; 2194 : 
; 2195 : 	// Create a new empty token
; 2196 : 	//
; 2197 : 	if	(recognizer->state->tokFactory == NULL)

  00084	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  00087	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0008a	83 7a 34 00	 cmp	 DWORD PTR [edx+52], 0
  0008e	75 18		 jne	 SHORT $LN3@getMissing

; 2198 : 	{
; 2199 : 		// We don't yet have a token factory for making tokens
; 2200 : 		// we just need a fake one using the input stream of the current
; 2201 : 		// token.
; 2202 : 		//
; 2203 : 		recognizer->state->tokFactory = antlr3TokenFactoryNew(current->input);

  00090	8b 45 f0	 mov	 eax, DWORD PTR _current$[ebp]
  00093	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00096	51		 push	 ecx
  00097	e8 00 00 00 00	 call	 _antlr3TokenFactoryNew
  0009c	83 c4 04	 add	 esp, 4
  0009f	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  000a2	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  000a5	89 41 34	 mov	 DWORD PTR [ecx+52], eax
$LN3@getMissing:

; 2204 : 	}
; 2205 : 	token	= recognizer->state->tokFactory->newToken(recognizer->state->tokFactory);

  000a8	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  000ab	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000ae	8b f4		 mov	 esi, esp
  000b0	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  000b3	51		 push	 ecx
  000b4	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  000b7	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000ba	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  000bd	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  000c3	ff d2		 call	 edx
  000c5	83 c4 04	 add	 esp, 4
  000c8	3b f4		 cmp	 esi, esp
  000ca	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000cf	89 45 f4	 mov	 DWORD PTR _token$[ebp], eax

; 2206 : 	if (token == NULL) { return NULL; }

  000d2	83 7d f4 00	 cmp	 DWORD PTR _token$[ebp], 0
  000d6	75 07		 jne	 SHORT $LN4@getMissing
  000d8	33 c0		 xor	 eax, eax
  000da	e9 5b 01 00 00	 jmp	 $LN1@getMissing
$LN4@getMissing:

; 2207 : 
; 2208 : 	// Set some of the token properties based on the current token
; 2209 : 	//
; 2210 : 	token->setLine					(token, current->getLine(current));

  000df	8b f4		 mov	 esi, esp
  000e1	8b 45 f0	 mov	 eax, DWORD PTR _current$[ebp]
  000e4	50		 push	 eax
  000e5	8b 4d f0	 mov	 ecx, DWORD PTR _current$[ebp]
  000e8	8b 51 5c	 mov	 edx, DWORD PTR [ecx+92]
  000eb	ff d2		 call	 edx
  000ed	83 c4 04	 add	 esp, 4
  000f0	3b f4		 cmp	 esi, esp
  000f2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f7	8b f4		 mov	 esi, esp
  000f9	50		 push	 eax
  000fa	8b 45 f4	 mov	 eax, DWORD PTR _token$[ebp]
  000fd	50		 push	 eax
  000fe	8b 4d f4	 mov	 ecx, DWORD PTR _token$[ebp]
  00101	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  00104	ff d2		 call	 edx
  00106	83 c4 08	 add	 esp, 8
  00109	3b f4		 cmp	 esi, esp
  0010b	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2211 : 	token->setCharPositionInLine	(token, current->getCharPositionInLine(current));

  00110	8b f4		 mov	 esi, esp
  00112	8b 45 f0	 mov	 eax, DWORD PTR _current$[ebp]
  00115	50		 push	 eax
  00116	8b 4d f0	 mov	 ecx, DWORD PTR _current$[ebp]
  00119	8b 51 64	 mov	 edx, DWORD PTR [ecx+100]
  0011c	ff d2		 call	 edx
  0011e	83 c4 04	 add	 esp, 4
  00121	3b f4		 cmp	 esi, esp
  00123	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00128	8b f4		 mov	 esi, esp
  0012a	50		 push	 eax
  0012b	8b 45 f4	 mov	 eax, DWORD PTR _token$[ebp]
  0012e	50		 push	 eax
  0012f	8b 4d f4	 mov	 ecx, DWORD PTR _token$[ebp]
  00132	8b 51 68	 mov	 edx, DWORD PTR [ecx+104]
  00135	ff d2		 call	 edx
  00137	83 c4 08	 add	 esp, 8
  0013a	3b f4		 cmp	 esi, esp
  0013c	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2212 : 	token->setChannel				(token, ANTLR3_TOKEN_DEFAULT_CHANNEL);

  00141	8b f4		 mov	 esi, esp
  00143	6a 00		 push	 0
  00145	8b 45 f4	 mov	 eax, DWORD PTR _token$[ebp]
  00148	50		 push	 eax
  00149	8b 4d f4	 mov	 ecx, DWORD PTR _token$[ebp]
  0014c	8b 51 70	 mov	 edx, DWORD PTR [ecx+112]
  0014f	ff d2		 call	 edx
  00151	83 c4 08	 add	 esp, 8
  00154	3b f4		 cmp	 esi, esp
  00156	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2213 : 	token->setType					(token, expectedTokenType);

  0015b	8b f4		 mov	 esi, esp
  0015d	8b 45 14	 mov	 eax, DWORD PTR _expectedTokenType$[ebp]
  00160	50		 push	 eax
  00161	8b 4d f4	 mov	 ecx, DWORD PTR _token$[ebp]
  00164	51		 push	 ecx
  00165	8b 55 f4	 mov	 edx, DWORD PTR _token$[ebp]
  00168	8b 42 58	 mov	 eax, DWORD PTR [edx+88]
  0016b	ff d0		 call	 eax
  0016d	83 c4 08	 add	 esp, 8
  00170	3b f4		 cmp	 esi, esp
  00172	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2214 :     token->user1                    = current->user1;

  00177	8b 4d f4	 mov	 ecx, DWORD PTR _token$[ebp]
  0017a	8b 55 f0	 mov	 edx, DWORD PTR _current$[ebp]
  0017d	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00180	89 41 34	 mov	 DWORD PTR [ecx+52], eax

; 2215 :     token->user2                    = current->user2;

  00183	8b 4d f4	 mov	 ecx, DWORD PTR _token$[ebp]
  00186	8b 55 f0	 mov	 edx, DWORD PTR _current$[ebp]
  00189	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  0018c	89 41 38	 mov	 DWORD PTR [ecx+56], eax

; 2216 :     token->user3                    = current->user3;

  0018f	8b 4d f4	 mov	 ecx, DWORD PTR _token$[ebp]
  00192	8b 55 f0	 mov	 edx, DWORD PTR _current$[ebp]
  00195	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  00198	89 41 3c	 mov	 DWORD PTR [ecx+60], eax

; 2217 :     token->custom                   = current->custom;

  0019b	8b 4d f4	 mov	 ecx, DWORD PTR _token$[ebp]
  0019e	8b 55 f0	 mov	 edx, DWORD PTR _current$[ebp]
  001a1	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  001a4	89 41 40	 mov	 DWORD PTR [ecx+64], eax

; 2218 :     token->lineStart                = current->lineStart;

  001a7	8b 4d f4	 mov	 ecx, DWORD PTR _token$[ebp]
  001aa	8b 55 f0	 mov	 edx, DWORD PTR _current$[ebp]
  001ad	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  001b0	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 2219 :     
; 2220 : 	// Create the token text that shows it has been inserted
; 2221 : 	//
; 2222 : 	token->setText8(token, (pANTLR3_UINT8)"<missing ");

  001b3	8b f4		 mov	 esi, esp
  001b5	68 00 00 00 00	 push	 OFFSET ??_C@_09MLMDPBIO@?$DMmissing?5@
  001ba	8b 4d f4	 mov	 ecx, DWORD PTR _token$[ebp]
  001bd	51		 push	 ecx
  001be	8b 55 f4	 mov	 edx, DWORD PTR _token$[ebp]
  001c1	8b 42 50	 mov	 eax, DWORD PTR [edx+80]
  001c4	ff d0		 call	 eax
  001c6	83 c4 08	 add	 esp, 8
  001c9	3b f4		 cmp	 esi, esp
  001cb	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2223 : 	text = token->getText(token);

  001d0	8b f4		 mov	 esi, esp
  001d2	8b 4d f4	 mov	 ecx, DWORD PTR _token$[ebp]
  001d5	51		 push	 ecx
  001d6	8b 55 f4	 mov	 edx, DWORD PTR _token$[ebp]
  001d9	8b 42 48	 mov	 eax, DWORD PTR [edx+72]
  001dc	ff d0		 call	 eax
  001de	83 c4 04	 add	 esp, 4
  001e1	3b f4		 cmp	 esi, esp
  001e3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001e8	89 45 ec	 mov	 DWORD PTR _text$[ebp], eax

; 2224 : 
; 2225 : 	if	(text != NULL)

  001eb	83 7d ec 00	 cmp	 DWORD PTR _text$[ebp], 0
  001ef	74 46		 je	 SHORT $LN5@getMissing

; 2226 : 	{
; 2227 : 		text->append8(text, (const char *)recognizer->state->tokenNames[expectedTokenType]);

  001f1	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  001f4	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  001f7	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  001fa	8b f4		 mov	 esi, esp
  001fc	8b 4d 14	 mov	 ecx, DWORD PTR _expectedTokenType$[ebp]
  001ff	8b 14 88	 mov	 edx, DWORD PTR [eax+ecx*4]
  00202	52		 push	 edx
  00203	8b 45 ec	 mov	 eax, DWORD PTR _text$[ebp]
  00206	50		 push	 eax
  00207	8b 4d ec	 mov	 ecx, DWORD PTR _text$[ebp]
  0020a	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  0020d	ff d2		 call	 edx
  0020f	83 c4 08	 add	 esp, 8
  00212	3b f4		 cmp	 esi, esp
  00214	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2228 : 		text->append8(text, (const char *)">");

  00219	8b f4		 mov	 esi, esp
  0021b	68 00 00 00 00	 push	 OFFSET ??_C@_01PPODPGHN@?$DO@
  00220	8b 45 ec	 mov	 eax, DWORD PTR _text$[ebp]
  00223	50		 push	 eax
  00224	8b 4d ec	 mov	 ecx, DWORD PTR _text$[ebp]
  00227	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  0022a	ff d2		 call	 edx
  0022c	83 c4 08	 add	 esp, 8
  0022f	3b f4		 cmp	 esi, esp
  00231	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00236	90		 npad	 1
$LN5@getMissing:

; 2229 : 	}
; 2230 : 	
; 2231 : 	// Finally return the pointer to our new token
; 2232 : 	//
; 2233 : 	return	token;

  00237	8b 45 f4	 mov	 eax, DWORD PTR _token$[ebp]
$LN1@getMissing:

; 2234 : }

  0023a	5e		 pop	 esi
  0023b	83 c4 14	 add	 esp, 20			; 00000014H
  0023e	3b ec		 cmp	 ebp, esp
  00240	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00245	8b e5		 mov	 esp, ebp
  00247	5d		 pop	 ebp
  00248	c3		 ret	 0
_getMissingSymbol ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3baserecognizer.c
;	COMDAT _getCurrentInputSymbol
_TEXT	SEGMENT
_recognizer$ = 8					; size = 4
_istream$ = 12						; size = 4
_getCurrentInputSymbol PROC				; COMDAT

; 2164 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2165 : 	return ((pANTLR3_TOKEN_STREAM)istream->super)->_LT((pANTLR3_TOKEN_STREAM)istream->super, 1);

  00004	8b f4		 mov	 esi, esp
  00006	6a 01		 push	 1
  00008	8b 45 0c	 mov	 eax, DWORD PTR _istream$[ebp]
  0000b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000e	51		 push	 ecx
  0000f	8b 55 0c	 mov	 edx, DWORD PTR _istream$[ebp]
  00012	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00015	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00018	ff d1		 call	 ecx
  0001a	83 c4 08	 add	 esp, 8
  0001d	3b f4		 cmp	 esi, esp
  0001f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2166 : }

  00024	5e		 pop	 esi
  00025	3b ec		 cmp	 ebp, esp
  00027	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
_getCurrentInputSymbol ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3baserecognizer.c
;	COMDAT _freeBR
_TEXT	SEGMENT
_thisE$ = -4						; size = 4
_recognizer$ = 8					; size = 4
_freeBR	PROC						; COMDAT

; 199  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 200  :     pANTLR3_EXCEPTION thisE;
; 201  : 
; 202  : 	// Did we have a state allocated?
; 203  : 	//
; 204  : 	if	(recognizer->state != NULL)

  0000c	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  0000f	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00013	0f 84 ea 00 00
	00		 je	 $LN2@freeBR

; 205  : 	{
; 206  : 		// Free any rule memoization we set up
; 207  : 		//
; 208  : 		if	(recognizer->state->ruleMemo != NULL)

  00019	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  0001c	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0001f	83 7a 24 00	 cmp	 DWORD PTR [edx+36], 0
  00023	74 31		 je	 SHORT $LN3@freeBR

; 209  : 		{
; 210  : 			recognizer->state->ruleMemo->free(recognizer->state->ruleMemo);

  00025	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  00028	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0002b	8b f4		 mov	 esi, esp
  0002d	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00030	52		 push	 edx
  00031	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  00034	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00037	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  0003a	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  0003d	ff d0		 call	 eax
  0003f	83 c4 04	 add	 esp, 4
  00042	3b f4		 cmp	 esi, esp
  00044	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 211  : 			recognizer->state->ruleMemo = NULL;

  00049	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  0004c	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0004f	c7 42 24 00 00
	00 00		 mov	 DWORD PTR [edx+36], 0
$LN3@freeBR:

; 212  : 		}
; 213  : 
; 214  : 		// Free any exception space we have left around
; 215  : 		//
; 216  : 		thisE = recognizer->state->exception;

  00056	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  00059	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0005c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0005f	89 55 fc	 mov	 DWORD PTR _thisE$[ebp], edx

; 217  : 		if	(thisE != NULL)

  00062	83 7d fc 00	 cmp	 DWORD PTR _thisE$[ebp], 0
  00066	74 19		 je	 SHORT $LN4@freeBR

; 218  : 		{
; 219  : 			thisE->freeEx(thisE);

  00068	8b f4		 mov	 esi, esp
  0006a	8b 45 fc	 mov	 eax, DWORD PTR _thisE$[ebp]
  0006d	50		 push	 eax
  0006e	8b 4d fc	 mov	 ecx, DWORD PTR _thisE$[ebp]
  00071	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  00074	ff d2		 call	 edx
  00076	83 c4 04	 add	 esp, 4
  00079	3b f4		 cmp	 esi, esp
  0007b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00080	90		 npad	 1
$LN4@freeBR:

; 220  : 		}
; 221  : 
; 222  : 		// Free any rewrite streams we have allocated
; 223  : 		//
; 224  : 		if	(recognizer->state->rStreams != NULL)

  00081	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  00084	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00087	83 79 68 00	 cmp	 DWORD PTR [ecx+104], 0
  0008b	74 28		 je	 SHORT $LN5@freeBR

; 225  : 		{
; 226  : 			recognizer->state->rStreams->free(recognizer->state->rStreams);

  0008d	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  00090	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00093	8b f4		 mov	 esi, esp
  00095	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  00098	51		 push	 ecx
  00099	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  0009c	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0009f	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  000a2	8b 91 90 00 00
	00		 mov	 edx, DWORD PTR [ecx+144]
  000a8	ff d2		 call	 edx
  000aa	83 c4 04	 add	 esp, 4
  000ad	3b f4		 cmp	 esi, esp
  000af	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b4	90		 npad	 1
$LN5@freeBR:

; 227  : 		}
; 228  : 
; 229  : 		// Free up any token factory we created (error recovery for instance)
; 230  : 		//
; 231  : 		if	(recognizer->state->tokFactory != NULL)

  000b5	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  000b8	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000bb	83 79 34 00	 cmp	 DWORD PTR [ecx+52], 0
  000bf	74 28		 je	 SHORT $LN6@freeBR

; 232  : 		{
; 233  : 			recognizer->state->tokFactory->close(recognizer->state->tokFactory);

  000c1	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  000c4	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000c7	8b f4		 mov	 esi, esp
  000c9	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  000cc	51		 push	 ecx
  000cd	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  000d0	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000d3	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  000d6	8b 91 b0 00 00
	00		 mov	 edx, DWORD PTR [ecx+176]
  000dc	ff d2		 call	 edx
  000de	83 c4 04	 add	 esp, 4
  000e1	3b f4		 cmp	 esi, esp
  000e3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e8	90		 npad	 1
$LN6@freeBR:

; 234  : 		}
; 235  : 		// Free the shared state memory
; 236  : 		//
; 237  : 		ANTLR3_FREE(recognizer->state);

  000e9	8b f4		 mov	 esi, esp
  000eb	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  000ee	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000f1	51		 push	 ecx
  000f2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  000f8	83 c4 04	 add	 esp, 4
  000fb	3b f4		 cmp	 esi, esp
  000fd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00102	90		 npad	 1
$LN2@freeBR:

; 238  : 	}
; 239  : 
; 240  : 	// Free the actual recognizer space
; 241  : 	//
; 242  :     ANTLR3_FREE(recognizer);

  00103	8b f4		 mov	 esi, esp
  00105	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  00108	52		 push	 edx
  00109	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0010f	83 c4 04	 add	 esp, 4
  00112	3b f4		 cmp	 esi, esp
  00114	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00119	90		 npad	 1

; 243  : }

  0011a	5e		 pop	 esi
  0011b	83 c4 04	 add	 esp, 4
  0011e	3b ec		 cmp	 ebp, esp
  00120	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00125	8b e5		 mov	 esp, ebp
  00127	5d		 pop	 ebp
  00128	c3		 ret	 0
_freeBR	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3baserecognizer.c
;	COMDAT _reset
_TEXT	SEGMENT
_thisE$ = -4						; size = 4
_recognizer$ = 8					; size = 4
_reset	PROC						; COMDAT

; 2121 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 2122 :     if	(recognizer->state->following != NULL)

  0000c	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  0000f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00012	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  00016	74 25		 je	 SHORT $LN2@reset

; 2123 :     {
; 2124 : 		recognizer->state->following->free(recognizer->state->following);

  00018	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  0001b	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0001e	8b f4		 mov	 esi, esp
  00020	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00023	51		 push	 ecx
  00024	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  00027	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0002a	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0002d	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00030	ff d2		 call	 edx
  00032	83 c4 04	 add	 esp, 4
  00035	3b f4		 cmp	 esi, esp
  00037	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003c	90		 npad	 1
$LN2@reset:

; 2125 :     }
; 2126 : 
; 2127 : 	// Reset the state flags
; 2128 : 	//
; 2129 : 	recognizer->state->errorRecovery	= ANTLR3_FALSE;

  0003d	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  00040	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00043	c6 41 10 00	 mov	 BYTE PTR [ecx+16], 0

; 2130 : 	recognizer->state->lastErrorIndex	= -1;

  00047	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  0004a	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0004d	c7 40 14 ff ff
	ff ff		 mov	 DWORD PTR [eax+20], -1

; 2131 : 	recognizer->state->failed			= ANTLR3_FALSE;

  00054	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  00057	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0005a	c6 42 18 00	 mov	 BYTE PTR [edx+24], 0

; 2132 : 	recognizer->state->errorCount		= 0;

  0005e	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  00061	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00064	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 2133 : 	recognizer->state->backtracking		= 0;

  0006b	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  0006e	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00071	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0

; 2134 : 	recognizer->state->following		= NULL;

  00078	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  0007b	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0007e	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0

; 2135 : 
; 2136 : 	if	(recognizer->state != NULL)

  00085	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  00088	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0008c	74 43		 je	 SHORT $LN4@reset

; 2137 : 	{
; 2138 : 		if	(recognizer->state->ruleMemo != NULL)

  0008e	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  00091	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00094	83 7a 24 00	 cmp	 DWORD PTR [edx+36], 0
  00098	74 37		 je	 SHORT $LN4@reset

; 2139 : 		{
; 2140 : 			recognizer->state->ruleMemo->free(recognizer->state->ruleMemo);

  0009a	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  0009d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000a0	8b f4		 mov	 esi, esp
  000a2	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  000a5	52		 push	 edx
  000a6	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  000a9	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000ac	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  000af	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  000b2	ff d0		 call	 eax
  000b4	83 c4 04	 add	 esp, 4
  000b7	3b f4		 cmp	 esi, esp
  000b9	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2141 : 			recognizer->state->ruleMemo = antlr3IntTrieNew(15);	/* 16 bit depth is enough for 32768 rules! */

  000be	6a 0f		 push	 15			; 0000000fH
  000c0	e8 00 00 00 00	 call	 _antlr3IntTrieNew
  000c5	83 c4 04	 add	 esp, 4
  000c8	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  000cb	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000ce	89 42 24	 mov	 DWORD PTR [edx+36], eax
$LN4@reset:

; 2142 : 		}
; 2143 : 	}
; 2144 : 	
; 2145 :   // ml: 2013-11-05, added reset of old exceptions.
; 2146 :   pANTLR3_EXCEPTION thisE = recognizer->state->exception;

  000d1	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  000d4	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000d7	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000da	89 55 fc	 mov	 DWORD PTR _thisE$[ebp], edx

; 2147 :   if	(thisE != NULL)

  000dd	83 7d fc 00	 cmp	 DWORD PTR _thisE$[ebp], 0
  000e1	74 25		 je	 SHORT $LN5@reset

; 2148 :   {
; 2149 :     thisE->freeEx(thisE);

  000e3	8b f4		 mov	 esi, esp
  000e5	8b 45 fc	 mov	 eax, DWORD PTR _thisE$[ebp]
  000e8	50		 push	 eax
  000e9	8b 4d fc	 mov	 ecx, DWORD PTR _thisE$[ebp]
  000ec	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  000ef	ff d2		 call	 edx
  000f1	83 c4 04	 add	 esp, 4
  000f4	3b f4		 cmp	 esi, esp
  000f6	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2150 :     recognizer->state->exception = NULL;

  000fb	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  000fe	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00101	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
$LN5@reset:

; 2151 :   }
; 2152 : 
; 2153 :     // Install a new following set
; 2154 :     //
; 2155 :     recognizer->state->following   = antlr3StackNew(8);

  00108	6a 08		 push	 8
  0010a	e8 00 00 00 00	 call	 _antlr3StackNew
  0010f	83 c4 04	 add	 esp, 4
  00112	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  00115	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  00118	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 2156 : 
; 2157 : }

  0011b	5e		 pop	 esi
  0011c	83 c4 04	 add	 esp, 4
  0011f	3b ec		 cmp	 ebp, esp
  00121	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00126	8b e5		 mov	 esp, ebp
  00128	5d		 pop	 ebp
  00129	c3		 ret	 0
_reset	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3baserecognizer.c
;	COMDAT _synpred
_TEXT	SEGMENT
tv65 = -20						; size = 4
_is$ = -16						; size = 4
_tparser$ = -12						; size = 4
_parser$ = -8						; size = 4
_start$ = -4						; size = 4
_recognizer$ = 8					; size = 4
_ctx$ = 12						; size = 4
_predicate$ = 16					; size = 4
_synpred PROC						; COMDAT

; 2056 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0000f	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00012	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00015	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00018	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 2057 :     ANTLR3_MARKER   start;
; 2058 :     pANTLR3_PARSER	    parser;
; 2059 :     pANTLR3_TREE_PARSER	    tparser;
; 2060 :     pANTLR3_INT_STREAM	    is;
; 2061 : 
; 2062 :     switch	(recognizer->type)

  0001b	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  0001e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00021	89 4d ec	 mov	 DWORD PTR tv65[ebp], ecx
  00024	83 7d ec 02	 cmp	 DWORD PTR tv65[ebp], 2
  00028	74 08		 je	 SHORT $LN4@synpred
  0002a	83 7d ec 04	 cmp	 DWORD PTR tv65[ebp], 4
  0002e	74 1f		 je	 SHORT $LN5@synpred
  00030	eb 3d		 jmp	 SHORT $LN6@synpred
$LN4@synpred:

; 2063 :     {
; 2064 : 		case	ANTLR3_TYPE_PARSER:
; 2065 : 
; 2066 : 			parser  = (pANTLR3_PARSER) (recognizer->super);

  00032	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  00035	8b 02		 mov	 eax, DWORD PTR [edx]
  00037	89 45 f8	 mov	 DWORD PTR _parser$[ebp], eax

; 2067 : 			tparser	= NULL;

  0003a	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _tparser$[ebp], 0

; 2068 : 			is	= parser->tstream->istream;

  00041	8b 4d f8	 mov	 ecx, DWORD PTR _parser$[ebp]
  00044	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00047	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0004a	89 45 f0	 mov	 DWORD PTR _is$[ebp], eax

; 2069 : 
; 2070 : 			break;

  0004d	eb 49		 jmp	 SHORT $LN2@synpred
$LN5@synpred:

; 2071 : 
; 2072 : 		case	ANTLR3_TYPE_TREE_PARSER:
; 2073 : 
; 2074 : 			tparser = (pANTLR3_TREE_PARSER) (recognizer->super);

  0004f	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  00052	8b 11		 mov	 edx, DWORD PTR [ecx]
  00054	89 55 f4	 mov	 DWORD PTR _tparser$[ebp], edx

; 2075 : 			parser	= NULL;

  00057	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _parser$[ebp], 0

; 2076 : 			is	= tparser->ctnstream->tnstream->istream;

  0005e	8b 45 f4	 mov	 eax, DWORD PTR _tparser$[ebp]
  00061	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00064	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00067	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0006a	89 45 f0	 mov	 DWORD PTR _is$[ebp], eax

; 2077 : 
; 2078 : 			break;

  0006d	eb 29		 jmp	 SHORT $LN2@synpred
$LN6@synpred:

; 2079 : 
; 2080 : 		default:
; 2081 : 		    
; 2082 : 			ANTLR3_FPRINTF(stderr, "Base recognizer function 'synPred' called by unknown parser type - provide override for this function\n");

  0006f	68 00 00 00 00	 push	 OFFSET ??_C@_0GH@CJOFJAFO@Base?5recognizer?5function?5?8synPr@
  00074	8b f4		 mov	 esi, esp
  00076	6a 02		 push	 2
  00078	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  0007e	83 c4 04	 add	 esp, 4
  00081	3b f4		 cmp	 esi, esp
  00083	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 _fprintf
  0008e	83 c4 08	 add	 esp, 8

; 2083 : 			return ANTLR3_FALSE;

  00091	32 c0		 xor	 al, al
  00093	e9 9f 00 00 00	 jmp	 $LN8@synpred
$LN2@synpred:

; 2084 : 
; 2085 : 			break;
; 2086 :     }
; 2087 : 
; 2088 :     /* Begin backtracking so we can get back to where we started after trying out
; 2089 :      * the syntactic predicate.
; 2090 :      */
; 2091 :     start   = is->mark(is);

  00098	8b f4		 mov	 esi, esp
  0009a	8b 4d f0	 mov	 ecx, DWORD PTR _is$[ebp]
  0009d	51		 push	 ecx
  0009e	8b 55 f0	 mov	 edx, DWORD PTR _is$[ebp]
  000a1	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  000a4	ff d0		 call	 eax
  000a6	83 c4 04	 add	 esp, 4
  000a9	3b f4		 cmp	 esi, esp
  000ab	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b0	89 45 fc	 mov	 DWORD PTR _start$[ebp], eax

; 2092 :     recognizer->state->backtracking++;

  000b3	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  000b6	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000b9	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  000bc	83 c0 01	 add	 eax, 1
  000bf	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  000c2	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000c5	89 42 20	 mov	 DWORD PTR [edx+32], eax

; 2093 : 
; 2094 :     /* Try the syntactical predicate
; 2095 :      */
; 2096 :     predicate(ctx);

  000c8	8b f4		 mov	 esi, esp
  000ca	8b 45 0c	 mov	 eax, DWORD PTR _ctx$[ebp]
  000cd	50		 push	 eax
  000ce	ff 55 10	 call	 DWORD PTR _predicate$[ebp]
  000d1	83 c4 04	 add	 esp, 4
  000d4	3b f4		 cmp	 esi, esp
  000d6	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2097 : 
; 2098 :     /* Reset
; 2099 :      */
; 2100 :     is->rewind(is, start);

  000db	8b f4		 mov	 esi, esp
  000dd	8b 4d fc	 mov	 ecx, DWORD PTR _start$[ebp]
  000e0	51		 push	 ecx
  000e1	8b 55 f0	 mov	 edx, DWORD PTR _is$[ebp]
  000e4	52		 push	 edx
  000e5	8b 45 f0	 mov	 eax, DWORD PTR _is$[ebp]
  000e8	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  000eb	ff d1		 call	 ecx
  000ed	83 c4 08	 add	 esp, 8
  000f0	3b f4		 cmp	 esi, esp
  000f2	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2101 :     recognizer->state->backtracking--;

  000f7	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  000fa	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000fd	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00100	83 e9 01	 sub	 ecx, 1
  00103	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  00106	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00109	89 48 20	 mov	 DWORD PTR [eax+32], ecx

; 2102 : 
; 2103 :     if	(recognizer->state->failed == ANTLR3_TRUE)

  0010c	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  0010f	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00112	0f b6 42 18	 movzx	 eax, BYTE PTR [edx+24]
  00116	83 f8 01	 cmp	 eax, 1
  00119	75 10		 jne	 SHORT $LN7@synpred

; 2104 :     {
; 2105 : 		/* Predicate failed
; 2106 : 		 */
; 2107 : 		recognizer->state->failed = ANTLR3_FALSE;

  0011b	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  0011e	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00121	c6 42 18 00	 mov	 BYTE PTR [edx+24], 0

; 2108 : 		return	ANTLR3_FALSE;

  00125	32 c0		 xor	 al, al
  00127	eb 0e		 jmp	 SHORT $LN8@synpred

; 2109 :     }

  00129	eb 0c		 jmp	 SHORT $LN8@synpred
$LN7@synpred:

; 2110 :     else
; 2111 :     {
; 2112 : 		/* Predicate was successful
; 2113 : 		 */
; 2114 : 		recognizer->state->failed	= ANTLR3_FALSE;

  0012b	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  0012e	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00131	c6 41 18 00	 mov	 BYTE PTR [ecx+24], 0

; 2115 : 		return	ANTLR3_TRUE;

  00135	b0 01		 mov	 al, 1
$LN8@synpred:

; 2116 :     }
; 2117 : }

  00137	5e		 pop	 esi
  00138	83 c4 14	 add	 esp, 20			; 00000014H
  0013b	3b ec		 cmp	 ebp, esp
  0013d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00142	8b e5		 mov	 esp, ebp
  00144	5d		 pop	 ebp
  00145	c3		 ret	 0
_synpred ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3baserecognizer.c
;	COMDAT _memoize
_TEXT	SEGMENT
tv91 = -36						; size = 4
tv65 = -32						; size = 4
_is$ = -28						; size = 4
_tparser$ = -24						; size = 4
_parser$ = -20						; size = 4
_lexer$ = -16						; size = 4
_stopIndex$ = -12					; size = 4
_entry$ = -8						; size = 4
_ruleList$ = -4						; size = 4
_recognizer$ = 8					; size = 4
_ruleIndex$ = 12					; size = 4
_ruleParseStart$ = 16					; size = 4
_memoize PROC						; COMDAT

; 1990 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 dc	 mov	 DWORD PTR [ebp-36], eax
  0000f	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  00012	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00015	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00018	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0001b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0001e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00021	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00024	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 1991 :     /* The rule memos are an ANTLR3_LIST of ANTLR3_LIST.
; 1992 :      */
; 1993 :     pANTLR3_INT_TRIE	    ruleList;
; 1994 :     pANTLR3_TRIE_ENTRY	    entry;
; 1995 :     ANTLR3_MARKER	    stopIndex;
; 1996 :     pANTLR3_LEXER	    lexer;
; 1997 :     pANTLR3_PARSER	    parser;
; 1998 :     pANTLR3_TREE_PARSER	    tparser;
; 1999 :     pANTLR3_INT_STREAM	    is;
; 2000 : 
; 2001 :     switch	(recognizer->type)

  00027	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  0002a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0002d	89 4d e0	 mov	 DWORD PTR tv65[ebp], ecx
  00030	83 7d e0 01	 cmp	 DWORD PTR tv65[ebp], 1
  00034	74 4b		 je	 SHORT $LN6@memoize
  00036	83 7d e0 02	 cmp	 DWORD PTR tv65[ebp], 2
  0003a	74 08		 je	 SHORT $LN4@memoize
  0003c	83 7d e0 04	 cmp	 DWORD PTR tv65[ebp], 4
  00040	74 1f		 je	 SHORT $LN5@memoize
  00042	eb 60		 jmp	 SHORT $LN7@memoize
$LN4@memoize:

; 2002 :     {
; 2003 : 		case	ANTLR3_TYPE_PARSER:
; 2004 : 
; 2005 : 			parser  = (pANTLR3_PARSER) (recognizer->super);

  00044	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  00047	8b 02		 mov	 eax, DWORD PTR [edx]
  00049	89 45 ec	 mov	 DWORD PTR _parser$[ebp], eax

; 2006 : 			tparser	= NULL;

  0004c	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _tparser$[ebp], 0

; 2007 : 			is	= parser->tstream->istream;

  00053	8b 4d ec	 mov	 ecx, DWORD PTR _parser$[ebp]
  00056	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00059	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0005c	89 45 e4	 mov	 DWORD PTR _is$[ebp], eax

; 2008 : 
; 2009 : 			break;

  0005f	eb 6a		 jmp	 SHORT $LN2@memoize
$LN5@memoize:

; 2010 : 
; 2011 : 		case	ANTLR3_TYPE_TREE_PARSER:
; 2012 : 
; 2013 : 			tparser = (pANTLR3_TREE_PARSER) (recognizer->super);

  00061	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  00064	8b 11		 mov	 edx, DWORD PTR [ecx]
  00066	89 55 e8	 mov	 DWORD PTR _tparser$[ebp], edx

; 2014 : 			parser	= NULL;

  00069	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _parser$[ebp], 0

; 2015 : 			is	= tparser->ctnstream->tnstream->istream;

  00070	8b 45 e8	 mov	 eax, DWORD PTR _tparser$[ebp]
  00073	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00076	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00079	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0007c	89 45 e4	 mov	 DWORD PTR _is$[ebp], eax

; 2016 : 
; 2017 : 			break;

  0007f	eb 4a		 jmp	 SHORT $LN2@memoize
$LN6@memoize:

; 2018 : 
; 2019 : 		case	ANTLR3_TYPE_LEXER:
; 2020 : 
; 2021 : 			lexer	= (pANTLR3_LEXER)   (recognizer->super);

  00081	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  00084	8b 11		 mov	 edx, DWORD PTR [ecx]
  00086	89 55 f0	 mov	 DWORD PTR _lexer$[ebp], edx

; 2022 : 			parser	= NULL;

  00089	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _parser$[ebp], 0

; 2023 : 			tparser	= NULL;

  00090	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _tparser$[ebp], 0

; 2024 : 			is		= lexer->input->istream;

  00097	8b 45 f0	 mov	 eax, DWORD PTR _lexer$[ebp]
  0009a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0009d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0009f	89 55 e4	 mov	 DWORD PTR _is$[ebp], edx

; 2025 : 			break;

  000a2	eb 27		 jmp	 SHORT $LN2@memoize
$LN7@memoize:

; 2026 : 
; 2027 : 		default:
; 2028 : 		    
; 2029 : 			ANTLR3_FPRINTF(stderr, "Base recognizer function consumeUntilSet called by unknown parser type - provide override for this function\n");

  000a4	68 00 00 00 00	 push	 OFFSET ??_C@_0GN@OCPDGBBI@Base?5recognizer?5function?5consum@
  000a9	8b f4		 mov	 esi, esp
  000ab	6a 02		 push	 2
  000ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  000b3	83 c4 04	 add	 esp, 4
  000b6	3b f4		 cmp	 esi, esp
  000b8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bd	50		 push	 eax
  000be	e8 00 00 00 00	 call	 _fprintf
  000c3	83 c4 08	 add	 esp, 8

; 2030 : 			return;

  000c6	e9 9d 00 00 00	 jmp	 $LN8@memoize
$LN2@memoize:

; 2031 : 
; 2032 : 			break;
; 2033 :     }
; 2034 :     
; 2035 :     stopIndex	= recognizer->state->failed == ANTLR3_TRUE ? MEMO_RULE_FAILED : is->index(is) - 1;

  000cb	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  000ce	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000d1	0f b6 51 18	 movzx	 edx, BYTE PTR [ecx+24]
  000d5	83 fa 01	 cmp	 edx, 1
  000d8	75 09		 jne	 SHORT $LN10@memoize
  000da	c7 45 dc fe ff
	ff ff		 mov	 DWORD PTR tv91[ebp], -2	; fffffffeH
  000e1	eb 1e		 jmp	 SHORT $LN11@memoize
$LN10@memoize:
  000e3	8b f4		 mov	 esi, esp
  000e5	8b 45 e4	 mov	 eax, DWORD PTR _is$[ebp]
  000e8	50		 push	 eax
  000e9	8b 4d e4	 mov	 ecx, DWORD PTR _is$[ebp]
  000ec	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  000ef	ff d2		 call	 edx
  000f1	83 c4 04	 add	 esp, 4
  000f4	3b f4		 cmp	 esi, esp
  000f6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000fb	83 e8 01	 sub	 eax, 1
  000fe	89 45 dc	 mov	 DWORD PTR tv91[ebp], eax
$LN11@memoize:
  00101	8b 45 dc	 mov	 eax, DWORD PTR tv91[ebp]
  00104	89 45 f4	 mov	 DWORD PTR _stopIndex$[ebp], eax

; 2036 : 
; 2037 :     entry	= recognizer->state->ruleMemo->get(recognizer->state->ruleMemo, (ANTLR3_INTKEY)ruleIndex);

  00107	8b f4		 mov	 esi, esp
  00109	8b 4d 0c	 mov	 ecx, DWORD PTR _ruleIndex$[ebp]
  0010c	51		 push	 ecx
  0010d	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  00110	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00113	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00116	51		 push	 ecx
  00117	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  0011a	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0011d	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00120	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00123	ff d2		 call	 edx
  00125	83 c4 08	 add	 esp, 8
  00128	3b f4		 cmp	 esi, esp
  0012a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0012f	89 45 f8	 mov	 DWORD PTR _entry$[ebp], eax

; 2038 : 
; 2039 :     if	(entry != NULL)

  00132	83 7d f8 00	 cmp	 DWORD PTR _entry$[ebp], 0
  00136	74 30		 je	 SHORT $LN8@memoize

; 2040 :     {
; 2041 : 		ruleList = (pANTLR3_INT_TRIE)(entry->data.ptr);

  00138	8b 45 f8	 mov	 eax, DWORD PTR _entry$[ebp]
  0013b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0013e	89 4d fc	 mov	 DWORD PTR _ruleList$[ebp], ecx

; 2042 : 
; 2043 : 		/* If we don't already have this entry, append it. The memoize trie does not
; 2044 : 		 * accept duplicates so it won't add it if already there and we just ignore the
; 2045 : 		 * return code as we don't care if it is there already.
; 2046 : 		 */
; 2047 : 		ruleList->add(ruleList, ruleParseStart, ANTLR3_HASH_TYPE_INT, stopIndex, NULL, NULL);

  00141	8b f4		 mov	 esi, esp
  00143	6a 00		 push	 0
  00145	6a 00		 push	 0
  00147	8b 55 f4	 mov	 edx, DWORD PTR _stopIndex$[ebp]
  0014a	52		 push	 edx
  0014b	6a 00		 push	 0
  0014d	8b 45 10	 mov	 eax, DWORD PTR _ruleParseStart$[ebp]
  00150	50		 push	 eax
  00151	8b 4d fc	 mov	 ecx, DWORD PTR _ruleList$[ebp]
  00154	51		 push	 ecx
  00155	8b 55 fc	 mov	 edx, DWORD PTR _ruleList$[ebp]
  00158	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0015b	ff d0		 call	 eax
  0015d	83 c4 18	 add	 esp, 24			; 00000018H
  00160	3b f4		 cmp	 esi, esp
  00162	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00167	90		 npad	 1
$LN8@memoize:

; 2048 :     }
; 2049 : }

  00168	5e		 pop	 esi
  00169	83 c4 24	 add	 esp, 36			; 00000024H
  0016c	3b ec		 cmp	 ebp, esp
  0016e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00173	8b e5		 mov	 esp, ebp
  00175	5d		 pop	 ebp
  00176	c3		 ret	 0
_memoize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3baserecognizer.c
;	COMDAT _alreadyParsedRule
_TEXT	SEGMENT
tv65 = -24						; size = 4
_is$ = -20						; size = 4
_tparser$ = -16						; size = 4
_parser$ = -12						; size = 4
_lexer$ = -8						; size = 4
_stopIndex$ = -4					; size = 4
_recognizer$ = 8					; size = 4
_ruleIndex$ = 12					; size = 4
_alreadyParsedRule PROC					; COMDAT

; 1919 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  0000f	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00012	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00015	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00018	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001b	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 1920 :     ANTLR3_MARKER			stopIndex;
; 1921 :     pANTLR3_LEXER			lexer;
; 1922 :     pANTLR3_PARSER			parser;
; 1923 :     pANTLR3_TREE_PARSER	    tparser;
; 1924 :     pANTLR3_INT_STREAM	    is;
; 1925 : 
; 1926 :     switch	(recognizer->type)

  0001e	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  00021	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00024	89 4d e8	 mov	 DWORD PTR tv65[ebp], ecx
  00027	83 7d e8 01	 cmp	 DWORD PTR tv65[ebp], 1
  0002b	74 59		 je	 SHORT $LN6@alreadyPar
  0002d	83 7d e8 02	 cmp	 DWORD PTR tv65[ebp], 2
  00031	74 08		 je	 SHORT $LN4@alreadyPar
  00033	83 7d e8 04	 cmp	 DWORD PTR tv65[ebp], 4
  00037	74 26		 je	 SHORT $LN5@alreadyPar
  00039	eb 6e		 jmp	 SHORT $LN7@alreadyPar
$LN4@alreadyPar:

; 1927 :     {
; 1928 : 		case	ANTLR3_TYPE_PARSER:
; 1929 : 
; 1930 : 			parser  = (pANTLR3_PARSER) (recognizer->super);

  0003b	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  0003e	8b 02		 mov	 eax, DWORD PTR [edx]
  00040	89 45 f4	 mov	 DWORD PTR _parser$[ebp], eax

; 1931 : 			tparser	= NULL;

  00043	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _tparser$[ebp], 0

; 1932 : 			lexer	= NULL;

  0004a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _lexer$[ebp], 0

; 1933 : 			is	= parser->tstream->istream;

  00051	8b 4d f4	 mov	 ecx, DWORD PTR _parser$[ebp]
  00054	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00057	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0005a	89 45 ec	 mov	 DWORD PTR _is$[ebp], eax

; 1934 : 
; 1935 : 			break;

  0005d	eb 70		 jmp	 SHORT $LN2@alreadyPar
$LN5@alreadyPar:

; 1936 : 
; 1937 : 		case	ANTLR3_TYPE_TREE_PARSER:
; 1938 : 
; 1939 : 			tparser = (pANTLR3_TREE_PARSER) (recognizer->super);

  0005f	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  00062	8b 11		 mov	 edx, DWORD PTR [ecx]
  00064	89 55 f0	 mov	 DWORD PTR _tparser$[ebp], edx

; 1940 : 			parser	= NULL;

  00067	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _parser$[ebp], 0

; 1941 : 			lexer	= NULL;

  0006e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _lexer$[ebp], 0

; 1942 : 			is	= tparser->ctnstream->tnstream->istream;

  00075	8b 45 f0	 mov	 eax, DWORD PTR _tparser$[ebp]
  00078	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0007b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0007e	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00081	89 45 ec	 mov	 DWORD PTR _is$[ebp], eax

; 1943 : 
; 1944 : 			break;

  00084	eb 49		 jmp	 SHORT $LN2@alreadyPar
$LN6@alreadyPar:

; 1945 : 
; 1946 : 		case	ANTLR3_TYPE_LEXER:
; 1947 : 
; 1948 : 			lexer	= (pANTLR3_LEXER)   (recognizer->super);

  00086	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  00089	8b 11		 mov	 edx, DWORD PTR [ecx]
  0008b	89 55 f8	 mov	 DWORD PTR _lexer$[ebp], edx

; 1949 : 			parser	= NULL;

  0008e	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _parser$[ebp], 0

; 1950 : 			tparser	= NULL;

  00095	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _tparser$[ebp], 0

; 1951 : 			is	= lexer->input->istream;

  0009c	8b 45 f8	 mov	 eax, DWORD PTR _lexer$[ebp]
  0009f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000a2	8b 11		 mov	 edx, DWORD PTR [ecx]
  000a4	89 55 ec	 mov	 DWORD PTR _is$[ebp], edx

; 1952 : 			break;

  000a7	eb 26		 jmp	 SHORT $LN2@alreadyPar
$LN7@alreadyPar:

; 1953 : 
; 1954 : 		default:
; 1955 : 		    
; 1956 : 			ANTLR3_FPRINTF(stderr, "Base recognizer function 'alreadyParsedRule' called by unknown parser type - provide override for this function\n");

  000a9	68 00 00 00 00	 push	 OFFSET ??_C@_0HB@KELCLOME@Base?5recognizer?5function?5?8alrea@
  000ae	8b f4		 mov	 esi, esp
  000b0	6a 02		 push	 2
  000b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  000b8	83 c4 04	 add	 esp, 4
  000bb	3b f4		 cmp	 esi, esp
  000bd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c2	50		 push	 eax
  000c3	e8 00 00 00 00	 call	 _fprintf
  000c8	83 c4 08	 add	 esp, 8

; 1957 : 			return ANTLR3_FALSE;

  000cb	32 c0		 xor	 al, al
  000cd	eb 76		 jmp	 SHORT $LN1@alreadyPar
$LN2@alreadyPar:

; 1958 : 
; 1959 : 			break;
; 1960 :     }
; 1961 : 
; 1962 :     /* See if we have a memo marker for this.
; 1963 :      */
; 1964 :     stopIndex	    = recognizer->getRuleMemoization(recognizer, ruleIndex, is->index(is));

  000cf	8b f4		 mov	 esi, esp
  000d1	8b 45 ec	 mov	 eax, DWORD PTR _is$[ebp]
  000d4	50		 push	 eax
  000d5	8b 4d ec	 mov	 ecx, DWORD PTR _is$[ebp]
  000d8	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  000db	ff d2		 call	 edx
  000dd	83 c4 04	 add	 esp, 4
  000e0	3b f4		 cmp	 esi, esp
  000e2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e7	8b f4		 mov	 esi, esp
  000e9	50		 push	 eax
  000ea	8b 45 0c	 mov	 eax, DWORD PTR _ruleIndex$[ebp]
  000ed	50		 push	 eax
  000ee	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  000f1	51		 push	 ecx
  000f2	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  000f5	8b 42 70	 mov	 eax, DWORD PTR [edx+112]
  000f8	ff d0		 call	 eax
  000fa	83 c4 0c	 add	 esp, 12			; 0000000cH
  000fd	3b f4		 cmp	 esi, esp
  000ff	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00104	89 45 fc	 mov	 DWORD PTR _stopIndex$[ebp], eax

; 1965 : 
; 1966 :     if	(stopIndex  == MEMO_RULE_UNKNOWN)

  00107	83 7d fc ff	 cmp	 DWORD PTR _stopIndex$[ebp], -1
  0010b	75 04		 jne	 SHORT $LN8@alreadyPar

; 1967 :     {
; 1968 : 		return ANTLR3_FALSE;

  0010d	32 c0		 xor	 al, al
  0010f	eb 34		 jmp	 SHORT $LN1@alreadyPar
$LN8@alreadyPar:

; 1969 :     }
; 1970 : 
; 1971 :     if	(stopIndex == MEMO_RULE_FAILED)

  00111	83 7d fc fe	 cmp	 DWORD PTR _stopIndex$[ebp], -2 ; fffffffeH
  00115	75 0c		 jne	 SHORT $LN9@alreadyPar

; 1972 :     {
; 1973 : 		recognizer->state->failed = ANTLR3_TRUE;

  00117	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  0011a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0011d	c6 42 18 01	 mov	 BYTE PTR [edx+24], 1

; 1974 :     }

  00121	eb 20		 jmp	 SHORT $LN10@alreadyPar
$LN9@alreadyPar:

; 1975 :     else
; 1976 :     {
; 1977 : 		is->seek(is, stopIndex+1);

  00123	8b 45 fc	 mov	 eax, DWORD PTR _stopIndex$[ebp]
  00126	83 c0 01	 add	 eax, 1
  00129	8b f4		 mov	 esi, esp
  0012b	50		 push	 eax
  0012c	8b 4d ec	 mov	 ecx, DWORD PTR _is$[ebp]
  0012f	51		 push	 ecx
  00130	8b 55 ec	 mov	 edx, DWORD PTR _is$[ebp]
  00133	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  00136	ff d0		 call	 eax
  00138	83 c4 08	 add	 esp, 8
  0013b	3b f4		 cmp	 esi, esp
  0013d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00142	90		 npad	 1
$LN10@alreadyPar:

; 1978 :     }
; 1979 : 
; 1980 :     /* If here then the rule was executed for this input already
; 1981 :      */
; 1982 :     return  ANTLR3_TRUE;

  00143	b0 01		 mov	 al, 1
$LN1@alreadyPar:

; 1983 : }

  00145	5e		 pop	 esi
  00146	83 c4 18	 add	 esp, 24			; 00000018H
  00149	3b ec		 cmp	 ebp, esp
  0014b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00150	8b e5		 mov	 esp, ebp
  00152	5d		 pop	 ebp
  00153	c3		 ret	 0
_alreadyParsedRule ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3baserecognizer.c
;	COMDAT _getRuleMemoization
_TEXT	SEGMENT
_entry$ = -12						; size = 4
_stopIndex$ = -8					; size = 4
_ruleList$ = -4						; size = 4
_recognizer$ = 8					; size = 4
_ruleIndex$ = 12					; size = 4
_ruleParseStart$ = 16					; size = 4
_getRuleMemoization PROC				; COMDAT

; 1856 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000e	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00015	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 1857 :     /* The rule memos are an ANTLR3_LIST of ANTLR3_LIST.
; 1858 :      */
; 1859 :     pANTLR3_INT_TRIE	ruleList;
; 1860 :     ANTLR3_MARKER	stopIndex;
; 1861 :     pANTLR3_TRIE_ENTRY	entry;
; 1862 : 
; 1863 :     /* See if we have a list in the ruleMemos for this rule, and if not, then create one
; 1864 :      * as we will need it eventually if we are being asked for the memo here.
; 1865 :      */
; 1866 :     entry	= recognizer->state->ruleMemo->get(recognizer->state->ruleMemo, (ANTLR3_INTKEY)ruleIndex);

  0001c	8b f4		 mov	 esi, esp
  0001e	8b 45 0c	 mov	 eax, DWORD PTR _ruleIndex$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  00025	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00028	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  0002b	50		 push	 eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  0002f	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00032	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00035	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00038	ff d1		 call	 ecx
  0003a	83 c4 08	 add	 esp, 8
  0003d	3b f4		 cmp	 esi, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	89 45 f4	 mov	 DWORD PTR _entry$[ebp], eax

; 1867 : 
; 1868 :     if	(entry == NULL)

  00047	83 7d f4 00	 cmp	 DWORD PTR _entry$[ebp], 0
  0004b	75 4e		 jne	 SHORT $LN2@getRuleMem

; 1869 :     {
; 1870 : 		/* Did not find it, so create a new one for it, with a bit depth based on the 
; 1871 : 		 * size of the input stream. We need the bit depth to incorporate the number if
; 1872 : 		 * bits required to represent the largest possible stop index in the input, which is the
; 1873 : 		 * last character. An int stream is free to return the largest 64 bit offset if it has
; 1874 : 		 * no idea of the size, but you should remember that this will cause the leftmost
; 1875 : 		 * bit match algorithm to run to 63 bits, which will be the whole time spent in the trie ;-)
; 1876 : 		 */
; 1877 : 		ruleList    = antlr3IntTrieNew(63);	/* Depth is theoretically 64 bits, but probably not ;-)	*/

  0004d	6a 3f		 push	 63			; 0000003fH
  0004f	e8 00 00 00 00	 call	 _antlr3IntTrieNew
  00054	83 c4 04	 add	 esp, 4
  00057	89 45 fc	 mov	 DWORD PTR _ruleList$[ebp], eax

; 1878 : 
; 1879 : 		if (ruleList != NULL)

  0005a	83 7d fc 00	 cmp	 DWORD PTR _ruleList$[ebp], 0
  0005e	74 36		 je	 SHORT $LN3@getRuleMem

; 1880 : 		{
; 1881 : 			recognizer->state->ruleMemo->add(recognizer->state->ruleMemo, (ANTLR3_INTKEY)ruleIndex, ANTLR3_HASH_TYPE_STR, 0, ANTLR3_FUNC_PTR(ruleList), freeIntTrie);

  00060	8b f4		 mov	 esi, esp
  00062	68 00 00 00 00	 push	 OFFSET _freeIntTrie
  00067	8b 55 fc	 mov	 edx, DWORD PTR _ruleList$[ebp]
  0006a	52		 push	 edx
  0006b	6a 00		 push	 0
  0006d	6a 01		 push	 1
  0006f	8b 45 0c	 mov	 eax, DWORD PTR _ruleIndex$[ebp]
  00072	50		 push	 eax
  00073	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  00076	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00079	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  0007c	50		 push	 eax
  0007d	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  00080	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00083	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00086	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00089	ff d1		 call	 ecx
  0008b	83 c4 18	 add	 esp, 24			; 00000018H
  0008e	3b f4		 cmp	 esi, esp
  00090	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00095	90		 npad	 1
$LN3@getRuleMem:

; 1882 : 		}
; 1883 : 
; 1884 : 		/* We cannot have a stopIndex in a trie we have just created of course
; 1885 : 		 */
; 1886 : 		return	MEMO_RULE_UNKNOWN;

  00096	83 c8 ff	 or	 eax, -1
  00099	eb 4c		 jmp	 SHORT $LN1@getRuleMem
$LN2@getRuleMem:

; 1887 :     }
; 1888 : 
; 1889 :     ruleList	= (pANTLR3_INT_TRIE) (entry->data.ptr);

  0009b	8b 55 f4	 mov	 edx, DWORD PTR _entry$[ebp]
  0009e	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000a1	89 45 fc	 mov	 DWORD PTR _ruleList$[ebp], eax

; 1890 : 
; 1891 :     /* See if there is a stop index associated with the supplied start index.
; 1892 :      */
; 1893 :     stopIndex	= 0;

  000a4	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _stopIndex$[ebp], 0

; 1894 : 
; 1895 :     entry = ruleList->get(ruleList, ruleParseStart);

  000ab	8b f4		 mov	 esi, esp
  000ad	8b 4d 10	 mov	 ecx, DWORD PTR _ruleParseStart$[ebp]
  000b0	51		 push	 ecx
  000b1	8b 55 fc	 mov	 edx, DWORD PTR _ruleList$[ebp]
  000b4	52		 push	 edx
  000b5	8b 45 fc	 mov	 eax, DWORD PTR _ruleList$[ebp]
  000b8	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  000bb	ff d1		 call	 ecx
  000bd	83 c4 08	 add	 esp, 8
  000c0	3b f4		 cmp	 esi, esp
  000c2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c7	89 45 f4	 mov	 DWORD PTR _entry$[ebp], eax

; 1896 :     if (entry != NULL)

  000ca	83 7d f4 00	 cmp	 DWORD PTR _entry$[ebp], 0
  000ce	74 09		 je	 SHORT $LN4@getRuleMem

; 1897 :     {
; 1898 : 		stopIndex = (ANTLR3_MARKER)(entry->data.intVal);

  000d0	8b 55 f4	 mov	 edx, DWORD PTR _entry$[ebp]
  000d3	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000d6	89 45 f8	 mov	 DWORD PTR _stopIndex$[ebp], eax
$LN4@getRuleMem:

; 1899 :     }
; 1900 : 
; 1901 :     if	(stopIndex == 0)

  000d9	83 7d f8 00	 cmp	 DWORD PTR _stopIndex$[ebp], 0
  000dd	75 05		 jne	 SHORT $LN5@getRuleMem

; 1902 :     {
; 1903 : 		return MEMO_RULE_UNKNOWN;

  000df	83 c8 ff	 or	 eax, -1
  000e2	eb 03		 jmp	 SHORT $LN1@getRuleMem
$LN5@getRuleMem:

; 1904 :     }
; 1905 : 
; 1906 :     return  stopIndex;

  000e4	8b 45 f8	 mov	 eax, DWORD PTR _stopIndex$[ebp]
$LN1@getRuleMem:

; 1907 : }

  000e7	5e		 pop	 esi
  000e8	83 c4 0c	 add	 esp, 12			; 0000000cH
  000eb	3b ec		 cmp	 ebp, esp
  000ed	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f2	8b e5		 mov	 esp, ebp
  000f4	5d		 pop	 ebp
  000f5	c3		 ret	 0
_getRuleMemoization ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3baserecognizer.c
;	COMDAT _toStrings
_TEXT	SEGMENT
_recognizer$ = 8					; size = 4
_tokens$ = 12						; size = 4
_toStrings PROC						; COMDAT

; 1833 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1834 :     return NULL;

  00003	33 c0		 xor	 eax, eax

; 1835 : }

  00005	5d		 pop	 ebp
  00006	c3		 ret	 0
_toStrings ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3baserecognizer.c
;	COMDAT _getRuleInvocationStackNamed
_TEXT	SEGMENT
_recognizer$ = 8					; size = 4
_name$ = 12						; size = 4
_getRuleInvocationStackNamed PROC			; COMDAT

; 1825 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1826 :     return NULL;

  00003	33 c0		 xor	 eax, eax

; 1827 : }

  00005	5d		 pop	 ebp
  00006	c3		 ret	 0
_getRuleInvocationStackNamed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3baserecognizer.c
;	COMDAT _getRuleInvocationStack
_TEXT	SEGMENT
_recognizer$ = 8					; size = 4
_getRuleInvocationStack PROC				; COMDAT

; 1819 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1820 :     return NULL;

  00003	33 c0		 xor	 eax, eax

; 1821 : }

  00005	5d		 pop	 ebp
  00006	c3		 ret	 0
_getRuleInvocationStack ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3baserecognizer.c
;	COMDAT _consumeUntilSet
_TEXT	SEGMENT
tv65 = -20						; size = 4
_is$ = -16						; size = 4
_tparser$ = -12						; size = 4
_parser$ = -8						; size = 4
_ttype$ = -4						; size = 4
_recognizer$ = 8					; size = 4
_set$ = 12						; size = 4
_consumeUntilSet PROC					; COMDAT

; 1767 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0000f	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00012	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00015	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00018	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 1768 :     ANTLR3_UINT32	    ttype;
; 1769 :     pANTLR3_PARSER	    parser;
; 1770 :     pANTLR3_TREE_PARSER	    tparser;
; 1771 :     pANTLR3_INT_STREAM	    is;
; 1772 : 
; 1773 :     switch	(recognizer->type)

  0001b	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  0001e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00021	89 4d ec	 mov	 DWORD PTR tv65[ebp], ecx
  00024	83 7d ec 02	 cmp	 DWORD PTR tv65[ebp], 2
  00028	74 08		 je	 SHORT $LN6@consumeUnt
  0002a	83 7d ec 04	 cmp	 DWORD PTR tv65[ebp], 4
  0002e	74 1f		 je	 SHORT $LN7@consumeUnt
  00030	eb 3d		 jmp	 SHORT $LN8@consumeUnt
$LN6@consumeUnt:

; 1774 :     {
; 1775 : 		case	ANTLR3_TYPE_PARSER:
; 1776 : 
; 1777 : 			parser  = (pANTLR3_PARSER) (recognizer->super);

  00032	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  00035	8b 02		 mov	 eax, DWORD PTR [edx]
  00037	89 45 f8	 mov	 DWORD PTR _parser$[ebp], eax

; 1778 : 			tparser	= NULL;

  0003a	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _tparser$[ebp], 0

; 1779 : 			is	= parser->tstream->istream;

  00041	8b 4d f8	 mov	 ecx, DWORD PTR _parser$[ebp]
  00044	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00047	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0004a	89 45 f0	 mov	 DWORD PTR _is$[ebp], eax

; 1780 : 
; 1781 : 			break;

  0004d	eb 44		 jmp	 SHORT $LN2@consumeUnt
$LN7@consumeUnt:

; 1782 : 
; 1783 : 		case	ANTLR3_TYPE_TREE_PARSER:
; 1784 : 
; 1785 : 			tparser = (pANTLR3_TREE_PARSER) (recognizer->super);

  0004f	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  00052	8b 11		 mov	 edx, DWORD PTR [ecx]
  00054	89 55 f4	 mov	 DWORD PTR _tparser$[ebp], edx

; 1786 : 			parser	= NULL;

  00057	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _parser$[ebp], 0

; 1787 : 			is	= tparser->ctnstream->tnstream->istream;

  0005e	8b 45 f4	 mov	 eax, DWORD PTR _tparser$[ebp]
  00061	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00064	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00067	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0006a	89 45 f0	 mov	 DWORD PTR _is$[ebp], eax

; 1788 : 
; 1789 : 			break;

  0006d	eb 24		 jmp	 SHORT $LN2@consumeUnt
$LN8@consumeUnt:

; 1790 : 
; 1791 : 		default:
; 1792 : 		    
; 1793 : 			ANTLR3_FPRINTF(stderr, "Base recognizer function 'consumeUntilSet' called by unknown parser type - provide override for this function\n");

  0006f	68 00 00 00 00	 push	 OFFSET ??_C@_0GP@DAFOBMIL@Base?5recognizer?5function?5?8consu@
  00074	8b f4		 mov	 esi, esp
  00076	6a 02		 push	 2
  00078	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  0007e	83 c4 04	 add	 esp, 4
  00081	3b f4		 cmp	 esi, esp
  00083	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 _fprintf
  0008e	83 c4 08	 add	 esp, 8

; 1794 : 			return;

  00091	eb 7d		 jmp	 SHORT $LN5@consumeUnt
$LN2@consumeUnt:

; 1795 : 
; 1796 : 			break;
; 1797 :     }
; 1798 : 
; 1799 :     // What do have at the moment?
; 1800 :     //
; 1801 :     ttype	= is->_LA(is, 1);

  00093	8b f4		 mov	 esi, esp
  00095	6a 01		 push	 1
  00097	8b 4d f0	 mov	 ecx, DWORD PTR _is$[ebp]
  0009a	51		 push	 ecx
  0009b	8b 55 f0	 mov	 edx, DWORD PTR _is$[ebp]
  0009e	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  000a1	ff d0		 call	 eax
  000a3	83 c4 08	 add	 esp, 8
  000a6	3b f4		 cmp	 esi, esp
  000a8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ad	89 45 fc	 mov	 DWORD PTR _ttype$[ebp], eax
$LN4@consumeUnt:

; 1802 : 
; 1803 :     // Start eating tokens until we get to one we want.
; 1804 :     //
; 1805 :     while   (ttype != ANTLR3_TOKEN_EOF && set->isMember(set, ttype) == ANTLR3_FALSE)

  000b0	83 7d fc ff	 cmp	 DWORD PTR _ttype$[ebp], -1
  000b4	74 5a		 je	 SHORT $LN5@consumeUnt
  000b6	8b f4		 mov	 esi, esp
  000b8	8b 4d fc	 mov	 ecx, DWORD PTR _ttype$[ebp]
  000bb	51		 push	 ecx
  000bc	8b 55 0c	 mov	 edx, DWORD PTR _set$[ebp]
  000bf	52		 push	 edx
  000c0	8b 45 0c	 mov	 eax, DWORD PTR _set$[ebp]
  000c3	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  000c6	ff d1		 call	 ecx
  000c8	83 c4 08	 add	 esp, 8
  000cb	3b f4		 cmp	 esi, esp
  000cd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d2	0f b6 d0	 movzx	 edx, al
  000d5	85 d2		 test	 edx, edx
  000d7	75 37		 jne	 SHORT $LN5@consumeUnt

; 1806 :     {
; 1807 : 		is->consume(is);

  000d9	8b f4		 mov	 esi, esp
  000db	8b 45 f0	 mov	 eax, DWORD PTR _is$[ebp]
  000de	50		 push	 eax
  000df	8b 4d f0	 mov	 ecx, DWORD PTR _is$[ebp]
  000e2	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  000e5	ff d2		 call	 edx
  000e7	83 c4 04	 add	 esp, 4
  000ea	3b f4		 cmp	 esi, esp
  000ec	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1808 : 		ttype	= is->_LA(is, 1);

  000f1	8b f4		 mov	 esi, esp
  000f3	6a 01		 push	 1
  000f5	8b 45 f0	 mov	 eax, DWORD PTR _is$[ebp]
  000f8	50		 push	 eax
  000f9	8b 4d f0	 mov	 ecx, DWORD PTR _is$[ebp]
  000fc	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  000ff	ff d2		 call	 edx
  00101	83 c4 08	 add	 esp, 8
  00104	3b f4		 cmp	 esi, esp
  00106	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0010b	89 45 fc	 mov	 DWORD PTR _ttype$[ebp], eax

; 1809 :     }

  0010e	eb a0		 jmp	 SHORT $LN4@consumeUnt
$LN5@consumeUnt:

; 1810 : }

  00110	5e		 pop	 esi
  00111	83 c4 14	 add	 esp, 20			; 00000014H
  00114	3b ec		 cmp	 ebp, esp
  00116	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0011b	8b e5		 mov	 esp, ebp
  0011d	5d		 pop	 ebp
  0011e	c3		 ret	 0
_consumeUntilSet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3baserecognizer.c
;	COMDAT _consumeUntil
_TEXT	SEGMENT
tv65 = -20						; size = 4
_is$ = -16						; size = 4
_tparser$ = -12						; size = 4
_parser$ = -8						; size = 4
_ttype$ = -4						; size = 4
_recognizer$ = 8					; size = 4
_tokenType$ = 12					; size = 4
_consumeUntil PROC					; COMDAT

; 1717 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0000f	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00012	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00015	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00018	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 1718 :     ANTLR3_UINT32			ttype;
; 1719 :     pANTLR3_PARSER			parser;
; 1720 :     pANTLR3_TREE_PARSER	    tparser;
; 1721 :     pANTLR3_INT_STREAM	    is;
; 1722 : 
; 1723 :     switch	(recognizer->type)

  0001b	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  0001e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00021	89 4d ec	 mov	 DWORD PTR tv65[ebp], ecx
  00024	83 7d ec 02	 cmp	 DWORD PTR tv65[ebp], 2
  00028	74 08		 je	 SHORT $LN6@consumeUnt
  0002a	83 7d ec 04	 cmp	 DWORD PTR tv65[ebp], 4
  0002e	74 1f		 je	 SHORT $LN7@consumeUnt
  00030	eb 3d		 jmp	 SHORT $LN8@consumeUnt
$LN6@consumeUnt:

; 1724 :     {
; 1725 : 		case	ANTLR3_TYPE_PARSER:
; 1726 : 
; 1727 : 			parser  = (pANTLR3_PARSER) (recognizer->super);

  00032	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  00035	8b 02		 mov	 eax, DWORD PTR [edx]
  00037	89 45 f8	 mov	 DWORD PTR _parser$[ebp], eax

; 1728 : 			tparser	= NULL;

  0003a	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _tparser$[ebp], 0

; 1729 : 			is	= parser->tstream->istream;

  00041	8b 4d f8	 mov	 ecx, DWORD PTR _parser$[ebp]
  00044	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00047	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0004a	89 45 f0	 mov	 DWORD PTR _is$[ebp], eax

; 1730 : 
; 1731 : 			break;

  0004d	eb 44		 jmp	 SHORT $LN2@consumeUnt
$LN7@consumeUnt:

; 1732 : 
; 1733 : 		case	ANTLR3_TYPE_TREE_PARSER:
; 1734 : 
; 1735 : 			tparser = (pANTLR3_TREE_PARSER) (recognizer->super);

  0004f	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  00052	8b 11		 mov	 edx, DWORD PTR [ecx]
  00054	89 55 f4	 mov	 DWORD PTR _tparser$[ebp], edx

; 1736 : 			parser	= NULL;

  00057	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _parser$[ebp], 0

; 1737 : 			is	= tparser->ctnstream->tnstream->istream;

  0005e	8b 45 f4	 mov	 eax, DWORD PTR _tparser$[ebp]
  00061	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00064	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00067	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0006a	89 45 f0	 mov	 DWORD PTR _is$[ebp], eax

; 1738 : 
; 1739 : 			break;

  0006d	eb 24		 jmp	 SHORT $LN2@consumeUnt
$LN8@consumeUnt:

; 1740 : 
; 1741 : 		default:
; 1742 : 		    
; 1743 : 			ANTLR3_FPRINTF(stderr, "Base recognizer function 'consumeUntil' called by unknown parser type - provide override for this function\n");

  0006f	68 00 00 00 00	 push	 OFFSET ??_C@_0GM@GBPBPFEJ@Base?5recognizer?5function?5?8consu@
  00074	8b f4		 mov	 esi, esp
  00076	6a 02		 push	 2
  00078	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  0007e	83 c4 04	 add	 esp, 4
  00081	3b f4		 cmp	 esi, esp
  00083	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 _fprintf
  0008e	83 c4 08	 add	 esp, 8

; 1744 : 			return;

  00091	eb 62		 jmp	 SHORT $LN5@consumeUnt
$LN2@consumeUnt:

; 1745 : 
; 1746 : 			break;
; 1747 :     }
; 1748 : 
; 1749 :     // What do have at the moment?
; 1750 :     //
; 1751 :     ttype	= is->_LA(is, 1);

  00093	8b f4		 mov	 esi, esp
  00095	6a 01		 push	 1
  00097	8b 4d f0	 mov	 ecx, DWORD PTR _is$[ebp]
  0009a	51		 push	 ecx
  0009b	8b 55 f0	 mov	 edx, DWORD PTR _is$[ebp]
  0009e	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  000a1	ff d0		 call	 eax
  000a3	83 c4 08	 add	 esp, 8
  000a6	3b f4		 cmp	 esi, esp
  000a8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ad	89 45 fc	 mov	 DWORD PTR _ttype$[ebp], eax
$LN4@consumeUnt:

; 1752 : 
; 1753 :     // Start eating tokens until we get to the one we want.
; 1754 :     //
; 1755 :     while   (ttype != ANTLR3_TOKEN_EOF && ttype != tokenType)

  000b0	83 7d fc ff	 cmp	 DWORD PTR _ttype$[ebp], -1
  000b4	74 3f		 je	 SHORT $LN5@consumeUnt
  000b6	8b 4d fc	 mov	 ecx, DWORD PTR _ttype$[ebp]
  000b9	3b 4d 0c	 cmp	 ecx, DWORD PTR _tokenType$[ebp]
  000bc	74 37		 je	 SHORT $LN5@consumeUnt

; 1756 :     {
; 1757 : 		is->consume(is);

  000be	8b f4		 mov	 esi, esp
  000c0	8b 55 f0	 mov	 edx, DWORD PTR _is$[ebp]
  000c3	52		 push	 edx
  000c4	8b 45 f0	 mov	 eax, DWORD PTR _is$[ebp]
  000c7	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000ca	ff d1		 call	 ecx
  000cc	83 c4 04	 add	 esp, 4
  000cf	3b f4		 cmp	 esi, esp
  000d1	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1758 : 		ttype	= is->_LA(is, 1);

  000d6	8b f4		 mov	 esi, esp
  000d8	6a 01		 push	 1
  000da	8b 55 f0	 mov	 edx, DWORD PTR _is$[ebp]
  000dd	52		 push	 edx
  000de	8b 45 f0	 mov	 eax, DWORD PTR _is$[ebp]
  000e1	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000e4	ff d1		 call	 ecx
  000e6	83 c4 08	 add	 esp, 8
  000e9	3b f4		 cmp	 esi, esp
  000eb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f0	89 45 fc	 mov	 DWORD PTR _ttype$[ebp], eax

; 1759 :     }

  000f3	eb bb		 jmp	 SHORT $LN4@consumeUnt
$LN5@consumeUnt:

; 1760 : }

  000f5	5e		 pop	 esi
  000f6	83 c4 14	 add	 esp, 20			; 00000014H
  000f9	3b ec		 cmp	 ebp, esp
  000fb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00100	8b e5		 mov	 esp, ebp
  00102	5d		 pop	 ebp
  00103	c3		 ret	 0
_consumeUntil ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3baserecognizer.c
;	COMDAT _recoverFromMismatchedElement
_TEXT	SEGMENT
tv65 = -24						; size = 4
_is$ = -20						; size = 4
_tparser$ = -16						; size = 4
_parser$ = -12						; size = 4
_follow$ = -8						; size = 4
_viableToksFollowingRule$ = -4				; size = 4
_recognizer$ = 8					; size = 4
_followBits$ = 12					; size = 4
_recoverFromMismatchedElement PROC			; COMDAT

; 1620 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  0000f	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00012	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00015	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00018	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001b	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 1621 :     pANTLR3_BITSET	    viableToksFollowingRule;
; 1622 :     pANTLR3_BITSET	    follow;
; 1623 :     pANTLR3_PARSER	    parser;
; 1624 :     pANTLR3_TREE_PARSER	    tparser;
; 1625 :     pANTLR3_INT_STREAM	    is;
; 1626 : 
; 1627 :     switch	(recognizer->type)

  0001e	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  00021	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00024	89 4d e8	 mov	 DWORD PTR tv65[ebp], ecx
  00027	83 7d e8 02	 cmp	 DWORD PTR tv65[ebp], 2
  0002b	74 08		 je	 SHORT $LN4@recoverFro
  0002d	83 7d e8 04	 cmp	 DWORD PTR tv65[ebp], 4
  00031	74 1f		 je	 SHORT $LN5@recoverFro
  00033	eb 3d		 jmp	 SHORT $LN6@recoverFro
$LN4@recoverFro:

; 1628 :     {
; 1629 :     case	ANTLR3_TYPE_PARSER:
; 1630 : 
; 1631 : 		parser  = (pANTLR3_PARSER) (recognizer->super);

  00035	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  00038	8b 02		 mov	 eax, DWORD PTR [edx]
  0003a	89 45 f4	 mov	 DWORD PTR _parser$[ebp], eax

; 1632 : 		tparser	= NULL;

  0003d	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _tparser$[ebp], 0

; 1633 : 		is	= parser->tstream->istream;

  00044	8b 4d f4	 mov	 ecx, DWORD PTR _parser$[ebp]
  00047	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0004a	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0004d	89 45 ec	 mov	 DWORD PTR _is$[ebp], eax

; 1634 : 
; 1635 : 	break;

  00050	eb 49		 jmp	 SHORT $LN2@recoverFro
$LN5@recoverFro:

; 1636 : 
; 1637 :     case	ANTLR3_TYPE_TREE_PARSER:
; 1638 : 
; 1639 : 		tparser = (pANTLR3_TREE_PARSER) (recognizer->super);

  00052	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  00055	8b 11		 mov	 edx, DWORD PTR [ecx]
  00057	89 55 f0	 mov	 DWORD PTR _tparser$[ebp], edx

; 1640 : 		parser	= NULL;

  0005a	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _parser$[ebp], 0

; 1641 : 		is	= tparser->ctnstream->tnstream->istream;

  00061	8b 45 f0	 mov	 eax, DWORD PTR _tparser$[ebp]
  00064	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00067	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0006a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0006d	89 45 ec	 mov	 DWORD PTR _is$[ebp], eax

; 1642 : 
; 1643 : 	break;

  00070	eb 29		 jmp	 SHORT $LN2@recoverFro
$LN6@recoverFro:

; 1644 : 
; 1645 :     default:
; 1646 : 	    
; 1647 : 		ANTLR3_FPRINTF(stderr, "Base recognizer function recover called by unknown parser type - provide override for this function\n");

  00072	68 00 00 00 00	 push	 OFFSET ??_C@_0GF@LHIHPDDL@Base?5recognizer?5function?5recove@
  00077	8b f4		 mov	 esi, esp
  00079	6a 02		 push	 2
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  00081	83 c4 04	 add	 esp, 4
  00084	3b f4		 cmp	 esi, esp
  00086	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008b	50		 push	 eax
  0008c	e8 00 00 00 00	 call	 _fprintf
  00091	83 c4 08	 add	 esp, 8

; 1648 : 		return ANTLR3_FALSE;

  00094	32 c0		 xor	 al, al
  00096	e9 36 01 00 00	 jmp	 $LN1@recoverFro
$LN2@recoverFro:

; 1649 : 
; 1650 : 	break;
; 1651 :     }
; 1652 : 
; 1653 :     follow	= antlr3BitsetLoad(followBits);

  0009b	8b 4d 0c	 mov	 ecx, DWORD PTR _followBits$[ebp]
  0009e	51		 push	 ecx
  0009f	e8 00 00 00 00	 call	 _antlr3BitsetLoad
  000a4	83 c4 04	 add	 esp, 4
  000a7	89 45 f8	 mov	 DWORD PTR _follow$[ebp], eax

; 1654 : 
; 1655 :     if	(follow == NULL)

  000aa	83 7d f8 00	 cmp	 DWORD PTR _follow$[ebp], 0
  000ae	75 07		 jne	 SHORT $LN7@recoverFro

; 1656 :     {
; 1657 : 		/* The follow set is NULL, which means we don't know what can come 
; 1658 : 		 * next, so we "hit and hope" by just signifying that we cannot
; 1659 : 		 * recover, which will just cause the next token to be consumed,
; 1660 : 		 * which might dig us out.
; 1661 : 		 */
; 1662 : 		return	ANTLR3_FALSE;

  000b0	32 c0		 xor	 al, al
  000b2	e9 1a 01 00 00	 jmp	 $LN1@recoverFro
$LN7@recoverFro:

; 1663 :     }
; 1664 : 
; 1665 :     /* We have a bitmap for the follow set, hence we can compute 
; 1666 :      * what can follow this grammar element reference.
; 1667 :      */
; 1668 :     if	(follow->isMember(follow, ANTLR3_EOR_TOKEN_TYPE) == ANTLR3_TRUE)

  000b7	8b f4		 mov	 esi, esp
  000b9	6a 01		 push	 1
  000bb	8b 55 f8	 mov	 edx, DWORD PTR _follow$[ebp]
  000be	52		 push	 edx
  000bf	8b 45 f8	 mov	 eax, DWORD PTR _follow$[ebp]
  000c2	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  000c5	ff d1		 call	 ecx
  000c7	83 c4 08	 add	 esp, 8
  000ca	3b f4		 cmp	 esi, esp
  000cc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d1	0f b6 d0	 movzx	 edx, al
  000d4	83 fa 01	 cmp	 edx, 1
  000d7	75 4e		 jne	 SHORT $LN8@recoverFro

; 1669 :     {
; 1670 : 		/* First we need to know which of the available tokens are viable
; 1671 : 		 * to follow this reference.
; 1672 : 		 */
; 1673 : 		viableToksFollowingRule	= recognizer->computeCSRuleFollow(recognizer);

  000d9	8b f4		 mov	 esi, esp
  000db	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  000de	50		 push	 eax
  000df	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  000e2	8b 51 48	 mov	 edx, DWORD PTR [ecx+72]
  000e5	ff d2		 call	 edx
  000e7	83 c4 04	 add	 esp, 4
  000ea	3b f4		 cmp	 esi, esp
  000ec	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f1	89 45 fc	 mov	 DWORD PTR _viableToksFollowingRule$[ebp], eax

; 1674 : 
; 1675 : 		/* Remove the EOR token, which we do not wish to compute with
; 1676 : 		 */
; 1677 : 		follow->remove(follow, ANTLR3_EOR_TOKEN_TYPE);

  000f4	8b f4		 mov	 esi, esp
  000f6	6a 01		 push	 1
  000f8	8b 45 f8	 mov	 eax, DWORD PTR _follow$[ebp]
  000fb	50		 push	 eax
  000fc	8b 4d f8	 mov	 ecx, DWORD PTR _follow$[ebp]
  000ff	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00102	ff d2		 call	 edx
  00104	83 c4 08	 add	 esp, 8
  00107	3b f4		 cmp	 esi, esp
  00109	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1678 : 		viableToksFollowingRule->free(viableToksFollowingRule);

  0010e	8b f4		 mov	 esi, esp
  00110	8b 45 fc	 mov	 eax, DWORD PTR _viableToksFollowingRule$[ebp]
  00113	50		 push	 eax
  00114	8b 4d fc	 mov	 ecx, DWORD PTR _viableToksFollowingRule$[ebp]
  00117	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  0011a	ff d2		 call	 edx
  0011c	83 c4 04	 add	 esp, 4
  0011f	3b f4		 cmp	 esi, esp
  00121	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00126	90		 npad	 1
$LN8@recoverFro:

; 1679 : 		/* We now have the computed set of what can follow the current token
; 1680 : 		 */
; 1681 :     }
; 1682 : 
; 1683 :     /* We can now see if the current token works with the set of tokens
; 1684 :      * that could follow the current grammar reference. If it looks like it
; 1685 :      * is consistent, then we can "insert" that token by not throwing
; 1686 :      * an exception and assuming that we saw it. 
; 1687 :      */
; 1688 :     if	( follow->isMember(follow, is->_LA(is, 1)) == ANTLR3_TRUE)

  00127	8b f4		 mov	 esi, esp
  00129	6a 01		 push	 1
  0012b	8b 45 ec	 mov	 eax, DWORD PTR _is$[ebp]
  0012e	50		 push	 eax
  0012f	8b 4d ec	 mov	 ecx, DWORD PTR _is$[ebp]
  00132	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00135	ff d2		 call	 edx
  00137	83 c4 08	 add	 esp, 8
  0013a	3b f4		 cmp	 esi, esp
  0013c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00141	8b f4		 mov	 esi, esp
  00143	50		 push	 eax
  00144	8b 45 f8	 mov	 eax, DWORD PTR _follow$[ebp]
  00147	50		 push	 eax
  00148	8b 4d f8	 mov	 ecx, DWORD PTR _follow$[ebp]
  0014b	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  0014e	ff d2		 call	 edx
  00150	83 c4 08	 add	 esp, 8
  00153	3b f4		 cmp	 esi, esp
  00155	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0015a	0f b6 c0	 movzx	 eax, al
  0015d	83 f8 01	 cmp	 eax, 1
  00160	75 4e		 jne	 SHORT $LN9@recoverFro

; 1689 :     {
; 1690 : 		/* report the error, but don't cause any rules to abort and stuff
; 1691 : 		 */
; 1692 : 		recognizer->reportError(recognizer);

  00162	8b f4		 mov	 esi, esp
  00164	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  00167	51		 push	 ecx
  00168	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  0016b	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  0016e	ff d0		 call	 eax
  00170	83 c4 04	 add	 esp, 4
  00173	3b f4		 cmp	 esi, esp
  00175	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1693 : 		if	(follow != NULL)

  0017a	83 7d f8 00	 cmp	 DWORD PTR _follow$[ebp], 0
  0017e	74 19		 je	 SHORT $LN10@recoverFro

; 1694 : 		{
; 1695 : 			follow->free(follow);

  00180	8b f4		 mov	 esi, esp
  00182	8b 4d f8	 mov	 ecx, DWORD PTR _follow$[ebp]
  00185	51		 push	 ecx
  00186	8b 55 f8	 mov	 edx, DWORD PTR _follow$[ebp]
  00189	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  0018c	ff d0		 call	 eax
  0018e	83 c4 04	 add	 esp, 4
  00191	3b f4		 cmp	 esi, esp
  00193	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00198	90		 npad	 1
$LN10@recoverFro:

; 1696 : 		}
; 1697 : 		recognizer->state->error			= ANTLR3_FALSE;

  00199	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  0019c	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0019f	c6 02 00	 mov	 BYTE PTR [edx], 0

; 1698 : 		recognizer->state->failed			= ANTLR3_FALSE;

  001a2	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  001a5	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001a8	c6 41 18 00	 mov	 BYTE PTR [ecx+24], 0

; 1699 : 		return ANTLR3_TRUE;	/* Success in recovery	*/

  001ac	b0 01		 mov	 al, 1
  001ae	eb 21		 jmp	 SHORT $LN1@recoverFro
$LN9@recoverFro:

; 1700 :     }
; 1701 : 
; 1702 :     if	(follow != NULL)

  001b0	83 7d f8 00	 cmp	 DWORD PTR _follow$[ebp], 0
  001b4	74 19		 je	 SHORT $LN11@recoverFro

; 1703 :     {
; 1704 : 		follow->free(follow);

  001b6	8b f4		 mov	 esi, esp
  001b8	8b 55 f8	 mov	 edx, DWORD PTR _follow$[ebp]
  001bb	52		 push	 edx
  001bc	8b 45 f8	 mov	 eax, DWORD PTR _follow$[ebp]
  001bf	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  001c2	ff d1		 call	 ecx
  001c4	83 c4 04	 add	 esp, 4
  001c7	3b f4		 cmp	 esi, esp
  001c9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001ce	90		 npad	 1
$LN11@recoverFro:

; 1705 :     }
; 1706 : 
; 1707 :     /* We could not find anything viable to do, so this is going to 
; 1708 :      * cause an exception.
; 1709 :      */
; 1710 :     return  ANTLR3_FALSE;

  001cf	32 c0		 xor	 al, al
$LN1@recoverFro:

; 1711 : }

  001d1	5e		 pop	 esi
  001d2	83 c4 18	 add	 esp, 24			; 00000018H
  001d5	3b ec		 cmp	 ebp, esp
  001d7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001dc	8b e5		 mov	 esp, ebp
  001de	5d		 pop	 ebp
  001df	c3		 ret	 0
_recoverFromMismatchedElement ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3baserecognizer.c
;	COMDAT _recoverFromMismatchedSet
_TEXT	SEGMENT
tv65 = -20						; size = 4
_matchedSymbol$ = -16					; size = 4
_is$ = -12						; size = 4
_tparser$ = -8						; size = 4
_parser$ = -4						; size = 4
_recognizer$ = 8					; size = 4
_follow$ = 12						; size = 4
_recoverFromMismatchedSet PROC				; COMDAT

; 1556 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0000f	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00012	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00015	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00018	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 1557 :     pANTLR3_PARSER			parser;
; 1558 :     pANTLR3_TREE_PARSER	    tparser;
; 1559 :     pANTLR3_INT_STREAM	    is;
; 1560 : 	pANTLR3_COMMON_TOKEN	matchedSymbol;
; 1561 : 
; 1562 :     switch	(recognizer->type)

  0001b	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  0001e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00021	89 4d ec	 mov	 DWORD PTR tv65[ebp], ecx
  00024	83 7d ec 02	 cmp	 DWORD PTR tv65[ebp], 2
  00028	74 08		 je	 SHORT $LN4@recoverFro
  0002a	83 7d ec 04	 cmp	 DWORD PTR tv65[ebp], 4
  0002e	74 1f		 je	 SHORT $LN5@recoverFro
  00030	eb 3d		 jmp	 SHORT $LN6@recoverFro
$LN4@recoverFro:

; 1563 :     {
; 1564 :     case	ANTLR3_TYPE_PARSER:
; 1565 : 
; 1566 : 		parser  = (pANTLR3_PARSER) (recognizer->super);

  00032	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  00035	8b 02		 mov	 eax, DWORD PTR [edx]
  00037	89 45 fc	 mov	 DWORD PTR _parser$[ebp], eax

; 1567 : 		tparser	= NULL;

  0003a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _tparser$[ebp], 0

; 1568 : 		is	= parser->tstream->istream;

  00041	8b 4d fc	 mov	 ecx, DWORD PTR _parser$[ebp]
  00044	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00047	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0004a	89 45 f4	 mov	 DWORD PTR _is$[ebp], eax

; 1569 : 
; 1570 : 	break;

  0004d	eb 49		 jmp	 SHORT $LN2@recoverFro
$LN5@recoverFro:

; 1571 : 
; 1572 :     case	ANTLR3_TYPE_TREE_PARSER:
; 1573 : 
; 1574 : 		tparser = (pANTLR3_TREE_PARSER) (recognizer->super);

  0004f	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  00052	8b 11		 mov	 edx, DWORD PTR [ecx]
  00054	89 55 f8	 mov	 DWORD PTR _tparser$[ebp], edx

; 1575 : 		parser	= NULL;

  00057	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _parser$[ebp], 0

; 1576 : 		is	= tparser->ctnstream->tnstream->istream;

  0005e	8b 45 f8	 mov	 eax, DWORD PTR _tparser$[ebp]
  00061	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00064	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00067	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0006a	89 45 f4	 mov	 DWORD PTR _is$[ebp], eax

; 1577 : 
; 1578 : 	break;

  0006d	eb 29		 jmp	 SHORT $LN2@recoverFro
$LN6@recoverFro:

; 1579 : 
; 1580 :     default:
; 1581 : 	    
; 1582 : 		ANTLR3_FPRINTF(stderr, "Base recognizer function recoverFromMismatchedSet called by unknown parser type - provide override for this function\n");

  0006f	68 00 00 00 00	 push	 OFFSET ??_C@_0HG@PBJLBMBD@Base?5recognizer?5function?5recove@
  00074	8b f4		 mov	 esi, esp
  00076	6a 02		 push	 2
  00078	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  0007e	83 c4 04	 add	 esp, 4
  00081	3b f4		 cmp	 esi, esp
  00083	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 _fprintf
  0008e	83 c4 08	 add	 esp, 8

; 1583 : 		return NULL;

  00091	33 c0		 xor	 eax, eax
  00093	e9 b3 00 00 00	 jmp	 $LN1@recoverFro
$LN2@recoverFro:

; 1584 : 
; 1585 : 	break;
; 1586 :     }
; 1587 : 
; 1588 : 	if	(recognizer->mismatchIsMissingToken(recognizer, is, follow) == ANTLR3_TRUE)

  00098	8b f4		 mov	 esi, esp
  0009a	8b 4d 0c	 mov	 ecx, DWORD PTR _follow$[ebp]
  0009d	51		 push	 ecx
  0009e	8b 55 f4	 mov	 edx, DWORD PTR _is$[ebp]
  000a1	52		 push	 edx
  000a2	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  000a5	50		 push	 eax
  000a6	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  000a9	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  000ac	ff d2		 call	 edx
  000ae	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b1	3b f4		 cmp	 esi, esp
  000b3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b8	0f b6 c0	 movzx	 eax, al
  000bb	83 f8 01	 cmp	 eax, 1
  000be	75 76		 jne	 SHORT $LN7@recoverFro

; 1589 : 	{
; 1590 : 		// We can fake the missing token and proceed
; 1591 : 		//
; 1592 : 		matchedSymbol = (pANTLR3_COMMON_TOKEN)recognizer->getMissingSymbol(recognizer, is, recognizer->state->exception, ANTLR3_TOKEN_INVALID, follow);

  000c0	8b f4		 mov	 esi, esp
  000c2	8b 4d 0c	 mov	 ecx, DWORD PTR _follow$[ebp]
  000c5	51		 push	 ecx
  000c6	6a 00		 push	 0
  000c8	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  000cb	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000ce	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000d1	51		 push	 ecx
  000d2	8b 55 f4	 mov	 edx, DWORD PTR _is$[ebp]
  000d5	52		 push	 edx
  000d6	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  000d9	50		 push	 eax
  000da	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  000dd	8b 91 80 00 00
	00		 mov	 edx, DWORD PTR [ecx+128]
  000e3	ff d2		 call	 edx
  000e5	83 c4 14	 add	 esp, 20			; 00000014H
  000e8	3b f4		 cmp	 esi, esp
  000ea	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ef	89 45 f0	 mov	 DWORD PTR _matchedSymbol$[ebp], eax

; 1593 : 		recognizer->state->exception->type	= ANTLR3_MISSING_TOKEN_EXCEPTION;

  000f2	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  000f5	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000f8	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000fb	c7 02 0a 00 00
	00		 mov	 DWORD PTR [edx], 10	; 0000000aH

; 1594 : 		recognizer->state->exception->token	= matchedSymbol;

  00101	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  00104	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00107	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0010a	8b 45 f0	 mov	 eax, DWORD PTR _matchedSymbol$[ebp]
  0010d	89 42 18	 mov	 DWORD PTR [edx+24], eax

; 1595 : 
; 1596 : 		// Print out the error after we insert so that ANTLRWorks sees the
; 1597 : 		// token in the exception.
; 1598 : 		//
; 1599 : 		recognizer->reportError(recognizer);

  00110	8b f4		 mov	 esi, esp
  00112	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  00115	51		 push	 ecx
  00116	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  00119	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  0011c	ff d0		 call	 eax
  0011e	83 c4 04	 add	 esp, 4
  00121	3b f4		 cmp	 esi, esp
  00123	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1600 : 
; 1601 : 		recognizer->state->error  = ANTLR3_FALSE;	// Exception is not outstanding any more

  00128	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  0012b	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0012e	c6 02 00	 mov	 BYTE PTR [edx], 0

; 1602 : 
; 1603 : 		return	matchedSymbol;

  00131	8b 45 f0	 mov	 eax, DWORD PTR _matchedSymbol$[ebp]
  00134	eb 15		 jmp	 SHORT $LN1@recoverFro
$LN7@recoverFro:

; 1604 : 	}
; 1605 : 
; 1606 :     // TODO - Single token deletion like in recoverFromMismatchedToken()
; 1607 :     //
; 1608 :     recognizer->state->error	= ANTLR3_TRUE;

  00136	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  00139	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0013c	c6 01 01	 mov	 BYTE PTR [ecx], 1

; 1609 : 	recognizer->state->failed	= ANTLR3_TRUE;

  0013f	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  00142	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00145	c6 40 18 01	 mov	 BYTE PTR [eax+24], 1

; 1610 : 	return NULL;

  00149	33 c0		 xor	 eax, eax
$LN1@recoverFro:

; 1611 : }

  0014b	5e		 pop	 esi
  0014c	83 c4 14	 add	 esp, 20			; 00000014H
  0014f	3b ec		 cmp	 ebp, esp
  00151	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00156	8b e5		 mov	 esp, ebp
  00158	5d		 pop	 ebp
  00159	c3		 ret	 0
_recoverFromMismatchedSet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3baserecognizer.c
;	COMDAT _recoverFromMismatchedToken
_TEXT	SEGMENT
tv65 = -20						; size = 4
_matchedSymbol$ = -16					; size = 4
_is$ = -12						; size = 4
_tparser$ = -8						; size = 4
_parser$ = -4						; size = 4
_recognizer$ = 8					; size = 4
_ttype$ = 12						; size = 4
_follow$ = 16						; size = 4
_recoverFromMismatchedToken PROC			; COMDAT

; 1433 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0000f	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00012	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00015	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00018	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 1434 : 	pANTLR3_PARSER			  parser;
; 1435 : 	pANTLR3_TREE_PARSER	      tparser;
; 1436 : 	pANTLR3_INT_STREAM	      is;
; 1437 : 	void					* matchedSymbol;
; 1438 : 
; 1439 : 
; 1440 : 
; 1441 : 	switch	(recognizer->type)

  0001b	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  0001e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00021	89 4d ec	 mov	 DWORD PTR tv65[ebp], ecx
  00024	83 7d ec 02	 cmp	 DWORD PTR tv65[ebp], 2
  00028	74 08		 je	 SHORT $LN4@recoverFro
  0002a	83 7d ec 04	 cmp	 DWORD PTR tv65[ebp], 4
  0002e	74 1f		 je	 SHORT $LN5@recoverFro
  00030	eb 3d		 jmp	 SHORT $LN6@recoverFro
$LN4@recoverFro:

; 1442 : 	{
; 1443 : 	case	ANTLR3_TYPE_PARSER:
; 1444 : 
; 1445 : 		parser  = (pANTLR3_PARSER) (recognizer->super);

  00032	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  00035	8b 02		 mov	 eax, DWORD PTR [edx]
  00037	89 45 fc	 mov	 DWORD PTR _parser$[ebp], eax

; 1446 : 		tparser	= NULL;

  0003a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _tparser$[ebp], 0

; 1447 : 		is	= parser->tstream->istream;

  00041	8b 4d fc	 mov	 ecx, DWORD PTR _parser$[ebp]
  00044	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00047	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0004a	89 45 f4	 mov	 DWORD PTR _is$[ebp], eax

; 1448 : 
; 1449 : 		break;

  0004d	eb 49		 jmp	 SHORT $LN2@recoverFro
$LN5@recoverFro:

; 1450 : 
; 1451 : 	case	ANTLR3_TYPE_TREE_PARSER:
; 1452 : 
; 1453 : 		tparser = (pANTLR3_TREE_PARSER) (recognizer->super);

  0004f	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  00052	8b 11		 mov	 edx, DWORD PTR [ecx]
  00054	89 55 f8	 mov	 DWORD PTR _tparser$[ebp], edx

; 1454 : 		parser	= NULL;

  00057	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _parser$[ebp], 0

; 1455 : 		is	= tparser->ctnstream->tnstream->istream;

  0005e	8b 45 f8	 mov	 eax, DWORD PTR _tparser$[ebp]
  00061	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00064	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00067	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0006a	89 45 f4	 mov	 DWORD PTR _is$[ebp], eax

; 1456 : 
; 1457 : 		break;

  0006d	eb 29		 jmp	 SHORT $LN2@recoverFro
$LN6@recoverFro:

; 1458 : 
; 1459 : 	default:
; 1460 : 
; 1461 : 		ANTLR3_FPRINTF(stderr, "Base recognizer function recoverFromMismatchedToken called by unknown parser type - provide override for this function\n");

  0006f	68 00 00 00 00	 push	 OFFSET ??_C@_0HI@JHLMLNCB@Base?5recognizer?5function?5recove@
  00074	8b f4		 mov	 esi, esp
  00076	6a 02		 push	 2
  00078	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  0007e	83 c4 04	 add	 esp, 4
  00081	3b f4		 cmp	 esi, esp
  00083	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 _fprintf
  0008e	83 c4 08	 add	 esp, 8

; 1462 : 		return NULL;

  00091	33 c0		 xor	 eax, eax
  00093	e9 1c 02 00 00	 jmp	 $LN1@recoverFro
$LN2@recoverFro:

; 1463 : 
; 1464 : 		break;
; 1465 : 	}
; 1466 : 
; 1467 : 	// Create an exception if we need one
; 1468 : 	//
; 1469 : 	if	(recognizer->state->exception == NULL)

  00098	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  0009b	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0009e	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  000a2	75 0c		 jne	 SHORT $LN7@recoverFro

; 1470 : 	{
; 1471 : 		antlr3RecognitionExceptionNew(recognizer);

  000a4	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  000a7	50		 push	 eax
  000a8	e8 00 00 00 00	 call	 _antlr3RecognitionExceptionNew
  000ad	83 c4 04	 add	 esp, 4
$LN7@recoverFro:

; 1472 : 	}
; 1473 : 
; 1474 : 	// If the next token after the one we are looking at in the input stream
; 1475 : 	// is what we are looking for then we remove the one we have discovered
; 1476 : 	// from the stream by consuming it, then consume this next one along too as
; 1477 : 	// if nothing had happened.
; 1478 : 	//
; 1479 : 	if	( recognizer->mismatchIsUnwantedToken(recognizer, is, ttype) == ANTLR3_TRUE)

  000b0	8b f4		 mov	 esi, esp
  000b2	8b 4d 0c	 mov	 ecx, DWORD PTR _ttype$[ebp]
  000b5	51		 push	 ecx
  000b6	8b 55 f4	 mov	 edx, DWORD PTR _is$[ebp]
  000b9	52		 push	 edx
  000ba	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  000bd	50		 push	 eax
  000be	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  000c1	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  000c4	ff d2		 call	 edx
  000c6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c9	3b f4		 cmp	 esi, esp
  000cb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d0	0f b6 c0	 movzx	 eax, al
  000d3	83 f8 01	 cmp	 eax, 1
  000d6	0f 85 17 01 00
	00		 jne	 $LN8@recoverFro

; 1480 : 	{
; 1481 : 		recognizer->state->exception->type		= ANTLR3_UNWANTED_TOKEN_EXCEPTION;

  000dc	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  000df	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000e2	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000e5	c7 00 09 00 00
	00		 mov	 DWORD PTR [eax], 9

; 1482 : 		recognizer->state->exception->message	= ANTLR3_UNWANTED_TOKEN_EXCEPTION_NAME;

  000eb	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  000ee	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000f1	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000f4	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], OFFSET ??_C@_0CJ@DEJOPFAB@org?4antlr?4runtime?4UnwantedToken@

; 1483 : 
; 1484 : 		// Call resync hook (for debuggers and so on)
; 1485 : 		//
; 1486 : 		if	(recognizer->debugger != NULL)

  000fb	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  000fe	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  00102	74 1f		 je	 SHORT $LN9@recoverFro

; 1487 : 		{
; 1488 : 			recognizer->debugger->beginResync(recognizer->debugger);

  00104	8b f4		 mov	 esi, esp
  00106	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  00109	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0010c	50		 push	 eax
  0010d	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  00110	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00113	8b 42 64	 mov	 eax, DWORD PTR [edx+100]
  00116	ff d0		 call	 eax
  00118	83 c4 04	 add	 esp, 4
  0011b	3b f4		 cmp	 esi, esp
  0011d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00122	90		 npad	 1
$LN9@recoverFro:

; 1489 : 		}
; 1490 : 
; 1491 : 		// "delete" the extra token
; 1492 : 		//
; 1493 : 		recognizer->beginResync(recognizer);

  00123	8b f4		 mov	 esi, esp
  00125	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  00128	51		 push	 ecx
  00129	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  0012c	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  0012f	ff d0		 call	 eax
  00131	83 c4 04	 add	 esp, 4
  00134	3b f4		 cmp	 esi, esp
  00136	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1494 : 		is->consume(is);

  0013b	8b f4		 mov	 esi, esp
  0013d	8b 4d f4	 mov	 ecx, DWORD PTR _is$[ebp]
  00140	51		 push	 ecx
  00141	8b 55 f4	 mov	 edx, DWORD PTR _is$[ebp]
  00144	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00147	ff d0		 call	 eax
  00149	83 c4 04	 add	 esp, 4
  0014c	3b f4		 cmp	 esi, esp
  0014e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1495 : 		recognizer->endResync(recognizer);

  00153	8b f4		 mov	 esi, esp
  00155	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  00158	51		 push	 ecx
  00159	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  0015c	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  0015f	ff d0		 call	 eax
  00161	83 c4 04	 add	 esp, 4
  00164	3b f4		 cmp	 esi, esp
  00166	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1496 : 		// End resync hook 
; 1497 : 		//
; 1498 : 		if	(recognizer->debugger != NULL)

  0016b	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  0016e	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  00172	74 1f		 je	 SHORT $LN10@recoverFro

; 1499 : 		{
; 1500 : 			recognizer->debugger->endResync(recognizer->debugger);

  00174	8b f4		 mov	 esi, esp
  00176	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  00179	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0017c	50		 push	 eax
  0017d	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  00180	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00183	8b 42 68	 mov	 eax, DWORD PTR [edx+104]
  00186	ff d0		 call	 eax
  00188	83 c4 04	 add	 esp, 4
  0018b	3b f4		 cmp	 esi, esp
  0018d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00192	90		 npad	 1
$LN10@recoverFro:

; 1501 : 		}
; 1502 : 
; 1503 : 		// Print out the error after we consume so that ANTLRWorks sees the
; 1504 : 		// token in the exception.
; 1505 : 		//
; 1506 : 		recognizer->reportError(recognizer);

  00193	8b f4		 mov	 esi, esp
  00195	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  00198	51		 push	 ecx
  00199	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  0019c	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  0019f	ff d0		 call	 eax
  001a1	83 c4 04	 add	 esp, 4
  001a4	3b f4		 cmp	 esi, esp
  001a6	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1507 : 
; 1508 : 		// Return the token we are actually matching
; 1509 : 		//
; 1510 : 		matchedSymbol = recognizer->getCurrentInputSymbol(recognizer, is);

  001ab	8b f4		 mov	 esi, esp
  001ad	8b 4d f4	 mov	 ecx, DWORD PTR _is$[ebp]
  001b0	51		 push	 ecx
  001b1	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  001b4	52		 push	 edx
  001b5	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  001b8	8b 48 7c	 mov	 ecx, DWORD PTR [eax+124]
  001bb	ff d1		 call	 ecx
  001bd	83 c4 08	 add	 esp, 8
  001c0	3b f4		 cmp	 esi, esp
  001c2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001c7	89 45 f0	 mov	 DWORD PTR _matchedSymbol$[ebp], eax

; 1511 : 
; 1512 : 		// Consume the token that the rule actually expected to get as if everything
; 1513 : 		// was hunky dory.
; 1514 : 		//
; 1515 : 		is->consume(is);

  001ca	8b f4		 mov	 esi, esp
  001cc	8b 55 f4	 mov	 edx, DWORD PTR _is$[ebp]
  001cf	52		 push	 edx
  001d0	8b 45 f4	 mov	 eax, DWORD PTR _is$[ebp]
  001d3	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  001d6	ff d1		 call	 ecx
  001d8	83 c4 04	 add	 esp, 4
  001db	3b f4		 cmp	 esi, esp
  001dd	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1516 : 
; 1517 : 		recognizer->state->error  = ANTLR3_FALSE;	// Exception is not outstanding any more

  001e2	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  001e5	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  001e8	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1518 : 
; 1519 : 		return	matchedSymbol;

  001eb	8b 45 f0	 mov	 eax, DWORD PTR _matchedSymbol$[ebp]
  001ee	e9 c1 00 00 00	 jmp	 $LN1@recoverFro
$LN8@recoverFro:

; 1520 : 	}
; 1521 : 
; 1522 : 	// Single token deletion (Unwanted above) did not work
; 1523 : 	// so we see if we can insert a token instead by calculating which
; 1524 : 	// token would be missing
; 1525 : 	//
; 1526 : 	if	(mismatchIsMissingToken(recognizer, is, follow))

  001f3	8b 4d 10	 mov	 ecx, DWORD PTR _follow$[ebp]
  001f6	51		 push	 ecx
  001f7	8b 55 f4	 mov	 edx, DWORD PTR _is$[ebp]
  001fa	52		 push	 edx
  001fb	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  001fe	50		 push	 eax
  001ff	e8 00 00 00 00	 call	 _mismatchIsMissingToken
  00204	83 c4 0c	 add	 esp, 12			; 0000000cH
  00207	0f b6 c8	 movzx	 ecx, al
  0020a	85 c9		 test	 ecx, ecx
  0020c	0f 84 97 00 00
	00		 je	 $LN11@recoverFro

; 1527 : 	{
; 1528 : 		// We can fake the missing token and proceed
; 1529 : 		//
; 1530 : 		matchedSymbol = recognizer->getMissingSymbol(recognizer, is, recognizer->state->exception, ttype, follow);

  00212	8b f4		 mov	 esi, esp
  00214	8b 55 10	 mov	 edx, DWORD PTR _follow$[ebp]
  00217	52		 push	 edx
  00218	8b 45 0c	 mov	 eax, DWORD PTR _ttype$[ebp]
  0021b	50		 push	 eax
  0021c	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  0021f	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00222	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00225	50		 push	 eax
  00226	8b 4d f4	 mov	 ecx, DWORD PTR _is$[ebp]
  00229	51		 push	 ecx
  0022a	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  0022d	52		 push	 edx
  0022e	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  00231	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  00237	ff d1		 call	 ecx
  00239	83 c4 14	 add	 esp, 20			; 00000014H
  0023c	3b f4		 cmp	 esi, esp
  0023e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00243	89 45 f0	 mov	 DWORD PTR _matchedSymbol$[ebp], eax

; 1531 : 		recognizer->state->exception->type		= ANTLR3_MISSING_TOKEN_EXCEPTION;

  00246	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  00249	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0024c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0024f	c7 01 0a 00 00
	00		 mov	 DWORD PTR [ecx], 10	; 0000000aH

; 1532 : 		recognizer->state->exception->message	= ANTLR3_MISSING_TOKEN_EXCEPTION_NAME;

  00255	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  00258	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0025b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0025e	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], OFFSET ??_C@_0CI@FIMBDEFG@org?4antlr?4runtime?4MissingTokenE@

; 1533 : 		recognizer->state->exception->token		= matchedSymbol;

  00265	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  00268	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0026b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0026e	8b 55 f0	 mov	 edx, DWORD PTR _matchedSymbol$[ebp]
  00271	89 51 18	 mov	 DWORD PTR [ecx+24], edx

; 1534 : 		recognizer->state->exception->expecting	= ttype;

  00274	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  00277	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0027a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0027d	8b 45 0c	 mov	 eax, DWORD PTR _ttype$[ebp]
  00280	89 42 1c	 mov	 DWORD PTR [edx+28], eax

; 1535 : 
; 1536 : 		// Print out the error after we insert so that ANTLRWorks sees the
; 1537 : 		// token in the exception.
; 1538 : 		//
; 1539 : 		recognizer->reportError(recognizer);

  00283	8b f4		 mov	 esi, esp
  00285	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  00288	51		 push	 ecx
  00289	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  0028c	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  0028f	ff d0		 call	 eax
  00291	83 c4 04	 add	 esp, 4
  00294	3b f4		 cmp	 esi, esp
  00296	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1540 : 
; 1541 : 		recognizer->state->error  = ANTLR3_FALSE;	// Exception is not outstanding any more

  0029b	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  0029e	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  002a1	c6 02 00	 mov	 BYTE PTR [edx], 0

; 1542 : 
; 1543 : 		return	matchedSymbol;

  002a4	8b 45 f0	 mov	 eax, DWORD PTR _matchedSymbol$[ebp]
  002a7	eb 0b		 jmp	 SHORT $LN1@recoverFro
$LN11@recoverFro:

; 1544 : 	}
; 1545 : 
; 1546 : 
; 1547 : 	// Neither deleting nor inserting tokens allows recovery
; 1548 : 	// must just report the exception.
; 1549 : 	//
; 1550 : 	recognizer->state->error	    = ANTLR3_TRUE;

  002a9	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  002ac	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  002af	c6 01 01	 mov	 BYTE PTR [ecx], 1

; 1551 : 	return NULL;

  002b2	33 c0		 xor	 eax, eax
$LN1@recoverFro:

; 1552 : }

  002b4	5e		 pop	 esi
  002b5	83 c4 14	 add	 esp, 20			; 00000014H
  002b8	3b ec		 cmp	 ebp, esp
  002ba	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002bf	8b e5		 mov	 esp, ebp
  002c1	5d		 pop	 ebp
  002c2	c3		 ret	 0
_recoverFromMismatchedToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3baserecognizer.c
;	COMDAT _recover
_TEXT	SEGMENT
tv65 = -20						; size = 4
_is$ = -16						; size = 4
_tparser$ = -12						; size = 4
_parser$ = -8						; size = 4
_followSet$ = -4					; size = 4
_recognizer$ = 8					; size = 4
_recover PROC						; COMDAT

; 1321 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000d	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00010	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00013	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00016	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00019	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 1322 :     // Used to compute the follow set of tokens
; 1323 :     //
; 1324 :     pANTLR3_BITSET			followSet;
; 1325 :     pANTLR3_PARSER			parser;
; 1326 :     pANTLR3_TREE_PARSER	    tparser;
; 1327 :     pANTLR3_INT_STREAM	    is;
; 1328 : 
; 1329 :     switch	(recognizer->type)

  0001c	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  0001f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00022	89 4d ec	 mov	 DWORD PTR tv65[ebp], ecx
  00025	83 7d ec 02	 cmp	 DWORD PTR tv65[ebp], 2
  00029	74 08		 je	 SHORT $LN4@recover
  0002b	83 7d ec 04	 cmp	 DWORD PTR tv65[ebp], 4
  0002f	74 1f		 je	 SHORT $LN5@recover
  00031	eb 3d		 jmp	 SHORT $LN6@recover
$LN4@recover:

; 1330 :     {
; 1331 : 		case	ANTLR3_TYPE_PARSER:
; 1332 : 
; 1333 : 		parser  = (pANTLR3_PARSER) (recognizer->super);

  00033	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  00036	8b 02		 mov	 eax, DWORD PTR [edx]
  00038	89 45 f8	 mov	 DWORD PTR _parser$[ebp], eax

; 1334 : 		tparser	= NULL;

  0003b	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _tparser$[ebp], 0

; 1335 : 		is		= parser->tstream->istream;

  00042	8b 4d f8	 mov	 ecx, DWORD PTR _parser$[ebp]
  00045	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00048	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0004b	89 45 f0	 mov	 DWORD PTR _is$[ebp], eax

; 1336 : 
; 1337 : 	break;

  0004e	eb 47		 jmp	 SHORT $LN2@recover
$LN5@recover:

; 1338 : 
; 1339 :     case	ANTLR3_TYPE_TREE_PARSER:
; 1340 : 
; 1341 : 		tparser = (pANTLR3_TREE_PARSER) (recognizer->super);

  00050	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  00053	8b 11		 mov	 edx, DWORD PTR [ecx]
  00055	89 55 f4	 mov	 DWORD PTR _tparser$[ebp], edx

; 1342 : 		parser	= NULL;

  00058	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _parser$[ebp], 0

; 1343 : 		is		= tparser->ctnstream->tnstream->istream;

  0005f	8b 45 f4	 mov	 eax, DWORD PTR _tparser$[ebp]
  00062	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00065	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00068	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0006b	89 45 f0	 mov	 DWORD PTR _is$[ebp], eax

; 1344 : 
; 1345 : 	break;

  0006e	eb 27		 jmp	 SHORT $LN2@recover
$LN6@recover:

; 1346 : 
; 1347 :     default:
; 1348 : 	    
; 1349 : 		ANTLR3_FPRINTF(stderr, "Base recognizer function recover called by unknown parser type - provide override for this function\n");

  00070	68 00 00 00 00	 push	 OFFSET ??_C@_0GF@LHIHPDDL@Base?5recognizer?5function?5recove@
  00075	8b f4		 mov	 esi, esp
  00077	6a 02		 push	 2
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  0007f	83 c4 04	 add	 esp, 4
  00082	3b f4		 cmp	 esi, esp
  00084	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00089	50		 push	 eax
  0008a	e8 00 00 00 00	 call	 _fprintf
  0008f	83 c4 08	 add	 esp, 8

; 1350 : 		return;

  00092	e9 ef 00 00 00	 jmp	 $LN1@recover
$LN2@recover:

; 1351 : 
; 1352 : 	break;
; 1353 :     }
; 1354 : 
; 1355 : 	// Are we about to repeat the same error?
; 1356 : 	//
; 1357 :     if	(recognizer->state->lastErrorIndex == is->index(is))

  00097	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  0009a	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]
  0009d	8b fc		 mov	 edi, esp
  0009f	8b 55 f0	 mov	 edx, DWORD PTR _is$[ebp]
  000a2	52		 push	 edx
  000a3	8b 45 f0	 mov	 eax, DWORD PTR _is$[ebp]
  000a6	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  000a9	ff d1		 call	 ecx
  000ab	83 c4 04	 add	 esp, 4
  000ae	3b fc		 cmp	 edi, esp
  000b0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b5	39 46 14	 cmp	 DWORD PTR [esi+20], eax
  000b8	75 19		 jne	 SHORT $LN7@recover

; 1358 :     {
; 1359 : 		// The last error was at the same token index point. This must be a case
; 1360 : 		// where LT(1) is in the recovery token set so nothing is
; 1361 : 		// consumed. Consume a single token so at least to prevent
; 1362 : 		// an infinite loop; this is a failsafe.
; 1363 : 		//
; 1364 : 		is->consume(is);

  000ba	8b f4		 mov	 esi, esp
  000bc	8b 55 f0	 mov	 edx, DWORD PTR _is$[ebp]
  000bf	52		 push	 edx
  000c0	8b 45 f0	 mov	 eax, DWORD PTR _is$[ebp]
  000c3	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000c6	ff d1		 call	 ecx
  000c8	83 c4 04	 add	 esp, 4
  000cb	3b f4		 cmp	 esi, esp
  000cd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d2	90		 npad	 1
$LN7@recover:

; 1365 :     }
; 1366 : 
; 1367 :     // Record error index position
; 1368 :     //
; 1369 :     recognizer->state->lastErrorIndex	 = is->index(is);

  000d3	8b f4		 mov	 esi, esp
  000d5	8b 55 f0	 mov	 edx, DWORD PTR _is$[ebp]
  000d8	52		 push	 edx
  000d9	8b 45 f0	 mov	 eax, DWORD PTR _is$[ebp]
  000dc	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  000df	ff d1		 call	 ecx
  000e1	83 c4 04	 add	 esp, 4
  000e4	3b f4		 cmp	 esi, esp
  000e6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000eb	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  000ee	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  000f1	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 1370 :     
; 1371 :     // Work out the follows set for error recovery
; 1372 :     //
; 1373 :     followSet	= recognizer->computeErrorRecoverySet(recognizer);

  000f4	8b f4		 mov	 esi, esp
  000f6	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  000f9	52		 push	 edx
  000fa	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  000fd	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  00100	ff d1		 call	 ecx
  00102	83 c4 04	 add	 esp, 4
  00105	3b f4		 cmp	 esi, esp
  00107	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0010c	89 45 fc	 mov	 DWORD PTR _followSet$[ebp], eax

; 1374 : 
; 1375 :     // Call resync hook (for debuggers and so on)
; 1376 :     //
; 1377 :     recognizer->beginResync(recognizer);

  0010f	8b f4		 mov	 esi, esp
  00111	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  00114	52		 push	 edx
  00115	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  00118	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0011b	ff d1		 call	 ecx
  0011d	83 c4 04	 add	 esp, 4
  00120	3b f4		 cmp	 esi, esp
  00122	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1378 : 
; 1379 :     // Consume tokens until we have resynced to something in the follows set
; 1380 :     //
; 1381 :     recognizer->consumeUntilSet(recognizer, followSet);

  00127	8b f4		 mov	 esi, esp
  00129	8b 55 fc	 mov	 edx, DWORD PTR _followSet$[ebp]
  0012c	52		 push	 edx
  0012d	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  00130	50		 push	 eax
  00131	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  00134	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  00137	ff d2		 call	 edx
  00139	83 c4 08	 add	 esp, 8
  0013c	3b f4		 cmp	 esi, esp
  0013e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1382 : 
; 1383 :     // End resync hook 
; 1384 :     //
; 1385 :     recognizer->endResync(recognizer);

  00143	8b f4		 mov	 esi, esp
  00145	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  00148	50		 push	 eax
  00149	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  0014c	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  0014f	ff d2		 call	 edx
  00151	83 c4 04	 add	 esp, 4
  00154	3b f4		 cmp	 esi, esp
  00156	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1386 : 
; 1387 :     // Destroy the temporary bitset we produced.
; 1388 :     //
; 1389 :     followSet->free(followSet);

  0015b	8b f4		 mov	 esi, esp
  0015d	8b 45 fc	 mov	 eax, DWORD PTR _followSet$[ebp]
  00160	50		 push	 eax
  00161	8b 4d fc	 mov	 ecx, DWORD PTR _followSet$[ebp]
  00164	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  00167	ff d2		 call	 edx
  00169	83 c4 04	 add	 esp, 4
  0016c	3b f4		 cmp	 esi, esp
  0016e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1390 : 
; 1391 :     // Reset the inError flag so we don't re-report the exception
; 1392 :     //
; 1393 :     recognizer->state->error	= ANTLR3_FALSE;

  00173	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  00176	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00179	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 1394 :     recognizer->state->failed	= ANTLR3_FALSE;

  0017c	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  0017f	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00182	c6 40 18 00	 mov	 BYTE PTR [eax+24], 0
$LN1@recover:

; 1395 : }

  00186	5f		 pop	 edi
  00187	5e		 pop	 esi
  00188	83 c4 14	 add	 esp, 20			; 00000014H
  0018b	3b ec		 cmp	 ebp, esp
  0018d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00192	8b e5		 mov	 esp, ebp
  00194	5d		 pop	 ebp
  00195	c3		 ret	 0
_recover ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3baserecognizer.c
;	COMDAT _displayRecognitionError
_TEXT	SEGMENT
tv307 = -72						; size = 4
tv213 = -68						; size = 4
tv171 = -64						; size = 4
tv143 = -60						; size = 4
_errBits$1 = -56					; size = 4
_numbits$2 = -52					; size = 4
_size$3 = -48						; size = 4
_bit$4 = -44						; size = 4
_count$5 = -40						; size = 4
_theCommonTree$ = -36					; size = 4
_theBaseTree$ = -32					; size = 4
_theToken$ = -28					; size = 4
_ex$ = -24						; size = 4
_ftext$ = -20						; size = 4
_ttext$ = -16						; size = 4
_is$ = -12						; size = 4
_tparser$ = -8						; size = 4
_parser$ = -4						; size = 4
_recognizer$ = 8					; size = 4
_tokenNames$ = 12					; size = 4
_displayRecognitionError PROC				; COMDAT

; 1009 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8d 7d b8	 lea	 edi, DWORD PTR [ebp-72]
  0000b	b9 12 00 00 00	 mov	 ecx, 18			; 00000012H
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd

; 1010 : 	pANTLR3_PARSER			parser;
; 1011 : 	pANTLR3_TREE_PARSER	    tparser;
; 1012 : 	pANTLR3_INT_STREAM	    is;
; 1013 : 	pANTLR3_STRING			ttext;
; 1014 : 	pANTLR3_STRING			ftext;
; 1015 : 	pANTLR3_EXCEPTION	    ex;
; 1016 : 	pANTLR3_COMMON_TOKEN    theToken;
; 1017 : 	pANTLR3_BASE_TREE	    theBaseTree;
; 1018 : 	pANTLR3_COMMON_TREE	    theCommonTree;
; 1019 : 
; 1020 : 	// Retrieve some info for easy reading.
; 1021 : 	//
; 1022 : 	ex	    =		recognizer->state->exception;

  00017	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  0001a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0001d	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00020	89 55 e8	 mov	 DWORD PTR _ex$[ebp], edx

; 1023 : 	ttext   =		NULL;

  00023	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _ttext$[ebp], 0

; 1024 : 
; 1025 : 	// See if there is a 'filename' we can use
; 1026 : 	//
; 1027 : 	if	(ex->streamName == NULL)

  0002a	8b 45 e8	 mov	 eax, DWORD PTR _ex$[ebp]
  0002d	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00031	75 53		 jne	 SHORT $LN9@displayRec

; 1028 : 	{
; 1029 : 		if	(((pANTLR3_COMMON_TOKEN)(ex->token))->type == ANTLR3_TOKEN_EOF)

  00033	8b 4d e8	 mov	 ecx, DWORD PTR _ex$[ebp]
  00036	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00039	83 3a ff	 cmp	 DWORD PTR [edx], -1
  0003c	75 24		 jne	 SHORT $LN11@displayRec

; 1030 : 		{
; 1031 : 			ANTLR3_FPRINTF(stderr, "-end of input-(");

  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@NHDJPBJB@?9end?5of?5input?9?$CI@
  00043	8b f4		 mov	 esi, esp
  00045	6a 02		 push	 2
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  0004d	83 c4 04	 add	 esp, 4
  00050	3b f4		 cmp	 esi, esp
  00052	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 _fprintf
  0005d	83 c4 08	 add	 esp, 8

; 1032 : 		}

  00060	eb 22		 jmp	 SHORT $LN12@displayRec
$LN11@displayRec:

; 1033 : 		else
; 1034 : 		{
; 1035 : 			ANTLR3_FPRINTF(stderr, "-unknown source-(");

  00062	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@NHAPJBAE@?9unknown?5source?9?$CI@
  00067	8b f4		 mov	 esi, esp
  00069	6a 02		 push	 2
  0006b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  00071	83 c4 04	 add	 esp, 4
  00074	3b f4		 cmp	 esi, esp
  00076	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 _fprintf
  00081	83 c4 08	 add	 esp, 8
$LN12@displayRec:

; 1036 : 		}
; 1037 : 	}

  00084	eb 4a		 jmp	 SHORT $LN10@displayRec
$LN9@displayRec:

; 1038 : 	else
; 1039 : 	{
; 1040 : 		ftext = ex->streamName->to8(ex->streamName);

  00086	8b f4		 mov	 esi, esp
  00088	8b 45 e8	 mov	 eax, DWORD PTR _ex$[ebp]
  0008b	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0008e	51		 push	 ecx
  0008f	8b 55 e8	 mov	 edx, DWORD PTR _ex$[ebp]
  00092	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00095	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00098	ff d1		 call	 ecx
  0009a	83 c4 04	 add	 esp, 4
  0009d	3b f4		 cmp	 esi, esp
  0009f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a4	89 45 ec	 mov	 DWORD PTR _ftext$[ebp], eax

; 1041 : 		ANTLR3_FPRINTF(stderr, "%s(", ftext->chars);

  000a7	8b 55 ec	 mov	 edx, DWORD PTR _ftext$[ebp]
  000aa	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000ad	50		 push	 eax
  000ae	68 00 00 00 00	 push	 OFFSET ??_C@_03ECLNAHEM@?$CFs?$CI@
  000b3	8b f4		 mov	 esi, esp
  000b5	6a 02		 push	 2
  000b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  000bd	83 c4 04	 add	 esp, 4
  000c0	3b f4		 cmp	 esi, esp
  000c2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c7	50		 push	 eax
  000c8	e8 00 00 00 00	 call	 _fprintf
  000cd	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN10@displayRec:

; 1042 : 	}
; 1043 : 
; 1044 : 	// Next comes the line number
; 1045 : 	//
; 1046 : 
; 1047 : 	ANTLR3_FPRINTF(stderr, "%d) ", recognizer->state->exception->line);

  000d0	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  000d3	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000d6	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000d9	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  000dc	51		 push	 ecx
  000dd	68 00 00 00 00	 push	 OFFSET ??_C@_04CGKAJBAP@?$CFd?$CJ?5@
  000e2	8b f4		 mov	 esi, esp
  000e4	6a 02		 push	 2
  000e6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  000ec	83 c4 04	 add	 esp, 4
  000ef	3b f4		 cmp	 esi, esp
  000f1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f6	50		 push	 eax
  000f7	e8 00 00 00 00	 call	 _fprintf
  000fc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1048 : 	ANTLR3_FPRINTF(stderr, " : error %d : %s", 

  000ff	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  00102	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00105	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00108	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0010b	52		 push	 edx
  0010c	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  0010f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00112	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00115	8b 02		 mov	 eax, DWORD PTR [edx]
  00117	50		 push	 eax
  00118	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IEOPNPCE@?5?3?5error?5?$CFd?5?3?5?$CFs@
  0011d	8b f4		 mov	 esi, esp
  0011f	6a 02		 push	 2
  00121	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  00127	83 c4 04	 add	 esp, 4
  0012a	3b f4		 cmp	 esi, esp
  0012c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00131	50		 push	 eax
  00132	e8 00 00 00 00	 call	 _fprintf
  00137	83 c4 10	 add	 esp, 16			; 00000010H

; 1049 : 										recognizer->state->exception->type,
; 1050 : 					(pANTLR3_UINT8)	   (recognizer->state->exception->message));
; 1051 : 
; 1052 : 
; 1053 : 	// How we determine the next piece is dependent on which thing raised the
; 1054 : 	// error.
; 1055 : 	//
; 1056 : 	switch	(recognizer->type)

  0013a	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  0013d	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00140	89 55 c4	 mov	 DWORD PTR tv143[ebp], edx
  00143	83 7d c4 02	 cmp	 DWORD PTR tv143[ebp], 2
  00147	74 0f		 je	 SHORT $LN13@displayRec
  00149	83 7d c4 04	 cmp	 DWORD PTR tv143[ebp], 4
  0014d	0f 84 f1 00 00
	00		 je	 $LN17@displayRec
  00153	e9 cd 01 00 00	 jmp	 $LN20@displayRec
$LN13@displayRec:

; 1057 : 	{
; 1058 : 	case	ANTLR3_TYPE_PARSER:
; 1059 : 
; 1060 : 		// Prepare the knowledge we know we have
; 1061 : 		//
; 1062 : 		parser	    = (pANTLR3_PARSER) (recognizer->super);

  00158	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  0015b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0015d	89 4d fc	 mov	 DWORD PTR _parser$[ebp], ecx

; 1063 : 		tparser	    = NULL;

  00160	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _tparser$[ebp], 0

; 1064 : 		is			= parser->tstream->istream;

  00167	8b 55 fc	 mov	 edx, DWORD PTR _parser$[ebp]
  0016a	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0016d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00170	89 4d f4	 mov	 DWORD PTR _is$[ebp], ecx

; 1065 : 		theToken    = (pANTLR3_COMMON_TOKEN)(recognizer->state->exception->token);

  00173	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  00176	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00179	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0017c	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0017f	89 55 e4	 mov	 DWORD PTR _theToken$[ebp], edx

; 1066 : 		ttext	    = theToken->toString(theToken);

  00182	8b f4		 mov	 esi, esp
  00184	8b 45 e4	 mov	 eax, DWORD PTR _theToken$[ebp]
  00187	50		 push	 eax
  00188	8b 4d e4	 mov	 ecx, DWORD PTR _theToken$[ebp]
  0018b	8b 91 8c 00 00
	00		 mov	 edx, DWORD PTR [ecx+140]
  00191	ff d2		 call	 edx
  00193	83 c4 04	 add	 esp, 4
  00196	3b f4		 cmp	 esi, esp
  00198	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0019d	89 45 f0	 mov	 DWORD PTR _ttext$[ebp], eax

; 1067 : 
; 1068 : 		ANTLR3_FPRINTF(stderr, ", at offset %d", recognizer->state->exception->charPositionInLine);

  001a0	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  001a3	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001a6	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  001a9	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  001ac	50		 push	 eax
  001ad	68 00 00 00 00	 push	 OFFSET ??_C@_0P@FFBCLMBE@?0?5at?5offset?5?$CFd@
  001b2	8b f4		 mov	 esi, esp
  001b4	6a 02		 push	 2
  001b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  001bc	83 c4 04	 add	 esp, 4
  001bf	3b f4		 cmp	 esi, esp
  001c1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001c6	50		 push	 eax
  001c7	e8 00 00 00 00	 call	 _fprintf
  001cc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1069 : 		if  (theToken != NULL)

  001cf	83 7d e4 00	 cmp	 DWORD PTR _theToken$[ebp], 0
  001d3	74 6a		 je	 SHORT $LN16@displayRec

; 1070 : 		{
; 1071 : 			if (theToken->type == ANTLR3_TOKEN_EOF)

  001d5	8b 4d e4	 mov	 ecx, DWORD PTR _theToken$[ebp]
  001d8	83 39 ff	 cmp	 DWORD PTR [ecx], -1
  001db	75 24		 jne	 SHORT $LN15@displayRec

; 1072 : 			{
; 1073 : 				ANTLR3_FPRINTF(stderr, ", at <EOF>");

  001dd	68 00 00 00 00	 push	 OFFSET ??_C@_0L@OOBCNBEJ@?0?5at?5?$DMEOF?$DO@
  001e2	8b f4		 mov	 esi, esp
  001e4	6a 02		 push	 2
  001e6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  001ec	83 c4 04	 add	 esp, 4
  001ef	3b f4		 cmp	 esi, esp
  001f1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001f6	50		 push	 eax
  001f7	e8 00 00 00 00	 call	 _fprintf
  001fc	83 c4 08	 add	 esp, 8

; 1074 : 			}

  001ff	eb 3e		 jmp	 SHORT $LN16@displayRec
$LN15@displayRec:

; 1075 : 			else
; 1076 : 			{
; 1077 : 				// Guard against null text in a token
; 1078 : 				//
; 1079 : 				ANTLR3_FPRINTF(stderr, "\n    near %s\n    ", ttext == NULL ? (pANTLR3_UINT8)"<no text for the token>" : ttext->chars);

  00201	83 7d f0 00	 cmp	 DWORD PTR _ttext$[ebp], 0
  00205	75 09		 jne	 SHORT $LN45@displayRec
  00207	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR tv171[ebp], OFFSET ??_C@_0BI@JEIKDPEP@?$DMno?5text?5for?5the?5token?$DO@
  0020e	eb 09		 jmp	 SHORT $LN46@displayRec
$LN45@displayRec:
  00210	8b 55 f0	 mov	 edx, DWORD PTR _ttext$[ebp]
  00213	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00216	89 45 c0	 mov	 DWORD PTR tv171[ebp], eax
$LN46@displayRec:
  00219	8b 4d c0	 mov	 ecx, DWORD PTR tv171[ebp]
  0021c	51		 push	 ecx
  0021d	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@FCBIMOGO@?6?5?5?5?5near?5?$CFs?6?5?5?5?5@
  00222	8b f4		 mov	 esi, esp
  00224	6a 02		 push	 2
  00226	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  0022c	83 c4 04	 add	 esp, 4
  0022f	3b f4		 cmp	 esi, esp
  00231	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00236	50		 push	 eax
  00237	e8 00 00 00 00	 call	 _fprintf
  0023c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN16@displayRec:

; 1080 : 			}
; 1081 : 		}
; 1082 : 		break;

  0023f	e9 08 01 00 00	 jmp	 $LN2@displayRec
$LN17@displayRec:

; 1083 : 
; 1084 : 	case	ANTLR3_TYPE_TREE_PARSER:
; 1085 : 
; 1086 : 		tparser		= (pANTLR3_TREE_PARSER) (recognizer->super);

  00244	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  00247	8b 02		 mov	 eax, DWORD PTR [edx]
  00249	89 45 f8	 mov	 DWORD PTR _tparser$[ebp], eax

; 1087 : 		parser		= NULL;

  0024c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _parser$[ebp], 0

; 1088 : 		is			= tparser->ctnstream->tnstream->istream;

  00253	8b 4d f8	 mov	 ecx, DWORD PTR _tparser$[ebp]
  00256	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00259	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0025c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0025f	89 4d f4	 mov	 DWORD PTR _is$[ebp], ecx

; 1089 : 		theBaseTree	= (pANTLR3_BASE_TREE)(recognizer->state->exception->token);

  00262	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  00265	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00268	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0026b	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0026e	89 55 e0	 mov	 DWORD PTR _theBaseTree$[ebp], edx

; 1090 : 		ttext		= theBaseTree->toStringTree(theBaseTree);

  00271	8b f4		 mov	 esi, esp
  00273	8b 45 e0	 mov	 eax, DWORD PTR _theBaseTree$[ebp]
  00276	50		 push	 eax
  00277	8b 4d e0	 mov	 ecx, DWORD PTR _theBaseTree$[ebp]
  0027a	8b 51 68	 mov	 edx, DWORD PTR [ecx+104]
  0027d	ff d2		 call	 edx
  0027f	83 c4 04	 add	 esp, 4
  00282	3b f4		 cmp	 esi, esp
  00284	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00289	89 45 f0	 mov	 DWORD PTR _ttext$[ebp], eax

; 1091 : 
; 1092 : 		if  (theBaseTree != NULL)

  0028c	83 7d e0 00	 cmp	 DWORD PTR _theBaseTree$[ebp], 0
  00290	0f 84 8d 00 00
	00		 je	 $LN18@displayRec

; 1093 : 		{
; 1094 : 			theCommonTree	= (pANTLR3_COMMON_TREE)	    theBaseTree->super;

  00296	8b 45 e0	 mov	 eax, DWORD PTR _theBaseTree$[ebp]
  00299	8b 08		 mov	 ecx, DWORD PTR [eax]
  0029b	89 4d dc	 mov	 DWORD PTR _theCommonTree$[ebp], ecx

; 1095 : 
; 1096 : 			if	(theCommonTree != NULL)

  0029e	83 7d dc 00	 cmp	 DWORD PTR _theCommonTree$[ebp], 0
  002a2	74 1b		 je	 SHORT $LN19@displayRec

; 1097 : 			{
; 1098 : 				theToken	= (pANTLR3_COMMON_TOKEN)    theBaseTree->getToken(theBaseTree);

  002a4	8b f4		 mov	 esi, esp
  002a6	8b 55 e0	 mov	 edx, DWORD PTR _theBaseTree$[ebp]
  002a9	52		 push	 edx
  002aa	8b 45 e0	 mov	 eax, DWORD PTR _theBaseTree$[ebp]
  002ad	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  002b0	ff d1		 call	 ecx
  002b2	83 c4 04	 add	 esp, 4
  002b5	3b f4		 cmp	 esi, esp
  002b7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002bc	89 45 e4	 mov	 DWORD PTR _theToken$[ebp], eax
$LN19@displayRec:

; 1099 : 			}
; 1100 : 			ANTLR3_FPRINTF(stderr, ", at offset %d", theBaseTree->getCharPositionInLine(theBaseTree));

  002bf	8b f4		 mov	 esi, esp
  002c1	8b 55 e0	 mov	 edx, DWORD PTR _theBaseTree$[ebp]
  002c4	52		 push	 edx
  002c5	8b 45 e0	 mov	 eax, DWORD PTR _theBaseTree$[ebp]
  002c8	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  002cb	ff d1		 call	 ecx
  002cd	83 c4 04	 add	 esp, 4
  002d0	3b f4		 cmp	 esi, esp
  002d2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002d7	50		 push	 eax
  002d8	68 00 00 00 00	 push	 OFFSET ??_C@_0P@FFBCLMBE@?0?5at?5offset?5?$CFd@
  002dd	8b f4		 mov	 esi, esp
  002df	6a 02		 push	 2
  002e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  002e7	83 c4 04	 add	 esp, 4
  002ea	3b f4		 cmp	 esi, esp
  002ec	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002f1	50		 push	 eax
  002f2	e8 00 00 00 00	 call	 _fprintf
  002f7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1101 : 			ANTLR3_FPRINTF(stderr, ", near %s", ttext->chars);

  002fa	8b 55 f0	 mov	 edx, DWORD PTR _ttext$[ebp]
  002fd	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00300	50		 push	 eax
  00301	68 00 00 00 00	 push	 OFFSET ??_C@_09NBGEJOP@?0?5near?5?$CFs@
  00306	8b f4		 mov	 esi, esp
  00308	6a 02		 push	 2
  0030a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  00310	83 c4 04	 add	 esp, 4
  00313	3b f4		 cmp	 esi, esp
  00315	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0031a	50		 push	 eax
  0031b	e8 00 00 00 00	 call	 _fprintf
  00320	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN18@displayRec:

; 1102 : 		}
; 1103 : 		break;

  00323	eb 27		 jmp	 SHORT $LN2@displayRec
$LN20@displayRec:

; 1104 : 
; 1105 : 	default:
; 1106 : 
; 1107 : 		ANTLR3_FPRINTF(stderr, "Base recognizer function displayRecognitionError called by unknown parser type - provide override for this function\n");

  00325	68 00 00 00 00	 push	 OFFSET ??_C@_0HF@PILNDIMB@Base?5recognizer?5function?5displa@
  0032a	8b f4		 mov	 esi, esp
  0032c	6a 02		 push	 2
  0032e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  00334	83 c4 04	 add	 esp, 4
  00337	3b f4		 cmp	 esi, esp
  00339	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0033e	50		 push	 eax
  0033f	e8 00 00 00 00	 call	 _fprintf
  00344	83 c4 08	 add	 esp, 8

; 1108 : 		return;

  00347	e9 cb 03 00 00	 jmp	 $LN4@displayRec
$LN2@displayRec:

; 1109 : 		break;
; 1110 : 	}
; 1111 : 
; 1112 : 	// Although this function should generally be provided by the implementation, this one
; 1113 : 	// should be as helpful as possible for grammar developers and serve as an example
; 1114 : 	// of what you can do with each exception type. In general, when you make up your
; 1115 : 	// 'real' handler, you should debug the routine with all possible errors you expect
; 1116 : 	// which will then let you be as specific as possible about all circumstances.
; 1117 : 	//
; 1118 : 	// Note that in the general case, errors thrown by tree parsers indicate a problem
; 1119 : 	// with the output of the parser or with the tree grammar itself. The job of the parser
; 1120 : 	// is to produce a perfect (in traversal terms) syntactically correct tree, so errors
; 1121 : 	// at that stage should really be semantic errors that your own code determines and handles
; 1122 : 	// in whatever way is appropriate.
; 1123 : 	//
; 1124 : 	switch  (ex->type)

  0034c	8b 4d e8	 mov	 ecx, DWORD PTR _ex$[ebp]
  0034f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00351	89 55 bc	 mov	 DWORD PTR tv213[ebp], edx
  00354	8b 45 bc	 mov	 eax, DWORD PTR tv213[ebp]
  00357	83 e8 01	 sub	 eax, 1
  0035a	89 45 bc	 mov	 DWORD PTR tv213[ebp], eax
  0035d	83 7d bc 09	 cmp	 DWORD PTR tv213[ebp], 9
  00361	0f 87 8e 03 00
	00		 ja	 $LN43@displayRec
  00367	8b 4d bc	 mov	 ecx, DWORD PTR tv213[ebp]
  0036a	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN49@displayRec[ecx*4]
$LN21@displayRec:

; 1125 : 	{
; 1126 : 	case	ANTLR3_UNWANTED_TOKEN_EXCEPTION:
; 1127 : 
; 1128 : 		// Indicates that the recognizer was fed a token which seesm to be
; 1129 : 		// spurious input. We can detect this when the token that follows
; 1130 : 		// this unwanted token would normally be part of the syntactically
; 1131 : 		// correct stream. Then we can see that the token we are looking at
; 1132 : 		// is just something that should not be there and throw this exception.
; 1133 : 		//
; 1134 : 		if	(tokenNames == NULL)

  00371	83 7d 0c 00	 cmp	 DWORD PTR _tokenNames$[ebp], 0
  00375	75 24		 jne	 SHORT $LN22@displayRec

; 1135 : 		{
; 1136 : 			ANTLR3_FPRINTF(stderr, " : Extraneous input...");

  00377	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@MJPMEPDL@?5?3?5Extraneous?5input?4?4?4@
  0037c	8b f4		 mov	 esi, esp
  0037e	6a 02		 push	 2
  00380	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  00386	83 c4 04	 add	 esp, 4
  00389	3b f4		 cmp	 esi, esp
  0038b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00390	50		 push	 eax
  00391	e8 00 00 00 00	 call	 _fprintf
  00396	83 c4 08	 add	 esp, 8

; 1137 : 		}

  00399	eb 5c		 jmp	 SHORT $LN25@displayRec
$LN22@displayRec:

; 1138 : 		else
; 1139 : 		{
; 1140 : 			if	(ex->expecting == ANTLR3_TOKEN_EOF)

  0039b	8b 55 e8	 mov	 edx, DWORD PTR _ex$[ebp]
  0039e	83 7a 1c ff	 cmp	 DWORD PTR [edx+28], -1
  003a2	75 24		 jne	 SHORT $LN24@displayRec

; 1141 : 			{
; 1142 : 				ANTLR3_FPRINTF(stderr, " : Extraneous input - expected <EOF>\n");

  003a4	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@FKGGLHMC@?5?3?5Extraneous?5input?5?9?5expected?5@
  003a9	8b f4		 mov	 esi, esp
  003ab	6a 02		 push	 2
  003ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  003b3	83 c4 04	 add	 esp, 4
  003b6	3b f4		 cmp	 esi, esp
  003b8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003bd	50		 push	 eax
  003be	e8 00 00 00 00	 call	 _fprintf
  003c3	83 c4 08	 add	 esp, 8

; 1143 : 			}

  003c6	eb 2f		 jmp	 SHORT $LN25@displayRec
$LN24@displayRec:

; 1144 : 			else
; 1145 : 			{
; 1146 : 				ANTLR3_FPRINTF(stderr, " : Extraneous input - expected %s ...\n", tokenNames[ex->expecting]);

  003c8	8b 45 e8	 mov	 eax, DWORD PTR _ex$[ebp]
  003cb	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  003ce	8b 55 0c	 mov	 edx, DWORD PTR _tokenNames$[ebp]
  003d1	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  003d4	50		 push	 eax
  003d5	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@BICFKPGJ@?5?3?5Extraneous?5input?5?9?5expected?5@
  003da	8b f4		 mov	 esi, esp
  003dc	6a 02		 push	 2
  003de	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  003e4	83 c4 04	 add	 esp, 4
  003e7	3b f4		 cmp	 esi, esp
  003e9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003ee	50		 push	 eax
  003ef	e8 00 00 00 00	 call	 _fprintf
  003f4	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN25@displayRec:

; 1147 : 			}
; 1148 : 		}
; 1149 : 		break;

  003f7	e9 1b 03 00 00	 jmp	 $LN4@displayRec
$LN26@displayRec:

; 1150 : 
; 1151 : 	case	ANTLR3_MISSING_TOKEN_EXCEPTION:
; 1152 : 
; 1153 : 		// Indicates that the recognizer detected that the token we just
; 1154 : 		// hit would be valid syntactically if preceeded by a particular 
; 1155 : 		// token. Perhaps a missing ';' at line end or a missing ',' in an
; 1156 : 		// expression list, and such like.
; 1157 : 		//
; 1158 : 		if	(tokenNames == NULL)

  003fc	83 7d 0c 00	 cmp	 DWORD PTR _tokenNames$[ebp], 0
  00400	75 2b		 jne	 SHORT $LN27@displayRec

; 1159 : 		{
; 1160 : 			ANTLR3_FPRINTF(stderr, " : Missing token (%d)...\n", ex->expecting);

  00402	8b 4d e8	 mov	 ecx, DWORD PTR _ex$[ebp]
  00405	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00408	52		 push	 edx
  00409	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@FIODKMIN@?5?3?5Missing?5token?5?$CI?$CFd?$CJ?4?4?4?6@
  0040e	8b f4		 mov	 esi, esp
  00410	6a 02		 push	 2
  00412	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  00418	83 c4 04	 add	 esp, 4
  0041b	3b f4		 cmp	 esi, esp
  0041d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00422	50		 push	 eax
  00423	e8 00 00 00 00	 call	 _fprintf
  00428	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1161 : 		}

  0042b	eb 5c		 jmp	 SHORT $LN30@displayRec
$LN27@displayRec:

; 1162 : 		else
; 1163 : 		{
; 1164 : 			if	(ex->expecting == ANTLR3_TOKEN_EOF)

  0042d	8b 45 e8	 mov	 eax, DWORD PTR _ex$[ebp]
  00430	83 78 1c ff	 cmp	 DWORD PTR [eax+28], -1
  00434	75 24		 jne	 SHORT $LN29@displayRec

; 1165 : 			{
; 1166 : 				ANTLR3_FPRINTF(stderr, " : Missing <EOF>\n");

  00436	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@DMIEBDKC@?5?3?5Missing?5?$DMEOF?$DO?6@
  0043b	8b f4		 mov	 esi, esp
  0043d	6a 02		 push	 2
  0043f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  00445	83 c4 04	 add	 esp, 4
  00448	3b f4		 cmp	 esi, esp
  0044a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0044f	50		 push	 eax
  00450	e8 00 00 00 00	 call	 _fprintf
  00455	83 c4 08	 add	 esp, 8

; 1167 : 			}

  00458	eb 2f		 jmp	 SHORT $LN30@displayRec
$LN29@displayRec:

; 1168 : 			else
; 1169 : 			{
; 1170 : 				ANTLR3_FPRINTF(stderr, " : Missing %s \n", tokenNames[ex->expecting]);

  0045a	8b 4d e8	 mov	 ecx, DWORD PTR _ex$[ebp]
  0045d	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00460	8b 45 0c	 mov	 eax, DWORD PTR _tokenNames$[ebp]
  00463	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  00466	51		 push	 ecx
  00467	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JJEGDFKK@?5?3?5Missing?5?$CFs?5?6@
  0046c	8b f4		 mov	 esi, esp
  0046e	6a 02		 push	 2
  00470	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  00476	83 c4 04	 add	 esp, 4
  00479	3b f4		 cmp	 esi, esp
  0047b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00480	50		 push	 eax
  00481	e8 00 00 00 00	 call	 _fprintf
  00486	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN30@displayRec:

; 1171 : 			}
; 1172 : 		}
; 1173 : 		break;

  00489	e9 89 02 00 00	 jmp	 $LN4@displayRec
$LN31@displayRec:

; 1174 : 
; 1175 : 	case	ANTLR3_RECOGNITION_EXCEPTION:
; 1176 : 
; 1177 : 		// Indicates that the recognizer received a token
; 1178 : 		// in the input that was not predicted. This is the basic exception type 
; 1179 : 		// from which all others are derived. So we assume it was a syntax error.
; 1180 : 		// You may get this if there are not more tokens and more are needed
; 1181 : 		// to complete a parse for instance.
; 1182 : 		//
; 1183 : 		ANTLR3_FPRINTF(stderr, " : syntax error...\n");    

  0048e	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@CLJLAAJJ@?5?3?5syntax?5error?4?4?4?6@
  00493	8b f4		 mov	 esi, esp
  00495	6a 02		 push	 2
  00497	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  0049d	83 c4 04	 add	 esp, 4
  004a0	3b f4		 cmp	 esi, esp
  004a2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  004a7	50		 push	 eax
  004a8	e8 00 00 00 00	 call	 _fprintf
  004ad	83 c4 08	 add	 esp, 8

; 1184 : 		break;

  004b0	e9 62 02 00 00	 jmp	 $LN4@displayRec
$LN32@displayRec:

; 1185 : 
; 1186 : 	case    ANTLR3_MISMATCHED_TOKEN_EXCEPTION:
; 1187 : 
; 1188 : 		// We were expecting to see one thing and got another. This is the
; 1189 : 		// most common error if we coudl not detect a missing or unwanted token.
; 1190 : 		// Here you can spend your efforts to
; 1191 : 		// derive more useful error messages based on the expected
; 1192 : 		// token set and the last token and so on. The error following
; 1193 : 		// bitmaps do a good job of reducing the set that we were looking
; 1194 : 		// for down to something small. Knowing what you are parsing may be
; 1195 : 		// able to allow you to be even more specific about an error.
; 1196 : 		//
; 1197 : 		if	(tokenNames == NULL)

  004b5	83 7d 0c 00	 cmp	 DWORD PTR _tokenNames$[ebp], 0
  004b9	75 24		 jne	 SHORT $LN33@displayRec

; 1198 : 		{
; 1199 : 			ANTLR3_FPRINTF(stderr, " : syntax error...\n");

  004bb	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@CLJLAAJJ@?5?3?5syntax?5error?4?4?4?6@
  004c0	8b f4		 mov	 esi, esp
  004c2	6a 02		 push	 2
  004c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  004ca	83 c4 04	 add	 esp, 4
  004cd	3b f4		 cmp	 esi, esp
  004cf	e8 00 00 00 00	 call	 __RTC_CheckEsp
  004d4	50		 push	 eax
  004d5	e8 00 00 00 00	 call	 _fprintf
  004da	83 c4 08	 add	 esp, 8

; 1200 : 		}

  004dd	eb 5c		 jmp	 SHORT $LN36@displayRec
$LN33@displayRec:

; 1201 : 		else
; 1202 : 		{
; 1203 : 			if	(ex->expecting == ANTLR3_TOKEN_EOF)

  004df	8b 55 e8	 mov	 edx, DWORD PTR _ex$[ebp]
  004e2	83 7a 1c ff	 cmp	 DWORD PTR [edx+28], -1
  004e6	75 24		 jne	 SHORT $LN35@displayRec

; 1204 : 			{
; 1205 : 				ANTLR3_FPRINTF(stderr, " : expected <EOF>\n");

  004e8	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@GBFOJBLI@?5?3?5expected?5?$DMEOF?$DO?6@
  004ed	8b f4		 mov	 esi, esp
  004ef	6a 02		 push	 2
  004f1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  004f7	83 c4 04	 add	 esp, 4
  004fa	3b f4		 cmp	 esi, esp
  004fc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00501	50		 push	 eax
  00502	e8 00 00 00 00	 call	 _fprintf
  00507	83 c4 08	 add	 esp, 8

; 1206 : 			}

  0050a	eb 2f		 jmp	 SHORT $LN36@displayRec
$LN35@displayRec:

; 1207 : 			else
; 1208 : 			{
; 1209 : 				ANTLR3_FPRINTF(stderr, " : expected %s ...\n", tokenNames[ex->expecting]);

  0050c	8b 45 e8	 mov	 eax, DWORD PTR _ex$[ebp]
  0050f	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00512	8b 55 0c	 mov	 edx, DWORD PTR _tokenNames$[ebp]
  00515	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  00518	50		 push	 eax
  00519	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@KIMOAPGN@?5?3?5expected?5?$CFs?5?4?4?4?6@
  0051e	8b f4		 mov	 esi, esp
  00520	6a 02		 push	 2
  00522	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  00528	83 c4 04	 add	 esp, 4
  0052b	3b f4		 cmp	 esi, esp
  0052d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00532	50		 push	 eax
  00533	e8 00 00 00 00	 call	 _fprintf
  00538	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN36@displayRec:

; 1210 : 			}
; 1211 : 		}
; 1212 : 		break;

  0053b	e9 d7 01 00 00	 jmp	 $LN4@displayRec
$LN37@displayRec:

; 1213 : 
; 1214 : 	case	ANTLR3_NO_VIABLE_ALT_EXCEPTION:
; 1215 : 
; 1216 : 		// We could not pick any alt decision from the input given
; 1217 : 		// so god knows what happened - however when you examine your grammar,
; 1218 : 		// you should. It means that at the point where the current token occurred
; 1219 : 		// that the DFA indicates nowhere to go from here.
; 1220 : 		//
; 1221 : 		ANTLR3_FPRINTF(stderr, " : cannot match to any predicted input...\n");

  00540	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@DEBMMGOB@?5?3?5cannot?5match?5to?5any?5predicte@
  00545	8b f4		 mov	 esi, esp
  00547	6a 02		 push	 2
  00549	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  0054f	83 c4 04	 add	 esp, 4
  00552	3b f4		 cmp	 esi, esp
  00554	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00559	50		 push	 eax
  0055a	e8 00 00 00 00	 call	 _fprintf
  0055f	83 c4 08	 add	 esp, 8

; 1222 : 
; 1223 : 		break;

  00562	e9 b0 01 00 00	 jmp	 $LN4@displayRec
$LN38@displayRec:

; 1224 : 
; 1225 : 	case	ANTLR3_MISMATCHED_SET_EXCEPTION:
; 1226 : 
; 1227 : 		{
; 1228 : 			ANTLR3_UINT32	  count;
; 1229 : 			ANTLR3_UINT32	  bit;
; 1230 : 			ANTLR3_UINT32	  size;
; 1231 : 			ANTLR3_UINT32	  numbits;
; 1232 : 			pANTLR3_BITSET	  errBits;
; 1233 : 
; 1234 : 			// This means we were able to deal with one of a set of
; 1235 : 			// possible tokens at this point, but we did not see any
; 1236 : 			// member of that set.
; 1237 : 			//
; 1238 : 			ANTLR3_FPRINTF(stderr, " : unexpected input...\n  expected one of : ");

  00567	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@CIKJCOFM@?5?3?5unexpected?5input?4?4?4?6?5?5expect@
  0056c	8b f4		 mov	 esi, esp
  0056e	6a 02		 push	 2
  00570	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  00576	83 c4 04	 add	 esp, 4
  00579	3b f4		 cmp	 esi, esp
  0057b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00580	50		 push	 eax
  00581	e8 00 00 00 00	 call	 _fprintf
  00586	83 c4 08	 add	 esp, 8

; 1239 : 
; 1240 : 			// What tokens could we have accepted at this point in the
; 1241 : 			// parse?
; 1242 : 			//
; 1243 : 			count   = 0;

  00589	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _count$5[ebp], 0

; 1244 : 			errBits = antlr3BitsetLoad		(ex->expectingSet);

  00590	8b 4d e8	 mov	 ecx, DWORD PTR _ex$[ebp]
  00593	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00596	52		 push	 edx
  00597	e8 00 00 00 00	 call	 _antlr3BitsetLoad
  0059c	83 c4 04	 add	 esp, 4
  0059f	89 45 c8	 mov	 DWORD PTR _errBits$1[ebp], eax

; 1245 : 			numbits = errBits->numBits		(errBits);

  005a2	8b f4		 mov	 esi, esp
  005a4	8b 45 c8	 mov	 eax, DWORD PTR _errBits$1[ebp]
  005a7	50		 push	 eax
  005a8	8b 4d c8	 mov	 ecx, DWORD PTR _errBits$1[ebp]
  005ab	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  005ae	ff d2		 call	 edx
  005b0	83 c4 04	 add	 esp, 4
  005b3	3b f4		 cmp	 esi, esp
  005b5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  005ba	89 45 cc	 mov	 DWORD PTR _numbits$2[ebp], eax

; 1246 : 			size    = errBits->size			(errBits);

  005bd	8b f4		 mov	 esi, esp
  005bf	8b 45 c8	 mov	 eax, DWORD PTR _errBits$1[ebp]
  005c2	50		 push	 eax
  005c3	8b 4d c8	 mov	 ecx, DWORD PTR _errBits$1[ebp]
  005c6	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  005c9	ff d2		 call	 edx
  005cb	83 c4 04	 add	 esp, 4
  005ce	3b f4		 cmp	 esi, esp
  005d0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  005d5	89 45 d0	 mov	 DWORD PTR _size$3[ebp], eax

; 1247 : 
; 1248 : 			if  (size > 0)

  005d8	83 7d d0 00	 cmp	 DWORD PTR _size$3[ebp], 0
  005dc	0f 86 a9 00 00
	00		 jbe	 $LN39@displayRec

; 1249 : 			{
; 1250 : 				// However many tokens we could have dealt with here, it is usually
; 1251 : 				// not useful to print ALL of the set here. I arbitrarily chose 8
; 1252 : 				// here, but you should do whatever makes sense for you of course.
; 1253 : 				// No token number 0, so look for bit 1 and on.
; 1254 : 				//
; 1255 : 				for	(bit = 1; bit < numbits && count < 8 && count < size; bit++)

  005e2	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _bit$4[ebp], 1
  005e9	eb 09		 jmp	 SHORT $LN8@displayRec
$LN6@displayRec:
  005eb	8b 45 d4	 mov	 eax, DWORD PTR _bit$4[ebp]
  005ee	83 c0 01	 add	 eax, 1
  005f1	89 45 d4	 mov	 DWORD PTR _bit$4[ebp], eax
$LN8@displayRec:
  005f4	8b 4d d4	 mov	 ecx, DWORD PTR _bit$4[ebp]
  005f7	3b 4d cc	 cmp	 ecx, DWORD PTR _numbits$2[ebp]
  005fa	73 6b		 jae	 SHORT $LN7@displayRec
  005fc	83 7d d8 08	 cmp	 DWORD PTR _count$5[ebp], 8
  00600	73 65		 jae	 SHORT $LN7@displayRec
  00602	8b 55 d8	 mov	 edx, DWORD PTR _count$5[ebp]
  00605	3b 55 d0	 cmp	 edx, DWORD PTR _size$3[ebp]
  00608	73 5d		 jae	 SHORT $LN7@displayRec

; 1256 : 				{
; 1257 : 					// TODO: This doesn;t look right - should be asking if the bit is set!!
; 1258 : 					//
; 1259 : 					if  (tokenNames[bit])

  0060a	8b 45 d4	 mov	 eax, DWORD PTR _bit$4[ebp]
  0060d	8b 4d 0c	 mov	 ecx, DWORD PTR _tokenNames$[ebp]
  00610	83 3c 81 00	 cmp	 DWORD PTR [ecx+eax*4], 0
  00614	74 4f		 je	 SHORT $LN41@displayRec

; 1260 : 					{
; 1261 : 						ANTLR3_FPRINTF(stderr, "%s%s", count > 0 ? ", " : "", tokenNames[bit]); 

  00616	83 7d d8 00	 cmp	 DWORD PTR _count$5[ebp], 0
  0061a	76 09		 jbe	 SHORT $LN47@displayRec
  0061c	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv307[ebp], OFFSET ??_C@_02KEGNLNML@?0?5@
  00623	eb 07		 jmp	 SHORT $LN48@displayRec
$LN47@displayRec:
  00625	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv307[ebp], OFFSET ??_C@_00CNPNBAHC@@
$LN48@displayRec:
  0062c	8b 55 d4	 mov	 edx, DWORD PTR _bit$4[ebp]
  0062f	8b 45 0c	 mov	 eax, DWORD PTR _tokenNames$[ebp]
  00632	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  00635	51		 push	 ecx
  00636	8b 55 b8	 mov	 edx, DWORD PTR tv307[ebp]
  00639	52		 push	 edx
  0063a	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs@
  0063f	8b f4		 mov	 esi, esp
  00641	6a 02		 push	 2
  00643	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  00649	83 c4 04	 add	 esp, 4
  0064c	3b f4		 cmp	 esi, esp
  0064e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00653	50		 push	 eax
  00654	e8 00 00 00 00	 call	 _fprintf
  00659	83 c4 10	 add	 esp, 16			; 00000010H

; 1262 : 						count++;

  0065c	8b 45 d8	 mov	 eax, DWORD PTR _count$5[ebp]
  0065f	83 c0 01	 add	 eax, 1
  00662	89 45 d8	 mov	 DWORD PTR _count$5[ebp], eax
$LN41@displayRec:

; 1263 : 					}
; 1264 : 				}

  00665	eb 84		 jmp	 SHORT $LN6@displayRec
$LN7@displayRec:

; 1265 : 				ANTLR3_FPRINTF(stderr, "\n");

  00667	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6@
  0066c	8b f4		 mov	 esi, esp
  0066e	6a 02		 push	 2
  00670	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  00676	83 c4 04	 add	 esp, 4
  00679	3b f4		 cmp	 esi, esp
  0067b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00680	50		 push	 eax
  00681	e8 00 00 00 00	 call	 _fprintf
  00686	83 c4 08	 add	 esp, 8

; 1266 : 			}

  00689	eb 44		 jmp	 SHORT $LN40@displayRec
$LN39@displayRec:

; 1267 : 			else
; 1268 : 			{
; 1269 : 				ANTLR3_FPRINTF(stderr, "Actually dude, we didn't seem to be expecting anything here, or at least\n");

  0068b	68 00 00 00 00	 push	 OFFSET ??_C@_0EK@GLJFAOIP@Actually?5dude?0?5we?5didn?8t?5seem?5t@
  00690	8b f4		 mov	 esi, esp
  00692	6a 02		 push	 2
  00694	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  0069a	83 c4 04	 add	 esp, 4
  0069d	3b f4		 cmp	 esi, esp
  0069f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  006a4	50		 push	 eax
  006a5	e8 00 00 00 00	 call	 _fprintf
  006aa	83 c4 08	 add	 esp, 8

; 1270 : 				ANTLR3_FPRINTF(stderr, "I could not work out what I was expecting, like so many of us these days!\n");

  006ad	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@LCDOFIDJ@I?5could?5not?5work?5out?5what?5I?5was@
  006b2	8b f4		 mov	 esi, esp
  006b4	6a 02		 push	 2
  006b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  006bc	83 c4 04	 add	 esp, 4
  006bf	3b f4		 cmp	 esi, esp
  006c1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  006c6	50		 push	 eax
  006c7	e8 00 00 00 00	 call	 _fprintf
  006cc	83 c4 08	 add	 esp, 8
$LN40@displayRec:

; 1271 : 			}
; 1272 : 		}
; 1273 : 		break;

  006cf	eb 46		 jmp	 SHORT $LN4@displayRec
$LN42@displayRec:

; 1274 : 
; 1275 : 	case	ANTLR3_EARLY_EXIT_EXCEPTION:
; 1276 : 
; 1277 : 		// We entered a loop requiring a number of token sequences
; 1278 : 		// but found a token that ended that sequence earlier than
; 1279 : 		// we should have done.
; 1280 : 		//
; 1281 : 		ANTLR3_FPRINTF(stderr, " : missing elements...\n");

  006d1	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@LEAIIGMG@?5?3?5missing?5elements?4?4?4?6@
  006d6	8b f4		 mov	 esi, esp
  006d8	6a 02		 push	 2
  006da	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  006e0	83 c4 04	 add	 esp, 4
  006e3	3b f4		 cmp	 esi, esp
  006e5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  006ea	50		 push	 eax
  006eb	e8 00 00 00 00	 call	 _fprintf
  006f0	83 c4 08	 add	 esp, 8

; 1282 : 		break;

  006f3	eb 22		 jmp	 SHORT $LN4@displayRec
$LN43@displayRec:

; 1283 : 
; 1284 : 	default:
; 1285 : 
; 1286 : 		// We don't handle any other exceptions here, but you can
; 1287 : 		// if you wish. If we get an exception that hits this point
; 1288 : 		// then we are just going to report what we know about the
; 1289 : 		// token.
; 1290 : 		//
; 1291 : 		ANTLR3_FPRINTF(stderr, " : syntax not recognized...\n");

  006f5	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@OMNOHKEK@?5?3?5syntax?5not?5recognized?4?4?4?6@
  006fa	8b f4		 mov	 esi, esp
  006fc	6a 02		 push	 2
  006fe	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  00704	83 c4 04	 add	 esp, 4
  00707	3b f4		 cmp	 esi, esp
  00709	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0070e	50		 push	 eax
  0070f	e8 00 00 00 00	 call	 _fprintf
  00714	83 c4 08	 add	 esp, 8
$LN4@displayRec:

; 1292 : 		break;
; 1293 : 	}
; 1294 : 
; 1295 : 	// Here you have the token that was in error which if this is
; 1296 : 	// the standard implementation will tell you the line and offset
; 1297 : 	// and also record the address of the start of the line in the
; 1298 : 	// input stream. You could therefore print the source line and so on.
; 1299 : 	// Generally though, I would expect that your lexer/parser will keep
; 1300 : 	// its own map of lines and source pointers or whatever as there
; 1301 : 	// are a lot of specific things you need to know about the input
; 1302 : 	// to do something like that.
; 1303 : 	// Here is where you do it though :-).
; 1304 : 	//
; 1305 : }

  00717	5f		 pop	 edi
  00718	5e		 pop	 esi
  00719	83 c4 48	 add	 esp, 72			; 00000048H
  0071c	3b ec		 cmp	 ebp, esp
  0071e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00723	8b e5		 mov	 esp, ebp
  00725	5d		 pop	 ebp
  00726	c3		 ret	 0
  00727	90		 npad	 1
$LN49@displayRec:
  00728	00 00 00 00	 DD	 $LN31@displayRec
  0072c	00 00 00 00	 DD	 $LN32@displayRec
  00730	00 00 00 00	 DD	 $LN37@displayRec
  00734	00 00 00 00	 DD	 $LN38@displayRec
  00738	00 00 00 00	 DD	 $LN42@displayRec
  0073c	00 00 00 00	 DD	 $LN43@displayRec
  00740	00 00 00 00	 DD	 $LN43@displayRec
  00744	00 00 00 00	 DD	 $LN43@displayRec
  00748	00 00 00 00	 DD	 $LN21@displayRec
  0074c	00 00 00 00	 DD	 $LN26@displayRec
_displayRecognitionError ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3baserecognizer.c
;	COMDAT _combineFollows
_TEXT	SEGMENT
_i$ = -16						; size = 4
_top$ = -12						; size = 4
_localFollowSet$ = -8					; size = 4
_followSet$ = -4					; size = 4
_recognizer$ = 8					; size = 4
_exact$ = 12						; size = 1
_combineFollows PROC					; COMDAT

; 948  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000f	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00012	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00015	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 949  :     pANTLR3_BITSET	followSet;
; 950  :     pANTLR3_BITSET	localFollowSet;
; 951  :     ANTLR3_UINT32	top;
; 952  :     ANTLR3_UINT32	i;
; 953  : 
; 954  :     top	= recognizer->state->following->size(recognizer->state->following);

  00018	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  0001b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0001e	8b f4		 mov	 esi, esp
  00020	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00023	52		 push	 edx
  00024	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  00027	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0002a	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0002d	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00030	ff d0		 call	 eax
  00032	83 c4 04	 add	 esp, 4
  00035	3b f4		 cmp	 esi, esp
  00037	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003c	89 45 f4	 mov	 DWORD PTR _top$[ebp], eax

; 955  : 
; 956  :     followSet	    = antlr3BitsetNew(0);

  0003f	6a 00		 push	 0
  00041	e8 00 00 00 00	 call	 _antlr3BitsetNew
  00046	83 c4 04	 add	 esp, 4
  00049	89 45 fc	 mov	 DWORD PTR _followSet$[ebp], eax

; 957  : 	localFollowSet	= NULL;

  0004c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _localFollowSet$[ebp], 0

; 958  : 
; 959  :     for (i = top; i>0; i--)

  00053	8b 4d f4	 mov	 ecx, DWORD PTR _top$[ebp]
  00056	89 4d f0	 mov	 DWORD PTR _i$[ebp], ecx
  00059	eb 09		 jmp	 SHORT $LN4@combineFol
$LN2@combineFol:
  0005b	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  0005e	83 ea 01	 sub	 edx, 1
  00061	89 55 f0	 mov	 DWORD PTR _i$[ebp], edx
$LN4@combineFol:
  00064	83 7d f0 00	 cmp	 DWORD PTR _i$[ebp], 0
  00068	0f 86 d0 00 00
	00		 jbe	 $LN3@combineFol

; 960  :     {
; 961  : 		localFollowSet = antlr3BitsetLoad((pANTLR3_BITSET_LIST) recognizer->state->following->get(recognizer->state->following, i-1));

  0006e	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  00071	83 e8 01	 sub	 eax, 1
  00074	8b f4		 mov	 esi, esp
  00076	50		 push	 eax
  00077	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  0007a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0007d	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00080	50		 push	 eax
  00081	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  00084	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00087	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0008a	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0008d	ff d1		 call	 ecx
  0008f	83 c4 08	 add	 esp, 8
  00092	3b f4		 cmp	 esi, esp
  00094	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00099	50		 push	 eax
  0009a	e8 00 00 00 00	 call	 _antlr3BitsetLoad
  0009f	83 c4 04	 add	 esp, 4
  000a2	89 45 f8	 mov	 DWORD PTR _localFollowSet$[ebp], eax

; 962  : 
; 963  : 		if  (localFollowSet != NULL)

  000a5	83 7d f8 00	 cmp	 DWORD PTR _localFollowSet$[ebp], 0
  000a9	0f 84 8a 00 00
	00		 je	 $LN5@combineFol

; 964  : 		{
; 965  : 			followSet->borInPlace(followSet, localFollowSet);

  000af	8b f4		 mov	 esi, esp
  000b1	8b 55 f8	 mov	 edx, DWORD PTR _localFollowSet$[ebp]
  000b4	52		 push	 edx
  000b5	8b 45 fc	 mov	 eax, DWORD PTR _followSet$[ebp]
  000b8	50		 push	 eax
  000b9	8b 4d fc	 mov	 ecx, DWORD PTR _followSet$[ebp]
  000bc	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  000bf	ff d2		 call	 edx
  000c1	83 c4 08	 add	 esp, 8
  000c4	3b f4		 cmp	 esi, esp
  000c6	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 966  : 
; 967  : 			if	(exact == ANTLR3_TRUE)

  000cb	0f b6 45 0c	 movzx	 eax, BYTE PTR _exact$[ebp]
  000cf	83 f8 01	 cmp	 eax, 1
  000d2	75 46		 jne	 SHORT $LN8@combineFol

; 968  : 			{
; 969  : 				if	(localFollowSet->isMember(localFollowSet, ANTLR3_EOR_TOKEN_TYPE) == ANTLR3_FALSE)

  000d4	8b f4		 mov	 esi, esp
  000d6	6a 01		 push	 1
  000d8	8b 4d f8	 mov	 ecx, DWORD PTR _localFollowSet$[ebp]
  000db	51		 push	 ecx
  000dc	8b 55 f8	 mov	 edx, DWORD PTR _localFollowSet$[ebp]
  000df	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  000e2	ff d0		 call	 eax
  000e4	83 c4 08	 add	 esp, 8
  000e7	3b f4		 cmp	 esi, esp
  000e9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ee	0f b6 c8	 movzx	 ecx, al
  000f1	85 c9		 test	 ecx, ecx
  000f3	75 23		 jne	 SHORT $LN7@combineFol

; 970  : 				{
; 971  : 					// Only leave EOR in the set if at top (start rule); this lets us know
; 972  : 					// if we have to include the follow(start rule); I.E., EOF
; 973  : 					//
; 974  : 					if	(i>1)

  000f5	83 7d f0 01	 cmp	 DWORD PTR _i$[ebp], 1
  000f9	76 1b		 jbe	 SHORT $LN9@combineFol

; 975  : 					{
; 976  : 						followSet->remove(followSet, ANTLR3_EOR_TOKEN_TYPE);

  000fb	8b f4		 mov	 esi, esp
  000fd	6a 01		 push	 1
  000ff	8b 55 fc	 mov	 edx, DWORD PTR _followSet$[ebp]
  00102	52		 push	 edx
  00103	8b 45 fc	 mov	 eax, DWORD PTR _followSet$[ebp]
  00106	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  00109	ff d1		 call	 ecx
  0010b	83 c4 08	 add	 esp, 8
  0010e	3b f4		 cmp	 esi, esp
  00110	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00115	90		 npad	 1
$LN9@combineFol:

; 977  : 					}
; 978  : 				}

  00116	eb 02		 jmp	 SHORT $LN8@combineFol
$LN7@combineFol:

; 979  : 				else
; 980  : 				{
; 981  : 					break;	// Cannot see End Of Rule from here, just drop out

  00118	eb 24		 jmp	 SHORT $LN3@combineFol
$LN8@combineFol:

; 982  : 				}
; 983  : 			}
; 984  : 			localFollowSet->free(localFollowSet);

  0011a	8b f4		 mov	 esi, esp
  0011c	8b 55 f8	 mov	 edx, DWORD PTR _localFollowSet$[ebp]
  0011f	52		 push	 edx
  00120	8b 45 f8	 mov	 eax, DWORD PTR _localFollowSet$[ebp]
  00123	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00126	ff d1		 call	 ecx
  00128	83 c4 04	 add	 esp, 4
  0012b	3b f4		 cmp	 esi, esp
  0012d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 985  : 			localFollowSet = NULL;

  00132	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _localFollowSet$[ebp], 0
$LN5@combineFol:

; 986  : 		}
; 987  :     }

  00139	e9 1d ff ff ff	 jmp	 $LN2@combineFol
$LN3@combineFol:

; 988  : 
; 989  : 	if	(localFollowSet != NULL)

  0013e	83 7d f8 00	 cmp	 DWORD PTR _localFollowSet$[ebp], 0
  00142	74 19		 je	 SHORT $LN10@combineFol

; 990  : 	{
; 991  : 		localFollowSet->free(localFollowSet);

  00144	8b f4		 mov	 esi, esp
  00146	8b 55 f8	 mov	 edx, DWORD PTR _localFollowSet$[ebp]
  00149	52		 push	 edx
  0014a	8b 45 f8	 mov	 eax, DWORD PTR _localFollowSet$[ebp]
  0014d	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00150	ff d1		 call	 ecx
  00152	83 c4 04	 add	 esp, 4
  00155	3b f4		 cmp	 esi, esp
  00157	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0015c	90		 npad	 1
$LN10@combineFol:

; 992  : 	}
; 993  :     return  followSet;

  0015d	8b 45 fc	 mov	 eax, DWORD PTR _followSet$[ebp]

; 994  : }

  00160	5e		 pop	 esi
  00161	83 c4 10	 add	 esp, 16			; 00000010H
  00164	3b ec		 cmp	 ebp, esp
  00166	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0016b	8b e5		 mov	 esp, ebp
  0016d	5d		 pop	 ebp
  0016e	c3		 ret	 0
_combineFollows ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3baserecognizer.c
;	COMDAT _computeCSRuleFollow
_TEXT	SEGMENT
_recognizer$ = 8					; size = 4
_computeCSRuleFollow PROC				; COMDAT

; 940  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 941  :     return   recognizer->combineFollows(recognizer, ANTLR3_FALSE);

  00004	8b f4		 mov	 esi, esp
  00006	6a 00		 push	 0
  00008	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  0000f	8b 51 4c	 mov	 edx, DWORD PTR [ecx+76]
  00012	ff d2		 call	 edx
  00014	83 c4 08	 add	 esp, 8
  00017	3b f4		 cmp	 esi, esp
  00019	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 942  : }

  0001e	5e		 pop	 esi
  0001f	3b ec		 cmp	 ebp, esp
  00021	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
_computeCSRuleFollow ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3baserecognizer.c
;	COMDAT _reportError
_TEXT	SEGMENT
_recognizer$ = 8					; size = 4
_reportError PROC					; COMDAT

; 722  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 723  :     	// Invoke the debugger event if there is a debugger listening to us
; 724  : 	//
; 725  : 	if	(recognizer->debugger != NULL)

  00004	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  00007	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  0000b	74 29		 je	 SHORT $LN2@reportErro

; 726  : 	{
; 727  : 		recognizer->debugger->recognitionException(recognizer->debugger, recognizer->state->exception);

  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  00010	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00013	8b f4		 mov	 esi, esp
  00015	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  0001c	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0001f	52		 push	 edx
  00020	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  00023	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00026	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  00029	ff d2		 call	 edx
  0002b	83 c4 08	 add	 esp, 8
  0002e	3b f4		 cmp	 esi, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	90		 npad	 1
$LN2@reportErro:

; 728  : 	}
; 729  : 
; 730  :     if	(recognizer->state->errorRecovery == ANTLR3_TRUE)

  00036	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  00039	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0003c	0f b6 51 10	 movzx	 edx, BYTE PTR [ecx+16]
  00040	83 fa 01	 cmp	 edx, 1
  00043	75 02		 jne	 SHORT $LN3@reportErro

; 731  :     {
; 732  : 		// Already in error recovery so don't display another error while doing so
; 733  : 		//
; 734  : 		return;

  00045	eb 42		 jmp	 SHORT $LN1@reportErro
$LN3@reportErro:

; 735  :     }
; 736  : 
; 737  :     // Signal we are in error recovery now
; 738  :     //
; 739  :     recognizer->state->errorRecovery = ANTLR3_TRUE;

  00047	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  0004a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0004d	c6 41 10 01	 mov	 BYTE PTR [ecx+16], 1

; 740  : 	
; 741  : 	// Indicate this recognizer had an error while processing.
; 742  : 	//
; 743  : 	recognizer->state->errorCount++;

  00051	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  00054	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00057	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0005a	83 c1 01	 add	 ecx, 1
  0005d	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  00060	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00063	89 48 1c	 mov	 DWORD PTR [eax+28], ecx

; 744  : 
; 745  : 	// Call the error display routine
; 746  : 	//
; 747  :     recognizer->displayRecognitionError(recognizer, recognizer->state->tokenNames);

  00066	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  00069	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0006c	8b f4		 mov	 esi, esp
  0006e	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  00071	50		 push	 eax
  00072	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  00075	51		 push	 ecx
  00076	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  00079	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  0007c	ff d0		 call	 eax
  0007e	83 c4 08	 add	 esp, 8
  00081	3b f4		 cmp	 esi, esp
  00083	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00088	90		 npad	 1
$LN1@reportErro:

; 748  : }

  00089	5e		 pop	 esi
  0008a	3b ec		 cmp	 ebp, esp
  0008c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00091	5d		 pop	 ebp
  00092	c3		 ret	 0
_reportError ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3baserecognizer.c
;	COMDAT _mismatchIsMissingToken
_TEXT	SEGMENT
_viableTokensFollowingThisRule$ = -12			; size = 4
_followClone$ = -8					; size = 4
_retcode$ = -1						; size = 1
_recognizer$ = 8					; size = 4
_is$ = 12						; size = 4
_follow$ = 16						; size = 4
_mismatchIsMissingToken PROC				; COMDAT

; 553  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000e	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00015	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 554  : 	ANTLR3_BOOLEAN	retcode;
; 555  : 	pANTLR3_BITSET	followClone;
; 556  : 	pANTLR3_BITSET	viableTokensFollowingThisRule;
; 557  : 
; 558  : 	if	(follow == NULL)

  0001c	83 7d 10 00	 cmp	 DWORD PTR _follow$[ebp], 0
  00020	75 07		 jne	 SHORT $LN2@mismatchIs

; 559  : 	{
; 560  : 		// There is no information about the tokens that can follow the last one
; 561  : 		// hence we must say that the current one we found is not a member of the 
; 562  : 		// follow set and does not indicate a missing token. We will just consume this
; 563  : 		// single token and see if the parser works it out from there.
; 564  : 		//
; 565  : 		return	ANTLR3_FALSE;

  00022	32 c0		 xor	 al, al
  00024	e9 44 01 00 00	 jmp	 $LN1@mismatchIs
$LN2@mismatchIs:

; 566  : 	}
; 567  : 
; 568  : 	followClone						= NULL;

  00029	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _followClone$[ebp], 0

; 569  : 	viableTokensFollowingThisRule	= NULL;

  00030	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _viableTokensFollowingThisRule$[ebp], 0

; 570  : 
; 571  : 	// The C bitset maps are laid down at compile time by the
; 572  : 	// C code generation. Hence we cannot remove things from them
; 573  : 	// and so on. So, in order to remove EOR (if we need to) then
; 574  : 	// we clone the static bitset.
; 575  : 	//
; 576  : 	followClone = antlr3BitsetLoad(follow);

  00037	8b 45 10	 mov	 eax, DWORD PTR _follow$[ebp]
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 _antlr3BitsetLoad
  00040	83 c4 04	 add	 esp, 4
  00043	89 45 f8	 mov	 DWORD PTR _followClone$[ebp], eax

; 577  : 	if	(followClone == NULL)

  00046	83 7d f8 00	 cmp	 DWORD PTR _followClone$[ebp], 0
  0004a	75 07		 jne	 SHORT $LN3@mismatchIs

; 578  : 	{
; 579  : 		return ANTLR3_FALSE;

  0004c	32 c0		 xor	 al, al
  0004e	e9 1a 01 00 00	 jmp	 $LN1@mismatchIs
$LN3@mismatchIs:

; 580  : 	}
; 581  : 
; 582  : 	// Compute what can follow this grammar reference
; 583  : 	//
; 584  : 	if	(followClone->isMember(followClone, ANTLR3_EOR_TOKEN_TYPE))

  00053	8b f4		 mov	 esi, esp
  00055	6a 01		 push	 1
  00057	8b 4d f8	 mov	 ecx, DWORD PTR _followClone$[ebp]
  0005a	51		 push	 ecx
  0005b	8b 55 f8	 mov	 edx, DWORD PTR _followClone$[ebp]
  0005e	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00061	ff d0		 call	 eax
  00063	83 c4 08	 add	 esp, 8
  00066	3b f4		 cmp	 esi, esp
  00068	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006d	0f b6 c8	 movzx	 ecx, al
  00070	85 c9		 test	 ecx, ecx
  00072	74 53		 je	 SHORT $LN4@mismatchIs

; 585  : 	{
; 586  : 		// EOR can follow, but if we are not the start symbol, we
; 587  : 		// need to remove it.
; 588  : 		//
; 589  : 		//if	(recognizer->state->following->vector->count >= 0) ml: always true
; 590  : 		{
; 591  : 			followClone->remove(followClone, ANTLR3_EOR_TOKEN_TYPE);

  00074	8b f4		 mov	 esi, esp
  00076	6a 01		 push	 1
  00078	8b 55 f8	 mov	 edx, DWORD PTR _followClone$[ebp]
  0007b	52		 push	 edx
  0007c	8b 45 f8	 mov	 eax, DWORD PTR _followClone$[ebp]
  0007f	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  00082	ff d1		 call	 ecx
  00084	83 c4 08	 add	 esp, 8
  00087	3b f4		 cmp	 esi, esp
  00089	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008e	90		 npad	 1

; 592  : 		}
; 593  : 
; 594  : 		// Now compute the visiable tokens that can follow this rule, according to context
; 595  : 		// and make them part of the follow set.
; 596  : 		//
; 597  : 		viableTokensFollowingThisRule = recognizer->computeCSRuleFollow(recognizer);

  0008f	8b f4		 mov	 esi, esp
  00091	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  00094	52		 push	 edx
  00095	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  00098	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  0009b	ff d1		 call	 ecx
  0009d	83 c4 04	 add	 esp, 4
  000a0	3b f4		 cmp	 esi, esp
  000a2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a7	89 45 f4	 mov	 DWORD PTR _viableTokensFollowingThisRule$[ebp], eax

; 598  : 		followClone->borInPlace(followClone, viableTokensFollowingThisRule);

  000aa	8b f4		 mov	 esi, esp
  000ac	8b 55 f4	 mov	 edx, DWORD PTR _viableTokensFollowingThisRule$[ebp]
  000af	52		 push	 edx
  000b0	8b 45 f8	 mov	 eax, DWORD PTR _followClone$[ebp]
  000b3	50		 push	 eax
  000b4	8b 4d f8	 mov	 ecx, DWORD PTR _followClone$[ebp]
  000b7	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  000ba	ff d2		 call	 edx
  000bc	83 c4 08	 add	 esp, 8
  000bf	3b f4		 cmp	 esi, esp
  000c1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c6	90		 npad	 1
$LN4@mismatchIs:

; 599  : 	}
; 600  : 
; 601  : 	/// if current token is consistent with what could come after set
; 602  : 	/// then we know we're missing a token; error recovery is free to
; 603  : 	/// "insert" the missing token
; 604  : 	///
; 605  : 	/// BitSet cannot handle negative numbers like -1 (EOF) so I leave EOR
; 606  : 	/// in follow set to indicate that the fall of the start symbol is
; 607  : 	/// in the set (EOF can follow).
; 608  : 	///
; 609  : 	if	(		followClone->isMember(followClone, is->_LA(is, 1))
; 610  : 			||	followClone->isMember(followClone, ANTLR3_EOR_TOKEN_TYPE)

  000c7	8b f4		 mov	 esi, esp
  000c9	6a 01		 push	 1
  000cb	8b 45 0c	 mov	 eax, DWORD PTR _is$[ebp]
  000ce	50		 push	 eax
  000cf	8b 4d 0c	 mov	 ecx, DWORD PTR _is$[ebp]
  000d2	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  000d5	ff d2		 call	 edx
  000d7	83 c4 08	 add	 esp, 8
  000da	3b f4		 cmp	 esi, esp
  000dc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e1	8b f4		 mov	 esi, esp
  000e3	50		 push	 eax
  000e4	8b 45 f8	 mov	 eax, DWORD PTR _followClone$[ebp]
  000e7	50		 push	 eax
  000e8	8b 4d f8	 mov	 ecx, DWORD PTR _followClone$[ebp]
  000eb	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  000ee	ff d2		 call	 edx
  000f0	83 c4 08	 add	 esp, 8
  000f3	3b f4		 cmp	 esi, esp
  000f5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000fa	0f b6 c0	 movzx	 eax, al
  000fd	85 c0		 test	 eax, eax
  000ff	75 21		 jne	 SHORT $LN7@mismatchIs
  00101	8b f4		 mov	 esi, esp
  00103	6a 01		 push	 1
  00105	8b 4d f8	 mov	 ecx, DWORD PTR _followClone$[ebp]
  00108	51		 push	 ecx
  00109	8b 55 f8	 mov	 edx, DWORD PTR _followClone$[ebp]
  0010c	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  0010f	ff d0		 call	 eax
  00111	83 c4 08	 add	 esp, 8
  00114	3b f4		 cmp	 esi, esp
  00116	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0011b	0f b6 c8	 movzx	 ecx, al
  0011e	85 c9		 test	 ecx, ecx
  00120	74 06		 je	 SHORT $LN5@mismatchIs
$LN7@mismatchIs:

; 611  : 		)
; 612  : 	{
; 613  : 		retcode = ANTLR3_TRUE;

  00122	c6 45 ff 01	 mov	 BYTE PTR _retcode$[ebp], 1

; 614  : 	}

  00126	eb 04		 jmp	 SHORT $LN6@mismatchIs
$LN5@mismatchIs:

; 615  : 	else
; 616  : 	{
; 617  : 		retcode	= ANTLR3_FALSE;

  00128	c6 45 ff 00	 mov	 BYTE PTR _retcode$[ebp], 0
$LN6@mismatchIs:

; 618  : 	}
; 619  : 
; 620  : 	if	(viableTokensFollowingThisRule != NULL)

  0012c	83 7d f4 00	 cmp	 DWORD PTR _viableTokensFollowingThisRule$[ebp], 0
  00130	74 19		 je	 SHORT $LN8@mismatchIs

; 621  : 	{
; 622  : 		viableTokensFollowingThisRule->free(viableTokensFollowingThisRule);

  00132	8b f4		 mov	 esi, esp
  00134	8b 55 f4	 mov	 edx, DWORD PTR _viableTokensFollowingThisRule$[ebp]
  00137	52		 push	 edx
  00138	8b 45 f4	 mov	 eax, DWORD PTR _viableTokensFollowingThisRule$[ebp]
  0013b	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  0013e	ff d1		 call	 ecx
  00140	83 c4 04	 add	 esp, 4
  00143	3b f4		 cmp	 esi, esp
  00145	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0014a	90		 npad	 1
$LN8@mismatchIs:

; 623  : 	}
; 624  : 	if	(followClone != NULL)

  0014b	83 7d f8 00	 cmp	 DWORD PTR _followClone$[ebp], 0
  0014f	74 19		 je	 SHORT $LN9@mismatchIs

; 625  : 	{
; 626  : 		followClone->free(followClone);

  00151	8b f4		 mov	 esi, esp
  00153	8b 55 f8	 mov	 edx, DWORD PTR _followClone$[ebp]
  00156	52		 push	 edx
  00157	8b 45 f8	 mov	 eax, DWORD PTR _followClone$[ebp]
  0015a	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  0015d	ff d1		 call	 ecx
  0015f	83 c4 04	 add	 esp, 4
  00162	3b f4		 cmp	 esi, esp
  00164	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00169	90		 npad	 1
$LN9@mismatchIs:

; 627  : 	}
; 628  : 
; 629  : 	return retcode;

  0016a	8a 45 ff	 mov	 al, BYTE PTR _retcode$[ebp]
$LN1@mismatchIs:

; 630  : 
; 631  : }

  0016d	5e		 pop	 esi
  0016e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00171	3b ec		 cmp	 ebp, esp
  00173	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00178	8b e5		 mov	 esp, ebp
  0017a	5d		 pop	 ebp
  0017b	c3		 ret	 0
_mismatchIsMissingToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3baserecognizer.c
;	COMDAT _mismatchIsUnwantedToken
_TEXT	SEGMENT
_nextt$ = -4						; size = 4
_recognizer$ = 8					; size = 4
_is$ = 12						; size = 4
_ttype$ = 16						; size = 4
_mismatchIsUnwantedToken PROC				; COMDAT

; 530  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 531  : 	ANTLR3_UINT32 nextt;
; 532  : 
; 533  : 	nextt = is->_LA(is, 2);

  0000c	8b f4		 mov	 esi, esp
  0000e	6a 02		 push	 2
  00010	8b 45 0c	 mov	 eax, DWORD PTR _is$[ebp]
  00013	50		 push	 eax
  00014	8b 4d 0c	 mov	 ecx, DWORD PTR _is$[ebp]
  00017	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0001a	ff d2		 call	 edx
  0001c	83 c4 08	 add	 esp, 8
  0001f	3b f4		 cmp	 esi, esp
  00021	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00026	89 45 fc	 mov	 DWORD PTR _nextt$[ebp], eax

; 534  : 
; 535  : 	if	(nextt == ttype)

  00029	8b 45 fc	 mov	 eax, DWORD PTR _nextt$[ebp]
  0002c	3b 45 10	 cmp	 eax, DWORD PTR _ttype$[ebp]
  0002f	75 21		 jne	 SHORT $LN2@mismatchIs

; 536  : 	{
; 537  : 		if	(recognizer->state->exception != NULL)

  00031	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  00034	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00037	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  0003b	74 0f		 je	 SHORT $LN4@mismatchIs

; 538  : 		{
; 539  : 			recognizer->state->exception->expecting = nextt;

  0003d	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  00040	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00043	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00046	8b 45 fc	 mov	 eax, DWORD PTR _nextt$[ebp]
  00049	89 42 1c	 mov	 DWORD PTR [edx+28], eax
$LN4@mismatchIs:

; 540  : 		}
; 541  : 		return ANTLR3_TRUE;		// This token is unknown, but the next one is the one we wanted

  0004c	b0 01		 mov	 al, 1
  0004e	eb 04		 jmp	 SHORT $LN3@mismatchIs

; 542  : 	}

  00050	eb 02		 jmp	 SHORT $LN3@mismatchIs
$LN2@mismatchIs:

; 543  : 	else
; 544  : 	{
; 545  : 		return ANTLR3_FALSE;	// Neither this token, nor the one following is the one we wanted

  00052	32 c0		 xor	 al, al
$LN3@mismatchIs:

; 546  : 	}
; 547  : }

  00054	5e		 pop	 esi
  00055	83 c4 04	 add	 esp, 4
  00058	3b ec		 cmp	 ebp, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
_mismatchIsUnwantedToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3baserecognizer.c
;	COMDAT _mismatch
_TEXT	SEGMENT
tv69 = -16						; size = 4
_is$ = -12						; size = 4
_tparser$ = -8						; size = 4
_parser$ = -4						; size = 4
_recognizer$ = 8					; size = 4
_ttype$ = 12						; size = 4
_follow$ = 16						; size = 4
_mismatch PROC						; COMDAT

; 643  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000f	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00012	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00015	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 644  :     pANTLR3_PARSER	    parser;
; 645  :     pANTLR3_TREE_PARSER	    tparser;
; 646  :     pANTLR3_INT_STREAM	    is;
; 647  : 
; 648  :     // Install a mismatched token exception in the exception stack
; 649  :     //
; 650  :     antlr3MTExceptionNew(recognizer);

  00018	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _antlr3MTExceptionNew
  00021	83 c4 04	 add	 esp, 4

; 651  :     recognizer->state->exception->expecting    = ttype;

  00024	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  00027	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0002a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0002d	8b 4d 0c	 mov	 ecx, DWORD PTR _ttype$[ebp]
  00030	89 48 1c	 mov	 DWORD PTR [eax+28], ecx

; 652  : 
; 653  :     switch	(recognizer->type)

  00033	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  00036	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00039	89 45 f0	 mov	 DWORD PTR tv69[ebp], eax
  0003c	83 7d f0 02	 cmp	 DWORD PTR tv69[ebp], 2
  00040	74 02		 je	 SHORT $LN4@mismatch
  00042	eb 1d		 jmp	 SHORT $LN5@mismatch
$LN4@mismatch:

; 654  :     {
; 655  : 		case	ANTLR3_TYPE_PARSER:
; 656  : 
; 657  : 			parser  = (pANTLR3_PARSER) (recognizer->super);

  00044	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  00047	8b 11		 mov	 edx, DWORD PTR [ecx]
  00049	89 55 fc	 mov	 DWORD PTR _parser$[ebp], edx

; 658  : 			tparser	= NULL;

  0004c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _tparser$[ebp], 0

; 659  : 			is	= parser->tstream->istream;

  00053	8b 45 fc	 mov	 eax, DWORD PTR _parser$[ebp]
  00056	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00059	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0005c	89 55 f4	 mov	 DWORD PTR _is$[ebp], edx

; 660  : 
; 661  : 			break;

  0005f	eb 27		 jmp	 SHORT $LN2@mismatch
$LN5@mismatch:

; 662  : 
; 663  : 		default:
; 664  : 		    
; 665  : 			ANTLR3_FPRINTF(stderr, "Base recognizer function 'mismatch' called by unknown parser type - provide override for this function\n");

  00061	68 00 00 00 00	 push	 OFFSET ??_C@_0GI@PGJHCPC@Base?5recognizer?5function?5?8misma@
  00066	8b f4		 mov	 esi, esp
  00068	6a 02		 push	 2
  0006a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  00070	83 c4 04	 add	 esp, 4
  00073	3b f4		 cmp	 esi, esp
  00075	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007a	50		 push	 eax
  0007b	e8 00 00 00 00	 call	 _fprintf
  00080	83 c4 08	 add	 esp, 8

; 666  : 			return;

  00083	e9 9c 00 00 00	 jmp	 $LN1@mismatch
$LN2@mismatch:

; 667  : 
; 668  : 			break;
; 669  :     }
; 670  : 
; 671  : 	if	(mismatchIsUnwantedToken(recognizer, is, ttype))

  00088	8b 45 0c	 mov	 eax, DWORD PTR _ttype$[ebp]
  0008b	50		 push	 eax
  0008c	8b 4d f4	 mov	 ecx, DWORD PTR _is$[ebp]
  0008f	51		 push	 ecx
  00090	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  00093	52		 push	 edx
  00094	e8 00 00 00 00	 call	 _mismatchIsUnwantedToken
  00099	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009c	0f b6 c0	 movzx	 eax, al
  0009f	85 c0		 test	 eax, eax
  000a1	74 2d		 je	 SHORT $LN6@mismatch

; 672  : 	{
; 673  : 		// Create a basic recognition exception structure
; 674  : 		//
; 675  : 	    antlr3RecognitionExceptionNew(recognizer);

  000a3	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  000a6	51		 push	 ecx
  000a7	e8 00 00 00 00	 call	 _antlr3RecognitionExceptionNew
  000ac	83 c4 04	 add	 esp, 4

; 676  : 		
; 677  : 		// Now update it to indicate this is an unwanted token exception
; 678  : 		//
; 679  : 		recognizer->state->exception->name		= ANTLR3_UNWANTED_TOKEN_EXCEPTION_NAME;

  000af	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  000b2	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000b5	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000b8	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET ??_C@_0CJ@DEJOPFAB@org?4antlr?4runtime?4UnwantedToken@

; 680  : 		recognizer->state->exception->type		= ANTLR3_UNWANTED_TOKEN_EXCEPTION;

  000bf	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  000c2	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000c5	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000c8	c7 01 09 00 00
	00		 mov	 DWORD PTR [ecx], 9

; 681  : 
; 682  : 		return;

  000ce	eb 54		 jmp	 SHORT $LN1@mismatch
$LN6@mismatch:

; 683  : 	}
; 684  : 	
; 685  : 	if	(mismatchIsMissingToken(recognizer, is, follow))

  000d0	8b 55 10	 mov	 edx, DWORD PTR _follow$[ebp]
  000d3	52		 push	 edx
  000d4	8b 45 f4	 mov	 eax, DWORD PTR _is$[ebp]
  000d7	50		 push	 eax
  000d8	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  000db	51		 push	 ecx
  000dc	e8 00 00 00 00	 call	 _mismatchIsMissingToken
  000e1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e4	0f b6 d0	 movzx	 edx, al
  000e7	85 d2		 test	 edx, edx
  000e9	74 2d		 je	 SHORT $LN7@mismatch

; 686  : 	{
; 687  : 		// Create a basic recognition exception structure
; 688  : 		//
; 689  : 	    antlr3RecognitionExceptionNew(recognizer);

  000eb	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  000ee	50		 push	 eax
  000ef	e8 00 00 00 00	 call	 _antlr3RecognitionExceptionNew
  000f4	83 c4 04	 add	 esp, 4

; 690  : 		
; 691  : 		// Now update it to indicate this is an unwanted token exception
; 692  : 		//
; 693  : 		recognizer->state->exception->name		= ANTLR3_MISSING_TOKEN_EXCEPTION_NAME;

  000f7	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  000fa	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000fd	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00100	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ??_C@_0CI@FIMBDEFG@org?4antlr?4runtime?4MissingTokenE@

; 694  : 		recognizer->state->exception->type		= ANTLR3_MISSING_TOKEN_EXCEPTION;

  00107	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  0010a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0010d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00110	c7 00 0a 00 00
	00		 mov	 DWORD PTR [eax], 10	; 0000000aH

; 695  : 
; 696  : 		return;

  00116	eb 0c		 jmp	 SHORT $LN1@mismatch
$LN7@mismatch:

; 697  : 	}
; 698  : 
; 699  : 	// Just a mismatched token is all we can dtermine
; 700  : 	//
; 701  : 	antlr3MTExceptionNew(recognizer);

  00118	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  0011b	51		 push	 ecx
  0011c	e8 00 00 00 00	 call	 _antlr3MTExceptionNew
  00121	83 c4 04	 add	 esp, 4
$LN1@mismatch:

; 702  : 
; 703  : 	return;
; 704  : }

  00124	5e		 pop	 esi
  00125	83 c4 10	 add	 esp, 16			; 00000010H
  00128	3b ec		 cmp	 ebp, esp
  0012a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0012f	8b e5		 mov	 esp, ebp
  00131	5d		 pop	 ebp
  00132	c3		 ret	 0
_mismatch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3baserecognizer.c
;	COMDAT _matchAny
_TEXT	SEGMENT
tv65 = -16						; size = 4
_is$ = -12						; size = 4
_tparser$ = -8						; size = 4
_parser$ = -4						; size = 4
_recognizer$ = 8					; size = 4
_matchAny PROC						; COMDAT

; 490  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000f	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00012	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00015	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 491  :     pANTLR3_PARSER	    parser;
; 492  :     pANTLR3_TREE_PARSER	    tparser;
; 493  :     pANTLR3_INT_STREAM	    is;
; 494  : 
; 495  :     switch	(recognizer->type)

  00018	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  0001b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001e	89 4d f0	 mov	 DWORD PTR tv65[ebp], ecx
  00021	83 7d f0 02	 cmp	 DWORD PTR tv65[ebp], 2
  00025	74 08		 je	 SHORT $LN4@matchAny
  00027	83 7d f0 04	 cmp	 DWORD PTR tv65[ebp], 4
  0002b	74 1f		 je	 SHORT $LN5@matchAny
  0002d	eb 3d		 jmp	 SHORT $LN6@matchAny
$LN4@matchAny:

; 496  :     {
; 497  : 		case	ANTLR3_TYPE_PARSER:
; 498  : 
; 499  : 			parser  = (pANTLR3_PARSER) (recognizer->super);

  0002f	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  00032	8b 02		 mov	 eax, DWORD PTR [edx]
  00034	89 45 fc	 mov	 DWORD PTR _parser$[ebp], eax

; 500  : 			tparser	= NULL;

  00037	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _tparser$[ebp], 0

; 501  : 			is	= parser->tstream->istream;

  0003e	8b 4d fc	 mov	 ecx, DWORD PTR _parser$[ebp]
  00041	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00044	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00047	89 45 f4	 mov	 DWORD PTR _is$[ebp], eax

; 502  : 
; 503  : 			break;

  0004a	eb 44		 jmp	 SHORT $LN2@matchAny
$LN5@matchAny:

; 504  : 
; 505  : 		case	ANTLR3_TYPE_TREE_PARSER:
; 506  : 
; 507  : 			tparser = (pANTLR3_TREE_PARSER) (recognizer->super);

  0004c	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  0004f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00051	89 55 f8	 mov	 DWORD PTR _tparser$[ebp], edx

; 508  : 			parser	= NULL;

  00054	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _parser$[ebp], 0

; 509  : 			is	= tparser->ctnstream->tnstream->istream;

  0005b	8b 45 f8	 mov	 eax, DWORD PTR _tparser$[ebp]
  0005e	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00061	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00064	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00067	89 45 f4	 mov	 DWORD PTR _is$[ebp], eax

; 510  : 
; 511  : 			break;

  0006a	eb 24		 jmp	 SHORT $LN2@matchAny
$LN6@matchAny:

; 512  : 
; 513  : 		default:
; 514  : 		    
; 515  : 			ANTLR3_FPRINTF(stderr, "Base recognizer function 'matchAny' called by unknown parser type - provide override for this function\n");

  0006c	68 00 00 00 00	 push	 OFFSET ??_C@_0GI@PFDGGJHE@Base?5recognizer?5function?5?8match@
  00071	8b f4		 mov	 esi, esp
  00073	6a 02		 push	 2
  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  0007b	83 c4 04	 add	 esp, 4
  0007e	3b f4		 cmp	 esi, esp
  00080	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00085	50		 push	 eax
  00086	e8 00 00 00 00	 call	 _fprintf
  0008b	83 c4 08	 add	 esp, 8

; 516  : 			return;

  0008e	eb 2d		 jmp	 SHORT $LN1@matchAny
$LN2@matchAny:

; 517  : 
; 518  : 		break;
; 519  :     }
; 520  :     recognizer->state->errorRecovery	= ANTLR3_FALSE;

  00090	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  00093	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00096	c6 42 10 00	 mov	 BYTE PTR [edx+16], 0

; 521  :     recognizer->state->failed		    = ANTLR3_FALSE;

  0009a	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  0009d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000a0	c6 41 18 00	 mov	 BYTE PTR [ecx+24], 0

; 522  :     is->consume(is);

  000a4	8b f4		 mov	 esi, esp
  000a6	8b 55 f4	 mov	 edx, DWORD PTR _is$[ebp]
  000a9	52		 push	 edx
  000aa	8b 45 f4	 mov	 eax, DWORD PTR _is$[ebp]
  000ad	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000b0	ff d1		 call	 ecx
  000b2	83 c4 04	 add	 esp, 4
  000b5	3b f4		 cmp	 esi, esp
  000b7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bc	90		 npad	 1
$LN1@matchAny:

; 523  : 
; 524  :     return;
; 525  : }

  000bd	5e		 pop	 esi
  000be	83 c4 10	 add	 esp, 16			; 00000010H
  000c1	3b ec		 cmp	 ebp, esp
  000c3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c8	8b e5		 mov	 esp, ebp
  000ca	5d		 pop	 ebp
  000cb	c3		 ret	 0
_matchAny ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3baserecognizer.c
;	COMDAT _match
_TEXT	SEGMENT
tv65 = -20						; size = 4
_matchedSymbol$ = -16					; size = 4
_is$ = -12						; size = 4
_tparser$ = -8						; size = 4
_parser$ = -4						; size = 4
_recognizer$ = 8					; size = 4
_ttype$ = 12						; size = 4
_follow$ = 16						; size = 4
_match	PROC						; COMDAT

; 417  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0000f	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00012	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00015	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00018	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 418  :     pANTLR3_PARSER			parser;
; 419  :     pANTLR3_TREE_PARSER	    tparser;
; 420  :     pANTLR3_INT_STREAM	    is;
; 421  : 	void					* matchedSymbol;
; 422  : 
; 423  :     switch	(recognizer->type)

  0001b	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  0001e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00021	89 4d ec	 mov	 DWORD PTR tv65[ebp], ecx
  00024	83 7d ec 02	 cmp	 DWORD PTR tv65[ebp], 2
  00028	74 08		 je	 SHORT $LN4@match
  0002a	83 7d ec 04	 cmp	 DWORD PTR tv65[ebp], 4
  0002e	74 1f		 je	 SHORT $LN5@match
  00030	eb 3d		 jmp	 SHORT $LN6@match
$LN4@match:

; 424  :     {
; 425  : 		case	ANTLR3_TYPE_PARSER:
; 426  : 
; 427  : 			parser  = (pANTLR3_PARSER) (recognizer->super);

  00032	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  00035	8b 02		 mov	 eax, DWORD PTR [edx]
  00037	89 45 fc	 mov	 DWORD PTR _parser$[ebp], eax

; 428  : 			tparser	= NULL;

  0003a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _tparser$[ebp], 0

; 429  : 			is	= parser->tstream->istream;

  00041	8b 4d fc	 mov	 ecx, DWORD PTR _parser$[ebp]
  00044	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00047	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0004a	89 45 f4	 mov	 DWORD PTR _is$[ebp], eax

; 430  : 
; 431  : 			break;

  0004d	eb 49		 jmp	 SHORT $LN2@match
$LN5@match:

; 432  : 
; 433  : 		case	ANTLR3_TYPE_TREE_PARSER:
; 434  : 
; 435  : 			tparser = (pANTLR3_TREE_PARSER) (recognizer->super);

  0004f	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  00052	8b 11		 mov	 edx, DWORD PTR [ecx]
  00054	89 55 f8	 mov	 DWORD PTR _tparser$[ebp], edx

; 436  : 			parser	= NULL;

  00057	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _parser$[ebp], 0

; 437  : 			is	= tparser->ctnstream->tnstream->istream;

  0005e	8b 45 f8	 mov	 eax, DWORD PTR _tparser$[ebp]
  00061	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00064	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00067	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0006a	89 45 f4	 mov	 DWORD PTR _is$[ebp], eax

; 438  : 
; 439  : 			break;

  0006d	eb 29		 jmp	 SHORT $LN2@match
$LN6@match:

; 440  : 
; 441  : 		default:
; 442  : 		    
; 443  : 			ANTLR3_FPRINTF(stderr, "Base recognizer function 'match' called by unknown parser type - provide override for this function\n");

  0006f	68 00 00 00 00	 push	 OFFSET ??_C@_0GF@OHPBBBJJ@Base?5recognizer?5function?5?8match@
  00074	8b f4		 mov	 esi, esp
  00076	6a 02		 push	 2
  00078	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  0007e	83 c4 04	 add	 esp, 4
  00081	3b f4		 cmp	 esi, esp
  00083	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 _fprintf
  0008e	83 c4 08	 add	 esp, 8

; 444  : 			return ANTLR3_FALSE;

  00091	33 c0		 xor	 eax, eax
  00093	e9 b0 00 00 00	 jmp	 $LN1@match
$LN2@match:

; 445  : 
; 446  : 			break;
; 447  :     }
; 448  : 
; 449  : 	// Pick up the current input token/node for assignment to labels
; 450  : 	//
; 451  : 	matchedSymbol = recognizer->getCurrentInputSymbol(recognizer, is);

  00098	8b f4		 mov	 esi, esp
  0009a	8b 4d f4	 mov	 ecx, DWORD PTR _is$[ebp]
  0009d	51		 push	 ecx
  0009e	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  000a1	52		 push	 edx
  000a2	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  000a5	8b 48 7c	 mov	 ecx, DWORD PTR [eax+124]
  000a8	ff d1		 call	 ecx
  000aa	83 c4 08	 add	 esp, 8
  000ad	3b f4		 cmp	 esi, esp
  000af	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b4	89 45 f0	 mov	 DWORD PTR _matchedSymbol$[ebp], eax

; 452  : 
; 453  :     if	(is->_LA(is, 1) == ttype)

  000b7	8b f4		 mov	 esi, esp
  000b9	6a 01		 push	 1
  000bb	8b 55 f4	 mov	 edx, DWORD PTR _is$[ebp]
  000be	52		 push	 edx
  000bf	8b 45 f4	 mov	 eax, DWORD PTR _is$[ebp]
  000c2	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000c5	ff d1		 call	 ecx
  000c7	83 c4 08	 add	 esp, 8
  000ca	3b f4		 cmp	 esi, esp
  000cc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d1	3b 45 0c	 cmp	 eax, DWORD PTR _ttype$[ebp]
  000d4	75 31		 jne	 SHORT $LN7@match

; 454  :     {
; 455  : 		// The token was the one we were told to expect
; 456  : 		//
; 457  : 		is->consume(is);									// Consume that token from the stream

  000d6	8b f4		 mov	 esi, esp
  000d8	8b 55 f4	 mov	 edx, DWORD PTR _is$[ebp]
  000db	52		 push	 edx
  000dc	8b 45 f4	 mov	 eax, DWORD PTR _is$[ebp]
  000df	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000e2	ff d1		 call	 ecx
  000e4	83 c4 04	 add	 esp, 4
  000e7	3b f4		 cmp	 esi, esp
  000e9	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 458  : 		recognizer->state->errorRecovery	= ANTLR3_FALSE;	// Not in error recovery now (if we were)

  000ee	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  000f1	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000f4	c6 40 10 00	 mov	 BYTE PTR [eax+16], 0

; 459  : 		recognizer->state->failed			= ANTLR3_FALSE;	// The match was a success

  000f8	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  000fb	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000fe	c6 42 18 00	 mov	 BYTE PTR [edx+24], 0

; 460  : 		return matchedSymbol;								// We are done

  00102	8b 45 f0	 mov	 eax, DWORD PTR _matchedSymbol$[ebp]
  00105	eb 41		 jmp	 SHORT $LN1@match
$LN7@match:

; 461  :     }
; 462  : 
; 463  :     // We did not find the expected token type, if we are backtracking then
; 464  :     // we just set the failed flag and return.
; 465  :     //
; 466  :     if	(recognizer->state->backtracking > 0)

  00107	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  0010a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0010d	83 79 20 00	 cmp	 DWORD PTR [ecx+32], 0
  00111	7e 0f		 jle	 SHORT $LN8@match

; 467  :     {
; 468  : 		// Backtracking is going on
; 469  : 		//
; 470  : 		recognizer->state->failed  = ANTLR3_TRUE;

  00113	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  00116	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00119	c6 40 18 01	 mov	 BYTE PTR [eax+24], 1

; 471  : 		return matchedSymbol;

  0011d	8b 45 f0	 mov	 eax, DWORD PTR _matchedSymbol$[ebp]
  00120	eb 26		 jmp	 SHORT $LN1@match
$LN8@match:

; 472  : 	}
; 473  : 
; 474  :     // We did not find the expected token and there is no backtracking
; 475  :     // going on, so we mismatch, which creates an exception in the recognizer exception
; 476  :     // stack.
; 477  :     //
; 478  : 	matchedSymbol = recognizer->recoverFromMismatchedToken(recognizer, ttype, follow);

  00122	8b f4		 mov	 esi, esp
  00124	8b 4d 10	 mov	 ecx, DWORD PTR _follow$[ebp]
  00127	51		 push	 ecx
  00128	8b 55 0c	 mov	 edx, DWORD PTR _ttype$[ebp]
  0012b	52		 push	 edx
  0012c	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  0012f	50		 push	 eax
  00130	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  00133	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  00136	ff d2		 call	 edx
  00138	83 c4 0c	 add	 esp, 12			; 0000000cH
  0013b	3b f4		 cmp	 esi, esp
  0013d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00142	89 45 f0	 mov	 DWORD PTR _matchedSymbol$[ebp], eax

; 479  :     return matchedSymbol;

  00145	8b 45 f0	 mov	 eax, DWORD PTR _matchedSymbol$[ebp]
$LN1@match:

; 480  : }

  00148	5e		 pop	 esi
  00149	83 c4 14	 add	 esp, 20			; 00000014H
  0014c	3b ec		 cmp	 ebp, esp
  0014e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00153	8b e5		 mov	 esp, ebp
  00155	5d		 pop	 ebp
  00156	c3		 ret	 0
_match	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3baserecognizer.c
;	COMDAT _endBacktrack
_TEXT	SEGMENT
_recognizer$ = 8					; size = 4
_level$ = 12						; size = 4
_successful$ = 16					; size = 1
_endBacktrack PROC					; COMDAT

; 761  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 762  : 	if	(recognizer->debugger != NULL)

  00004	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  00007	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  0000b	74 28		 je	 SHORT $LN2@endBacktra

; 763  : 	{
; 764  : 		recognizer->debugger->endBacktrack(recognizer->debugger, level, successful);

  0000d	8b f4		 mov	 esi, esp
  0000f	0f b6 4d 10	 movzx	 ecx, BYTE PTR _successful$[ebp]
  00013	51		 push	 ecx
  00014	8b 55 0c	 mov	 edx, DWORD PTR _level$[ebp]
  00017	52		 push	 edx
  00018	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  0001b	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0001e	51		 push	 ecx
  0001f	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  00022	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00025	8b 48 58	 mov	 ecx, DWORD PTR [eax+88]
  00028	ff d1		 call	 ecx
  0002a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002d	3b f4		 cmp	 esi, esp
  0002f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00034	90		 npad	 1
$LN2@endBacktra:

; 765  : 	}
; 766  : }

  00035	5e		 pop	 esi
  00036	3b ec		 cmp	 ebp, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
_endBacktrack ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3baserecognizer.c
;	COMDAT _beginBacktrack
_TEXT	SEGMENT
_recognizer$ = 8					; size = 4
_level$ = 12						; size = 4
_beginBacktrack PROC					; COMDAT

; 752  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 753  : 	if	(recognizer->debugger != NULL)

  00004	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  00007	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  0000b	74 23		 je	 SHORT $LN2@beginBackt

; 754  : 	{
; 755  : 		recognizer->debugger->beginBacktrack(recognizer->debugger, level);

  0000d	8b f4		 mov	 esi, esp
  0000f	8b 4d 0c	 mov	 ecx, DWORD PTR _level$[ebp]
  00012	51		 push	 ecx
  00013	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  00016	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00019	50		 push	 eax
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  0001d	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00020	8b 42 54	 mov	 eax, DWORD PTR [edx+84]
  00023	ff d0		 call	 eax
  00025	83 c4 08	 add	 esp, 8
  00028	3b f4		 cmp	 esi, esp
  0002a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002f	90		 npad	 1
$LN2@beginBackt:

; 756  : 	}
; 757  : }

  00030	5e		 pop	 esi
  00031	3b ec		 cmp	 ebp, esp
  00033	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
_beginBacktrack ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3baserecognizer.c
;	COMDAT _endResync
_TEXT	SEGMENT
_recognizer$ = 8					; size = 4
_endResync PROC						; COMDAT

; 778  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 779  : 	if	(recognizer->debugger != NULL)

  00004	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  00007	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  0000b	74 1f		 je	 SHORT $LN2@endResync

; 780  : 	{
; 781  : 		recognizer->debugger->endResync(recognizer->debugger);

  0000d	8b f4		 mov	 esi, esp
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  00012	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00015	52		 push	 edx
  00016	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  00019	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0001c	8b 51 68	 mov	 edx, DWORD PTR [ecx+104]
  0001f	ff d2		 call	 edx
  00021	83 c4 04	 add	 esp, 4
  00024	3b f4		 cmp	 esi, esp
  00026	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002b	90		 npad	 1
$LN2@endResync:

; 782  : 	}
; 783  : }

  0002c	5e		 pop	 esi
  0002d	3b ec		 cmp	 ebp, esp
  0002f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
_endResync ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3baserecognizer.c
;	COMDAT _computeErrorRecoverySet
_TEXT	SEGMENT
_recognizer$ = 8					; size = 4
_computeErrorRecoverySet PROC				; COMDAT

; 880  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 881  :     return   recognizer->combineFollows(recognizer, ANTLR3_FALSE);

  00004	8b f4		 mov	 esi, esp
  00006	6a 00		 push	 0
  00008	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  0000f	8b 51 4c	 mov	 edx, DWORD PTR [ecx+76]
  00012	ff d2		 call	 edx
  00014	83 c4 08	 add	 esp, 8
  00017	3b f4		 cmp	 esi, esp
  00019	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 882  : }

  0001e	5e		 pop	 esi
  0001f	3b ec		 cmp	 ebp, esp
  00021	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
_computeErrorRecoverySet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3baserecognizer.c
;	COMDAT _beginResync
_TEXT	SEGMENT
_recognizer$ = 8					; size = 4
_beginResync PROC					; COMDAT

; 769  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 770  : 	if	(recognizer->debugger != NULL)

  00004	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  00007	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  0000b	74 1f		 je	 SHORT $LN2@beginResyn

; 771  : 	{
; 772  : 		recognizer->debugger->beginResync(recognizer->debugger);

  0000d	8b f4		 mov	 esi, esp
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  00012	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00015	52		 push	 edx
  00016	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  00019	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0001c	8b 51 64	 mov	 edx, DWORD PTR [ecx+100]
  0001f	ff d2		 call	 edx
  00021	83 c4 04	 add	 esp, 4
  00024	3b f4		 cmp	 esi, esp
  00026	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002b	90		 npad	 1
$LN2@beginResyn:

; 773  : 	}
; 774  : }

  0002c	5e		 pop	 esi
  0002d	3b ec		 cmp	 ebp, esp
  0002f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
_beginResync ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3baserecognizer.c
;	COMDAT _antlr3MTExceptionNew
_TEXT	SEGMENT
_recognizer$ = 8					; size = 4
_antlr3MTExceptionNew PROC				; COMDAT

; 255  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 256  :     /* Create a basic recognition exception structure
; 257  :      */
; 258  :     antlr3RecognitionExceptionNew(recognizer);

  00003	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 _antlr3RecognitionExceptionNew
  0000c	83 c4 04	 add	 esp, 4

; 259  : 
; 260  :     /* Now update it to indicate this is a Mismatched token exception
; 261  :      */
; 262  :     recognizer->state->exception->name		= ANTLR3_MISMATCHED_EX_NAME;

  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  00012	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00015	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00018	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ??_C@_0CL@GOBGIMMF@org?4antlr?4runtime?4MismatchedTok@

; 263  :     recognizer->state->exception->type		= ANTLR3_MISMATCHED_TOKEN_EXCEPTION;

  0001f	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  00022	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00025	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00028	c7 00 02 00 00
	00		 mov	 DWORD PTR [eax], 2

; 264  : 
; 265  :     return;
; 266  : }

  0002e	3b ec		 cmp	 ebp, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
_antlr3MTExceptionNew ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3baserecognizer.c
;	COMDAT _antlr3RecognitionExceptionNew
_TEXT	SEGMENT
tv92 = -44						; size = 4
tv65 = -40						; size = 4
_tnode$1 = -36						; size = 4
_tns$ = -32						; size = 4
_cts$ = -28						; size = 4
_is$ = -24						; size = 4
_ins$ = -20						; size = 4
_tparser$ = -16						; size = 4
_parser$ = -12						; size = 4
_lexer$ = -8						; size = 4
_ex$ = -4						; size = 4
_recognizer$ = 8					; size = 4
_antlr3RecognitionExceptionNew PROC			; COMDAT

; 270  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8d 7d d4	 lea	 edi, DWORD PTR [ebp-44]
  0000b	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd

; 271  : 	pANTLR3_EXCEPTION				ex;
; 272  : 	pANTLR3_LEXER					lexer;
; 273  : 	pANTLR3_PARSER					parser;
; 274  : 	pANTLR3_TREE_PARSER				tparser;
; 275  : 
; 276  : 	pANTLR3_INPUT_STREAM			ins;
; 277  : 	pANTLR3_INT_STREAM				is;
; 278  : 	pANTLR3_COMMON_TOKEN_STREAM	    cts;
; 279  : 	pANTLR3_TREE_NODE_STREAM	    tns;
; 280  : 
; 281  : 	ins	    = NULL;

  00017	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _ins$[ebp], 0

; 282  : 	cts	    = NULL;

  0001e	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _cts$[ebp], 0

; 283  : 	tns	    = NULL;

  00025	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _tns$[ebp], 0

; 284  : 	is	    = NULL;

  0002c	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _is$[ebp], 0

; 285  : 	lexer   = NULL;

  00033	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _lexer$[ebp], 0

; 286  : 	parser  = NULL;

  0003a	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _parser$[ebp], 0

; 287  : 	tparser = NULL;

  00041	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _tparser$[ebp], 0

; 288  : 
; 289  : 	switch	(recognizer->type)

  00048	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  0004b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0004e	89 4d d8	 mov	 DWORD PTR tv65[ebp], ecx
  00051	83 7d d8 01	 cmp	 DWORD PTR tv65[ebp], 1
  00055	74 0e		 je	 SHORT $LN6@antlr3Reco
  00057	83 7d d8 02	 cmp	 DWORD PTR tv65[ebp], 2
  0005b	74 23		 je	 SHORT $LN7@antlr3Reco
  0005d	83 7d d8 04	 cmp	 DWORD PTR tv65[ebp], 4
  00061	74 3f		 je	 SHORT $LN8@antlr3Reco
  00063	eb 5c		 jmp	 SHORT $LN9@antlr3Reco
$LN6@antlr3Reco:

; 290  : 	{
; 291  : 	case	ANTLR3_TYPE_LEXER:
; 292  : 
; 293  : 		lexer	= (pANTLR3_LEXER) (recognizer->super);

  00065	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  00068	8b 02		 mov	 eax, DWORD PTR [edx]
  0006a	89 45 f8	 mov	 DWORD PTR _lexer$[ebp], eax

; 294  : 		ins	= lexer->input;

  0006d	8b 4d f8	 mov	 ecx, DWORD PTR _lexer$[ebp]
  00070	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00073	89 55 ec	 mov	 DWORD PTR _ins$[ebp], edx

; 295  : 		is	= ins->istream;

  00076	8b 45 ec	 mov	 eax, DWORD PTR _ins$[ebp]
  00079	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007b	89 4d e8	 mov	 DWORD PTR _is$[ebp], ecx

; 296  : 
; 297  : 		break;

  0007e	eb 68		 jmp	 SHORT $LN2@antlr3Reco
$LN7@antlr3Reco:

; 298  : 
; 299  : 	case	ANTLR3_TYPE_PARSER:
; 300  : 
; 301  : 		parser  = (pANTLR3_PARSER) (recognizer->super);

  00080	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  00083	8b 02		 mov	 eax, DWORD PTR [edx]
  00085	89 45 f4	 mov	 DWORD PTR _parser$[ebp], eax

; 302  : 		cts	= (pANTLR3_COMMON_TOKEN_STREAM)(parser->tstream->super);

  00088	8b 4d f4	 mov	 ecx, DWORD PTR _parser$[ebp]
  0008b	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0008e	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00091	89 45 e4	 mov	 DWORD PTR _cts$[ebp], eax

; 303  : 		is	= parser->tstream->istream;

  00094	8b 4d f4	 mov	 ecx, DWORD PTR _parser$[ebp]
  00097	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0009a	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0009d	89 45 e8	 mov	 DWORD PTR _is$[ebp], eax

; 304  : 
; 305  : 		break;

  000a0	eb 46		 jmp	 SHORT $LN2@antlr3Reco
$LN8@antlr3Reco:

; 306  : 
; 307  : 	case	ANTLR3_TYPE_TREE_PARSER:
; 308  : 
; 309  : 		tparser = (pANTLR3_TREE_PARSER) (recognizer->super);

  000a2	8b 4d 08	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  000a5	8b 11		 mov	 edx, DWORD PTR [ecx]
  000a7	89 55 f0	 mov	 DWORD PTR _tparser$[ebp], edx

; 310  : 		tns	= tparser->ctnstream->tnstream;

  000aa	8b 45 f0	 mov	 eax, DWORD PTR _tparser$[ebp]
  000ad	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000b0	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000b3	89 55 e0	 mov	 DWORD PTR _tns$[ebp], edx

; 311  : 		is	= tns->istream;

  000b6	8b 45 e0	 mov	 eax, DWORD PTR _tns$[ebp]
  000b9	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000bc	89 4d e8	 mov	 DWORD PTR _is$[ebp], ecx

; 312  : 
; 313  : 		break;

  000bf	eb 27		 jmp	 SHORT $LN2@antlr3Reco
$LN9@antlr3Reco:

; 314  : 
; 315  : 	default:
; 316  : 
; 317  : 		ANTLR3_FPRINTF(stderr, "Base recognizer function antlr3RecognitionExceptionNew called by unknown parser type - provide override for this function\n");

  000c1	68 00 00 00 00	 push	 OFFSET ??_C@_0HL@JIGEPJEO@Base?5recognizer?5function?5antlr3@
  000c6	8b f4		 mov	 esi, esp
  000c8	6a 02		 push	 2
  000ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  000d0	83 c4 04	 add	 esp, 4
  000d3	3b f4		 cmp	 esi, esp
  000d5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000da	50		 push	 eax
  000db	e8 00 00 00 00	 call	 _fprintf
  000e0	83 c4 08	 add	 esp, 8

; 318  : 		return;

  000e3	e9 d3 02 00 00	 jmp	 $LN1@antlr3Reco
$LN2@antlr3Reco:

; 319  : 
; 320  : 		break;
; 321  : 	}
; 322  : 
; 323  : 	/* Create a basic exception structure
; 324  : 	 */
; 325  : 	ex = antlr3ExceptionNew(ANTLR3_RECOGNITION_EXCEPTION,

  000e8	6a 00		 push	 0
  000ea	6a 00		 push	 0
  000ec	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@CEOAHODC@org?4antlr?4runtime?4RecognitionEx@
  000f1	6a 01		 push	 1
  000f3	e8 00 00 00 00	 call	 _antlr3ExceptionNew
  000f8	83 c4 10	 add	 esp, 16			; 00000010H
  000fb	89 45 fc	 mov	 DWORD PTR _ex$[ebp], eax

; 326  : 		(void *)ANTLR3_RECOGNITION_EX_NAME,
; 327  : 		NULL,
; 328  : 		ANTLR3_FALSE);
; 329  : 
; 330  : 	/* Rest of information depends on the base type of the 
; 331  : 	 * input stream.
; 332  : 	 */
; 333  : 	switch  (is->type & ANTLR3_INPUT_MASK)

  000fe	8b 55 e8	 mov	 edx, DWORD PTR _is$[ebp]
  00101	8b 02		 mov	 eax, DWORD PTR [edx]
  00103	83 e0 07	 and	 eax, 7
  00106	89 45 d4	 mov	 DWORD PTR tv92[ebp], eax
  00109	83 7d d4 01	 cmp	 DWORD PTR tv92[ebp], 1
  0010d	74 19		 je	 SHORT $LN10@antlr3Reco
  0010f	83 7d d4 02	 cmp	 DWORD PTR tv92[ebp], 2
  00113	0f 84 a4 00 00
	00		 je	 $LN11@antlr3Reco
  00119	83 7d d4 04	 cmp	 DWORD PTR tv92[ebp], 4
  0011d	0f 84 66 01 00
	00		 je	 $LN14@antlr3Reco
  00123	e9 66 02 00 00	 jmp	 $LN4@antlr3Reco
$LN10@antlr3Reco:

; 334  : 	{
; 335  : 	case    ANTLR3_CHARSTREAM:
; 336  : 
; 337  : 		ex->c			= is->_LA		    	(is, 1);					/* Current input character			*/

  00128	8b f4		 mov	 esi, esp
  0012a	6a 01		 push	 1
  0012c	8b 4d e8	 mov	 ecx, DWORD PTR _is$[ebp]
  0012f	51		 push	 ecx
  00130	8b 55 e8	 mov	 edx, DWORD PTR _is$[ebp]
  00133	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00136	ff d0		 call	 eax
  00138	83 c4 08	 add	 esp, 8
  0013b	3b f4		 cmp	 esi, esp
  0013d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00142	8b 4d fc	 mov	 ecx, DWORD PTR _ex$[ebp]
  00145	89 41 28	 mov	 DWORD PTR [ecx+40], eax

; 338  : 		ex->line		= ins->getLine			(ins);						/* Line number comes from stream		*/

  00148	8b f4		 mov	 esi, esp
  0014a	8b 55 ec	 mov	 edx, DWORD PTR _ins$[ebp]
  0014d	52		 push	 edx
  0014e	8b 45 ec	 mov	 eax, DWORD PTR _ins$[ebp]
  00151	8b 48 58	 mov	 ecx, DWORD PTR [eax+88]
  00154	ff d1		 call	 ecx
  00156	83 c4 04	 add	 esp, 4
  00159	3b f4		 cmp	 esi, esp
  0015b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00160	8b 55 fc	 mov	 edx, DWORD PTR _ex$[ebp]
  00163	89 42 2c	 mov	 DWORD PTR [edx+44], eax

; 339  : 		ex->charPositionInLine	= ins->getCharPositionInLine	(ins);	    /* Line offset also comes from the stream   */

  00166	8b f4		 mov	 esi, esp
  00168	8b 45 ec	 mov	 eax, DWORD PTR _ins$[ebp]
  0016b	50		 push	 eax
  0016c	8b 4d ec	 mov	 ecx, DWORD PTR _ins$[ebp]
  0016f	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  00172	ff d2		 call	 edx
  00174	83 c4 04	 add	 esp, 4
  00177	3b f4		 cmp	 esi, esp
  00179	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0017e	8b 4d fc	 mov	 ecx, DWORD PTR _ex$[ebp]
  00181	89 41 30	 mov	 DWORD PTR [ecx+48], eax

; 340  : 		ex->index		= is->index			(is);

  00184	8b f4		 mov	 esi, esp
  00186	8b 55 e8	 mov	 edx, DWORD PTR _is$[ebp]
  00189	52		 push	 edx
  0018a	8b 45 e8	 mov	 eax, DWORD PTR _is$[ebp]
  0018d	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00190	ff d1		 call	 ecx
  00192	83 c4 04	 add	 esp, 4
  00195	3b f4		 cmp	 esi, esp
  00197	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0019c	8b 55 fc	 mov	 edx, DWORD PTR _ex$[ebp]
  0019f	89 42 14	 mov	 DWORD PTR [edx+20], eax

; 341  : 		ex->streamName		= ins->fileName;

  001a2	8b 45 fc	 mov	 eax, DWORD PTR _ex$[ebp]
  001a5	8b 4d ec	 mov	 ecx, DWORD PTR _ins$[ebp]
  001a8	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  001ab	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 342  : 		ex->message		= "Unexpected character";

  001ae	8b 45 fc	 mov	 eax, DWORD PTR _ex$[ebp]
  001b1	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], OFFSET ??_C@_0BF@BIIJEBMB@Unexpected?5character@

; 343  : 		break;

  001b8	e9 d1 01 00 00	 jmp	 $LN4@antlr3Reco
$LN11@antlr3Reco:

; 344  : 
; 345  : 	case    ANTLR3_TOKENSTREAM:
; 346  : 
; 347  : 		ex->token		= cts->tstream->_LT						(cts->tstream, 1);	    /* Current input token			    */

  001bd	8b f4		 mov	 esi, esp
  001bf	6a 01		 push	 1
  001c1	8b 4d e4	 mov	 ecx, DWORD PTR _cts$[ebp]
  001c4	8b 11		 mov	 edx, DWORD PTR [ecx]
  001c6	52		 push	 edx
  001c7	8b 45 e4	 mov	 eax, DWORD PTR _cts$[ebp]
  001ca	8b 08		 mov	 ecx, DWORD PTR [eax]
  001cc	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  001cf	ff d2		 call	 edx
  001d1	83 c4 08	 add	 esp, 8
  001d4	3b f4		 cmp	 esi, esp
  001d6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001db	8b 4d fc	 mov	 ecx, DWORD PTR _ex$[ebp]
  001de	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 348  : 		ex->line		= ((pANTLR3_COMMON_TOKEN)(ex->token))->getLine			((pANTLR3_COMMON_TOKEN)(ex->token));

  001e1	8b f4		 mov	 esi, esp
  001e3	8b 55 fc	 mov	 edx, DWORD PTR _ex$[ebp]
  001e6	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  001e9	50		 push	 eax
  001ea	8b 4d fc	 mov	 ecx, DWORD PTR _ex$[ebp]
  001ed	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  001f0	8b 42 5c	 mov	 eax, DWORD PTR [edx+92]
  001f3	ff d0		 call	 eax
  001f5	83 c4 04	 add	 esp, 4
  001f8	3b f4		 cmp	 esi, esp
  001fa	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001ff	8b 4d fc	 mov	 ecx, DWORD PTR _ex$[ebp]
  00202	89 41 2c	 mov	 DWORD PTR [ecx+44], eax

; 349  : 		ex->charPositionInLine	= ((pANTLR3_COMMON_TOKEN)(ex->token))->getCharPositionInLine	((pANTLR3_COMMON_TOKEN)(ex->token));

  00205	8b f4		 mov	 esi, esp
  00207	8b 55 fc	 mov	 edx, DWORD PTR _ex$[ebp]
  0020a	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0020d	50		 push	 eax
  0020e	8b 4d fc	 mov	 ecx, DWORD PTR _ex$[ebp]
  00211	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00214	8b 42 64	 mov	 eax, DWORD PTR [edx+100]
  00217	ff d0		 call	 eax
  00219	83 c4 04	 add	 esp, 4
  0021c	3b f4		 cmp	 esi, esp
  0021e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00223	8b 4d fc	 mov	 ecx, DWORD PTR _ex$[ebp]
  00226	89 41 30	 mov	 DWORD PTR [ecx+48], eax

; 350  : 		ex->index		= cts->tstream->istream->index					(cts->tstream->istream);

  00229	8b 55 e4	 mov	 edx, DWORD PTR _cts$[ebp]
  0022c	8b 02		 mov	 eax, DWORD PTR [edx]
  0022e	8b f4		 mov	 esi, esp
  00230	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00233	51		 push	 ecx
  00234	8b 55 e4	 mov	 edx, DWORD PTR _cts$[ebp]
  00237	8b 02		 mov	 eax, DWORD PTR [edx]
  00239	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0023c	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  0023f	ff d2		 call	 edx
  00241	83 c4 04	 add	 esp, 4
  00244	3b f4		 cmp	 esi, esp
  00246	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0024b	8b 4d fc	 mov	 ecx, DWORD PTR _ex$[ebp]
  0024e	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 351  : 		if	(((pANTLR3_COMMON_TOKEN)(ex->token))->type == ANTLR3_TOKEN_EOF)

  00251	8b 55 fc	 mov	 edx, DWORD PTR _ex$[ebp]
  00254	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00257	83 38 ff	 cmp	 DWORD PTR [eax], -1
  0025a	75 0c		 jne	 SHORT $LN12@antlr3Reco

; 352  : 		{
; 353  : 			ex->streamName		= NULL;

  0025c	8b 4d fc	 mov	 ecx, DWORD PTR _ex$[ebp]
  0025f	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 354  : 		}

  00266	eb 12		 jmp	 SHORT $LN13@antlr3Reco
$LN12@antlr3Reco:

; 355  : 		else
; 356  : 		{
; 357  : 			ex->streamName		= ((pANTLR3_COMMON_TOKEN)(ex->token))->input->fileName;

  00268	8b 55 fc	 mov	 edx, DWORD PTR _ex$[ebp]
  0026b	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0026e	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00271	8b 55 fc	 mov	 edx, DWORD PTR _ex$[ebp]
  00274	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00277	89 42 0c	 mov	 DWORD PTR [edx+12], eax
$LN13@antlr3Reco:

; 358  : 		}
; 359  : 		ex->message		= "Unexpected token";

  0027a	8b 4d fc	 mov	 ecx, DWORD PTR _ex$[ebp]
  0027d	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], OFFSET ??_C@_0BB@FKAIECKK@Unexpected?5token@

; 360  : 		break;

  00284	e9 05 01 00 00	 jmp	 $LN4@antlr3Reco
$LN14@antlr3Reco:

; 361  : 
; 362  : 	case    ANTLR3_COMMONTREENODE:
; 363  : 
; 364  : 		ex->token		= tns->_LT						    (tns, 1);	    /* Current input tree node			    */

  00289	8b f4		 mov	 esi, esp
  0028b	6a 01		 push	 1
  0028d	8b 55 e0	 mov	 edx, DWORD PTR _tns$[ebp]
  00290	52		 push	 edx
  00291	8b 45 e0	 mov	 eax, DWORD PTR _tns$[ebp]
  00294	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00297	ff d1		 call	 ecx
  00299	83 c4 08	 add	 esp, 8
  0029c	3b f4		 cmp	 esi, esp
  0029e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002a3	8b 55 fc	 mov	 edx, DWORD PTR _ex$[ebp]
  002a6	89 42 18	 mov	 DWORD PTR [edx+24], eax

; 365  : 		ex->line		= ((pANTLR3_BASE_TREE)(ex->token))->getLine		    ((pANTLR3_BASE_TREE)(ex->token));

  002a9	8b f4		 mov	 esi, esp
  002ab	8b 45 fc	 mov	 eax, DWORD PTR _ex$[ebp]
  002ae	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  002b1	51		 push	 ecx
  002b2	8b 55 fc	 mov	 edx, DWORD PTR _ex$[ebp]
  002b5	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  002b8	8b 48 58	 mov	 ecx, DWORD PTR [eax+88]
  002bb	ff d1		 call	 ecx
  002bd	83 c4 04	 add	 esp, 4
  002c0	3b f4		 cmp	 esi, esp
  002c2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002c7	8b 55 fc	 mov	 edx, DWORD PTR _ex$[ebp]
  002ca	89 42 2c	 mov	 DWORD PTR [edx+44], eax

; 366  : 		ex->charPositionInLine	= ((pANTLR3_BASE_TREE)(ex->token))->getCharPositionInLine   ((pANTLR3_BASE_TREE)(ex->token));

  002cd	8b f4		 mov	 esi, esp
  002cf	8b 45 fc	 mov	 eax, DWORD PTR _ex$[ebp]
  002d2	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  002d5	51		 push	 ecx
  002d6	8b 55 fc	 mov	 edx, DWORD PTR _ex$[ebp]
  002d9	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  002dc	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  002df	ff d1		 call	 ecx
  002e1	83 c4 04	 add	 esp, 4
  002e4	3b f4		 cmp	 esi, esp
  002e6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002eb	8b 55 fc	 mov	 edx, DWORD PTR _ex$[ebp]
  002ee	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 367  : 		ex->index		= tns->istream->index					    (tns->istream);

  002f1	8b f4		 mov	 esi, esp
  002f3	8b 45 e0	 mov	 eax, DWORD PTR _tns$[ebp]
  002f6	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  002f9	51		 push	 ecx
  002fa	8b 55 e0	 mov	 edx, DWORD PTR _tns$[ebp]
  002fd	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00300	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00303	ff d1		 call	 ecx
  00305	83 c4 04	 add	 esp, 4
  00308	3b f4		 cmp	 esi, esp
  0030a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0030f	8b 55 fc	 mov	 edx, DWORD PTR _ex$[ebp]
  00312	89 42 14	 mov	 DWORD PTR [edx+20], eax

; 368  : 
; 369  : 		// Are you ready for this? Deep breath now...
; 370  : 		//
; 371  : 		{
; 372  : 			pANTLR3_COMMON_TREE tnode;
; 373  : 
; 374  : 			tnode		= ((pANTLR3_COMMON_TREE)(((pANTLR3_BASE_TREE)(ex->token))->super));

  00315	8b 45 fc	 mov	 eax, DWORD PTR _ex$[ebp]
  00318	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0031b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0031d	89 55 dc	 mov	 DWORD PTR _tnode$1[ebp], edx

; 375  : 
; 376  : 			if	(tnode->token    == NULL)

  00320	8b 45 dc	 mov	 eax, DWORD PTR _tnode$1[ebp]
  00323	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00327	75 31		 jne	 SHORT $LN15@antlr3Reco

; 377  : 			{
; 378  : 				ex->streamName = ((pANTLR3_BASE_TREE)(ex->token))->strFactory->newStr(((pANTLR3_BASE_TREE)(ex->token))->strFactory, (pANTLR3_UINT8)"-unknown source-");

  00329	8b f4		 mov	 esi, esp
  0032b	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@DHPGECBL@?9unknown?5source?9@
  00330	8b 4d fc	 mov	 ecx, DWORD PTR _ex$[ebp]
  00333	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00336	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00339	50		 push	 eax
  0033a	8b 4d fc	 mov	 ecx, DWORD PTR _ex$[ebp]
  0033d	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00340	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00343	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00346	ff d1		 call	 ecx
  00348	83 c4 08	 add	 esp, 8
  0034b	3b f4		 cmp	 esi, esp
  0034d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00352	8b 55 fc	 mov	 edx, DWORD PTR _ex$[ebp]
  00355	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 379  : 			}

  00358	eb 2a		 jmp	 SHORT $LN18@antlr3Reco
$LN15@antlr3Reco:

; 380  : 			else
; 381  : 			{
; 382  : 				if	(tnode->token->input == NULL)

  0035a	8b 45 dc	 mov	 eax, DWORD PTR _tnode$1[ebp]
  0035d	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00360	83 79 1c 00	 cmp	 DWORD PTR [ecx+28], 0
  00364	75 0c		 jne	 SHORT $LN17@antlr3Reco

; 383  : 				{
; 384  : 					ex->streamName		= NULL;

  00366	8b 55 fc	 mov	 edx, DWORD PTR _ex$[ebp]
  00369	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0

; 385  : 				}

  00370	eb 12		 jmp	 SHORT $LN18@antlr3Reco
$LN17@antlr3Reco:

; 386  : 				else
; 387  : 				{
; 388  : 					ex->streamName		= tnode->token->input->fileName;

  00372	8b 45 dc	 mov	 eax, DWORD PTR _tnode$1[ebp]
  00375	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00378	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0037b	8b 45 fc	 mov	 eax, DWORD PTR _ex$[ebp]
  0037e	8b 4a 30	 mov	 ecx, DWORD PTR [edx+48]
  00381	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
$LN18@antlr3Reco:

; 389  : 				}
; 390  : 			}
; 391  : 			ex->message		= "Unexpected node";

  00384	8b 55 fc	 mov	 edx, DWORD PTR _ex$[ebp]
  00387	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], OFFSET ??_C@_0BA@IGJLDFLP@Unexpected?5node@
$LN4@antlr3Reco:

; 392  : 		}
; 393  : 		break;
; 394  : 	}
; 395  : 
; 396  : 	ex->input						= is;

  0038e	8b 45 fc	 mov	 eax, DWORD PTR _ex$[ebp]
  00391	8b 4d e8	 mov	 ecx, DWORD PTR _is$[ebp]
  00394	89 48 44	 mov	 DWORD PTR [eax+68], ecx

; 397  : 	ex->nextException				= recognizer->state->exception;	/* So we don't leak the memory */

  00397	8b 55 08	 mov	 edx, DWORD PTR _recognizer$[ebp]
  0039a	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0039d	8b 4d fc	 mov	 ecx, DWORD PTR _ex$[ebp]
  003a0	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  003a3	89 51 40	 mov	 DWORD PTR [ecx+64], edx

; 398  : 	recognizer->state->exception	= ex;

  003a6	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  003a9	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  003ac	8b 55 fc	 mov	 edx, DWORD PTR _ex$[ebp]
  003af	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 399  : 	recognizer->state->error	    = ANTLR3_TRUE;	    /* Exception is outstanding	*/

  003b2	8b 45 08	 mov	 eax, DWORD PTR _recognizer$[ebp]
  003b5	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  003b8	c6 01 01	 mov	 BYTE PTR [ecx], 1
$LN1@antlr3Reco:

; 400  : 
; 401  : 	return;
; 402  : }

  003bb	5f		 pop	 edi
  003bc	5e		 pop	 esi
  003bd	83 c4 2c	 add	 esp, 44			; 0000002cH
  003c0	3b ec		 cmp	 ebp, esp
  003c2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003c7	8b e5		 mov	 esp, ebp
  003c9	5d		 pop	 ebp
  003ca	c3		 ret	 0
_antlr3RecognitionExceptionNew ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\SPO_labs\C\src\antlr3baserecognizer.c
;	COMDAT _antlr3BaseRecognizerNew
_TEXT	SEGMENT
_recognizer$ = -4					; size = 4
_type$ = 8						; size = 4
_sizeHint$ = 12						; size = 4
_state$ = 16						; size = 4
_antlr3BaseRecognizerNew PROC				; COMDAT

; 85   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 86   :     pANTLR3_BASE_RECOGNIZER recognizer;
; 87   : 
; 88   :     // Allocate memory for the structure
; 89   :     //
; 90   :     recognizer	    = (pANTLR3_BASE_RECOGNIZER) ANTLR3_MALLOC((size_t)sizeof(ANTLR3_BASE_RECOGNIZER));

  0000c	8b f4		 mov	 esi, esp
  0000e	68 94 00 00 00	 push	 148			; 00000094H
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00019	83 c4 04	 add	 esp, 4
  0001c	3b f4		 cmp	 esi, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	89 45 fc	 mov	 DWORD PTR _recognizer$[ebp], eax

; 91   : 
; 92   :     if	(recognizer == NULL)

  00026	83 7d fc 00	 cmp	 DWORD PTR _recognizer$[ebp], 0
  0002a	75 07		 jne	 SHORT $LN2@antlr3Base

; 93   :     {
; 94   : 		// Allocation failed
; 95   : 		//
; 96   : 		return	NULL;

  0002c	33 c0		 xor	 eax, eax
  0002e	e9 a3 02 00 00	 jmp	 $LN1@antlr3Base
$LN2@antlr3Base:

; 97   :     }
; 98   : 
; 99   : 	
; 100  : 	// If we have been supplied with a pre-existing recognizer state
; 101  : 	// then we just install it, otherwise we must create one from scratch
; 102  : 	//
; 103  : 	if	(state == NULL)

  00033	83 7d 10 00	 cmp	 DWORD PTR _state$[ebp], 0
  00037	0f 85 21 01 00
	00		 jne	 $LN3@antlr3Base

; 104  : 	{
; 105  : 		recognizer->state = (pANTLR3_RECOGNIZER_SHARED_STATE) ANTLR3_CALLOC(1, (size_t)sizeof(ANTLR3_RECOGNIZER_SHARED_STATE));

  0003d	8b f4		 mov	 esi, esp
  0003f	6a 6c		 push	 108			; 0000006cH
  00041	6a 01		 push	 1
  00043	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__calloc
  00049	83 c4 08	 add	 esp, 8
  0004c	3b f4		 cmp	 esi, esp
  0004e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00053	8b 4d fc	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  00056	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 106  : 
; 107  : 		if	(recognizer->state == NULL)

  00059	8b 55 fc	 mov	 edx, DWORD PTR _recognizer$[ebp]
  0005c	83 7a 08 00	 cmp	 DWORD PTR [edx+8], 0
  00060	75 1d		 jne	 SHORT $LN5@antlr3Base

; 108  : 		{
; 109  : 			ANTLR3_FREE(recognizer);

  00062	8b f4		 mov	 esi, esp
  00064	8b 45 fc	 mov	 eax, DWORD PTR _recognizer$[ebp]
  00067	50		 push	 eax
  00068	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0006e	83 c4 04	 add	 esp, 4
  00071	3b f4		 cmp	 esi, esp
  00073	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 110  : 			return	NULL;

  00078	33 c0		 xor	 eax, eax
  0007a	e9 57 02 00 00	 jmp	 $LN1@antlr3Base
$LN5@antlr3Base:

; 111  : 		}
; 112  : 
; 113  : 		// Initialize any new recognizer state
; 114  : 		//
; 115  : 		recognizer->state->errorRecovery	= ANTLR3_FALSE;

  0007f	8b 4d fc	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  00082	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00085	c6 42 10 00	 mov	 BYTE PTR [edx+16], 0

; 116  : 		recognizer->state->lastErrorIndex	= -1;

  00089	8b 45 fc	 mov	 eax, DWORD PTR _recognizer$[ebp]
  0008c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0008f	c7 41 14 ff ff
	ff ff		 mov	 DWORD PTR [ecx+20], -1

; 117  : 		recognizer->state->failed		= ANTLR3_FALSE;

  00096	8b 55 fc	 mov	 edx, DWORD PTR _recognizer$[ebp]
  00099	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0009c	c6 40 18 00	 mov	 BYTE PTR [eax+24], 0

; 118  : 		recognizer->state->errorCount		= 0;

  000a0	8b 4d fc	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  000a3	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000a6	c7 42 1c 00 00
	00 00		 mov	 DWORD PTR [edx+28], 0

; 119  : 		recognizer->state->backtracking		= 0;

  000ad	8b 45 fc	 mov	 eax, DWORD PTR _recognizer$[ebp]
  000b0	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000b3	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 120  : 		recognizer->state->following		= NULL;

  000ba	8b 55 fc	 mov	 edx, DWORD PTR _recognizer$[ebp]
  000bd	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000c0	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 121  : 		recognizer->state->ruleMemo		= NULL;

  000c7	8b 4d fc	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  000ca	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000cd	c7 42 24 00 00
	00 00		 mov	 DWORD PTR [edx+36], 0

; 122  : 		recognizer->state->tokenNames		= NULL;

  000d4	8b 45 fc	 mov	 eax, DWORD PTR _recognizer$[ebp]
  000d7	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000da	c7 41 28 00 00
	00 00		 mov	 DWORD PTR [ecx+40], 0

; 123  : 		recognizer->state->sizeHint             = sizeHint;

  000e1	8b 55 fc	 mov	 edx, DWORD PTR _recognizer$[ebp]
  000e4	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000e7	8b 4d 0c	 mov	 ecx, DWORD PTR _sizeHint$[ebp]
  000ea	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 124  : 		recognizer->state->tokSource		= NULL;

  000ed	8b 55 fc	 mov	 edx, DWORD PTR _recognizer$[ebp]
  000f0	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000f3	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [eax+56], 0

; 125  :                 recognizer->state->tokFactory           = NULL;

  000fa	8b 4d fc	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  000fd	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00100	c7 42 34 00 00
	00 00		 mov	 DWORD PTR [edx+52], 0

; 126  : 
; 127  : 		// Rather than check to see if we must initialize
; 128  : 		// the stack every time we are asked for an new rewrite stream
; 129  : 		// we just always create an empty stack and then just
; 130  : 		// free it when the base recognizer is freed.
; 131  : 		//
; 132  : 		recognizer->state->rStreams		= antlr3VectorNew(0);  // We don't know the size.

  00107	6a 00		 push	 0
  00109	e8 00 00 00 00	 call	 _antlr3VectorNew
  0010e	83 c4 04	 add	 esp, 4
  00111	8b 4d fc	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  00114	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00117	89 42 68	 mov	 DWORD PTR [edx+104], eax

; 133  : 
; 134  : 		if	(recognizer->state->rStreams == NULL)

  0011a	8b 45 fc	 mov	 eax, DWORD PTR _recognizer$[ebp]
  0011d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00120	83 79 68 00	 cmp	 DWORD PTR [ecx+104], 0
  00124	75 36		 jne	 SHORT $LN6@antlr3Base

; 135  : 		{
; 136  : 			// Out of memory
; 137  : 			//
; 138  : 			ANTLR3_FREE(recognizer->state);

  00126	8b f4		 mov	 esi, esp
  00128	8b 55 fc	 mov	 edx, DWORD PTR _recognizer$[ebp]
  0012b	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0012e	50		 push	 eax
  0012f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00135	83 c4 04	 add	 esp, 4
  00138	3b f4		 cmp	 esi, esp
  0013a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 139  : 			ANTLR3_FREE(recognizer);

  0013f	8b f4		 mov	 esi, esp
  00141	8b 4d fc	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  00144	51		 push	 ecx
  00145	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0014b	83 c4 04	 add	 esp, 4
  0014e	3b f4		 cmp	 esi, esp
  00150	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 140  : 			return	NULL;

  00155	33 c0		 xor	 eax, eax
  00157	e9 7a 01 00 00	 jmp	 $LN1@antlr3Base
$LN6@antlr3Base:

; 141  : 		}
; 142  : 	}

  0015c	eb 09		 jmp	 SHORT $LN4@antlr3Base
$LN3@antlr3Base:

; 143  : 	else
; 144  : 	{
; 145  : 		// Install the one we were given, and do not reset it here
; 146  : 		// as it will either already have been initialized or will
; 147  : 		// be in a state that needs to be preserved.
; 148  : 		//
; 149  : 		recognizer->state = state;

  0015e	8b 55 fc	 mov	 edx, DWORD PTR _recognizer$[ebp]
  00161	8b 45 10	 mov	 eax, DWORD PTR _state$[ebp]
  00164	89 42 08	 mov	 DWORD PTR [edx+8], eax
$LN4@antlr3Base:

; 150  : 	}
; 151  : 		
; 152  :     // Install the BR API
; 153  :     //
; 154  :     recognizer->alreadyParsedRule           = alreadyParsedRule;

  00167	8b 4d fc	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  0016a	c7 41 74 00 00
	00 00		 mov	 DWORD PTR [ecx+116], OFFSET _alreadyParsedRule

; 155  :     recognizer->beginResync                 = beginResync;

  00171	8b 55 fc	 mov	 edx, DWORD PTR _recognizer$[ebp]
  00174	c7 42 34 00 00
	00 00		 mov	 DWORD PTR [edx+52], OFFSET _beginResync

; 156  :     recognizer->combineFollows              = combineFollows;

  0017b	8b 45 fc	 mov	 eax, DWORD PTR _recognizer$[ebp]
  0017e	c7 40 4c 00 00
	00 00		 mov	 DWORD PTR [eax+76], OFFSET _combineFollows

; 157  :     recognizer->beginBacktrack              = beginBacktrack;

  00185	8b 4d fc	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  00188	c7 41 3c 00 00
	00 00		 mov	 DWORD PTR [ecx+60], OFFSET _beginBacktrack

; 158  :     recognizer->endBacktrack                = endBacktrack;

  0018f	8b 55 fc	 mov	 edx, DWORD PTR _recognizer$[ebp]
  00192	c7 42 40 00 00
	00 00		 mov	 DWORD PTR [edx+64], OFFSET _endBacktrack

; 159  :     recognizer->computeCSRuleFollow         = computeCSRuleFollow;

  00199	8b 45 fc	 mov	 eax, DWORD PTR _recognizer$[ebp]
  0019c	c7 40 48 00 00
	00 00		 mov	 DWORD PTR [eax+72], OFFSET _computeCSRuleFollow

; 160  :     recognizer->computeErrorRecoverySet     = computeErrorRecoverySet;

  001a3	8b 4d fc	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  001a6	c7 41 44 00 00
	00 00		 mov	 DWORD PTR [ecx+68], OFFSET _computeErrorRecoverySet

; 161  :     recognizer->consumeUntil                = consumeUntil;

  001ad	8b 55 fc	 mov	 edx, DWORD PTR _recognizer$[ebp]
  001b0	c7 42 5c 00 00
	00 00		 mov	 DWORD PTR [edx+92], OFFSET _consumeUntil

; 162  :     recognizer->consumeUntilSet             = consumeUntilSet;

  001b7	8b 45 fc	 mov	 eax, DWORD PTR _recognizer$[ebp]
  001ba	c7 40 60 00 00
	00 00		 mov	 DWORD PTR [eax+96], OFFSET _consumeUntilSet

; 163  :     recognizer->displayRecognitionError     = displayRecognitionError;

  001c1	8b 4d fc	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  001c4	c7 41 28 00 00
	00 00		 mov	 DWORD PTR [ecx+40], OFFSET _displayRecognitionError

; 164  :     recognizer->endResync                   = endResync;

  001cb	8b 55 fc	 mov	 edx, DWORD PTR _recognizer$[ebp]
  001ce	c7 42 38 00 00
	00 00		 mov	 DWORD PTR [edx+56], OFFSET _endResync

; 165  :     recognizer->exConstruct                 = antlr3MTExceptionNew;

  001d5	8b 45 fc	 mov	 eax, DWORD PTR _recognizer$[ebp]
  001d8	c7 80 88 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+136], OFFSET _antlr3MTExceptionNew

; 166  :     recognizer->getRuleInvocationStack      = getRuleInvocationStack;

  001e2	8b 4d fc	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  001e5	c7 41 64 00 00
	00 00		 mov	 DWORD PTR [ecx+100], OFFSET _getRuleInvocationStack

; 167  :     recognizer->getRuleInvocationStackNamed = getRuleInvocationStackNamed;

  001ec	8b 55 fc	 mov	 edx, DWORD PTR _recognizer$[ebp]
  001ef	c7 42 68 00 00
	00 00		 mov	 DWORD PTR [edx+104], OFFSET _getRuleInvocationStackNamed

; 168  :     recognizer->getRuleMemoization          = getRuleMemoization;

  001f6	8b 45 fc	 mov	 eax, DWORD PTR _recognizer$[ebp]
  001f9	c7 40 70 00 00
	00 00		 mov	 DWORD PTR [eax+112], OFFSET _getRuleMemoization

; 169  :     recognizer->match                       = match;

  00200	8b 4d fc	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  00203	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], OFFSET _match

; 170  :     recognizer->matchAny                    = matchAny;

  0020a	8b 55 fc	 mov	 edx, DWORD PTR _recognizer$[ebp]
  0020d	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], OFFSET _matchAny

; 171  :     recognizer->memoize                     = memoize;

  00214	8b 45 fc	 mov	 eax, DWORD PTR _recognizer$[ebp]
  00217	c7 40 78 00 00
	00 00		 mov	 DWORD PTR [eax+120], OFFSET _memoize

; 172  :     recognizer->mismatch                    = mismatch;

  0021e	8b 4d fc	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  00221	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], OFFSET _mismatch

; 173  :     recognizer->mismatchIsUnwantedToken     = mismatchIsUnwantedToken;

  00228	8b 55 fc	 mov	 edx, DWORD PTR _recognizer$[ebp]
  0022b	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET _mismatchIsUnwantedToken

; 174  :     recognizer->mismatchIsMissingToken      = mismatchIsMissingToken;

  00232	8b 45 fc	 mov	 eax, DWORD PTR _recognizer$[ebp]
  00235	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], OFFSET _mismatchIsMissingToken

; 175  :     recognizer->recover                     = recover;

  0023c	8b 4d fc	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  0023f	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], OFFSET _recover

; 176  :     recognizer->recoverFromMismatchedElement= recoverFromMismatchedElement;

  00246	8b 55 fc	 mov	 edx, DWORD PTR _recognizer$[ebp]
  00249	c7 42 58 00 00
	00 00		 mov	 DWORD PTR [edx+88], OFFSET _recoverFromMismatchedElement

; 177  :     recognizer->recoverFromMismatchedSet    = recoverFromMismatchedSet;

  00250	8b 45 fc	 mov	 eax, DWORD PTR _recognizer$[ebp]
  00253	c7 40 54 00 00
	00 00		 mov	 DWORD PTR [eax+84], OFFSET _recoverFromMismatchedSet

; 178  :     recognizer->recoverFromMismatchedToken  = recoverFromMismatchedToken;

  0025a	8b 4d fc	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  0025d	c7 41 50 00 00
	00 00		 mov	 DWORD PTR [ecx+80], OFFSET _recoverFromMismatchedToken

; 179  :     recognizer->getNumberOfSyntaxErrors     = getNumberOfSyntaxErrors;

  00264	8b 55 fc	 mov	 edx, DWORD PTR _recognizer$[ebp]
  00267	c7 42 2c 00 00
	00 00		 mov	 DWORD PTR [edx+44], OFFSET _getNumberOfSyntaxErrors

; 180  :     recognizer->reportError                 = reportError;

  0026e	8b 45 fc	 mov	 eax, DWORD PTR _recognizer$[ebp]
  00271	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], OFFSET _reportError

; 181  :     recognizer->reset                       = reset;

  00278	8b 4d fc	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  0027b	c7 81 8c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+140], OFFSET _reset

; 182  :     recognizer->synpred                     = synpred;

  00285	8b 55 fc	 mov	 edx, DWORD PTR _recognizer$[ebp]
  00288	c7 82 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+132], OFFSET _synpred

; 183  :     recognizer->toStrings                   = toStrings;

  00292	8b 45 fc	 mov	 eax, DWORD PTR _recognizer$[ebp]
  00295	c7 40 6c 00 00
	00 00		 mov	 DWORD PTR [eax+108], OFFSET _toStrings

; 184  :     recognizer->getCurrentInputSymbol       = getCurrentInputSymbol;

  0029c	8b 4d fc	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  0029f	c7 41 7c 00 00
	00 00		 mov	 DWORD PTR [ecx+124], OFFSET _getCurrentInputSymbol

; 185  :     recognizer->getMissingSymbol            = getMissingSymbol;

  002a6	8b 55 fc	 mov	 edx, DWORD PTR _recognizer$[ebp]
  002a9	c7 82 80 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+128], OFFSET _getMissingSymbol

; 186  :     recognizer->debugger                    = NULL;

  002b3	8b 45 fc	 mov	 eax, DWORD PTR _recognizer$[ebp]
  002b6	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 187  : 
; 188  :     recognizer->free = freeBR;

  002bd	8b 4d fc	 mov	 ecx, DWORD PTR _recognizer$[ebp]
  002c0	c7 81 90 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+144], OFFSET _freeBR

; 189  : 
; 190  :     /* Initialize variables
; 191  :      */
; 192  :     recognizer->type			= type;

  002ca	8b 55 fc	 mov	 edx, DWORD PTR _recognizer$[ebp]
  002cd	8b 45 08	 mov	 eax, DWORD PTR _type$[ebp]
  002d0	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 193  : 
; 194  : 
; 195  :     return  recognizer;

  002d3	8b 45 fc	 mov	 eax, DWORD PTR _recognizer$[ebp]
$LN1@antlr3Base:

; 196  : }

  002d6	5e		 pop	 esi
  002d7	83 c4 04	 add	 esp, 4
  002da	3b ec		 cmp	 ebp, esp
  002dc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002e1	8b e5		 mov	 esp, ebp
  002e3	5d		 pop	 ebp
  002e4	c3		 ret	 0
_antlr3BaseRecognizerNew ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 837  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 838  :         int _Result;
; 839  :         va_list _ArgList;
; 840  :         __crt_va_start(_ArgList, _Format);

  00014	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00017	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 841  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

  0001a	8b 4d f8	 mov	 ecx, DWORD PTR __ArgList$[ebp]
  0001d	51		 push	 ecx
  0001e	6a 00		 push	 0
  00020	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00023	52		 push	 edx
  00024	8b 45 08	 mov	 eax, DWORD PTR __Stream$[ebp]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 __vfprintf_l
  0002d	83 c4 10	 add	 esp, 16			; 00000010H
  00030	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 842  :         __crt_va_end(_ArgList);

  00033	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 843  :         return _Result;

  0003a	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 844  :     }

  0003d	83 c4 08	 add	 esp, 8
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 644  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00004	8b f4		 mov	 esi, esp
  00006	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  0000d	51		 push	 ecx
  0000e	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00011	52		 push	 edx
  00012	8b 45 08	 mov	 eax, DWORD PTR __Stream$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  0001b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001e	51		 push	 ecx
  0001f	8b 10		 mov	 edx, DWORD PTR [eax]
  00021	52		 push	 edx
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vfprintf
  00028	83 c4 18	 add	 esp, 24			; 00000018H
  0002b	3b f4		 cmp	 esi, esp
  0002d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 646  :     }

  00032	5e		 pop	 esi
  00033	3b ec		 cmp	 ebp, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 90   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00003	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
